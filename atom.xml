<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>冰糖几何</title>
  
  <subtitle>我们的目标是大海星辰! | Our Goal Is The Sea And Stars!</subtitle>
  <link href="http://cvki.cn/atom.xml" rel="self"/>
  
  <link href="http://cvki.cn/"/>
  <updated>2023-08-18T08:21:25.610Z</updated>
  <id>http://cvki.cn/</id>
  
  <author>
    <name>冰糖</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker快速入门&amp;备份和迁移数据</title>
    <link href="http://cvki.cn/posts/eee57fff.html"/>
    <id>http://cvki.cn/posts/eee57fff.html</id>
    <published>2023-05-08T07:07:09.000Z</published>
    <updated>2023-08-18T08:21:25.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="🎯备份和迁移数据"><a href="#🎯备份和迁移数据" class="headerlink" title="🎯备份和迁移数据"></a>🎯备份和迁移数据</h1><h3 id="迁移方式介绍"><a href="#迁移方式介绍" class="headerlink" title="迁移方式介绍"></a>迁移方式介绍</h3><p>容器中的数据，如果没有用挂载目录，删除容器后就会丢失数据。<br>前面我们已经讲解了如何 <a href="doc:kze7f0ZR">挂载目录</a><br>如果你是用<code>bind mount</code>直接把宿主机的目录挂进去容器，那迁移数据很方便，直接复制目录就好了<br>如果你是用<code>volume</code>方式挂载的，由于数据是由容器创建和管理的，需要用特殊的方式把数据弄出来。</p><h3 id="备份和导入-Volume-的流程"><a href="#备份和导入-Volume-的流程" class="headerlink" title="备份和导入 Volume 的流程"></a>备份和导入 Volume 的流程</h3><p>备份：</p><ul><li>运行一个 ubuntu 的容器，挂载需要备份的 volume 到容器，并且挂载宿主机目录到容器里的备份目录。</li><li>运行 tar 命令把数据压缩为一个文件</li><li>把备份文件复制到需要导入的机器</li></ul><p>导入：</p><ul><li>运行 ubuntu 容器，挂载容器的 volume，并且挂载宿主机备份文件所在目录到容器里</li><li>运行 tar 命令解压备份文件到指定目录</li></ul><h3 id="备份-MongoDB-数据演示"><a href="#备份-MongoDB-数据演示" class="headerlink" title="备份 MongoDB 数据演示"></a>备份 MongoDB 数据演示</h3><ul><li>运行一个 mongodb，创建一个名叫<code>mongo-data</code>的 volume 指向容器的 &#x2F;data 目录<br><code>docker run -p 27018:27017 --name mongo -v mongo-data:/data -d mongo:4.4</code></li><li>运行一个 Ubuntu 的容器，挂载<code>mongo</code>容器的所有 volume，映射宿主机的 backup 目录到容器里面的 &#x2F;backup 目录，然后运行 tar 命令把数据压缩打包<br><code>docker run --rm --volumes-from mongo -v d:/backup:/backup ubuntu tar cvf /backup/backup.tar /data/</code></li></ul><p>最后你就可以拿着这个 backup.tar 文件去其他地方导入了。</p><h3 id="恢复-Volume-数据演示"><a href="#恢复-Volume-数据演示" class="headerlink" title="恢复 Volume 数据演示"></a>恢复 Volume 数据演示</h3><ul><li>运行一个 ubuntu 容器，挂载 mongo 容器的所有 volumes，然后读取 &#x2F;backup 目录中的备份文件，解压到 &#x2F;data&#x2F; 目录<br><code>docker run --rm --volumes-from mongo -v d:/backup:/backup ubuntu bash -c &quot;cd /data/ &amp;&amp; tar xvf /backup/backup.tar --strip 1&quot;</code></li></ul><blockquote><p>注意，volumes-from 指定的是容器名字<br>strip 1 表示解压时去掉前面1层目录，因为压缩时包含了绝对路径</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;🎯备份和迁移数据&quot;&gt;&lt;a href=&quot;#🎯备份和迁移数据&quot; class=&quot;headerlink&quot; title=&quot;🎯备份和迁移数据&quot;&gt;&lt;/a&gt;🎯备份和迁移数据&lt;/h1&gt;&lt;h3 id=&quot;迁移方式介绍&quot;&gt;&lt;a href=&quot;#迁移方式介绍&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Docker" scheme="http://cvki.cn/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://cvki.cn/tags/Docker/"/>
    
    <category term="Docker快速入门" scheme="http://cvki.cn/tags/Docker%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Docker快速入门&amp;发布和部署</title>
    <link href="http://cvki.cn/posts/a502abd5.html"/>
    <id>http://cvki.cn/posts/a502abd5.html</id>
    <published>2023-05-08T06:04:09.000Z</published>
    <updated>2023-08-18T08:21:25.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="🚚发布和部署"><a href="#🚚发布和部署" class="headerlink" title="🚚发布和部署"></a>🚚发布和部署</h1><h3 id="镜像仓库介绍"><a href="#镜像仓库介绍" class="headerlink" title="镜像仓库介绍"></a>镜像仓库介绍</h3><p>镜像仓库用来存储我们 build 出来的“安装包”，Docker 官方提供了一个 <a href="https://hub.docker.com/">镜像库</a>，里面包含了大量镜像，基本各种软件所需依赖都有，要什么直接上去搜索。</p><p>我们也可以把自己 build 出来的镜像上传到 docker 提供的镜像库中，方便传播。<br>当然你也可以搭建自己的私有镜像库，或者使用国内各种大厂提供的镜像托管服务，例如：阿里云、腾讯云</p><h3 id="上传我们的镜像"><a href="#上传我们的镜像" class="headerlink" title="上传我们的镜像"></a>上传我们的镜像</h3><ul><li>首先你要先 <a href="https://hub.docker.com/">注册一个账号</a></li><li>创建一个镜像库<div class="tag-plugin image"><div class="image-bg"><img src="/posts/a502abd5/kv9a2wty.png" alt="image.png"></div><div class="image-meta"><span class="image-caption center">image.png</span></div></div></li><li>命令行登录账号：<br><code>docker login -u username</code></li><li>新建一个tag，名字必须跟你注册账号一样<br><code>docker tag test:v1 username/test:v1</code></li><li>推上去<br><code>docker push username/test:v1</code></li><li>部署试下<br><code>docker run -dp 8080:8080 username/test:v1</code></li></ul><h5 id="docker-compose-中也可以直接用这个镜像了"><a href="#docker-compose-中也可以直接用这个镜像了" class="headerlink" title="docker-compose 中也可以直接用这个镜像了"></a>docker-compose 中也可以直接用这个镜像了</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  app:</span><br><span class="line">#    build: ./</span><br><span class="line">    image: helloguguji/test:v1</span><br><span class="line">    ports:</span><br><span class="line">      - 80:8080</span><br><span class="line">    volumes:</span><br><span class="line">      - ./:/app</span><br><span class="line">    environment:</span><br><span class="line">      - TZ=Asia/Shanghai</span><br><span class="line">  redis:</span><br><span class="line">    image: redis:5.0.13</span><br><span class="line">    volumes:</span><br><span class="line">      - redis:/data</span><br><span class="line">    environment:</span><br><span class="line">      - TZ=Asia/Shanghai</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  redis:</span><br></pre></td></tr></table></figure><h3 id="阿里云容器托管"><a href="#阿里云容器托管" class="headerlink" title="阿里云容器托管"></a>阿里云容器托管</h3><p>docker 官方的镜像托管有时候上传和下载都太慢了，如果你想要更快的速度，可以使用阿里云的免费镜像托管<br>登录 <a href="https://www.aliyun.com/">阿里云</a></p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/a502abd5/kv9dqxuo.png" alt="image.png"></div><div class="image-meta"><span class="image-caption center">image.png</span></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;🚚发布和部署&quot;&gt;&lt;a href=&quot;#🚚发布和部署&quot; class=&quot;headerlink&quot; title=&quot;🚚发布和部署&quot;&gt;&lt;/a&gt;🚚发布和部署&lt;/h1&gt;&lt;h3 id=&quot;镜像仓库介绍&quot;&gt;&lt;a href=&quot;#镜像仓库介绍&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="Docker" scheme="http://cvki.cn/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://cvki.cn/tags/Docker/"/>
    
    <category term="Docker快速入门" scheme="http://cvki.cn/tags/Docker%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Docker快速入门&amp;Docker-Compose</title>
    <link href="http://cvki.cn/posts/31e1fdfd.html"/>
    <id>http://cvki.cn/posts/31e1fdfd.html</id>
    <published>2023-05-07T09:34:43.000Z</published>
    <updated>2023-08-18T08:21:25.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="🍁Docker-Compose"><a href="#🍁Docker-Compose" class="headerlink" title="🍁Docker-Compose"></a>🍁Docker-Compose</h1><h3 id="现存问题"><a href="#现存问题" class="headerlink" title="现存问题"></a>现存问题</h3><p>在上节，我们运行了两个容器：Web 项目 + Redis<br>如果项目依赖更多的第三方软件，我们需要管理的容器就更加多，每个都要单独配置运行，指定网络。<br>这节，我们使用 docker-compose 把项目的多个服务集合到一起，一键运行。</p><h3 id="安装-Docker-Compose"><a href="#安装-Docker-Compose" class="headerlink" title="安装 Docker Compose"></a>安装 Docker Compose</h3><ul><li>如果你是安装的桌面版 Docker，不需要额外安装，已经包含了。</li><li>如果是没图形界面的服务器版 Docker，你需要单独安装 <a href="https://docs.docker.com/compose/install/#install-compose-on-linux-systems">安装文档</a></li><li>运行<code>docker-compose</code>检查是否安装成功</li></ul><h3 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h3><p>要把项目依赖的多个服务集合到一起，我们需要编写一个<code>docker-compose.yml</code>文件，描述依赖哪些服务<br>参考文档：<a href="https://docs.docker.com/compose/">https://docs.docker.com/compose/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  app:</span><br><span class="line">    build: ./</span><br><span class="line">    ports:</span><br><span class="line">      - 80:8080</span><br><span class="line">    volumes:</span><br><span class="line">      - ./:/app</span><br><span class="line">    environment:</span><br><span class="line">      - TZ=Asia/Shanghai</span><br><span class="line">  redis:</span><br><span class="line">    image: redis:5.0.13</span><br><span class="line">    volumes:</span><br><span class="line">      - redis:/data</span><br><span class="line">    environment:</span><br><span class="line">      - TZ=Asia/Shanghai</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  redis:</span><br></pre></td></tr></table></figure><blockquote><p>容器默认时间不是北京时间，增加 TZ&#x3D;Asia&#x2F;Shanghai 可以改为北京时间</p></blockquote><h3 id="跑起来"><a href="#跑起来" class="headerlink" title="跑起来"></a>跑起来</h3><p>在<code>docker-compose.yml</code> 文件所在目录，执行：<code>docker-compose up</code>就可以跑起来了。<br>命令参考：<a href="https://docs.docker.com/compose/reference/up/">https://docs.docker.com/compose/reference/up/</a></p><p>在后台运行只需要加一个 -d 参数<code>docker-compose up -d</code><br>查看运行状态：<code>docker-compose ps</code><br>停止运行：<code>docker-compose stop</code><br>重启：<code>docker-compose restart</code><br>重启单个服务：<code>docker-compose restart service-name</code><br>进入容器命令行：<code>docker-compose exec service-name sh</code><br>查看容器运行log：&#96;docker-compose logs [service-name]</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;🍁Docker-Compose&quot;&gt;&lt;a href=&quot;#🍁Docker-Compose&quot; class=&quot;headerlink&quot; title=&quot;🍁Docker-Compose&quot;&gt;&lt;/a&gt;🍁Docker-Compose&lt;/h1&gt;&lt;h3 id=&quot;现存问题&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="Docker" scheme="http://cvki.cn/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://cvki.cn/tags/Docker/"/>
    
    <category term="Docker快速入门" scheme="http://cvki.cn/tags/Docker%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Docker快速入门&amp;多容器通信</title>
    <link href="http://cvki.cn/posts/36d19d1c.html"/>
    <id>http://cvki.cn/posts/36d19d1c.html</id>
    <published>2023-05-06T02:17:57.000Z</published>
    <updated>2023-08-18T08:21:25.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="👨‍👦‍👦多容器通信"><a href="#👨‍👦‍👦多容器通信" class="headerlink" title="👨‍👦‍👦多容器通信"></a>👨‍👦‍👦多容器通信</h1><h3 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h3><p>项目往往都不是独立运行的，需要数据库、缓存这些东西配合运作。<br>这节我们把前面的 Web 项目增加一个 Redis 依赖，多跑一个 Redis 容器，演示如何多容器之间的通信。</p><h3 id="创建虚拟网络"><a href="#创建虚拟网络" class="headerlink" title="创建虚拟网络"></a>创建虚拟网络</h3><p>要想多容器之间互通，从 Web 容器访问 Redis 容器，我们只需要把他们放到同个网络中就可以了。</p><p>文档参考：<a href="https://docs.docker.com/engine/reference/commandline/network/">https://docs.docker.com/engine/reference/commandline/network/</a></p><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><h5 id="创建一个名为test-net的网络："><a href="#创建一个名为test-net的网络：" class="headerlink" title="创建一个名为test-net的网络："></a>创建一个名为<code>test-net</code>的网络：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create test-net</span><br></pre></td></tr></table></figure><h5 id="运行-Redis-在-test-net-网络中，别名redis"><a href="#运行-Redis-在-test-net-网络中，别名redis" class="headerlink" title="运行 Redis 在 test-net 网络中，别名redis"></a>运行 Redis 在 <code>test-net</code> 网络中，别名<code>redis</code></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name redis --network test-net --network-alias redis redis:latest</span><br></pre></td></tr></table></figure><h5 id="修改代码中访问redis的地址为网络别名"><a href="#修改代码中访问redis的地址为网络别名" class="headerlink" title="修改代码中访问redis的地址为网络别名"></a>修改代码中访问<code>redis</code>的地址为网络别名</h5><div class="tag-plugin image"><div class="image-bg"><img src="/posts/36d19d1c/kv98rfvb.png" alt="image.png"></div><div class="image-meta"><span class="image-caption center">image.png</span></div></div><h5 id="运行-Web-项目，使用同个网络"><a href="#运行-Web-项目，使用同个网络" class="headerlink" title="运行 Web 项目，使用同个网络"></a>运行 Web 项目，使用同个网络</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:8080 --name test -v D:/test:/app --network test-net -d test:v1</span><br></pre></td></tr></table></figure><h5 id="查看数据"><a href="#查看数据" class="headerlink" title="查看数据"></a>查看数据</h5><p><code>http://localhost:8080/redis</code><br>容器终端查看数据是否一致</p><h3 id="更多相关命令"><a href="#更多相关命令" class="headerlink" title="更多相关命令"></a>更多相关命令</h3><p><code>docker ps</code> 查看当前运行中的容器<br><code>docker images</code> 查看镜像列表<br><code>docker rm container-id</code> 删除指定 id 的容器<br><code>docker stop/start container-id</code> 停止&#x2F;启动指定 id 的容器<br><code>docker rmi image-id</code> 删除指定 id 的镜像<br><code>docker volume ls</code> 查看 volume 列表<br><code>docker network ls</code> 查看网络列表</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;👨‍👦‍👦多容器通信&quot;&gt;&lt;a href=&quot;#👨‍👦‍👦多容器通信&quot; class=&quot;headerlink&quot; title=&quot;👨‍👦‍👦多容器通信&quot;&gt;&lt;/a&gt;👨‍👦‍👦多容器通信&lt;/h1&gt;&lt;h3 id=&quot;学习目标&quot;&gt;&lt;a href=&quot;#学习目标&quot;</summary>
      
    
    
    
    <category term="Docker" scheme="http://cvki.cn/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://cvki.cn/tags/Docker/"/>
    
    <category term="Docker快速入门" scheme="http://cvki.cn/tags/Docker%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Docker快速入门&amp;目录挂载</title>
    <link href="http://cvki.cn/posts/b03c4432.html"/>
    <id>http://cvki.cn/posts/b03c4432.html</id>
    <published>2023-05-05T10:01:35.000Z</published>
    <updated>2023-08-18T08:21:25.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="🥙目录挂载"><a href="#🥙目录挂载" class="headerlink" title="🥙目录挂载"></a>🥙目录挂载</h1><h3 id="现存问题"><a href="#现存问题" class="headerlink" title="现存问题"></a>现存问题</h3><ul><li>使用 Docker 运行后，我们改了项目代码不会立刻生效，需要重新<code>build</code>和<code>run</code>，很是麻烦。</li><li>容器里面产生的数据，例如 log 文件，数据库备份文件，容器删除后就丢失了。</li></ul><blockquote><p>目录挂载解决以上问题</p></blockquote><h3 id="几种挂载方式"><a href="#几种挂载方式" class="headerlink" title="几种挂载方式"></a>几种挂载方式</h3><ul><li><code>bind mount</code> 直接把宿主机目录映射到容器内，适合挂代码目录和配置文件。可挂到多个容器上</li><li><code>volume</code> 由容器创建和管理，创建在宿主机，所以删除容器不会丢失，官方推荐，更高效，Linux 文件系统，适合存储数据库数据。可挂到多个容器上</li><li><code>tmpfs mount</code> 适合存储临时文件，存宿主机内存中。不可多容器共享。</li></ul><p>文档参考：<a href="https://docs.docker.com/storage/">https://docs.docker.com/storage/</a></p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/b03c4432/kv96dc4q.png" alt="image.png"></div><div class="image-meta"><span class="image-caption center">image.png</span></div></div><h3 id="挂载演示"><a href="#挂载演示" class="headerlink" title="挂载演示"></a>挂载演示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bind mount` 方式用绝对路径 `-v D:/code:/app</span><br><span class="line">volume` 方式，只需要一个名字 `-v db-data:/app</span><br></pre></td></tr></table></figure><p>示例：<br><code>docker run -p 8080:8080 --name test-hello -v D:/code:/app -d test:v1</code></p><blockquote><p>注意！<br>因为挂载后，容器里的代码就会替换为你本机的代码了，如果你代码目录没有<code>node_modules</code>目录，你需要在代码目录执行下<code>npm install --registry=https://registry.npm.taobao.org</code>确保依赖库都已经安装，否则可能会提示“Error: Cannot find module ‘koa’”<br>如果你的电脑没有安装 <a href="https://nodejs.org/en/">nodejs</a>，你需要安装一下才能执行上面的命令。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;🥙目录挂载&quot;&gt;&lt;a href=&quot;#🥙目录挂载&quot; class=&quot;headerlink&quot; title=&quot;🥙目录挂载&quot;&gt;&lt;/a&gt;🥙目录挂载&lt;/h1&gt;&lt;h3 id=&quot;现存问题&quot;&gt;&lt;a href=&quot;#现存问题&quot; class=&quot;headerlink&quot; title=&quot;现</summary>
      
    
    
    
    <category term="Docker" scheme="http://cvki.cn/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://cvki.cn/tags/Docker/"/>
    
    <category term="Docker快速入门" scheme="http://cvki.cn/tags/Docker%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Docker快速入门&amp;制作自己的镜像</title>
    <link href="http://cvki.cn/posts/118ee6c6.html"/>
    <id>http://cvki.cn/posts/118ee6c6.html</id>
    <published>2023-05-04T18:13:18.000Z</published>
    <updated>2023-08-18T08:21:25.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="💽制作自己的镜像"><a href="#💽制作自己的镜像" class="headerlink" title="💽制作自己的镜像"></a>💽制作自己的镜像</h1><h3 id="为自己的-Web-项目构建镜像"><a href="#为自己的-Web-项目构建镜像" class="headerlink" title="为自己的 Web 项目构建镜像"></a>为自己的 Web 项目构建镜像</h3><p>示例项目代码：<a href="https://github.com/gzyunke/test-docker">https://github.com/gzyunke/test-docker</a><br>这是一个 Nodejs + Koa2 写的 Web 项目，提供了简单的两个演示页面。<br>软件依赖：<a href="https://nodejs.org/zh-cn/">nodejs</a><br>项目依赖库：koa、log4js、koa-router</p><h3 id="编写-Dockerfile"><a href="#编写-Dockerfile" class="headerlink" title="编写 Dockerfile"></a>编写 Dockerfile</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">FROM node:11</span><br><span class="line">MAINTAINER notnonex&lt;notnonex@gmail.com&gt;</span><br><span class="line"></span><br><span class="line"># 复制代码</span><br><span class="line">ADD . /app</span><br><span class="line"></span><br><span class="line"># 设置容器启动后的默认运行目录</span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"># 运行命令，安装依赖</span><br><span class="line"># RUN 命令可以有多个，但是可以用 &amp;&amp; 连接多个命令来减少层级。</span><br><span class="line"># 例如 RUN npm install &amp;&amp; cd /app &amp;&amp; mkdir logs</span><br><span class="line">RUN npm install --registry=https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line"># CMD 指令只能一个，是容器启动后执行的命令，算是程序的入口。</span><br><span class="line"># 如果还需要运行其他命令可以用 &amp;&amp; 连接，也可以写成一个shell脚本去执行。</span><br><span class="line"># 例如 CMD cd /app &amp;&amp; ./start.sh</span><br><span class="line">CMD node app.js</span><br></pre></td></tr></table></figure><p><a href="https://docs.docker.com/engine/reference/builder/#run">Dockerfile文档</a></p><blockquote><p>实用技巧：<br>如果你写 Dockerfile 时经常遇到一些运行错误，依赖错误等，你可以直接运行一个依赖的底，然后进入终端进行配置环境，成功后再把做过的步骤命令写道 Dockerfile 文件中，这样编写调试会快很多。<br>例如上面的底是<code>node:11</code>，我们可以运行<code>docker run -it -d node:11 bash</code>，跑起来后进入容器终端配置依赖的软件，然后尝试跑起来自己的软件，最后把所有做过的步骤写入到 Dockerfile 就好了。<br>掌握好这个技巧，你的 Dockerfile 文件编写起来就非常的得心应手了。</p></blockquote><h3 id="Build-为镜像（安装包）和运行"><a href="#Build-为镜像（安装包）和运行" class="headerlink" title="Build 为镜像（安装包）和运行"></a>Build 为镜像（安装包）和运行</h3><p>编译 <code>docker build -t test:v1 .</code></p><blockquote><p><code>-t</code> 设置镜像名字和版本号<br>命令参考：<a href="https://docs.docker.com/engine/reference/commandline/build/">https://docs.docker.com/engine/reference/commandline/build/</a></p></blockquote><p>运行 <code>docker run -p 8080:8080 --name test-hello test:v1</code></p><blockquote><p><code>-p</code> 映射容器内端口到宿主机<br><code>--name</code> 容器名字<br><code>-d</code> 后台运行<br>命令参考文档：<a href="https://docs.docker.com/engine/reference/run/">https://docs.docker.com/engine/reference/run/</a></p></blockquote><h3 id="更多相关命令"><a href="#更多相关命令" class="headerlink" title="更多相关命令"></a>更多相关命令</h3><p><code>docker ps</code> 查看当前运行中的容器<br><code>docker images</code> 查看镜像列表<br><code>docker rm container-id</code> 删除指定 id 的容器<br><code>docker stop/start container-id</code> 停止&#x2F;启动指定 id 的容器<br><code>docker rmi image-id</code> 删除指定 id 的镜像<br><code>docker volume ls</code> 查看 volume 列表<br><code>docker network ls</code> 查看网络列表</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;💽制作自己的镜像&quot;&gt;&lt;a href=&quot;#💽制作自己的镜像&quot; class=&quot;headerlink&quot; title=&quot;💽制作自己的镜像&quot;&gt;&lt;/a&gt;💽制作自己的镜像&lt;/h1&gt;&lt;h3 id=&quot;为自己的-Web-项目构建镜像&quot;&gt;&lt;a href=&quot;#为自己的-Web-项</summary>
      
    
    
    
    <category term="Docker" scheme="http://cvki.cn/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://cvki.cn/tags/Docker/"/>
    
    <category term="Docker快速入门" scheme="http://cvki.cn/tags/Docker%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Docker快速入门&amp;Docker 快速安装软件</title>
    <link href="http://cvki.cn/posts/887b1872.html"/>
    <id>http://cvki.cn/posts/887b1872.html</id>
    <published>2023-05-04T04:05:18.000Z</published>
    <updated>2023-08-18T08:21:25.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="💻Docker-快速安装软件"><a href="#💻Docker-快速安装软件" class="headerlink" title="💻Docker 快速安装软件"></a>💻Docker 快速安装软件</h1><h3 id="直接安装的缺点"><a href="#直接安装的缺点" class="headerlink" title="直接安装的缺点"></a>直接安装的缺点</h3><ul><li>安装麻烦，可能有各种依赖，运行报错。例如：WordPress，ElasticSearch，Redis，ELK</li><li>可能对 Windows 并不友好，运行有各种兼容问题，软件只支持 Linux 上跑</li><li>不方便安装多版本软件，不能共存。</li><li>电脑安装了一堆软件，拖慢电脑速度。</li><li>不同系统和硬件，安装方式不一样</li></ul><h3 id="Docker-安装的优点"><a href="#Docker-安装的优点" class="headerlink" title="Docker 安装的优点"></a>Docker 安装的优点</h3><ul><li>一个命令就可以安装好，快速方便</li><li>有大量的镜像，可直接使用</li><li>没有系统兼容问题，Linux 专享软件也照样跑</li><li>支持软件多版本共存</li><li>用完就丢，不拖慢电脑速度</li><li>不同系统和硬件，只要安装好 Docker 其他都一样了，一个命令搞定所有</li></ul><h3 id="演示-Docker-安装-Redis"><a href="#演示-Docker-安装-Redis" class="headerlink" title="演示 Docker 安装 Redis"></a>演示 Docker 安装 Redis</h3><p>Redis 官网：<a href="https://redis.io/">https://redis.io/</a></p><blockquote><p>官网下载安装教程只有源码安装方式，没有 Windows 版本。想要自己安装 windows 版本需要去找别人编译好的安装包。</p></blockquote><p>Docker 官方镜像仓库查找 Redis ：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/887b1872/kv8zs4qr.png" alt="Docker镜像官网"></div><div class="image-meta"><span class="image-caption center">Docker镜像官网</span></div></div><p>一个命令跑起来：<code>docker run -d -p 6379:6379 --name redis redis:latest</code><br>命令参考：<a href="https://docs.docker.com/engine/reference/commandline/run/">https://docs.docker.com/engine/reference/commandline/run/</a></p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/887b1872/kv8zy4xn.png" alt="Docker运行Redis后"></div><div class="image-meta"><span class="image-caption center">Docker运行Redis后</span></div></div><h3 id="安装-Wordpress"><a href="#安装-Wordpress" class="headerlink" title="安装 Wordpress"></a>安装 Wordpress</h3><p>docker-compose.yml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3.1&#x27;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  wordpress:</span><br><span class="line">    image: wordpress</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 8080:80</span><br><span class="line">    environment:</span><br><span class="line">      WORDPRESS_DB_HOST: db</span><br><span class="line">      WORDPRESS_DB_USER: exampleuser</span><br><span class="line">      WORDPRESS_DB_PASSWORD: examplepass</span><br><span class="line">      WORDPRESS_DB_NAME: exampledb</span><br><span class="line">    volumes:</span><br><span class="line">      - wordpress:/var/www/html</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: mysql:5.7</span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_DATABASE: exampledb</span><br><span class="line">      MYSQL_USER: exampleuser</span><br><span class="line">      MYSQL_PASSWORD: examplepass</span><br><span class="line">      MYSQL_RANDOM_ROOT_PASSWORD: &#x27;1&#x27;</span><br><span class="line">    volumes:</span><br><span class="line">      - db:/var/lib/mysql</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  wordpress:</span><br><span class="line">  db:</span><br></pre></td></tr></table></figure><h3 id="安装-ELK"><a href="#安装-ELK" class="headerlink" title="安装 ELK"></a>安装 ELK</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 5601:5601 -p 9200:9200 -p 5044:5044 -it --name elk sebp/elk</span><br></pre></td></tr></table></figure><p><a href="https://docs.microsoft.com/en-us/windows/wsl/wsl-config#global-configuration-options-with-wslconfig">内存不够解决方法</a><br>转到用户目录 <code>cd ~</code>，路径类似这个：<code>C:\Users\&lt;UserName&gt;</code><br>创建 <code>.wslconfig</code> 文件填入以下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[wsl2]</span><br><span class="line">memory=10GB # Limits VM memory in WSL 2 to 4 GB</span><br><span class="line">processors=2 # Makes the WSL 2 VM use two virtual processors</span><br></pre></td></tr></table></figure><p>生效配置，命令行运行 <code>wsl --shutdown</code></p><h3 id="更多相关命令"><a href="#更多相关命令" class="headerlink" title="更多相关命令"></a>更多相关命令</h3><p><code>docker ps</code> 查看当前运行中的容器<br><code>docker images</code> 查看镜像列表<br><code>docker rm container-id</code> 删除指定 id 的容器<br><code>docker stop/start container-id</code> 停止&#x2F;启动指定 id 的容器<br><code>docker rmi image-id</code> 删除指定 id 的镜像<br><code>docker volume ls</code> 查看 volume 列表<br><code>docker network ls</code> 查看网络列表</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;💻Docker-快速安装软件&quot;&gt;&lt;a href=&quot;#💻Docker-快速安装软件&quot; class=&quot;headerlink&quot; title=&quot;💻Docker 快速安装软件&quot;&gt;&lt;/a&gt;💻Docker 快速安装软件&lt;/h1&gt;&lt;h3 id=&quot;直接安装的缺点&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="Docker" scheme="http://cvki.cn/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://cvki.cn/tags/Docker/"/>
    
    <category term="Docker快速入门" scheme="http://cvki.cn/tags/Docker%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Docker快速入门&amp;Docker 简介和安装</title>
    <link href="http://cvki.cn/posts/87fcc52f.html"/>
    <id>http://cvki.cn/posts/87fcc52f.html</id>
    <published>2023-05-03T03:19:18.000Z</published>
    <updated>2023-08-18T08:21:25.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="🎉Docker-简介和安装"><a href="#🎉Docker-简介和安装" class="headerlink" title="🎉Docker 简介和安装"></a>🎉Docker 简介和安装</h1><h3 id="Docker-是什么"><a href="#Docker-是什么" class="headerlink" title="Docker 是什么"></a>Docker 是什么</h3><p>Docker 是一个应用打包、分发、部署的工具<br>你也可以把它理解为一个轻量的虚拟机，它只虚拟你软件需要的运行环境，多余的一点都不要，<br>而普通虚拟机则是一个完整而庞大的系统，包含各种不管你要不要的软件。</p><h3 id="跟普通虚拟机的对比"><a href="#跟普通虚拟机的对比" class="headerlink" title="跟普通虚拟机的对比"></a>跟普通虚拟机的对比</h3><table><thead><tr><th>特性</th><th>普通虚拟机</th><th>Docker</th></tr></thead><tbody><tr><td>跨平台</td><td>通常只能在桌面级系统运行，例如 Windows&#x2F;Mac，无法在不带图形界面的服务器上运行</td><td>支持的系统非常多，各类 windows 和 Linux 都支持</td></tr><tr><td>性能</td><td>性能损耗大，内存占用高，因为是把整个完整系统都虚拟出来了</td><td>性能好，只虚拟软件所需运行环境，最大化减少没用的配置</td></tr><tr><td>自动化</td><td>需要手动安装所有东西</td><td>一个命令就可以自动部署好所需环境</td></tr><tr><td>稳定性</td><td>稳定性不高，不同系统差异大</td><td>稳定性好，不同系统都一样部署方式</td></tr></tbody></table><h3 id="打包、分发、部署"><a href="#打包、分发、部署" class="headerlink" title="打包、分发、部署"></a>打包、分发、部署</h3><p><strong>打包</strong>：就是把你软件运行所需的依赖、第三方库、软件打包到一起，变成一个安装包<br><strong>分发</strong>：你可以把你打包好的“安装包”上传到一个镜像仓库，其他人可以非常方便的获取和安装<br><strong>部署</strong>：拿着“安装包”就可以一个命令运行起来你的应用，自动模拟出一摸一样的运行环境，不管是在 Windows&#x2F;Mac&#x2F;Linux。</p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/87fcc52f/kv7rlicu.png" alt="image.png"></div><div class="image-meta"><span class="image-caption center">image.png</span></div></div><h3 id="Docker-部署的优势"><a href="#Docker-部署的优势" class="headerlink" title="Docker 部署的优势"></a>Docker 部署的优势</h3><p>常规应用开发部署方式：自己在 Windows 上开发、测试 –&gt; 到 Linux 服务器配置运行环境部署。</p><blockquote><p>问题：我机器上跑都没问题，怎么到服务器就各种问题了</p></blockquote><p>用 Docker 开发部署流程：自己在 Windows 上开发、测试 –&gt; 打包为 Docker 镜像（可以理解为软件安装包） –&gt; 各种服务器上只需要一个命令部署好</p><blockquote><p>优点：确保了不同机器上跑都是一致的运行环境，不会出现我机器上跑正常，你机器跑就有问题的情况。</p></blockquote><p>例如 <a href="https://easydoc.net/">易文档</a>，<a href="https://svnbucket.com/">SVNBucket</a> 的私有化部署就是用 Docker，轻松应对客户的各种服务器。</p><h3 id="Docker-通常用来做什么"><a href="#Docker-通常用来做什么" class="headerlink" title="Docker 通常用来做什么"></a>Docker 通常用来做什么</h3><ul><li>应用分发、部署，方便传播给他人安装。特别是开源软件和提供私有部署的应用</li><li>快速安装测试&#x2F;学习软件，用完就丢（类似小程序），不把时间浪费在安装软件上。例如 Redis &#x2F; MongoDB &#x2F; ElasticSearch &#x2F; ELK</li><li>多个版本软件共存，不污染系统，例如 Python2、Python3，Redis4.0，Redis5.0</li><li>Windows 上体验&#x2F;学习各种 Linux 系统</li></ul><h3 id="重要概念：镜像、容器"><a href="#重要概念：镜像、容器" class="headerlink" title="重要概念：镜像、容器"></a>重要概念：镜像、容器</h3><p><strong>镜像</strong>：可以理解为软件安装包，可以方便的进行传播和安装。<br><strong>容器</strong>：软件安装后的状态，每个软件运行环境都是独立的、隔离的，称之为容器。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>桌面版：<a href="https://www.docker.com/products/docker-desktop">https://www.docker.com/products/docker-desktop</a><br>服务器版：<a href="https://docs.docker.com/engine/install/#server">https://docs.docker.com/engine/install/#server</a></p><h3 id="启动报错解决"><a href="#启动报错解决" class="headerlink" title="启动报错解决"></a>启动报错解决</h3><p>报错截图</p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/87fcc52f/kvacsk82.png)" alt="**解决方法**： 控制面板->程序->启用或关闭 windows 功能，开启 Windows 虚拟化和 Linux 子系统（WSL2 image.png"></div><div class="image-meta"><span class="image-caption center">**解决方法**： 控制面板->程序->启用或关闭 windows 功能，开启 Windows 虚拟化和 Linux 子系统（WSL2 image.png</span></div></div><div class="tag-plugin image"><div class="image-bg"><img src="/posts/87fcc52f/kvactn57.png" alt="image.png"></div><div class="image-meta"><span class="image-caption center">image.png</span></div></div><p><strong>命令行安装 Linux 内核</strong><br><code>wsl.exe --install -d Ubuntu</code></p><blockquote><p>你也可以打开微软商店 Microsoft Store 搜索 Linux 进行安装，选择一个最新版本的 Ubuntu 或者 Debian 都可以</p></blockquote><blockquote><p>上面命令很可能你安装不了，微软商店你也可能打不开，如果遇到这个问题，参考：<a href="https://blog.csdn.net/qq_42220935/article/details/104714114">https://blog.csdn.net/qq_42220935/article/details/104714114</a></p></blockquote><p><strong>设置开机启动 Hypervisor</strong><br><code>bcdedit /set hypervisorlaunchtype auto</code></p><blockquote><p>注意要用管理员权限打开 PowerShell</p></blockquote><p><strong>设置默认使用版本2</strong><br><code>wsl.exe --set-default-version 2</code></p><p><strong>查看 WSL 是否安装正确</strong><br><code>wsl.exe --list --verbose</code><br>应该如下图，可以看到一个 Linux 系统，名字你的不一定跟我的一样，看你安装的是什么版本。<br>并且 VERSION 是 2</p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/87fcc52f/ldxvkks2.png" alt="image.png"></div><div class="image-meta"><span class="image-caption center">image.png</span></div></div><p><strong>确保 BIOS 已开启虚拟化，下图检查是否已开启好</strong></p><blockquote><p>如果是已禁用，请在开机时按 F2 进入 BIOS 开启一下，不会设置的可以网上搜索下自己主板的设置方法，Intel 和 AMD 的设置可能稍有不同</p></blockquote><div class="tag-plugin image"><div class="image-bg"><img src="/posts/87fcc52f/kvaf7ody.png" alt="image.png"></div><div class="image-meta"><span class="image-caption center">image.png</span></div></div><p><strong>出现下图错误，点击链接安装最新版本的 WSL2</strong><br><a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi</a></p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/87fcc52f/kvajwvuw.png" alt="image.png"></div><div class="image-meta"><span class="image-caption center">image.png</span></div></div><h3 id="镜像加速源"><a href="#镜像加速源" class="headerlink" title="镜像加速源"></a>镜像加速源</h3><table><thead><tr><th>镜像加速器</th><th>镜像加速器地址</th></tr></thead><tbody><tr><td>Docker 中国官方镜像</td><td><a href="https://registry.docker-cn.com/">https://registry.docker-cn.com</a></td></tr><tr><td>DaoCloud 镜像站</td><td><a href="http://f1361db2.m.daocloud.io/">http://f1361db2.m.daocloud.io</a></td></tr><tr><td>Azure 中国镜像</td><td><a href="https://dockerhub.azk8s.cn/">https://dockerhub.azk8s.cn</a></td></tr><tr><td>科大镜像站</td><td><a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn</a></td></tr><tr><td>阿里云</td><td><a href="https://ud6340vz.mirror.aliyuncs.com/">https://ud6340vz.mirror.aliyuncs.com</a></td></tr><tr><td>七牛云</td><td><a href="https://reg-mirror.qiniu.com/">https://reg-mirror.qiniu.com</a></td></tr><tr><td>网易云</td><td><a href="https://hub-mirror.c.163.com/">https://hub-mirror.c.163.com</a></td></tr><tr><td>腾讯云</td><td><a href="https://mirror.ccs.tencentyun.com/">https://mirror.ccs.tencentyun.com</a></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]</span><br></pre></td></tr></table></figure><div class="tag-plugin image"><div class="image-bg"><img src="/posts/87fcc52f/l25jdwrn.png" alt="1.png"></div><div class="image-meta"><span class="image-caption center">1.png</span></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;🎉Docker-简介和安装&quot;&gt;&lt;a href=&quot;#🎉Docker-简介和安装&quot; class=&quot;headerlink&quot; title=&quot;🎉Docker 简介和安装&quot;&gt;&lt;/a&gt;🎉Docker 简介和安装&lt;/h1&gt;&lt;h3 id=&quot;Docker-是什么&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="Docker" scheme="http://cvki.cn/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://cvki.cn/tags/Docker/"/>
    
    <category term="Docker快速入门" scheme="http://cvki.cn/tags/Docker%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Docker学习笔记之基础篇</title>
    <link href="http://cvki.cn/posts/85fe2496.html"/>
    <id>http://cvki.cn/posts/85fe2496.html</id>
    <published>2023-04-06T11:10:13.000Z</published>
    <updated>2023-08-18T08:21:25.578Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习资料：</p></blockquote><p><a href="https://www.bilibili.com/video/BV1og4y1q7M4">【狂神说Java】Docker最新超详细版教程通俗易懂_哔哩哔哩_bilibili</a></p><p><a href="https://blog.csdn.net/huangjhai/article/details/118854733">Docker快速入门总结笔记_huangjhai的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/xiaozecheng/article/details/106165491">docker 进阶 之容器数据卷 DockerFile Docker网络 — 狂神说_cheng的博客-CSDN博客</a></p><p>官网：<a href="https://www.docker.com/">https://www.docker.com/</a></p><p>文档地址： <a href="https://docs.docker.com/">https://docs.docker.com/</a> （Docker 官网文档超级详细）</p><p>仓库地址：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p><p><a href="http://www.dockerinfo.net/document">Docker中文文档 Docker概述-DockerInfo</a></p><p><a href="https://blog.csdn.net/nickDaDa/article/details/88716395">Docker 中文文档（译）_nickDaDa的博客-CSDN博客_docker中文文档</a></p><h2 id="1、Docker概述"><a href="#1、Docker概述" class="headerlink" title="1、Docker概述"></a>1、Docker概述</h2><h2 id="1-1-Docker-为什么会出现"><a href="#1-1-Docker-为什么会出现" class="headerlink" title="1.1 Docker 为什么会出现"></a>1.1 Docker 为什么会出现</h2><blockquote><p>一款产品上线：面临问题：</p></blockquote><p>问题1：开发 和 上线 俩套环境</p><p>问题2：开发人员 和 运维人员 ，开发测试可运行，上线就运行不了</p><p>问题3：环境配置十分麻烦，每个机器都要部署环境（集群 Redis、ES、Hadoop 等等）</p><p>问题4： 发布 jar包 时 又要 部署（Mysql、ES、Redis、jdk 等等）费时的环境，希望jar + 环境一起发布</p><p>问题5：部署的环境不能跨平台 windows 与 Linux</p><p><strong>Docker 给以上问题提出了解决方案</strong></p><p>传统：开发打jar包 给运维来部署</p><p>现在：开发即负责打包又负责部署，全栈开发</p><p>开发人员 打jar包带上环境（这里的环境称为<strong>镜像</strong>） – Docker 仓库（商店） – 运维人员下载 <strong>镜像</strong> 可直接运行</p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406171433771.png" alt="image-20230406171433771"></div><div class="image-meta"><span class="image-caption center">image-20230406171433771</span></div></div><p>docker 的 思想 来源于 集装箱 ，打包装箱，相互隔离</p><p><strong>虚拟机非常笨重，而docker十分小巧。</strong></p><p>开源：开放源代码</p><h2 id="1-2-Docker的概述"><a href="#1-2-Docker的概述" class="headerlink" title="1.2 Docker的概述"></a>1.2 Docker的概述</h2><blockquote><p>1、基本介绍</p></blockquote><p> Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。</p><p> Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><p> 容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p><p> Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版），我们用社区版就可以了。</p><p>官网：<a href="https://www.docker.com/">https://www.docker.com/</a></p><p>文档地址： <a href="https://docs.docker.com/">https://docs.docker.com/</a> （<strong>Docker 官网文档超级详细</strong>）</p><p>仓库地址：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p><blockquote><p>2、应用场景</p></blockquote><p> Web 应用的自动化打包和发布。</p><p> 自动化测试和持续集成、发布。</p><p> 在服务型环境中部署和调整数据库或其他的后台应用。</p><p> 从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</p><blockquote><p>3、Docker 的优势</p></blockquote><p> Docker 是一个用于开发，交付和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助 Docker，您可以与管理应用程序相同的方式来管理基础架构。通过利用 Docker 的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。</p><p>(1) 快速，一致地交付您的应用程序。</p><p> Docker 允许开发人员使用您提供的应用程序或服务的本地容器在标准化环境中工作，从而简化了开发的生命周期。</p><p> 容器非常适合持续集成和持续交付（CI &#x2F; CD）工作流程，请考虑以下示例方案：</p><p> 您的开发人员在本地编写代码，并使用 Docker 容器与同事共享他们的工作。他们使用 Docker 将其应用程序推送到测试环境中，并执行自动或手动测试。当开发人员发现错误时，他们可以在开发环境中对其进行修复，然后将其重新部署到测试环境中，以进行测试和验证。测试完成后，将修补程序推送给生产环境，就像将更新的镜像推送到生产环境一样简单。</p><p>(2) 响应式部署和扩展-<br>Docker 是基于容器的平台，允许高度可移植的工作负载。Docker 容器可以在开发人员的本机上，数据中心的物理或虚拟机上，云服务上或混合环境中运行。</p><p> Docker 的可移植性和轻量级的特性，还可以使您轻松地完成动态管理的工作负担，并根据业务需求指示，实时扩展或拆除应用程序和服务。</p><p>(3) 在同一硬件上运行更多工作负载-<br>Docker 轻巧快速。它为基于虚拟机管理程序的虚拟机提供了可行、经济、高效的替代方案，因此您可以利用更多的计算能力来实现业务目标。Docker 非常适合于高密度环境以及中小型部署，而您可以用更少的资源做更多的事情。</p><h2 id="2、-虚拟化技术和容器化技术"><a href="#2、-虚拟化技术和容器化技术" class="headerlink" title="2、 虚拟化技术和容器化技术"></a>2、 虚拟化技术和容器化技术</h2><p> 虚拟化技术特点：1.资源占用多 2.冗余步骤多 3.启动很慢</p><p> 容器化技术：容器化技术不是模拟的一个完整的操作系统</p><p> 虚拟机非常笨重，而docker十分小巧。</p><blockquote><p>比较Docker和虚拟机的不同：</p></blockquote><ul><li>传统虚拟机：</li></ul><p> 虚拟出硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件。</p><ul><li>Docker容器 ：</li></ul><p> Docker容器内的应用直接运行在宿主机的内容，容器是没有自己的内核的，也没有虚拟硬件。</p><p> 每个容器都是相互隔离的，每个容器都有属于自己的文件系统，互不影响。</p><blockquote><p>DevOps (Dev:开发，Ops:运维)</p></blockquote><p>容器化带来的好处：</p><ul><li>应用更快速的交付和部署-<br>传统：一堆帮助文档，安装程序-<br>Docker :打包镜像发布测试，一键运行</li><li>更便捷的升级和扩缩容-<br>使用了Docker之后，我们部署应用就和搭积木一样！-<br>项目打包为一个镜像，扩展服务器A !服务器B</li><li>更简单的系统运维-<br>在容器化之后，我们的开发，测试环境都是高度一致的.</li><li>更高效的计算资源利用：-<br>Docker是内核级别的虚拟化，可以再一个物理机上可以运行很多的容器实例！服务器的性能可以被压榨到极致。</li></ul><h2 id="3、-Docker的基本组成"><a href="#3、-Docker的基本组成" class="headerlink" title="3、 Docker的基本组成"></a>3、 Docker的基本组成</h2><blockquote><p>Docker的基本组成图如下：</p></blockquote><p>Client:客户端</p><p>DOCKER_HOST:docker的主机（服务器）</p><p>Registry: 远程仓库</p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406171444126.png" alt="image-20230406171444126"></div><div class="image-meta"><span class="image-caption center">image-20230406171444126</span></div></div><blockquote><p>基本组成</p></blockquote><ul><li><p>镜像(image ):-<br>docker镜像就好比是一个模板，可以通过这个模板来创建容器服务，tomcat镜像&#x3D;&#x3D;&gt; run &#x3D;&#x3D;&gt; tomcatOI容器(提供服务器)，通过这个镜像可以创建多个容器(最终服务运行或者项目运行就是在容器中的).</p><p> 开发人员 打jar包带上环境（这里的环境称为<strong>镜像</strong>）</p></li><li><p>容器(container ):-<br>Docker用容器技术，独立运行Y或者一个组应用，通过镜像来创建的。启动，停止，删除，基本命令！目前就可以把这个容器理解为就是一个简易的linux系统</p><p><strong>镜像启动后出现容器</strong></p><p>（镜像相当于类，容器相当于实例。一个镜像可以创建多个容器）</p></li><li><p>仓库(repository ):-<br>仓库就是存放镜像的地方！仓库分为公有仓库和私有仓库！Docker Hub (默认是国外的)</p></li></ul><h2 id="4、-Docker的安装"><a href="#4、-Docker的安装" class="headerlink" title="4、 Docker的安装"></a>4、 Docker的安装</h2><p><a href="https://docs.docker.com/engine/install/centos/">在 CentOS | 上安装 Docker 引擎Docker 文档</a></p><blockquote><p>环境准备</p></blockquote><p>Linux CentOS7</p><p>1、查看系统的内核：<code>uname -r</code></p><p>系统内核版本为3.10.0</p><pre><code>[root@192 ~]#  uname -r3.10.0-1160.el7.x86_64</code></pre><p>​        </p><p>2、查看系统配置<code>cat /etc/os-release</code></p><pre><code>[root@192 ~]# cat /etc/os-releaseNAME=&quot;CentOS Linux&quot;VERSION=&quot;7 (Core)&quot;ID=&quot;centos&quot;ID_LIKE=&quot;rhel fedora&quot;VERSION_ID=&quot;7&quot;PRETTY_NAME=&quot;CentOS Linux 7 (Core)&quot;ANSI_COLOR=&quot;0;31&quot;CPE_NAME=&quot;cpe:/o:centos:centos:7&quot;HOME_URL=&quot;https://www.centos.org/&quot;BUG_REPORT_URL=&quot;https://bugs.centos.org/&quot;CENTOS_MANTISBT_PROJECT=&quot;CentOS-7&quot;CENTOS_MANTISBT_PROJECT_VERSION=&quot;7&quot;REDHAT_SUPPORT_PRODUCT=&quot;centos&quot;REDHAT_SUPPORT_PRODUCT_VERSION=&quot;7&quot;</code></pre><p>​        </p><blockquote><p>卸载旧版本</p></blockquote><p>旧版本的 Docker 被称为 或 .如果已安装这些项，请将其以及关联的依赖项一起卸载。</p><pre><code>[root@192 ~]# sudo yum remove docker \                  docker-client \                  docker-client-latest \                  docker-common \                  docker-latest \                  docker-latest-logrotate \                  docker-logrotate \                  docker-engine</code></pre><p>​        </p><h2 id="4-1-开始安装"><a href="#4-1-开始安装" class="headerlink" title="4.1 开始安装"></a>4.1 开始安装</h2><blockquote><p>Docker的安装步骤</p></blockquote><p>1、下载需要的安装包</p><pre><code>yum install -y yum-utils</code></pre><p>​        </p><p>2、设置阿里云的Docker镜像仓库</p><pre><code>yum-config-manager \    --add-repo \    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo </code></pre><p>​        </p><p>3、更新yum软件包索引</p><pre><code>yum makecache fast</code></pre><p>​        </p><p>4、安装docker相关的配置</p><p>docker-ce 是社区版，docker-ee 企业版</p><pre><code> yum install docker-ce docker-ce-cli containerd.io</code></pre><p>​        </p><p>出现了completed（或 完毕！）即安装成功。</p><p>5、启动Docker</p><pre><code># 启动Dockersystemctl start docker# 查看当前版本号，是否启动成功docker version# 设置开机自启动systemctl enable docker</code></pre><p>​        </p><h2 id="4-2-hello-world镜像测试"><a href="#4-2-hello-world镜像测试" class="headerlink" title="4.2 hello-world镜像测试"></a>4.2 hello-world镜像测试</h2><p>1、下载hello-world镜像进行测试</p><pre><code>docker run hello-world</code></pre><p>​        </p><pre><code>[root@192 ~]# clear[root@192 ~]# docker run hello-worldUnable to find image &#39;hello-world:latest&#39; locally //本地没在到 hello-world 镜像latest: Pulling from library/hello-world // pull 远程拉取 hello-world 镜像2db29710123e: Pull complete  // pull完成Digest: sha256:507ecde44b8eb741278274653120c2bf793b174c06ff4eaa672b713b3263477bStatus: Downloaded newer image for hello-world:latestHello from Docker! //运行成功This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.    (amd64) 3. The Docker daemon created a new container from that image which runs the    executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it    to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/get-started/</code></pre><p>​        </p><p>2、查看下载的hello-world镜像</p><pre><code>[root@192 ~]# docker imagesREPOSITORY    TAG       IMAGE ID       CREATED        SIZEhello-world   latest    feb5d9fea6a5   4 months ago   13.3kB //hello-world镜像</code></pre><p>​        </p><blockquote><p>Docker的卸载</p></blockquote><p>1、卸载依赖</p><pre><code>yum remove docker-ce docker-ce-cli containerd.io</code></pre><p>​        </p><p>2、删除资源 <code>./var/lib/docker</code>是docker的默认工作路径</p><pre><code>rm -rf /var/lib/docker</code></pre><p>​        </p><h2 id="5、配置阿里云镜像加速"><a href="#5、配置阿里云镜像加速" class="headerlink" title="5、配置阿里云镜像加速"></a>5、配置阿里云镜像加速</h2><p><strong>本地机器无法使用</strong></p><p>1、进入阿里云官网，搜索容器镜像服务</p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406171456451.png" alt="image-20230406171456451"></div><div class="image-meta"><span class="image-caption center">image-20230406171456451</span></div></div><p>2、同时执行官方的命令</p><pre><code>sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39;&#123;  &quot;registry-mirrors&quot;: [&quot;https://2y5oty1p.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docke</code></pre><p>​        </p><p>3、查看配置命令<code>docker info</code>，配置成功-</p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406171511070.png" alt="image-20230406171511070"></div><div class="image-meta"><span class="image-caption center">image-20230406171511070</span></div></div><h2 id="6、Docker原理"><a href="#6、Docker原理" class="headerlink" title="6、Docker原理"></a>6、Docker原理</h2><h2 id="6-1-Docker容器运行流程"><a href="#6-1-Docker容器运行流程" class="headerlink" title="6.1 Docker容器运行流程"></a>6.1 Docker容器运行流程</h2><p>启动一个容器，<code>docker run</code>的运行流程如下图：</p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406171517262.png" alt="image-20230406171517262"></div><div class="image-meta"><span class="image-caption center">image-20230406171517262</span></div></div><h2 id="6-2-底层原理"><a href="#6-2-底层原理" class="headerlink" title="6.2 底层原理"></a>6.2 底层原理</h2><p>Docker是一个Client-Server（客户端-服务器）结构的系统，Docker的守护进程运行在主机上，通过Socker从客户端访问！Docker Server(服务器)接收到Docker-Client(客户端)的指令，就会执行这个指令！</p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406171533139.png" alt="image-20230406171533139"></div><div class="image-meta"><span class="image-caption center">image-20230406171533139</span></div></div><blockquote><p>Docker为什么比VMWare(虚拟机)快？</p></blockquote><p>1、Docker比虚拟机更少的抽象层</p><p>2、docker利用宿主机的内核，而VM需要的是Guest OS（虚拟机操作系统）</p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406171547989.png" alt="image-20230406171547989"></div><div class="image-meta"><span class="image-caption center">image-20230406171547989</span></div></div><p> Docker新建一个容器的时候，不需要像虚拟机一样重新加载一个操作系统内核，直接利用宿主机的操作系统，而虚拟机是需要加载Guest OS（虚拟机操作系统）。Docker和VM的对比如下：</p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406171551174.png" alt="image-20230406171551174"></div><div class="image-meta"><span class="image-caption center">image-20230406171551174</span></div></div><h2 id="7、Docker常用命令"><a href="#7、Docker常用命令" class="headerlink" title="7、Docker常用命令"></a>7、Docker常用命令</h2><p>命令的帮助文档地址:<a href="https://docs.docker.com/engine/reference/commandline/docker/">https://docs.docker.com/engine/reference/commandline/docker/</a></p><h2 id="7-1-全部命令"><a href="#7-1-全部命令" class="headerlink" title="7.1 全部命令"></a>7.1 全部命令</h2><pre><code>[root@192 ~]# docker --help Usage:  docker [OPTIONS] COMMAND// docker [选项] 命令A self-sufficient runtime for containers //翻译：容器的自给自足运行时</code></pre><p>​<br>​    Options:【选项】<br>​          –config string      &#x2F;&#x2F;客户端配置文件的位置 (default “&#x2F;root&#x2F;.docker”)<br>​      -c, –context string    &#x2F;&#x2F;用于连接到守护进程的上下文的名称(覆盖DOCKER_HOST env变量和默认上下文设置 “docker context use”)<br>​      -D, –debug              &#x2F;&#x2F;启用调试模式<br>​      -H, –host list          &#x2F;&#x2F;守护进程 socket(s) 连接<br>​      -l, –log-level string   &#x2F;&#x2F;设置日志级别 (“debug”|”info”|”warn”|”error”|”fatal”) (default “info”)<br>​          –tls                &#x2F;&#x2F;使用 TLS; 隐含 –tlsverify<br>​          –tlscacert string   &#x2F;&#x2F;仅由此CA签名的信任证书(default “&#x2F;root&#x2F;.docker&#x2F;ca.pem”)<br>​          –tlscert string     &#x2F;&#x2F;TLS证书文件路径 (default “&#x2F;root&#x2F;.docker&#x2F;cert.pem”)<br>​          –tlskey string      &#x2F;&#x2F;TLS密钥文件的路径  (default “&#x2F;root&#x2F;.docker&#x2F;key.pem”)<br>​          –tlsverify          &#x2F;&#x2F;使用TLS并验证远端<br>​      -v, –version            &#x2F;&#x2F;打印版本信息并退出<br>​<br>​    Management Commands:【管理命令】<br>​      app*        Docker App (Docker Inc., v0.9.1-beta3)<br>​      builder     Manage(管理) builds<br>​      buildx*     Docker Buildx (Docker Inc., v0.7.1-docker)<br>​      config      Manage Docker configs<br>​      container   Manage containers &#x2F;&#x2F;containers:容器<br>​      context     Manage contexts<br>​      image       Manage images<br>​      manifest    Manage Docker image manifests and manifest lists &#x2F;&#x2F;管理Docker镜像清单和清单列表<br>​      network     Manage networks<br>​      node        Manage Swarm nodes &#x2F;&#x2F;群节点<br>​      plugin      Manage plugins &#x2F;&#x2F;插件<br>​      scan*       Docker Scan (Docker Inc., v0.12.0) &#x2F;&#x2F;Scan:扫描<br>​      secret      Manage Docker secrets &#x2F;&#x2F;密码<br>​      service     Manage services<br>​      stack       Manage Docker stacks<br>​      swarm       Manage Swarm &#x2F;&#x2F;群<br>​      system      Manage Docker<br>​      trust       Manage trust on Docker images &#x2F;&#x2F; trust:信任<br>​      volume      Manage volumes &#x2F;&#x2F;卷<br>​<br>​    Commands:【命令】<br>​      attach      &#x2F;&#x2F;将本地标准输入、输出和错误流附加到运行的容器 attach:附加<br>​      build       &#x2F;&#x2F;从Dockerfile构建一个映像<br>​      commit      &#x2F;&#x2F;根据容器的更改创建一个新镜像<br>​      cp          &#x2F;&#x2F;在容器和本地文件系统之间复制文件&#x2F;文件夹<br>​      create      &#x2F;&#x2F;创建一个新容器<br>​      diff        &#x2F;&#x2F;检查容器文件系统中文件或目录的更改<br>​      events      &#x2F;&#x2F;从服务器获取实时事件 events:事件<br>​      exec        &#x2F;&#x2F;在运行的容器中运行命令 exec:执行<br>​      export      &#x2F;&#x2F;将容器的文件系统导出为tar存档文件 export:导出<br>​      history     &#x2F;&#x2F;显示一个镜像的历史<br>​      images      &#x2F;&#x2F;镜像的列表<br>​      import      &#x2F;&#x2F;从tarball文件中导入内容以创建文件系统映像<br>​      info        &#x2F;&#x2F;显示整个系统的信息<br>​      inspect     &#x2F;&#x2F;返回Docker对象的底层信息 inspect:检查<br>​      kill        &#x2F;&#x2F;杀死一个或多个正在运行的容器<br>​      load        &#x2F;&#x2F;从tar存档文件或STDIN加载镜像<br>​      login       &#x2F;&#x2F;登录到Docker注册表<br>​      logout      &#x2F;&#x2F;从Docker注册表注销<br>​      logs        &#x2F;&#x2F;获取容器的日志<br>​      pause       &#x2F;&#x2F;暂停一个或多个容器中的所有进程 pause:暂停<br>​      port        &#x2F;&#x2F;列出容器的端口映射或特定映射<br>​      ps          &#x2F;&#x2F;容器的列表<br>​      pull        &#x2F;&#x2F;从仓库（registry）中拉取镜像或存储库<br>​      push        &#x2F;&#x2F;将镜像或存储库推送到仓库（registry）<br>​      rename      &#x2F;&#x2F;重命名一个容器<br>​      restart     &#x2F;&#x2F;重新启动一个或多个容器<br>​      rm          &#x2F;&#x2F;移除一个或多个容器<br>​      rmi          &#x2F;&#x2F;移除一个或多个镜像<br>​      run         &#x2F;&#x2F;在新容器中运行命令<br>​      save        &#x2F;&#x2F;将一个或多个镜像保存到tar存档文件(默认情况下流到STDOUT)<br>​      search      &#x2F;&#x2F;在Docker Hub搜索镜像<br>​      start       &#x2F;&#x2F;启动一个或多个停止的容器<br>​      stats       &#x2F;&#x2F;显示容器资源使用统计的实时流<br>​      stop        &#x2F;&#x2F;停止一个或多个正在运行的容器<br>​      tag         &#x2F;&#x2F;创建引用SOURCE_IMAGE的标记TARGET_IMAGE<br>​      top         &#x2F;&#x2F;显示容器的运行进程<br>​      unpause     &#x2F;&#x2F;取消暂停一个或多个容器中的所有进程 unpause:不暂停<br>​      update     &#x2F;&#x2F;更新一个或多个容器的配置<br>​      version    &#x2F;&#x2F;查看Docker版本信息<br>​      wait        &#x2F;&#x2F;阻塞直到一个或多个容器停止，然后打印它们的退出代码<br>​<br>​    Run ‘docker COMMAND –help’ for more information on a command.</p><p>​        </p><h2 id="7-2-基础命令"><a href="#7-2-基础命令" class="headerlink" title="7.2 基础命令"></a>7.2 基础命令</h2><pre><code>docker version          #查看docker的版本信息docker info             #查看docker的系统信息,包括镜像和容器的数量docker 命令 --help       #帮助命令(可查看可选的参数)docker COMMAND --helpdocker --help           #列出所有命令</code></pre><p>​        </p><h2 id="7-3-镜像命令"><a href="#7-3-镜像命令" class="headerlink" title="7.3 镜像命令"></a>7.3 镜像命令</h2><blockquote><p>拉取(下载)一个镜像</p></blockquote><pre><code>//docker pull 镜像[:tag]  tag:版本（版本默认最新）docker pull mysqldocker pull mysql:5.7 //指定版本</code></pre><p>​        </p><pre><code>[root@192 ~]# docker pull mysqlUsing default tag: latestlatest: Pulling from library/mysql# == 分层下载，docker iamge的核心联合文件系统 ==6552179c3509: Pull complete d69aa66e4482: Pull complete  3b19465b002b: Pull complete #...Digest: sha256:92d27b8222bbcf53bc42c70ca7cd1010d6c0527efc61f14980ce77c50932bef4 # 签名Status: Downloaded newer image for mysql:latestdocker.io/library/mysql:latest #真实地址# 下载成功[root@192 ~]# docker imagesREPOSITORY    TAG       IMAGE ID       CREATED        SIZEmysql         latest    d1dc36cf8d9e   3 days ago     519MBhello-world   latest    feb5d9fea6a5   4 months ago   13.3kB#等价于docker pull mysql 等价于 docker pull docker.io/library/mysqlzlatest</code></pre><p>​        </p><p><strong>分层下载</strong>,比如mysql5.7 与 mysql 8.0 有层一致就不用重新下载</p><blockquote><p><code>docker images</code> 查看本地主机的所有镜像</p></blockquote><pre><code>[root@iZwz99sm8v95sckz8bd2c4Z ~]# docker images[镜像的仓库源  镜像的标签  镜像的id     镜像的创建时间    镜像的大小]REPOSITORY    TAG       IMAGE ID       CREATED         SIZEhello-world   latest    bf756fb1ae65   11 months ago   13.3kB</code></pre><p>​<br>​    # 可选参数<br>​<br>​    -a&#x2F;–all 列出所有镜像<br>​    -q&#x2F;–quiet 只显示镜像的id</p><p>​        </p><blockquote><p><code>docker search</code> 搜索镜像</p></blockquote><pre><code>[root@192 ~]# docker search mysql  NAME                              DESCRIPTION                                     STARS     OFFICIAL   AUTOMATEDmysql                             MySQL is a widely used, open-source relation…   12043     [OK]       mariadb                           MariaDB Server is a high performing open sou…   4613      [OK]       mysql/mysql-server                Optimized MySQL Server Docker images. Create…   901       [OK]phpmyadmin                        phpMyAdmin - A web interface for MySQL and M…   439       [OK]       //...// STARS:收藏数</code></pre><p>​        </p><p>查看其可选参数</p><pre><code>[root@192 ~]# docker search --helpUsage:  docker search [OPTIONS] TERMSearch the Docker Hub for imagesOptions:  -f, --filter filter   //根据所提供的条件过滤输出      --format string   //使用Go模板的漂亮打印搜索      --limit int       //搜索结果的最大数目(默认25个)      --no-trunc        //不截断输出</code></pre><p>​        </p><blockquote><p>搜索收藏数大于3000的镜像</p></blockquote><pre><code>// STARS:收藏数[root@192 ~]# docker search mysql --filter=STARS=3000NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATEDmysql     MySQL is a widely used, open-source relation…   12043     [OK]       mariadb   MariaDB Server is a high performing open sou…   4613      [OK]  </code></pre><p>​        </p><blockquote><p>在仓库搜索</p></blockquote><p><a href="https://hub.docker.com/search?q=mysql&type=image">https://hub.docker.com/search?q=mysql&amp;type=image</a></p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406171559287.png" alt="image-20230406171559287"></div><div class="image-meta"><span class="image-caption center">image-20230406171559287</span></div></div><blockquote><p>删除镜像</p></blockquote><pre><code>docker rmi -f 【镜像id】</code></pre><p>​        </p><pre><code>[root@192 ~]# clear[root@192 ~]# docker rmi -f feb5d9fea6a5Untagged: hello-world:latestUntagged: hello-world@sha256:507ecde44b8eb741278274653120c2bf793b174c06ff4eaa672b713b3263477bDeleted: sha256:feb5d9fea6a5e9606aa995e879d862b825965ba48de054caab5ef356dc6b3412</code></pre><p>​        </p><ul><li><p>删除多个镜像</p><p>docker rmi -f 【镜像id】 【镜像id】 【镜像id】 …</p><p>​    </p></li><li><p>删除所有镜像</p><p>docker rmi -f $(docker images)</p><p>​</p></li></ul><h2 id="7-4-容器命令"><a href="#7-4-容器命令" class="headerlink" title="7.4 容器命令"></a>7.4 容器命令</h2><p><strong>镜像启动后出现容器</strong></p><p>（镜像相当于类，容器相当于实例。一个镜像可以创建多个容器）</p><p>（镜像相当于你安装系统时下载的镜像文件，而容器呢就相当于你安装好的系统）</p><blockquote><p>1、先拉取一个centos镜像</p></blockquote><pre><code>docker pull centos</code></pre><p>​        </p><pre><code>[root@192 ~]# docker pull centosUsing default tag: latestlatest: Pulling from library/centosa1d0c7532777: Pull complete Digest: sha256:a27fd8080b517143cbbbab9dfb7c8571c40d67d534bbdee55bd6c473f432b177Status: Downloaded newer image for centos:latestdocker.io/library/centos:latest</code></pre><p>​        </p><blockquote><p>运行容器</p></blockquote><p>run是新建一个容器(直接使用容器会自动退出)，start是启动一个已经存在的容器</p><pre><code>//image：镜像名字或id docker run [可选参数] image//参数说明--name=&quot;名字&quot;           //指定容器名字-d                     //后台方式运行 若没有提供服务则自动退出（停止）-it                    //使用交互方式运行,进入容器查看内容-p                     //指定容器的端口(小写的P)     -p ip:主机端口:容器端口  //配置主机端口映射到容器端口(小写的P)     -p 主机端口:容器端口      -p 容器端口  -P                     //随机指定端口(大写的P)</code></pre><p>​        </p><pre><code>[root@192 ~]# docker start --help// CONTAINER:容器idUsage:  docker start [OPTIONS] CONTAINER:容器id [CONTAINER...]//启动一个或多个停止的容器Options:  -a, --attach               //附加STDOUT/STDERR和前向信号      --detach-keys string   //覆盖用于分离容器的键序列  -i, --interactive         //将容器的STDIN</code></pre><p>​        </p><blockquote><p>进入容器</p></blockquote><pre><code>docker run -it centos /bin/bash</code></pre><p>​        </p><ul><li><p>容器内就是一个独立和隔离的centos环境</p><p>[root@192 ~]# docker run -it centos &#x2F;bin&#x2F;bash<br>[root@b8f211692996 &#x2F;]# ls<br>bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</p><p>​</p></li></ul><blockquote><p>退出容器<code>exit</code></p></blockquote><pre><code># exit 停止并退出容器（后台方式运行则仅退出）# Ctrl+P+Q  不停止容器退出[root@b8f211692996 /]# exitexit</code></pre><p>​        </p><blockquote><p>列出容器</p></blockquote><pre><code>docker ps    // 列出当前正在运行的容器docker ps -a   // 列出所有容器的运行记录docker ps -n=? // 显示最近创建的n个容器docker ps -q   // 只显示容器的编号</code></pre><p>​        </p><pre><code>[root@192 ~]# docker ps      #列出当前正在运行的容器CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS          PORTS     NAMESb8f211692996   centos    &quot;/bin/bash&quot;   14 minutes ago   Up 14 minutes             zealous_lichterman[root@192 ~]# docker ps -a   # 列出所有容器的运行记录CONTAINER ID   IMAGE          COMMAND       CREATED          STATUS                          PORTS     NAMES0f009b5ce7d7   centos         &quot;/bin/bash&quot;   3 minutes ago    Exited (0) About a minute ago             cool_lovelaceb8f211692996   centos         &quot;/bin/bash&quot;   14 minutes ago   Up 14 minutes                             zealous_lichterman9d6d432cfc32   feb5d9fea6a5   &quot;/hello&quot;      19 hours ago     Exited (0) 19 hours ago                   wizardly_booth53ef5a5247a6   feb5d9fea6a5   &quot;/hello&quot;      19 hours ago     Exited (0) 19 hours ago                   eloquent_chatterjee</code></pre><p>​        </p><blockquote><p>停止容器</p></blockquote><pre><code>[root@192 ~]# docker stop --help// CONTAINER：容器(但要用容器id才行)Usage:  docker stop [OPTIONS] CONTAINER [CONTAINER...]//翻译：停止一个或多个正在运行的容器Stop one or more running containersOptions:  -t, --time int   //在杀死它之前等待几秒钟 (default 10)</code></pre><p>​        </p><pre><code>[root@192 ~]# docker psCONTAINER ID   IMAGE     COMMAND       CREATED          STATUS          PORTS     NAMESeb679ca2e254   centos    &quot;/bin/bash&quot;   4 minutes ago    Up 4 minutes              blissful_robinsonb8f211692996   centos    &quot;/bin/bash&quot;   26 minutes ago   Up 26 minutes             zealous_lichterman[root@192 ~]# docker stop centosError response from daemon: No such container: centos[root@192 ~]# docker stop eb679ca2e254eb679ca2e254[root@192 ~]# docker stop b8f211692996b8f211692996[root@192 ~]# docker psCONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</code></pre><p>​        </p><blockquote><p>删除容器</p></blockquote><pre><code>docker rm 容器id                 # 删除指定的容器,不能删除正在运行的容器docker rm -f 容器id     # 强制删除，包括正在运行的容器docker rm -f $(docker ps -aq)   # 删除所有的容器docker ps -a -q|xargs docker rm # 删除所有的容器</code></pre><p>​        </p><blockquote><p>启动和停止容器</p></blockquote><pre><code>docker start 容器id          #启动容器docker restart 容器id        #重启容器docker stop 容器id           #停止当前运行的容器docker kill 容器id           #强制停止当前容器</code></pre><p>​        </p><h2 id="7-5-其他常用命令"><a href="#7-5-其他常用命令" class="headerlink" title="7.5 其他常用命令"></a>7.5 其他常用命令</h2><blockquote><p>日志的查看</p></blockquote><pre><code>[root@192 ~]# docker logs --helpUsage:  docker logs [OPTIONS] CONTAINER//获取容器的日志Options:      --details        //显示提供给日志的额外细节  -f, --follow         //跟踪日志输出      --since string   //显示自定义时间戳以来的日志 (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes)  -n, --tail string    、、从日志的末尾显示的行数(default &quot;all&quot;)  -t, --timestamps     //显示时间戳      --until string  //在时间戳之前显示日志 (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes)//常用：docker logs -tf 【容器id】docker logs --tail number 【容器id】 //num为要显示的日志条数</code></pre><p>​        </p><pre><code>#docker容器后台运行，必须要有一个前台的进程，否则会自动停止#编写shell脚本循环执行，使得centos容器保持运行状态[root@192 ~]# docker run -d centos /bin/sh -c &quot;while true;do echo hi;sleep 5;done&quot;2b8ed9e4dcb655547b3c2aa28cd849179190ec03ecca2aabf9c7a44155b13097[root@192 ~]# docker psCONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMES2b8ed9e4dcb6   centos    &quot;/bin/sh -c &#39;while t…&quot;   3 seconds ago   Up 2 seconds             beautiful_elion[root@192 ~]# docker logs -tf --tail 10 2b8ed9e4dcb62022-01-31T02:32:36.215664841Z hi2022-01-31T02:32:41.224798220Z hi2022-01-31T02:32:46.227706348Z hi2022-01-31T02:32:51.243402617Z hi2022-01-31T02:32:56.257314943Z hi2022-01-31T02:33:01.284139739Z hi2022-01-31T02:33:06.294600809Z hi# Ctrl + Shift + c 退出</code></pre><p>​        </p><blockquote><p>查看容器中进程信息</p></blockquote><pre><code>docker top 容器id</code></pre><p>​        </p><pre><code>[root@192 ~]# docker top 2b8ed9e4dcb6UID     PID       PPID     C    STIME      TTY      TIME                CMDroot    11156    11135     0    11:31      ?     00:00:00     /bin/sh -c while true;do echo hi;sleep 5;doneroot     11886   11156     0     11:43     ?     00:00:00   /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 5</code></pre><p>​        </p><blockquote><p>查看容器的元数据</p></blockquote><pre><code>docker inspect 容器id</code></pre><p>​        </p><pre><code>[root@192 ~]# docker inspect 2b8ed9e4dcb6 # 显示的id是 真实id 的 缩写[    &#123;        &quot;Id&quot;: &quot;2b8ed9e4dcb655547b3c2aa28cd849179190ec03ecca2aabf9c7a44155b13097&quot;,# 真实id        &quot;Created&quot;: &quot;2022-01-31T02:32:35.769096414Z&quot;,        &quot;Path&quot;: &quot;/bin/sh&quot;,        &quot;Args&quot;: [            &quot;-c&quot;,            &quot;while true;do echo hi;sleep 5;done&quot;        ],        &quot;State&quot;: &#123;            &quot;Status&quot;: &quot;running&quot;,            &quot;Running&quot;: true,            &quot;Paused&quot;: false,</code></pre><p>​<br>​        </p><blockquote><p>进入当前正在运行的容器</p></blockquote><p>因为通常我们的容器都是使用后台方式来运行的，有时需要进入容器修改配置</p><pre><code>// 方式一 docker exec -it 【容器id】 /bin/bash// 方式二docker attach 【容器id】</code></pre><p>​        </p><p>方式一：进入容器后开启一个新的终端，可以在里面操作 （常用）</p><pre><code>[root@192 ~]# docker exec -it 2b8ed9e4dcb6 /bin/bash[root@2b8ed9e4dcb6 /]# lsbin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var# 查看进程[root@48c706c3a876 /]#  ps -ef UID         PID   PPID  C STIME TTY          TIME CMDroot          1      0  0 03:38 ?        00:00:00 /bin/sh -c while true;do echo hi;sleep 5;doneroot         12      0  0 03:38 pts/0    00:00:00 /bin/bashroot         28      1  0 03:38 ?        00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 5root         29     12  0 03:38 pts/0    00:00:00 ps -ef</code></pre><p>​        </p><p>方式二：进入容器正在执行的终端，不会启动新的进程</p><pre><code>[root@192 ~]# docker attach 2b8ed9e4dcb6 hihihi//...</code></pre><p>​        </p><blockquote><p>拷贝操作</p></blockquote><p>（还可以使用 -v 卷技术）</p><p>拷贝操作的命令如下：</p><pre><code>//将容器的文件拷贝到主机中docker cp 容器id:容器内路径  目的主机路径//docker cp 7b605b457f23:/home/Hello.txt hello.txt//将宿主机的文件拷贝到容器中docker cp 目的主机路径 容器id:容器内路径</code></pre><p>​        </p><ul><li><p>将容器的文件拷贝到主机中</p><p>[root@192 ~]# docker run -it centos &#x2F;bin&#x2F;bash<br>[root@7b605b457f23 &#x2F;]# cd home&#x2F;<br>[root@7b605b457f23 home]# touch Hello.txt<br>[root@7b605b457f23 home]# ls<br>Hello.txt</p><p>​</p></li></ul><p>1、在容器中新建文件</p><pre><code>[root@iZwz99sm8v95sckz8bd2c4Z ~]# docker exec -it c703b5b1911f /bin/bash[root@c703b5b1911f /]# cd home[root@c703b5b1911f home]# ls#touch 新建文件[root@c703b5b1911f home]# touch test.java[root@c703b5b1911f home]# lstest.java[root@c703b5b1911f home]# exitexit[root@iZwz99sm8v95sckz8bd2c4Z ~]# docker psCONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS     NAMESc703b5b1911f   centos    &quot;/bin/sh -c &#39;while t…&quot;   35 minutes ago   Up 35 minutes             pedantic_banach[root@iZwz99sm8v95sckz8bd2c4Z ~]# docker cp c703b5b1911f:/home/test.java /home[root@iZwz99sm8v95sckz8bd2c4Z ~]# ls /homehai  pan  test.java[root@7b605b457f23 home]# exitexit</code></pre><p>​        </p><p>2.copy文件</p><pre><code>[root@192 ~]# cd 桌面[root@192 桌面]# lsKuang[root@192 桌面]# docker psCONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES[root@192 桌面]# docker ps -aCONTAINER ID   IMAGE    COMMAND        CREATED         STATUS                     PORTS     NAMES7b605b457f23   centos   &quot;/bin/bash&quot;    3 minutes ago   Exited (0) 2 minutes ago     tender_burnell# ...[root@192 桌面]# docker cp 7b605b457f23:/home/Hello.txt hello.txt[root@192 桌面]# lshello.txt  Kuang # 成功</code></pre><p>​        </p><blockquote><p>常用命令小节</p></blockquote><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406171613580.png" alt="image-20230406171613580"></div><div class="image-meta"><span class="image-caption center">image-20230406171613580</span></div></div><h2 id="8、docker-练习"><a href="#8、docker-练习" class="headerlink" title="8、docker 练习"></a>8、docker 练习</h2><h2 id="8-1-部署Nginx"><a href="#8-1-部署Nginx" class="headerlink" title="8.1 部署Nginx"></a>8.1 部署Nginx</h2><p>（Nginx：是一个高性能的HTTP和反向代理web服务器）</p><p>1、搜索nginx</p><p><a href="https://hub.docker.com//_/nginx">https://hub.docker.com/\_/nginx</a></p><pre><code>[root@192 ~]# docker search nginxNAME                DESCRIPTION                            STARS     OFFICIAL   AUTOMATEDnginx            Official build of Nginx.                  16232     [OK] //...</code></pre><p>​        </p><p>2、拉取nginx</p><pre><code>[root@192 ~]# docker pull nginxUsing default tag: latestlatest: Pulling from library/nginx5eb5b503b376: Pull complete 1ae07ab881bd: Pull complete 78091884b7be: Pull complete 091c283c6a66: Pull complete 55de5851019b: Pull complete b559bad762be: Pull complete Digest: sha256:2834dc507516af02784808c5f48b7cbe38b8ed5d0f4837f16e78d00deb7e7767Status: Downloaded newer image for nginx:latestdocker.io/library/nginx:latest[root@192 ~]# docker images # 下载成功REPOSITORY   TAG       IMAGE ID       CREATED        SIZEnginx        latest    c316d5a335a5   4 days ago     142MB</code></pre><p>​        </p><p>3、启动nginx镜像</p><pre><code>[root@192 ~]# docker run -d --name nginx01 -p 8801:80 nginxb93af0c28d2baca7b03dc34eaf6d0b8778abdb989e091d9461351a48b12fb706[root@192 ~]# docker ps #运行成功CONTAINER ID   IMAGE       COMMAND                  CREATED          STATUS                PORTS                           NAMESb93af0c28d2b   nginx     &quot;/docker-entrypoint.…&quot;   13 seconds ago   Up 11 seconds   0.0.0.0:8801-&gt;80/tcp, :::8801-&gt;80/tcp   nginx01</code></pre><p>​<br>​        </p><p> <code>-p 8801:80</code>通过端口映射将 主机的8801端口 与 容器的80端口 连通，从而暴露 容器的80端口</p><p>4、测试连接nginx</p><pre><code>[root@192 ~]# curl localhost:8801&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;&lt;style&gt;html &#123; color-scheme: light dark; &#125;body &#123; width: 35em; margin: 0 auto;font-family: Tahoma, Verdana, Arial, sans-serif; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt; # 连接成功&lt;p&gt;If you see this page, the nginx web server is successfully installed andworking. Further configuration is required.&lt;/p&gt;&lt;p&gt;For online documentation and support please refer to&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;Commercial support is available at&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>​        </p><ul><li>windows（外网）上访问成功</li></ul><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406171622920.png" alt="image-20230406171622920"></div><div class="image-meta"><span class="image-caption center">image-20230406171622920</span></div></div><p>5、进入nginx容器</p><pre><code>[root@192 ~]# docker exec -it nginx01 /bin/bashroot@b93af0c28d2b:/# whereis nginxnginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx</code></pre><p>​        </p><h2 id="8-2-部署Tomcat"><a href="#8-2-部署Tomcat" class="headerlink" title="8.2 部署Tomcat"></a>8.2 部署Tomcat</h2><p>1、搜索tomcat</p><pre><code>[root@192 ~]# docker search tomcatNAME                          DESCRIPTION                                     STARS     OFFICIAL   AUTOMATEDtomcat                        Apache Tomcat is an open source implementati…   3248      [OK]       </code></pre><p>​        </p><p>2、拉取tomcat</p><pre><code>docker pull tomcat:9.0</code></pre><p>​        </p><pre><code>[root@192 ~]# docker pull tomcat:9.09.0: Pulling from library/tomcat0c6b8ff8c37e: Pull complete # ...Digest: sha256:c1cbd0fcc6d937c79d9f84ad6747b8ace4846a7ddf44f9344695c61f7443fa02Status: Downloaded newer image for tomcat:9.0docker.io/library/tomcat:9.0</code></pre><p>​        </p><p>3、启动Tomcat</p><pre><code>docker run -d -p 8002:8080 --name tomcat01 tomcat</code></pre><p>​        </p><ul><li><p>docker 自动给我下载最新版（启动成功）</p><p>[root@192 ~]# docker run -d -p 8002:8080 –name tomcat01 tomcat<br>Unable to find image ‘tomcat:latest’ locally # 没有发现最新版<br>latest: Pulling from library&#x2F;tomcat<br>0c6b8ff8c37e: Already exists # 下载Tomcat9.0时已下载</p><h1 id="…"><a href="#…" class="headerlink" title="…"></a>…</h1><p>bc5c573a9ab7: Pull complete # 补充下载<br>f9f34f3a3d27: Pull complete<br>Digest: sha256:28ef9f9a08f812de2f7f1de9076f39c911e5f92615ea168693964fbc2247701c<br>Status: Downloaded newer image for tomcat:latest<br>b55631abdbffbe3bf156050846e71f03834f8984bf4fe96952ddda46e209967b #启动成功，容器id</p><p>​    </p></li><li><p>启动成功</p><p>[root@192 ~]# docker ps<br>CONTAINER ID   IMAGE     COMMAND             CREATED          STATUS          PORTS                                       NAMES<br>b55631abdbff   tomcat    “catalina.sh run”   33 seconds ago   Up 30 seconds   0.0.0.0:8002-&gt;8080&#x2F;tcp, :::8002-&gt;8080&#x2F;tcp   tomcat01 </p><p>​</p></li></ul><p>4、测试，windows(外网)访问成功-</p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406171634897.png" alt="image-20230406171634897"></div><div class="image-meta"><span class="image-caption center">image-20230406171634897</span></div></div><p>5、进入tomcat容器</p><pre><code>docker exec -it nginx01 /bin/bash</code></pre><p>​        </p><pre><code>[root@192 ~]# docker exec -it tomcat01 /bin/bashroot@b55631abdbff:/usr/local/tomcat# lsBUILDING.txt LICENSE  README.md RUNNING.txt  conf  logs    temp     webapps.distCONTRIBUTING.md  NOTICE   RELEASE-NOTES  bin      lib   native-jni-lib  webapps  work</code></pre><p>​        </p><p>(容器中的命令是少了,阿里云镜像默认下载的是最小的镜像，保证最小的运行环境。)</p><p>6、部署网站</p><p> 在webapps.dist文件在个tomcat网站代码</p><pre><code>root@b55631abdbff:/usr/local/tomcat# cd webapps.dist/root@b55631abdbff:/usr/local/tomcat/webapps.dist# lsROOT  docs  examples  host-manager  managerroot@b55631abdbff:/usr/local/tomcat/webapps.dist# cd examples/root@b55631abdbff:/usr/local/tomcat/webapps.dist/examples# lsMETA-INF  WEB-INF  index.html  jsp  servlets  websocketroot@b55631abdbff:/usr/local/tomcat/webapps.dist/examples# cat index.html&lt;!--  # ...--&gt;&lt;!DOCTYPE HTML&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Apache Tomcat Examples&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;h3&gt;Apache Tomcat Examples&lt;/H3&gt;&lt;p&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;servlets&quot;&gt;Servlets examples&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;jsp&quot;&gt;JSP Examples&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;websocket/index.xhtml&quot;&gt;WebSocket Examples&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>​        </p><p> 将webapps.dist的网站代码copy到webapps中让服务器运行</p><pre><code>root@b55631abdbff:/usr/local/tomcat# cp -r webapps.dist/* webapps</code></pre><p>​        </p><ul><li>测试，windows(外网)访问成功</li></ul><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406171640413.png" alt="image-20230406171640413"></div><div class="image-meta"><span class="image-caption center">image-20230406171640413</span></div></div><blockquote><p>思考问题</p></blockquote><p> 每次部署项目都要进入容器是不是太麻烦，可以通过修改外部影响容器内部就好了。</p><h2 id="8-3-部署-ElasticSearch-Kibana"><a href="#8-3-部署-ElasticSearch-Kibana" class="headerlink" title="8.3 部署 ElasticSearch+Kibana"></a>8.3 部署 ElasticSearch+Kibana</h2><blockquote><p>部署难点</p></blockquote><p>ElasticSearch是什么： <a href="https://blog.csdn.net/JENREY/article/details/81290535?ops_request_misc=%7B%22request_id%22:%22164368073116780274110758%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164368073116780274110758&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81290535.pc_search_insert_ulrmf&utm_term=Elasticsearch+&spm=1018.2226.3001.4187">ElasticSearch从入门到精通，史上最全（持续更新，未完待续，每天一点点）_Null的博客-CSDN博客</a></p><p>ElasticSearch是 智能搜索，分布式的搜索引擎</p><p>ElasticSearch暴露的端口多、十分耗内存、数据一定要放安全目录</p><p>ElasticSearch是一个日志切割管理的工具</p><blockquote><p>部署 ElasticSearch</p></blockquote><p> 正常安装ElasticSearch后太消耗内存,导致Linux太卡了，需要添加 <code>-e ES_JAVA_OPTS=&quot;-Xms128m -Xmx512m&quot;</code> 配置ElasticSearch的虚拟机占用的内存大小。</p><p>1、安装并启动</p><pre><code>docker run -d --name elasticsearch01 -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms128m -Xmx512m&quot; elasticsearch:7.6.2</code></pre><p>​        </p><pre><code>[root@192 ~]# docker run -d --name elasticsearch01 -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms128m -Xmx512m&quot; elasticsearch:7.6.2Unable to find image &#39;elasticsearch:7.6.2&#39; locally7.6.2: Pulling from library/elasticsearchab5ef0e58194: Pull complete c4d1ca5c8a25: Pull complete 941a3cc8e7b8: Pull complete 43ec483d9618: Pull complete c486fd200684: Pull complete 1b960df074b2: Pull complete 1719d48d6823: Pull complete Digest: sha256:1b09dbd93085a1e7bca34830e77d2981521a7210e11f11eda997add1c12711faStatus: Downloaded newer image for elasticsearch:7.6.2c097654fbab08d26f803e150b54c471336a9ba24283595ba64f33d87aba33c62[root@192 ~]# docker psCONTAINER ID   IMAGE                 COMMAND                  CREATED         STATUS         PORTS                                                                                  NAMESc097654fbab0   elasticsearch:7.6.2   &quot;/usr/local/bin/dock…&quot;   2 minutes ago   Up 2 minutes   0.0.0.0:9200-&gt;9200/tcp, :::9200-&gt;9200/tcp, 0.0.0.0:9300-&gt;9300/tcp, :::9300-&gt;9300/tcp   elasticsearch01</code></pre><p>​        </p><p>2、测试连接ElasticSearch</p><pre><code>[root@192 ~]# curl localhost:9200&#123;  &quot;name&quot; : &quot;c097654fbab0&quot;,  &quot;cluster_name&quot; : &quot;docker-cluster&quot;,  &quot;cluster_uuid&quot; : &quot;HtBpQlrcR_mI-Suj8qzW8w&quot;,  &quot;version&quot; : &#123;    &quot;number&quot; : &quot;7.6.2&quot;,    &quot;build_flavor&quot; : &quot;default&quot;,    &quot;build_type&quot; : &quot;docker&quot;,    &quot;build_hash&quot; : &quot;ef48eb35cf30adf4db14086e8aabd07ef6fb113f&quot;,    &quot;build_date&quot; : &quot;2020-03-26T06:34:37.794943Z&quot;,    &quot;build_snapshot&quot; : false,    &quot;lucene_version&quot; : &quot;8.4.0&quot;,    &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;,    &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot;  &#125;,  &quot;tagline&quot; : &quot;You Know, for Search&quot;&#125;</code></pre><p>​        </p><p>3、查看资源占用情况</p><pre><code>docker stats</code></pre><p>​        </p><pre><code>[root@192 ~]# docker statsCONTAINER ID   NAME              CPU %     MEM USAGE / LIMIT   MEM %     NET I/O           BLOCK I/O     PIDSc097654fbab0   elasticsearch01   0.25%     420MiB / 2.406GiB   17.05%    3.71kB / 2.75kB   0B / 1.74MB   44</code></pre><p>​        </p><blockquote><p>Kibana</p></blockquote><p> Kibana 是一款开源的数据分析和可视化平台，它是 Elastic Stack 成员之一，设计用于和 Elasticsearch 协作。您可以使用 Kibana 对 Elasticsearch 索引中的数据进行搜索、查看、交互操作。您可以很方便的利用图表、表格及地图对数据进行多元化的分析和呈现。</p><h2 id="9、图形化管理工具Portaniner安装"><a href="#9、图形化管理工具Portaniner安装" class="headerlink" title="9、图形化管理工具Portaniner安装"></a>9、图形化管理工具Portaniner安装</h2><p>Portaniner是Docker的图形化管理工具，类似的工具还有Rancher(CI&#x2F;CD再用)</p><p>（Portaniner平时比较少用）</p><p>1、下载运行Portaniner镜像并运行，设置本机映射端口为8088</p><pre><code>docker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</code></pre><p>​        </p><pre><code>[root@192 ~]# docker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainerUnable to find image &#39;portainer/portainer:latest&#39; locallylatest: Pulling from portainer/portainer94cfa856b2b1: Pull complete 49d59ee0881a: Pull complete a2300fd28637: Pull complete Digest: sha256:fb45b43738646048a0a0cc74fcee2865b69efde857e710126084ee5de9be0f3fStatus: Downloaded newer image for portainer/portainer:latestb3b421cc14a11d7a4119eb8b3144c8f4796d7ad078ff9e1ecbdf8044b3e1a4cd[root@192 ~]# docker psCONTAINER ID   IMAGE                 COMMAND        CREATED          STATUS          PORTS                                       NAMESb3b421cc14a1   portainer/portainer   &quot;/portainer&quot;   29 seconds ago   Up 27 seconds   0.0.0.0:8088-&gt;9000/tcp, :::8088-&gt;9000/tcp   flamboyant_cray</code></pre><p>​        </p><p>2、windows(外网)访问成功</p><p>(1) 第一次登录设置admin用户的密码 (测试中为了好记可以设置成12345678)</p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406185947485.png" alt="image-20230406185947485"></div><div class="image-meta"><span class="image-caption center">image-20230406185947485</span></div></div><p>(2) 选择Local(本地)</p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406185950988.png" alt="image-20230406185950988"></div><div class="image-meta"><span class="image-caption center">image-20230406185950988</span></div></div><pre><code># 安装时要加上-v &quot;/var/run/docker.sock:/var/run/docker.sock&quot; </code></pre><p>​        </p><p>(3) 主页</p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406185955884.png" alt="image-20230406185955884"></div><div class="image-meta"><span class="image-caption center">image-20230406185955884</span></div></div><p>（4） 查看镜像列表</p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406190000461.png" alt="image-20230406190000461"></div><div class="image-meta"><span class="image-caption center">image-20230406190000461</span></div></div><h2 id="10、Docker镜像详解"><a href="#10、Docker镜像详解" class="headerlink" title="10、Docker镜像详解"></a>10、Docker镜像详解</h2><h2 id="10-1-什么是镜像"><a href="#10-1-什么是镜像" class="headerlink" title="10.1 什么是镜像"></a>10.1 什么是镜像</h2><p> 镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需要的所有内容，包括代码，运行时（一个程序在运行或者在被执行的依赖）、库，环境变量和配置文件。</p><p> 所以应用直接打包镜像，就可以用于运行</p><p> 获得镜像的途径：</p><pre><code>- 自己制作镜像DockerFile- 远程仓库下载- 别人copy给你</code></pre><p>​        </p><h2 id="10-2-联合文件系统"><a href="#10-2-联合文件系统" class="headerlink" title="10.2 联合文件系统"></a>10.2 联合文件系统</h2><blockquote><p>UnionFS （联合文件系统）</p></blockquote><p> Docker的镜像实际上由一层一层的文件系统组成(下载镜像时分层下载可印证)，这种层级的文件系统是UnionFS联合文件系统。</p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406190005007.png" alt="image-20230406190005007"></div><div class="image-meta"><span class="image-caption center">image-20230406190005007</span></div></div><p> UnionFS （联合文件系统）是一种分层、轻量级并且高性能的文件系统，它支持对文研系统的修改-<br> 作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下，Union文件系统是Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。-<br> 特性：一次同时加载多个文件系统，但从外面看起来，只能看到外文件系统，联合加载会把各层文件系统叠加起来,这样最终的文件系统会包含所有底层的文件和目录</p><p>作用：比如tomcat下载了centos,则mysql就不用下载了。相同层可复用</p><p>思考：为什么Docke也像要采用这种分层的结构呢？-<br>最大的好处，莫过于是资源共享了 ！比如有多个镜像都从相同的Base镜像构建而来，那么宿主机只需在磁盘上保留一份base镜像，同时内存中也只高要加载一份base镜像,这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享.-<br>查看镜像分层的方式可以通过<code>docker image inspect</code>命令!</p><pre><code>docker image inspect redis</code></pre><p>​        </p><pre><code>[root@192 ~]# docker image inspect redis[    &#123;        &quot;Id&quot;: &quot;sha256:f1b6973564e91aecb808142499829a15798fdc783a30de902bb0c4133fee19ad&quot;,        &quot;RepoTags&quot;: [            &quot;redis:latest&quot;        ],        # ...                &quot;RootFS&quot;: &#123;             &quot;Type&quot;: &quot;layers&quot;,            &quot;Layers&quot;: [ # 这里指示了分层信息                &quot;sha256:7d0ebbe3f5d26c1b5ec4d5dbb6fe3205d7061f9735080b0162d550530328abd6&quot;,                &quot;sha256:92b6c42121d80f330a80c20afa928e19c31ab3a5fe7cf9c91517fa8cc468b33f&quot;,                &quot;sha256:65845b69eb5c3291dd610ddf2f61f524ab206f9754900d9f3512fcbc2d38604f&quot;,                &quot;sha256:7048818d16571a765e2b0cf82c20d627abebccec73ac3d7b7973501000e6e05d&quot;,                &quot;sha256:c61d5cbf862134aad34822e96d9efc009cca19ad604419cb3f8cf8857eb18372&quot;,                &quot;sha256:ff503dae4eb68eb7a71095e5b1b1b123f42d37e923222038b64fba5a80b13307&quot;            ]        &#125;,        &quot;Metadata&quot;: &#123;            &quot;LastTagTime&quot;: &quot;0001-01-01T00:00:00Z&quot;        &#125;    &#125;]</code></pre><p>​        </p><p> 所有的Docker镜像都起始于一个基础镜像层，当进行修改或增加新的内容时，就会在当前镜像层之上,创建新的镜像层.-<br>举一个简单的例子，假如基于Ubuntu Linux 16.04创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加Python包，-<br>就会在基础镜像层之上创建第二个镜像层;如果继续添加一个安全补丁，就会创建第三个镜像层。-<br>该镜像当前已经包含3个镜像层，如下图所示（这只是一个用于演示的很简单的例子）.</p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406190010300.png" alt="image-20230406190010300"></div><div class="image-meta"><span class="image-caption center">image-20230406190010300</span></div></div><p> 在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合，理解这一点非常里要.下图中举了一个简单的例子，每个镜像层包含3个文件，而镜像包含了来自两个镜像层的6个文件.</p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406190014018.png" alt="image-20230406190014018"></div><div class="image-meta"><span class="image-caption center">image-20230406190014018</span></div></div><p> 这种情况下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新镜像层添加到镜像当中。-<br> Docker通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统。-<br>Linux上可用的存储引擎有AUFS、Overlay2. Device hopper、Btrfs以及ZFS。顾名思义，每种存储引擎都基于Linux中对应的-<br>文件系统或者块设备技术，并且每种存储引擎都有其独有的性能特点。</p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406190018074.png" alt="image-20230406190018074"></div><div class="image-meta"><span class="image-caption center">image-20230406190018074</span></div></div><p> Docker在Windows上仅支持windowsfilter 一种存储引擎，该引擎基于NTFS文件系统之上实现了分层和CoW［ 1］ 0-<br>下图展示了与系统显示相同的三层镜像。所有镜像层堆叠并合并，对外提供统一的视图。-</p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406190021861.png" alt="image-20230406190021861"></div><div class="image-meta"><span class="image-caption center">image-20230406190021861</span></div></div><blockquote><p>特点</p></blockquote><p> Docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部！这一层就是我们通常说的容器层，容器之下的都叫镜像层！</p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406190024959.png" alt="image-20230406190024959"></div><div class="image-meta"><span class="image-caption center">image-20230406190024959</span></div></div><h2 id="11、提交自己镜像"><a href="#11、提交自己镜像" class="headerlink" title="11、提交自己镜像"></a>11、提交自己镜像</h2><p>使用<code>docker commit</code>命令提交容器成为一个新的版本</p><pre><code>docker commit -m=&quot;提交的描述信息&quot;  -a=&quot;作者&quot; 容器id 目标镜像名:[TAG] </code></pre><p>​        </p><p> 由于默认的Tomcat镜像的webapps文件夹中没有任何内容，需要从webapps.dist中拷贝文件到webapps文件夹。下面自行制作镜像：就是从webapps.dist中拷贝文件到webapps文件夹下，并提交该镜像作为一个新的镜像。<strong>使得该镜像默认的webapps文件夹下就有文件</strong>。具体步骤如下：</p><p>1、启动Tomcat</p><pre><code>// 启动Tomcat 一定要配置端口映射 `-p 8080:8080`docker run -it -p 8080:8080 tomcat//开多一个终端// 进入容器docker exec -it d55df6cdafe8 /bin/bash</code></pre><p>​        </p><p>2、制作（修改）镜像，拷贝<code>cp -r webapps.dist/* webapps</code></p><pre><code>root@d55df6cdafe8:/usr/local/tomcat# cd webappsroot@d55df6cdafe8:/usr/local/tomcat/webapps# lsroot@d55df6cdafe8:/usr/local/tomcat/webapps# cd ..root@d55df6cdafe8:/usr/local/tomcat# lsBUILDING.txt LICENSE  README.md RUNNING.txt  conf  logs    temp     webapps.distCONTRIBUTING.md  NOTICE   RELEASE-NOTES  bin      lib   native-jni-lib  webapps  workroot@d55df6cdafe8:/usr/local/tomcat# cp -r webapps.dist/* webappsroot@d55df6cdafe8:/usr/local/tomcat# cd webappsroot@d55df6cdafe8:/usr/local/tomcat/webapps# lsROOT  docs  examples  host-manager  manager</code></pre><p>​        </p><p>3、windows访问</p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406190029165.png" alt="image-20230406190029165"></div><div class="image-meta"><span class="image-caption center">image-20230406190029165</span></div></div><p>4、提交自己镜像,提交到本地（之后再发布到远程仓库）</p><pre><code>//docker commit -m=&quot;提交的描述信息&quot;  -a=&quot;作者&quot; 容器id 目标镜像名:[TAG] docker commit -m=&quot;add webapps app&quot;  -a=&quot;一个平凡de人&quot; 6df1e2c4a350 tomcat02:1.0</code></pre><p>​        </p><pre><code>[root@192 ~]# docker commit -m=&quot;add webapps app&quot;  -a=&quot;一个平凡de人&quot; 6df1e2c4a350 tomcat02:1.0sha256:e699f08da20e848d7a9bd7c8953b63500abe1ea6a6605838dc9f97876857c229[root@192 ~]# docker imagesREPOSITORY            TAG       IMAGE ID       CREATED          SIZEtomcat02              1.0       e699f08da20e   35 seconds ago   684MB # 自己镜像tomcat                latest    413407dddb5e   4 days ago       680MBredis                 latest    f1b6973564e9   5 days ago       113MBportainer/portainer   latest    580c0e4e98b0   10 months ago    79.1MBelasticsearch         7.6.2     f29a1ee41030   22 months ago    791MB</code></pre><p>​        </p><p>5、测试</p><p> （1）启动</p><pre><code>docker run -it -p 8080:8080 tomcat02:1.0</code></pre><p>​        </p><p> （2）windows访问，测试成功</p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406190033178.png" alt="image-20230406190033178"></div><div class="image-meta"><span class="image-caption center">image-20230406190033178</span></div></div><blockquote><p>小节</p></blockquote><p>如果你想要保存当前容器的状态，就可以通过commit来提交，获得一个镜像,就好比我们以前学习VM时候，快照保存虚拟机状态，之后可状态回滚！</p><h2 id="12、容器数据卷"><a href="#12、容器数据卷" class="headerlink" title="12、容器数据卷"></a>12、容器数据卷</h2><blockquote><p>docker的理念回顾</p></blockquote><p>将应用和环境打包成一个镜像</p><p>数据？如果数据都在容器中，那么我们容器删除，数据就会丢失！需求：数据可以持久化</p><p>MySQL，容器删除了，删库跑路！需求：MySQL数据可以存储在本地！</p><p>容器之间可以有一个数据共享的技术！Docker容器中产生的数据，同步到本地！</p><p>这就是卷技术！<strong>目录的挂载</strong>，将我们容器内的目录，挂载到Linux上面！</p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406190037262.png" alt="image-20230406190037262"></div><div class="image-meta"><span class="image-caption center">image-20230406190037262</span></div></div><p>使用卷技术的原因：容器的持久化和同步操作！容器间也是可以数据共享的！</p><h2 id="12-1-使用数据卷"><a href="#12-1-使用数据卷" class="headerlink" title="12.1 使用数据卷"></a>12.1 使用数据卷</h2><p>挂载后 主机目录和容器目录<strong>共享</strong>一个目录资源，容器目录也可以理解为是主机目录的快捷方式</p><blockquote><p>方式一 ：直接使用命令挂载 -v</p></blockquote><pre><code>//-v, --volume list      绑定挂载卷docker run -it -v 主机目录:容器目录  -p 主机端口:容器内端口//通过 查看挂载docker inspect 容器id</code></pre><p>​        </p><p>1、挂载并进入命令行<code>/bin/bash</code></p><pre><code>docker run -it -v /home/ceshi:/home centos /bin/bash</code></pre><p>​        </p><pre><code>[root@192 ~]# docker run -it -v /home/ceshi:/home centos /bin/bash[root@a40aea147d6d /]# cd /home[root@a40aea147d6d home]# ls # 空</code></pre><p>​        </p><pre><code>[root@192 ~]# cd /home[root@192 home]# lsceshi # 找到ceshi目录</code></pre><p>​        </p><p>2、查看挂载</p><pre><code>docker inspect 【容器id】</code></pre><p>​        </p><pre><code>[root@192 home]# docker inspect a40aea147d6d# ...&quot;Mounts&quot;: [            &#123;                &quot;Type&quot;: &quot;bind&quot;,                &quot;Source&quot;: &quot;/home/ceshi&quot;, # 挂载成功 主机目录                &quot;Destination&quot;: &quot;/home&quot;, # 挂载成功 容器目录                &quot;Mode&quot;: &quot;&quot;,                &quot;RW&quot;: true,                &quot;Propagation&quot;: &quot;rprivate&quot;            &#125;        ],# ...</code></pre><p>​        </p><p>3、测试挂载</p><p>挂载后 主机目录和容器目录<strong>共享</strong>一个目录资源，容器目录也可以理解为是主机目录的快捷方式</p><pre><code>[root@a40aea147d6d home]# touch test.txt # 创建文件[root@a40aea147d6d home]# lstest.txt</code></pre><p>​        </p><pre><code>[root@192 home]# lsceshi[root@192 home]# cd ceshi/[root@192 ceshi]# lstest.txt # 挂载成功，也test.txt文件# 向文件写入数据[root@192 ceshi]# echo &quot;This is test data&quot; &gt; test.txt[root@192 ceshi]# cat test.txt This is test data</code></pre><p>​        </p><pre><code># 容器内目录也有数据[root@a40aea147d6d home]# cat test.txt This is test data</code></pre><p>​        </p><p>就算容器关闭，数据依旧一致。</p><h2 id="12-2-MySQL同步数据实战"><a href="#12-2-MySQL同步数据实战" class="headerlink" title="12.2 MySQL同步数据实战"></a>12.2 MySQL同步数据实战</h2><p>1、获取mysql镜像</p><pre><code>docker pull mysql</code></pre><p>​        </p><p>2、运行容器,挂载倆个数据目录，配置密码<code>-e MYSQL_ROOT_PASSWORD=password</code></p><pre><code># -e 环境配置，配置mysql密码docker run -d -p 3306:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql  -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql</code></pre><p>​        </p><pre><code>[root@192 ~]# docker run -d -p 3306:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql  -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql05574ce7407c7745ee28951f5ccc032062b83b9d9486ef6062a1d321df2ad0c8</code></pre><p>​        </p><pre><code># 启动成功之后，我们在本地使用sqlyog来测试一下# sqlyog-连接到服务器的3306--和容器内的3306映射 # 在本地测试创建一个数据库，查看一下我们映射的路径是否ok！</code></pre><p>​        </p><p>3、测试连接，在windows上用数据库连接工具测试连接mysql容器·</p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406190044355.png" alt="image-20230406190044355"></div><div class="image-meta"><span class="image-caption center">image-20230406190044355</span></div></div><ul><li>连接成功</li></ul><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406190048110.png" alt="image-20230406190048110"></div><div class="image-meta"><span class="image-caption center">image-20230406190048110</span></div></div><p>4、文件目录映射成功</p><pre><code>[root@192 mysql]# cd /home/mysql/[root@192 mysql]# lsconf  data[root@192 mysql]# cd data[root@192 data]# lsauto.cnf       ca-key.pem       #ib_16384_0.dblwr  ib_logfile0   mysql               public_key.pem   undo_001binlog.000001  ca.pem           #ib_16384_1.dblwr  ib_logfile1   mysql.ibd           server-cert.pem  undo_002binlog.000002  client-cert.pem  ib_buffer_pool     ibtmp1        performance_schema  server-key.pembinlog.index   client-key.pem   ibdata1            #innodb_temp  private_key.pem     sys</code></pre><p>​        </p><p>5、linux中，一个数据库对应一个目录，一个数据表对应一个文件</p><p>（1）创建数据库</p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406190051764.png" alt="image-20230406190051764"></div><div class="image-meta"><span class="image-caption center">image-20230406190051764</span></div></div><p>（2）成功看到test目录</p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406190057738.png" alt="image-20230406190057738"></div><div class="image-meta"><span class="image-caption center">image-20230406190057738</span></div></div><p>（3）创建数据表</p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406190102699.png" alt="image-20230406190102699"></div><div class="image-meta"><span class="image-caption center">image-20230406190102699</span></div></div><p>（4）成功看到文件</p><blockquote><p>容器数据持久化</p></blockquote><p>假设我们将容器删除，发现我们挂载到本地的数据卷依旧没有丢失，这就实现了容器数据持久化功能。</p><h2 id="12-3-具名挂载和匿名挂载"><a href="#12-3-具名挂载和匿名挂载" class="headerlink" title="12.3 具名挂载和匿名挂载"></a>12.3 具名挂载和匿名挂载</h2><p><strong>卷指容器被挂载的主机目录</strong></p><blockquote><p>匿名挂载</p></blockquote><p>1、匿名挂载就是不指定主机目录进行挂载（没有给卷（主机目录）起名就是匿名）</p><pre><code># -v 容器内路径!docker run -d -P --name nginx01 -v /etc/nginx nginx</code></pre><p>​        </p><p>2、查看所有的volume（卷）的情况</p><pre><code>docker volume ls   </code></pre><p>​        </p><pre><code>[root@192 ~]# docker volume ls   DRIVER    VOLUME NAMElocal     7ef9dee8a0efcf74601d3ce615fc1a74a96008d861648d5f415c581ce426b44c #这些字符串就代表匿名卷(目录),是匿名挂载local     8ecbc00746d9bea6a8095e65ead44e30b5cbf49f7409bc58aff9fab4b10cf0f4local     d745315f9e2d743c1a83edc5312809efba67693b8a01a27eb0a49a4ff572a450</code></pre><p>​        </p><p>3、指定卷来查看挂载</p><pre><code> docker volume inspect 7ef9dee8a0efcf74601d3ce615fc1a74a96008d861648d5f415c581ce426b44c</code></pre><p>​        </p><pre><code>[root@192 ~]#  docker volume inspect 7ef9dee8a0efcf74601d3ce615fc1a74a96008d861648d5f415c581ce426b44c[    &#123;        &quot;CreatedAt&quot;: &quot;2022-02-01T21:04:59+08:00&quot;,        &quot;Driver&quot;: &quot;local&quot;,        &quot;Labels&quot;: null,        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/7ef9dee8a0efcf74601d3ce615fc1a74a96008d861648d5f415c581ce426b44c/_data&quot;,# 挂载的目录        &quot;Name&quot;: &quot;7ef9dee8a0efcf74601d3ce615fc1a74a96008d861648d5f415c581ce426b44c&quot;,        &quot;Options&quot;: null,        &quot;Scope&quot;: &quot;local&quot;    &#125;]</code></pre><p>​<br>​        </p><blockquote><p>具名挂载</p></blockquote><p>1、具名挂载就是指定了主机目录进行挂载（有给卷（主机目录）起名就是具名（有具体的名））</p><pre><code>docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx</code></pre><p>​        </p><p>2、查看所有的volume（卷）的情况</p><pre><code>[root@192 home]# docker volume ls   DRIVER    VOLUME NAMElocal     7ef9dee8a0efcf74601d3ce615fc1a74a96008d861648d5f415c581ce426b44clocal     8ecbc00746d9bea6a8095e65ead44e30b5cbf49f7409bc58aff9fab4b10cf0f4local     d745315f9e2d743c1a83edc5312809efba67693b8a01a27eb0a49a4ff572a450local     juming-nginx #有具体的名,具名挂载</code></pre><p>​        </p><p>3、指定卷来查看挂载</p><pre><code>[root@192 home]# docker volume inspect juming-nginx[    &#123;        &quot;CreatedAt&quot;: &quot;2022-02-01T21:16:26+08:00&quot;,        &quot;Driver&quot;: &quot;local&quot;,        &quot;Labels&quot;: null,        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/juming-nginx/_data&quot;, # 挂载的目录        &quot;Name&quot;: &quot;juming-nginx&quot;,        &quot;Options&quot;: null,        &quot;Scope&quot;: &quot;local&quot;    &#125;]</code></pre><p>​        </p><p> 所有的docker容器内的卷，没有指定<strong>绝对路径的目录</strong>的情况下都是在<code>/var/lib/docker/volumes/xxxx/_data</code>下的，-<br>如果指定了目录，<code>docker volume ls</code> 是查看不到的。</p><blockquote><p>小节</p></blockquote><pre><code># 三种挂载： 匿名挂载、具名挂载、指定路径挂载-v 容器内路径#匿名挂载-v 卷名：容器内路径  #具名挂载-v /宿主机路径：容器内路径 #指定路径挂载 docker volume ls 是查看不到的</code></pre><p>​        </p><blockquote><p>拓展</p></blockquote><p>通过 -v 容器内路径： ro rw 改变读写权限</p><pre><code>ro #readonly 只读rw #readwrite 可读可写docker run -d -P --name nginx05 -v juming:/etc/nginx:ro nginxdocker run -d -P --name nginx05 -v juming:/etc/nginx:rw nginx</code></pre><p>​        </p><p>ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内部是无法操作！</p><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="13、-初始Dockerfile"><a href="#13、-初始Dockerfile" class="headerlink" title="13、 初始Dockerfile"></a>13、 初始Dockerfile</h2><blockquote><p>什么是Dockerfile</p></blockquote><p>Dockerfile 是用来构建docker镜像的构建文件，是一段命令脚本。</p><blockquote><p>创建Dockerfile</p></blockquote><p>1、创建docker的测试目录</p><pre><code>[root@192 _data]# cd /home[root@192 home]# mkdir docker-test-volume</code></pre><p>​        </p><p>2、创建Dockerfile脚本文件，通过这个脚本可以生成镜像,</p><p>Dockerfile脚本文件内容分析:</p><pre><code># 文件中的内容 指令(大写) 参数#镜像是一层一层的，这里的每个命令，就是镜像的一层！FROM centos # 指定镜像VOLUME [&quot;volume01&quot;,&quot;volume02&quot;] # 挂载目录CMD echo &quot;----end----&quot; # CMD 执行命令行命令 CMD /bin/bash</code></pre><p>​        </p><pre><code>[root@192 docker-test-volume]# vim dockerfile01[root@192 docker-test-volume]# cat dockerfile01 FROM centos VOLUME [&quot;volume01&quot;,&quot;volume02&quot;] CMD echo &quot;----end----&quot; CMD /bin/bash</code></pre><p>​        </p><p>3、执行Dockerfile脚本文件，构建镜像</p><pre><code>docker build -f /home/docker-test-volume dockerfile01 -t /kuangshen/centos .</code></pre><p>​        </p><pre><code>[root@192 ~]# docker imagesREPOSITORY            TAG       IMAGE ID       CREATED         SIZEkuangshen/centos      latest    6b3e9b445d81   3 hours ago     231MB #构建成功# ...</code></pre><p>​        </p><p>4、启动镜像，查看容器</p><pre><code>docker run -it /kuangshen/centos /bin/bash</code></pre><p>​        </p><pre><code>[root@b68f2c5c965b /]# lsbin  etc   lib  lost+found  mnt  proc  run   srv  tmp  var   volume02dev  home  lib64  media       opt  root  sbin  sys  usr  volume01# 找到挂载的目录volume01、volume02</code></pre><p>​        </p><h2 id="14、-数据卷容器"><a href="#14、-数据卷容器" class="headerlink" title="14、 数据卷容器"></a>14、 数据卷容器</h2><h2 id="14-1-数据卷容器"><a href="#14-1-数据卷容器" class="headerlink" title="14.1 数据卷容器"></a>14.1 数据卷容器</h2><p>容器挂载数据卷,实现容器间的数据同步和资源共享！</p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406190112408.png)" alt="1、启动父容器docker01 docker run -it --name docker01 kuangshen/centos ​ 2、启动容器docker02并挂载到父容器docker01的共享卷,命令`--volumes-from 容器列表` docker run -it --name docker02 --volumes-from docker01 kuangshen/centos ​ 3、查看容器运行 [root@192 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES fa68f1afa235 kuangshen/centos /bin/sh -c /bin/bash 11 seconds ago Up 10 seconds docker02 eb991bf17656 kuangshen/centos /bin/sh -c /bin/bash 2 minutes ago Up 2 minutes docker01 ​ 4、在父容器docker01的共享卷中创建文件，看docker02共享卷的变化 [root@eb991bf17656 /]# cd volume01 [root@eb991bf17656 volume01]# touch docker.txt ​ * docker02容器内成功看到docker01创建的文件 [root@fa68f1afa235 /]# cd volume01 [root@fa68f1afa235 volume01]# ls docker.txt ​ 5、再加个docker03试试，也有docker01创建的文件 docker run -it --name docker03 --volumes-from docker01 kuangshen/centos ​ [root@e4ad9cb37d01 /]# cd volume01 [root@e4ad9cb37d01 volume01]# ls docker.txt ​ 6、小结 * docker03创建的文件docker01、docker02也同步共享。 * 删除docker01，docker02和docker03依旧保持数据同步和资源共享。 * 容器挂载后双向资源绑定，双向拷贝。 ## 14.2 Mysql容器实现数据同步 1、启动mysql01,绑定端口3306,配置密码`-e MYSQL_ROOT_PASSWORD=password`,挂载卷`-v` docker run -it --name mysql01 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -v /etc/mysql/conf.d -v /var/lib/mysql mysql ​ 2、启动mysql02（绑定端口3307）、mysql03（绑定端口3308） # mysql02 docker run -it --name mysql02 --volumes-from mysql01 -p 3100:3306 -e MYSQL_ROOT_PASSWORD=123456 -v /etc/mysql/conf.d -v /var/lib/mysql mysql # mysql03 docker run -it --name mysql03 --volumes-from mysql01 -p 330:3306 -e MYSQL_ROOT_PASSWORD=123456 -v /etc/mysql/conf.d -v /var/lib/mysql mysql ​ 3、连接数据库测试 > 结论 容器之间的配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止。 但是一旦你持久化到了本地，这个时候，本地的数据是不会删除的！ ## 15、Dockerfile（重点） dockerfile是用来构建docker镜像的文件！命令参数脚本！ > 构建步骤： 1、 编写一个dockerfile文件 2、 docker build 构建称为一个镜像 3、 docker run运行镜像 4、 docker push发布镜像（DockerHub 、阿里云仓库 image-20230406190112408"></div><div class="image-meta"><span class="image-caption center">1、启动父容器docker01 docker run -it --name docker01 kuangshen/centos ​ 2、启动容器docker02并挂载到父容器docker01的共享卷,命令`--volumes-from 容器列表` docker run -it --name docker02 --volumes-from docker01 kuangshen/centos ​ 3、查看容器运行 [root@192 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES fa68f1afa235 kuangshen/centos /bin/sh -c /bin/bash 11 seconds ago Up 10 seconds docker02 eb991bf17656 kuangshen/centos /bin/sh -c /bin/bash 2 minutes ago Up 2 minutes docker01 ​ 4、在父容器docker01的共享卷中创建文件，看docker02共享卷的变化 [root@eb991bf17656 /]# cd volume01 [root@eb991bf17656 volume01]# touch docker.txt ​ * docker02容器内成功看到docker01创建的文件 [root@fa68f1afa235 /]# cd volume01 [root@fa68f1afa235 volume01]# ls docker.txt ​ 5、再加个docker03试试，也有docker01创建的文件 docker run -it --name docker03 --volumes-from docker01 kuangshen/centos ​ [root@e4ad9cb37d01 /]# cd volume01 [root@e4ad9cb37d01 volume01]# ls docker.txt ​ 6、小结 * docker03创建的文件docker01、docker02也同步共享。 * 删除docker01，docker02和docker03依旧保持数据同步和资源共享。 * 容器挂载后双向资源绑定，双向拷贝。 ## 14.2 Mysql容器实现数据同步 1、启动mysql01,绑定端口3306,配置密码`-e MYSQL_ROOT_PASSWORD=password`,挂载卷`-v` docker run -it --name mysql01 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -v /etc/mysql/conf.d -v /var/lib/mysql mysql ​ 2、启动mysql02（绑定端口3307）、mysql03（绑定端口3308） # mysql02 docker run -it --name mysql02 --volumes-from mysql01 -p 3100:3306 -e MYSQL_ROOT_PASSWORD=123456 -v /etc/mysql/conf.d -v /var/lib/mysql mysql # mysql03 docker run -it --name mysql03 --volumes-from mysql01 -p 330:3306 -e MYSQL_ROOT_PASSWORD=123456 -v /etc/mysql/conf.d -v /var/lib/mysql mysql ​ 3、连接数据库测试 > 结论 容器之间的配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止。 但是一旦你持久化到了本地，这个时候，本地的数据是不会删除的！ ## 15、Dockerfile（重点） dockerfile是用来构建docker镜像的文件！命令参数脚本！ > 构建步骤： 1、 编写一个dockerfile文件 2、 docker build 构建称为一个镜像 3、 docker run运行镜像 4、 docker push发布镜像（DockerHub 、阿里云仓库 image-20230406190112408</span></div></div><blockquote><p>官方的镜像</p></blockquote><p>官方仓库搜索：<a href="https://hub.docker.com//_/centos">https://hub.docker.com/\_/centos</a></p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406190118318.png" alt="image-20230406190118318"></div><div class="image-meta"><span class="image-caption center">image-20230406190118318</span></div></div><p>点击版本跳转到Github,看到dockerfile文件：</p><p> docker 99%的镜像都是从FROM scratch（基础镜像）开始-</p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406190600870.png" alt="image-20230406190600870"></div><div class="image-meta"><span class="image-caption center">image-20230406190600870</span></div></div><p>很多官方镜像都是基础包，很多功能没有，我们通常会自己搭建自己的镜像！</p><p>官方既然可以制作镜像，那我们也可以！</p><h2 id="15-1-DockerFile构建过程"><a href="#15-1-DockerFile构建过程" class="headerlink" title="15.1 DockerFile构建过程"></a>15.1 DockerFile构建过程</h2><blockquote><p>DockerFile脚本文件语法</p></blockquote><p>1、每个保留关键字(指令）都是必须是大写字母</p><p>2、执行从上到下顺序</p><p>3、#表示注释</p><p>4、每一个指令都会创建提交一个新的镜像曾，并提交！</p><blockquote><p>Dockerfile</p></blockquote><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406190121577.png" alt="image-20230406190121577"></div><div class="image-meta"><span class="image-caption center">image-20230406190121577</span></div></div><p>Dockerfile是面向开发的，我们以后要发布项目，做镜像，就需要编写dockerfile文件，这个文件十分简单！</p><p>Docker镜像逐渐成企业交付的标准，必须要掌握！</p><p>DockerFile：构建文件，定义了一切的步骤，源代码</p><p>DockerImages：通过DockerFile构建生成的镜像，最终发布和运行产品。</p><p>Docker容器：容器就是镜像运行起来提供服务。</p><blockquote><p>DockerFile的指令</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">指令解释</span><br><span class="line"></span><br><span class="line">FROM基础镜像，一切从这里开始构建</span><br><span class="line"></span><br><span class="line">MAINTAINER镜像是谁写的， 姓名+邮箱(翻译：维护人员)</span><br><span class="line"></span><br><span class="line">RUN镜像构建的时候需要运行的命令</span><br><span class="line"></span><br><span class="line">ADD步骤，tomcat镜像，这个tomcat压缩包！添加内容 添加同目录</span><br><span class="line"></span><br><span class="line">WORKDIR镜像的工作目录</span><br><span class="line"></span><br><span class="line">VOLUME挂载的目录</span><br><span class="line"></span><br><span class="line">EXPOSE保留端口配置（开放的端口）</span><br><span class="line"></span><br><span class="line">CMD指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代。</span><br><span class="line"></span><br><span class="line">ENTRYPOINT指定这个容器启动的时候要运行的命令，可以追加命令（入口点）</span><br><span class="line"></span><br><span class="line">ONBUILD当构建一个被继承 DockerFile 这个时候就会运行ONBUILD的指令，触发指令。</span><br><span class="line"></span><br><span class="line">COPY类似ADD，将我们文件拷贝到镜像中</span><br><span class="line"></span><br><span class="line">ENV构建的时候设置环境变量！</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="15-2-Dockerfile实战"><a href="#15-2-Dockerfile实战" class="headerlink" title="15.2 Dockerfile实战"></a>15.2 Dockerfile实战</h2><blockquote><p>创建一个自己的centos镜像</p></blockquote><p>官方的centos许多命令都没有，所以我们创建一个自己的centos镜像</p><p>1、创建工作目录</p><pre><code>[root@192 dockerfile]# pwd/home/dockerfile[root@192 dockerfile]# vim centos-dockerfile</code></pre><p>​        </p><p>2、编写Dockerfile文件 (文件名：centos-dockerfile)</p><pre><code>FROM centosMAINTAINER root&lt;id_07221888@qq.com&gt;ENV MYPATH /usr/local # 设置环境变量WORKDIR $MYPATH # 镜像的工作目录，进入镜像的初始目录 # RUN: 镜像构建的时候需要运行的命令 RUN yum -y install vim      # 新增 vim 工具RUN yum -y install net-tools # 新增 网络 工具 有ifconfig命令EXPOSE 80 # 开放的端口CMD echo $MYPATH # CMD：容器启动的时候要运行的命令CMD echo &quot;-----end----&quot;CMD /bin/bash </code></pre><p>​        </p><pre><code>FROM centosMAINTAINER root&lt;id_07221888@qq.com&gt;ENV MYPATH /usr/local WORKDIR $MYPATH  RUN yum -y install vim      RUN yum -y install net-tools EXPOSE 80 CMD echo $MYPATH CMD echo &quot;-----end----&quot;CMD /bin/bash </code></pre><p>​        </p><p>3、通过这个文件构建镜像</p><pre><code># 命令 docker build -f 文件路径 -t 镜像名:[tag] .docker build -f /home/dockerfile/centos-dockerfile  -t mycentos:0.1 .</code></pre><p>​        </p><pre><code>Step 5/10 : RUN yum -y install vim ---&gt; Running in 64495d343335CentOS Linux 8 - AppStream                       68  B/s |  38  B     00:00    Error: Failed to download metadata for repo &#39;appstream&#39;: Cannot prepare internal mirrorlist: No URLs in mirrorlistThe command &#39;/bin/sh -c yum -y install vim&#39; returned a non-zero code: 1</code></pre><p>​        </p><pre><code>因为没有vim这个rpm包。vim命令在vim-ehanced这个包内。yum失败的可以在yum之前加一个更新软件源</code></pre><p>​        </p><pre><code>systemctl stop firewalld.service                          # 停止防火墙 </code></pre><p>​        </p><p>4、启动镜像</p><blockquote><p>列出镜像的变更历史</p></blockquote><pre><code>docker history 镜像</code></pre><p>​        </p><pre><code>[root@192 dockerfile]# docker history mysqlIMAGE          CREATED      CREATED BY                                      SIZE      COMMENTd1dc36cf8d9e   6 days ago   /bin/sh -c #(nop)  CMD [&quot;mysqld&quot;]               0B        &lt;missing&gt;      6 days ago   /bin/sh -c #(nop)  EXPOSE 3306 33060            0B        &lt;missing&gt;      6 days ago   /bin/sh -c #(nop)  ENTRYPOINT [&quot;docker-entry…   0B        &lt;missing&gt;      6 days ago   /bin/sh -c ln -s usr/local/bin/docker-entryp…   34B       &lt;missing&gt;      6 days ago   /bin/sh -c #(nop) COPY file:c112ec3a02a7b818…   13.2kB    &lt;missing&gt;      6 days ago   /bin/sh -c #(nop) COPY dir:2e040acc386ebd23b…   1.12kB    &lt;missing&gt;      6 days ago   /bin/sh -c #(nop)  VOLUME [/var/lib/mysql]      0B        &lt;missing&gt;      6 days ago   /bin/sh -c &#123;   echo mysql-community-server m…   384MB     &lt;missing&gt;      6 days ago   /bin/sh -c echo &#39;deb http://repo.mysql.com/a…   55B       &lt;missing&gt;      6 days ago   /bin/sh -c #(nop)  ENV MYSQL_VERSION=8.0.28-…   0B        &lt;missing&gt;      6 days ago   /bin/sh -c #(nop)  ENV MYSQL_MAJOR=8.0          0B        &lt;missing&gt;      6 days ago   /bin/sh -c set -ex;  key=&#39;859BE8D7C586F53843…   2.29kB    &lt;missing&gt;      6 days ago   /bin/sh -c apt-get update &amp;&amp; apt-get install…   52.2MB    &lt;missing&gt;      6 days ago   /bin/sh -c mkdir /docker-entrypoint-initdb.d    0B        &lt;missing&gt;      6 days ago   /bin/sh -c set -eux;  savedAptMark=&quot;$(apt-ma…   4.06MB    &lt;missing&gt;      6 days ago   /bin/sh -c #(nop)  ENV GOSU_VERSION=1.14        0B        &lt;missing&gt;      6 days ago   /bin/sh -c apt-get update &amp;&amp; apt-get install…   9.34MB    &lt;missing&gt;      6 days ago   /bin/sh -c groupadd -r mysql &amp;&amp; useradd -r -…   329kB     &lt;missing&gt;      7 days ago   /bin/sh -c #(nop)  CMD [&quot;bash&quot;]                 0B        &lt;missing&gt;      7 days ago   /bin/sh -c #(nop) ADD file:c51141702f568a28a…   69.3MB    </code></pre><p>​        </p><p>使用我们平时拿到一个镜像，可以研究一下是什么做的</p><h2 id="15-3-CMD-和-ENTRYPOINT区别"><a href="#15-3-CMD-和-ENTRYPOINT区别" class="headerlink" title="15.3 CMD 和 ENTRYPOINT区别"></a>15.3 CMD 和 ENTRYPOINT区别</h2><ul><li>CMD : 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代。(替代的方式)</li><li>ENTRYPOINT : 指定这个容器启动的时候要运行的命令，可以追加命令。(追加的方式)</li></ul><blockquote><p>测试cmd</p></blockquote><p>1、编写dockerfile文件</p><pre><code>[root@192 dockerfile]# cat dockerfile-test-cmdFROM centosCMD [&quot;ls&quot;,&quot;-a&quot;]</code></pre><p>​        </p><p>2、 构建镜像</p><pre><code>docker build  -f dockerfile-test-cmd -t cmd-test:0.1 .</code></pre><p>​        </p><pre><code>[root@192 dockerfile]# docker build  -f dockerfile-test-cmd -t cmd-test:0.1 .Sending build context to Docker daemon  3.072kBStep 1/2 : FROM centos ---&gt; 5d0da3dc9764Step 2/2 : CMD [&quot;ls&quot;,&quot;-a&quot;] ---&gt; Running in 462edab225f4Removing intermediate container 462edab225f4 ---&gt; 3a12f3d5b2a5Successfully built 3a12f3d5b2a5Successfully tagged cmd-test:0.1</code></pre><p>​<br>​        </p><p>3、运行镜像</p><pre><code>[root@192 dockerfile]# docker run cmd-test:0.1....dockerenvbindevetc# .. # 列出了 容器内 根目录所有文件夹</code></pre><p>​        </p><p>4、想追加一个命令 -l 成为ls -al</p><pre><code>docker run cmd-test:0.1 ls -al</code></pre><p>​        </p><pre><code>[root@192 ~]# docker run cmd-test:0.1 ls -altotal 0drwxr-xr-x.   1 root root   6 Feb  2 13:53 .drwxr-xr-x.   1 root root   6 Feb  2 13:53 ..-rwxr-xr-x.   1 root root   0 Feb  2 13:53 .dockerenvlrwxrwxrwx.   1 root root   7 Nov  3  2020 bin -&gt; usr/bindrwxr-xr-x.   5 root root 340 Feb  2 13:53 dev# ...</code></pre><p>​        </p><blockquote><p>测试ENTRYPOINT</p></blockquote><p>1、编写dockerfile文件</p><pre><code>vim dockerfile-test-entrypointFROM centosENTRYPOINT [&quot;ls&quot;,&quot;-a&quot;]</code></pre><p>​        </p><p>2、构建镜像</p><pre><code>docker build  -f dockerfile-test-entrypoint -t entrypoint-test:0.1 .</code></pre><p>​        </p><pre><code>[root@192 dockerfile]# docker imagesREPOSITORY        TAG       IMAGE ID       CREATED         SIZEentrypoint-test   0.1       390f47c46bdd   9 seconds ago   231MB</code></pre><p>​        </p><p>3、想追加一个命令 -l</p><pre><code>docker run entrypoint-test:0.1 -l</code></pre><p>​        </p><ul><li><p>成功</p><p>[root@192 dockerfile]# docker run entrypoint-test:0.1 -l<br>total 0<br>drwxr-xr-x.   1 root root   6 Feb  2 13:59 .<br>drwxr-xr-x.   1 root root   6 Feb  2 13:59 ..<br>-rwxr-xr-x.   1 root root   0 Feb  2 13:59 .dockerenv<br>lrwxrwxrwx.   1 root root   7 Nov  3  2020 bin -&gt; usr&#x2F;bin</p><h1 id="…-1"><a href="#…-1" class="headerlink" title="…"></a>…</h1><p>​</p></li></ul><h2 id="15-4-Dockerfile制作tomcat镜像"><a href="#15-4-Dockerfile制作tomcat镜像" class="headerlink" title="15.4 Dockerfile制作tomcat镜像"></a>15.4 Dockerfile制作tomcat镜像</h2><p>1、准备镜像文件</p><p>准备tomcat 和 jdk到当前目录，编写好README</p><p><a href="https://tomcat.apache.org/download-90.cgi">Apache Tomcat® - Apache Tomcat 9 Software Downloads</a></p><pre><code>[root@192 tomcat]# lsapache-tomcat-9.0.58.tar.gz  jdk-8u60-linux-x64.tar.gz[root@192 tomcat]# pwd/root/桌面/Kuang/tomcat</code></pre><p>​        </p><ul><li><p>创建readme.txt文件</p><p>[root@192 tomcat]# ls<br>apache-tomcat-9.0.58.tar.gz  Dockerfile  jdk-8u60-linux-x64.tar.gz  readme.txt</p><p>​</p></li></ul><p>2、编写dokerfile，官方命名<code>Dockerfile</code>,build 会自动寻找,就不用-f 指定了</p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406190440376.png" alt="image-20230406190440376"></div><div class="image-meta"><span class="image-caption center">image-20230406190440376</span></div></div><pre><code>FROM centos MAINTAINER root&lt;id_07221888@qq.com&gt;COPY readme.txt /usr/local/readme.txt #复制文件ADD jdk-8u60-linux-x64.tar.gz /usr/local/ #复制解压ADD apache-tomcat-9.0.58.tar.gz /usr/local/ ENV MYPATH /usr/local #设置环境变量WORKDIR $MYPATH #设置工作目录ENV JAVA_HOME /usr/local/jdk1.8.0_60 #设置环境变量ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools/jarENV CATALINA_HOME /usr/local/apache-tomcat-9.0.58 #设置环境变量ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.58ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin #设置环境变量 分隔符是：EXPOSE 8080 #设置暴露的端口CMD /usr/local/apache-tomcat-9.0.58/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.58/bin/logs/catalina.out # 设置默认命令</code></pre><p>​        </p><pre><code>FROM centos #MAINTAINER cheng&lt;1204598429@qq.com&gt;COPY README /usr/local/README #复制文件ADD jdk-8u231-linux-x64.tar.gz /usr/local/ #复制解压ADD apache-tomcat-9.0.35.tar.gz /usr/local/ #复制解压RUN yum -y install vimENV MYPATH /usr/local #设置环境变量WORKDIR $MYPATH #设置工作目录ENV JAVA_HOME /usr/local/jdk1.8.0_231 #设置环境变量ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.35 #设置环境变量ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib #设置环境变量 分隔符是：EXPOSE 8080 #设置暴露的端口CMD /usr/local/apache-tomcat-9.0.35/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.35/logs/catalina.out # 设置默认命令</code></pre><p>​<br>​        </p><p>3、构造镜像</p><pre><code>docker build  -t diytomcat .</code></pre><p>​        </p><p><strong>构建失败</strong></p><p>4、运行镜像</p><pre><code>docker run -d -p 8080:8080 --name tomcat01 -v /home/kuangshen/build/tomcat/test:/usr/local/apache-tomcat-9.0.35/webapps/test -v /home/kuangshen/build/tomcat/tomcatlogs/:/usr/local/apache-tomcat-9.0.35/logs mytomcat:0.1</code></pre><p>​        </p><p>5、访问测试</p><p>6、发布项目(由于做了卷挂载，我们直接在本地编写项目就可以发布了！)</p><p>发现：项目部署成功，可以直接访问！</p><p>我们以后开发的步骤：需要掌握Dockerfile的编写！我们之后的一切都是使用docker镜像来发布运行！</p><h2 id="15-5-发布镜像到DockerHub-常用"><a href="#15-5-发布镜像到DockerHub-常用" class="headerlink" title="15.5 发布镜像到DockerHub(常用)"></a>15.5 发布镜像到DockerHub(常用)</h2><p>1、登录远程仓库（ <a href="https://hub.docker.com/%EF%BC%89">https://hub.docker.com/）</a></p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406190151990.png" alt="image-20230406190151990"></div><div class="image-meta"><span class="image-caption center">image-20230406190151990</span></div></div><p>2、终端登录</p><pre><code>[root@192 ~]# docker login --helpUsage:  docker login [OPTIONS] [SERVER]登录到Docker注册表。如果没有指定服务器，则由守护进程定义默认值。Options:  -p, --password string   Password      --password-stdin    从stdin获取密码  -u, --username string   Username</code></pre><p>​        </p><p>3、登录成功</p><pre><code>docker login -u 【你的用户名】 -p 【你的密码】</code></pre><p>​        </p><pre><code>[root@192 ~]#  docker login -u 【你的用户名】 -p 【你的密码】WARNING! Using --password via the CLI is insecure. Use --password-stdin.WARNING! Your password will be stored unencrypted in /root/.docker/config.json.Configure a credential helper to remove this warning. Seehttps://docs.docker.com/engine/reference/commandline/login/#credentials-storeLogin Succeeded</code></pre><p>​        </p><p>4、提交 push镜像</p><pre><code>[root@192 ~]# docker imagesREPOSITORY        TAG       IMAGE ID       CREATED        SIZEcmd-test          0.1       3a12f3d5b2a5   18 hours ago   231MB# ...</code></pre><p>​        </p><p>(1) 先打标签</p><pre><code># docker tag 镜像id 你的账户名/镜像仓库名:tag名docker tag 3a12f3d5b2a5 dockerywl/cmd-test:0.1</code></pre><p>​        </p><p>(2) 再提交 push镜像</p><pre><code># docker push 作者/镜像:TAG(版本)docker push dockerywl/cmd-test:0.1</code></pre><p>​        </p><pre><code>[root@192 ~]# docker push dockerywl/cmd-test:0.1The push refers to repository [docker.io/dockerywl/cmd-test]74ddd0ec08fa: Pushing [================&gt;                                  ]  77.74MB/231.3MB</code></pre><p>​        </p><p>(3) push成功</p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406190157116.png" alt="image-20230406190157116"></div><div class="image-meta"><span class="image-caption center">image-20230406190157116</span></div></div><blockquote><p>发布到阿里云镜像服务上</p></blockquote><p>看官网 很详细<a href="https://cr.console.aliyun.com/repository/">https://cr.console.aliyun.com/repository/</a></p><h2 id="15-6-保存传输"><a href="#15-6-保存传输" class="headerlink" title="15.6 保存传输"></a>15.6 保存传输</h2><p>保存后拷贝的U盘交给别人使用</p><p>1、保存(压缩)成backup.tar</p><pre><code>[root@192 ~]# docker save --helpUsage:  docker save [OPTIONS] IMAGE [IMAGE...]将一个或多个镜像保存到tar存档文件(默认情况下流到STDOUT)Options:  -o, --output string   写入一个文件，而不是STDOUT</code></pre><p>​        </p><pre><code>docker save 镜像 -o 文件名</code></pre><p>​        </p><pre><code>[root@192 ~]# docker save redis -o backup.tar [root@192 ~]# ls backup.tar  # 成功</code></pre><p>​        </p><p>2、加载（解压）镜像压缩文件backup.tar</p><pre><code>[root@192 ~]# docker load --helpUsage:  docker load [OPTIONS]从tar存档文件或STDIN加载镜像Options:  -i, --input string   从tar存档文件读取，而不是STDIN  -q, --quiet          抑制负载输出</code></pre><p>​        </p><pre><code>docker load -i backup.tar</code></pre><p>​        </p><pre><code>[root@192 ~]# docker load -i backup.tar92b6c42121d8: Loading layer [==================================================&gt;]  338.4kB/338.4kB65845b69eb5c: Loading layer [==================================================&gt;]  4.274MB/4.274MB7048818d1657: Loading layer [==================================================&gt;]   27.8MB/27.8MBc61d5cbf8621: Loading layer [==================================================&gt;]  2.048kB/2.048kBff503dae4eb6: Loading layer [==================================================&gt;]  3.584kB/3.584kBLoaded image: redis:latest # 成功</code></pre><p>​        </p><h2 id="15-7-Docker所有流程小结（重点）"><a href="#15-7-Docker所有流程小结（重点）" class="headerlink" title="15.7 Docker所有流程小结（重点）"></a>15.7 Docker所有流程小结（重点）</h2><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406190204844.png" alt="image-20230406190204844"></div><div class="image-meta"><span class="image-caption center">image-20230406190204844</span></div></div><h2 id="容器内安装工具"><a href="#容器内安装工具" class="headerlink" title="= 容器内安装工具 &#x3D;"></a>= 容器内安装工具 &#x3D;</h2><p>tomcat 容器</p><p><a href="https://www.runoob.com/linux/linux-comm-apt.html">Linux apt 命令 | 菜鸟教程 (runoob.com)</a></p><pre><code># 先执行apt update # 安装 ip 查看工具apt install -y iproute2# 安装 ping 命令工具apt-get install inetutils-ping# 安装 vim 命令工具apt install vimapt update &amp;&amp;  apt install -y iproute2 &amp;&amp; apt-get install inetutils-ping</code></pre><p>​        </p><h2 id="16、Docker网络详解"><a href="#16、Docker网络详解" class="headerlink" title="16、Docker网络详解"></a>16、Docker网络详解</h2><p>容器编排、集群部署</p><h2 id="16-1-理解Docker-0-不推荐使用"><a href="#16-1-理解Docker-0-不推荐使用" class="headerlink" title="16.1 理解Docker 0(不推荐使用)"></a>16.1 理解Docker 0(不推荐使用)</h2><p>不推荐使用：Docker 0 不支持 ping 容器名</p><blockquote><p>清空所有环境</p></blockquote><pre><code># 删除所有镜像docker rmi -f $(docker images)# 删除所有的容器docker rm -f $(docker ps -aq)   </code></pre><p>​        </p><pre><code>[root@192 ~]# ifconfig# docker0地址 有路由器的功能。docker0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255        # ...# 本机地址ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 192.168.64.130  netmask 255.255.255.0  broadcast 192.168.64.255        # ...# 本机回环地址lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536        inet 127.0.0.1  netmask 255.0.0.0        # ...</code></pre><p>​        </p><blockquote><p>Linux主机 与 容器 互相ping通</p></blockquote><p>1、新建容器</p><pre><code>docker pull tomcatdocker run -it -d -P --name tomcat01 tomcat /bin/bash</code></pre><p>​        </p><p>2、进入为容器安装 ip 查看工具</p><pre><code>docker attath 容器id# 常用apt update &amp;&amp; apt install -y iproute2</code></pre><p>​        </p><p>3、查看容器内网ip</p><p> docker分配的容器内网ip ： 172.17.0.2</p><pre><code>root@138f304dfa38:/usr/local/tomcat# ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever       # veth-pair技术 6 与  7 成对6: eth0@if7: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default     link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0       valid_lft forever preferred_lft forever</code></pre><p>​        </p><p>4、可以ping通 (毕竟tomcat提供的服务外网都可以访问，肯定ping的通)</p><pre><code>[root@192 ~]# ping 172.17.0.2PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.048 ms64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.052 ms64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.085 ms^C--- 172.17.0.2 ping statistics ---3 packets transmitted, 3 received, 0% packet loss, time 2001msrtt min/avg/max/mdev = 0.048/0.061/0.085/0.018 ms</code></pre><p>​        </p><p>5、进入为容器安装 ping 命令工具</p><pre><code>apt-get install inetutils-ping</code></pre><p>​        </p><p>6、 容器 ping通 Linux主机</p><pre><code>root@138f304dfa38:/usr/local/tomcat# ping 192.168.64.130PING 192.168.64.130 (192.168.64.130): 56 data bytes64 bytes from 192.168.64.130: icmp_seq=0 ttl=64 time=0.294 ms64 bytes from 192.168.64.130: icmp_seq=1 ttl=64 time=0.125 ms^C--- 192.168.64.130 ping statistics ---7 packets transmitted, 7 packets received, 0% packet lossround-trip min/avg/max/stddev = 0.125/0.181/0.294/0.056 ms</code></pre><p>​        </p><blockquote><p>原理</p></blockquote><p>1、我们每启动一个docker容器，docker就会给docker容器分配一个ip，我们只要按照了docker，就会有一个docker0桥接模式，使用的技术是veth-pair技术！</p><p><a href="https://www.cnblogs.com/bakari/p/10613710.html">https://www.cnblogs.com/bakari/p/10613710.html</a></p><p>veth-pair 就是一对的虚拟设备接口，和 tap&#x2F;tun 设备不同的是，它都是<strong>成对</strong>出现的。一端连着协议栈，一端彼此相连着。</p><p>（成对：Linux 主机网卡 6,7成对，则容器网卡7，6成对）</p><p>Linux 主机 再次执行 <code>ip addr</code>，多了个网卡</p><pre><code>[root@192 ~]# ip addr1: lo: # ...2: ens33: # ...3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default     link/ether 02:42:a4:0b:89:6b brd ff:ff:ff:ff:ff:ff    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0     # ...# 多了个网卡7: veth568cc5e@if6: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default     link/ether de:55:c0:b4:58:42 brd ff:ff:ff:ff:ff:ff link-netnsid 0    inet6 fe80::dc55:c0ff:feb4:5842/64 scope link        valid_lft forever preferred_lft forever</code></pre><p>​        </p><p>2、再启动一个tocmat02容器，执行 <code>ip addr</code>，又多了个网卡</p><pre><code>docker run -it -d -P --name tomcat02 tomcat</code></pre><p>​        </p><pre><code>[root@192 ~]# ip addr# ...# veth-pair技术 7 与  6 成对，Linux主机则为6 与 7成对7: veth568cc5e@if6: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default     link/ether de:55:c0:b4:58:42 brd ff:ff:ff:ff:ff:ff link-netnsid 0    inet6 fe80::dc55:c0ff:feb4:5842/64 scope link        valid_lft forever preferred_lft forever# veth-pair技术 9 与  8 成对9: veth7668013@if8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default     link/ether 7a:c2:eb:86:ae:9f brd ff:ff:ff:ff:ff:ff link-netnsid 1    inet6 fe80::78c2:ebff:fe86:ae9f/64 scope link        valid_lft forever preferred_lft forever</code></pre><p>​        </p><p>3、进入tocmat02容器，为容器安装 ip 查看工具,ip:172.17.0.2</p><pre><code>apt update &amp;&amp; apt install -y iproute2 </code></pre><p>​        </p><pre><code>root@443a02110963:/usr/local/tomcat# ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever10: eth0@if11: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default     link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0       valid_lft forever preferred_lft foreverroot@443a02110963:/usr/local/tomcat# </code></pre><p>​        </p><p>4、tomcat01与tocmat02 可以相互ping 通</p><pre><code>root@443a02110963:/usr/local/tomcat# ping 172.17.0.2PING 172.17.0.2 (172.17.0.2): 56 data bytes64 bytes from 172.17.0.2: icmp_seq=0 ttl=64 time=0.129 ms64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.279 ms64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.142 ms^C--- 172.17.0.2 ping statistics ---3 packets transmitted, 3 packets received, 0% packet lossround-trip min/avg/max/stddev = 0.129/0.183/0.279/0.068 ms</code></pre><p>​        </p><blockquote><p>结论</p></blockquote><p>tomcat01和tomcat02公用一个路由器，docker0。</p><p>所有的容器不指定网络的情况下，都是docker0路由的，docker会给我们的容器分配一个默认的可用ip。</p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406190216290.png" alt="image-20230406190216290"></div><div class="image-meta"><span class="image-caption center">image-20230406190216290</span></div></div><p>Docker使用的是Linux的桥接，宿主机是一个Docker容器的网桥 docker0</p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406190219194.png" alt="image-20230406190219194"></div><div class="image-meta"><span class="image-caption center">image-20230406190219194</span></div></div><p>Docker中所有网络接口都是虚拟的，虚拟的转发效率高（内网传递文件）</p><p><strong>只要容器删除，对应的网桥一对就没了！</strong></p><h2 id="16-2-–link（不推荐使用）"><a href="#16-2-–link（不推荐使用）" class="headerlink" title="16.2 –link（不推荐使用）"></a>16.2 –link（不推荐使用）</h2><blockquote><p>思考一个场景</p></blockquote><p> 我们编写了一个微服务，database url&#x3D;ip: 项目不重启，数据库ip换了，我们希望可以处理这个问题，可以通过名字来进行访问容器？（高可用）</p><p> <strong>实现ping 通 容器名</strong></p><blockquote><p>–link 作用</p></blockquote><p> docker run –link可以用来链接2个容器，使得源容器（被链接的容器）和接收容器（主动去链接的容器）之间可以互相通信，并且接收容器可以获取源容器的一些数据，如源容器的环境变量。</p><blockquote><p>测试</p></blockquote><p>1、准备centos01、centos02</p><pre><code>$ docker run -it -d --name centos01 centos $ docker run -it -d --name centos02 centos </code></pre><p>​        </p><p>2、实现ping不通容器名</p><pre><code>$ docker exec -it centos02 ping centos01 </code></pre><p>​        </p><pre><code>[root@192 ~]# docker exec -it centos02 ping centos01 ping: centos01: Name or service not known</code></pre><p>​        </p><p>3、运行一个tomcat03 ,加上参数<code>--link centos02</code>，连接centos02</p><pre><code>$ docker run -it --name centos03 --link centos02 centos /bin/bash</code></pre><p>​        </p><pre><code>[root@a04540580e1b /]# ping centos02PING centos02 (172.17.0.3) 56(84) bytes of data.64 bytes from centos02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.118 ms64 bytes from centos02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.110 ms^C--- centos02 ping statistics ---2 packets transmitted, 2 received, 0% packet loss, time 1003msrtt min/avg/max/mdev = 0.110/0.114/0.118/0.004 ms[root@a04540580e1b /]# </code></pre><p>​        </p><p>4、用centos03 ping centos02 可以ping通</p><pre><code>docker exec -it centos03 ping centos02</code></pre><p>​        </p><pre><code>[root@192 ~]# docker exec -it centos03 ping centos02PING centos02 (172.17.0.3) 56(84) bytes of data.64 bytes from centos02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.071 ms64 bytes from centos02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.154 ms^C--- centos02 ping statistics ---2 packets transmitted, 2 received, 0% packet loss, time 1003msrtt min/avg/max/mdev = 0.071/0.112/0.154/0.042 ms</code></pre><p>​        </p><p>但是用tomcat02 ping tomcat03 ping不通</p><h2 id="16-3-Docker网络探究"><a href="#16-3-Docker网络探究" class="headerlink" title="16.3 Docker网络探究"></a>16.3 Docker网络探究</h2><p><code>docker network</code></p><pre><code>[root@192 ~]# docker network lsNETWORK ID     NAME      DRIVER    SCOPE297f07c51979   bridge    bridge    local # bridge:桥接 docker087a8f8309bfa   host      host      local51b67872ea20   none      null      local</code></pre><p>​        </p><pre><code>[root@192 ~]# docker network --helpUsage:  docker network COMMANDManage networks  # 管理网络Commands:  connect     # 将容器连接到网络  create      # 创建网络  disconnect  # 断开一个容器与网络的连接  inspect     # 显示一个或多个网络的详细信息  ls          # 网络列表  prune       # 删除所有未使用的网络  rm          # 删除一个或多个网络</code></pre><p>​        </p><p>1、查看docker0的网络信息</p><pre><code>docker network inspect 297f07c51979 </code></pre><p>​        </p><pre><code>[root@192 ~]# docker network inspect 297f07c51979 [    &#123;        &quot;Name&quot;: &quot;bridge&quot;,        &quot;Id&quot;: &quot;297f07c5197942c2a4bc867abd31c61f6f804f1b7fc08b6e7b3da2839c77bc34&quot;,        &quot;Created&quot;: &quot;2022-02-03T17:50:16.517397962+08:00&quot;,        &quot;Scope&quot;: &quot;local&quot;,        &quot;Driver&quot;: &quot;bridge&quot;,        &quot;EnableIPv6&quot;: false,        &quot;IPAM&quot;: &#123;            &quot;Driver&quot;: &quot;default&quot;, # default            &quot;Options&quot;: null,            &quot;Config&quot;: [                &#123;                    &quot;Subnet&quot;: &quot;172.17.0.0/16&quot;, # 网段                    &quot;Gateway&quot;: &quot;172.17.0.1&quot;                &#125;            ]        &#125;,        &quot;Internal&quot;: false,        &quot;Attachable&quot;: false,        &quot;Ingress&quot;: false,        &quot;ConfigFrom&quot;: &#123;            &quot;Network&quot;: &quot;&quot;        &#125;,        &quot;ConfigOnly&quot;: false,        &quot;Containers&quot;: &#123;            &quot;78904cf546599b37473b34ff4a5bf5f1af3a632e5bd80ff8e72904d7ed339c45&quot;: &#123;                &quot;Name&quot;: &quot;tomcat02&quot;, # tomcat02                &quot;EndpointID&quot;: &quot;ea7126991ab6eab6d65f0bc8c0135d014446c919c9ceee1e94d1ddd8c07e5c80&quot;,                &quot;MacAddress&quot;: &quot;02:42:ac:11:00:03&quot;,                &quot;IPv4Address&quot;: &quot;172.17.0.3/16&quot;, # tomcat02 的 ip 地址                &quot;IPv6Address&quot;: &quot;&quot;            &#125;,            &quot;95cac41f93906a08c79b49e84ed490b220032ee954c27b243835de6cb035bb56&quot;: &#123;                &quot;Name&quot;: &quot;tomcat01&quot;, # tomcat01                &quot;EndpointID&quot;: &quot;4c10c4fe891272787fc69121be3f929a830fef79eca92c507f5fdccad9d83145&quot;,                &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,                &quot;IPv4Address&quot;: &quot;172.17.0.2/16&quot;,                &quot;IPv6Address&quot;: &quot;&quot;            &#125;        &#125;,        &quot;Options&quot;: &#123;            # ...        &#125;,        &quot;Labels&quot;: &#123;&#125;    &#125;]</code></pre><p>​<br>​        </p><p>2、查看容器tomcat02详细信息</p><pre><code>docker inspect 容器id</code></pre><p>​        </p><pre><code>[root@192 ~]# docker inspect 78904cf54659[    &#123;        &quot;Id&quot;: &quot;78904cf546599b37473b34ff4a5bf5f1af3a632e5bd80ff8e72904d7ed339c45&quot;,        &quot;Created&quot;: &quot;2022-02-03T12:13:25.377988982Z&quot;,        &quot;Path&quot;: &quot;/bin/bash&quot;,        &quot;Args&quot;: [],        &quot;State&quot;: &#123; # 主题            &quot;Status&quot;: &quot;running&quot;,            &quot;Running&quot;: true, # 运行            &quot;Paused&quot;: false,            &quot;Restarting&quot;: false,            &quot;OOMKilled&quot;: false,            &quot;Dead&quot;: false,             &quot;Pid&quot;: 9965,            &quot;ExitCode&quot;: 0,            &quot;Error&quot;: &quot;&quot;,            &quot;StartedAt&quot;: &quot;2022-02-03T12:44:20.630270698Z&quot;,            &quot;FinishedAt&quot;: &quot;2022-02-03T12:34:37.648949082Z&quot;        &#125;,              &quot;Config&quot;: &#123;            &quot;Hostname&quot;: &quot;78904cf54659&quot;,            &quot;Domainname&quot;: &quot;&quot;,            &quot;User&quot;: &quot;&quot;,            # ...            &quot;Env&quot;: [# 环境配置                &quot;PATH=/usr/local/tomcat/bin:/usr/local/openjdk-11/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;,                &quot;JAVA_HOME=/usr/local/openjdk-11&quot;,                &quot;LANG=C.UTF-8&quot;,                &quot;JAVA_VERSION=11.0.13&quot;,                # ...            ],            &quot;Cmd&quot;: [                &quot;/bin/bash&quot;            ],            &quot;Image&quot;: &quot;tomcat&quot;, # 镜像            &quot;Volumes&quot;: null,            &quot;WorkingDir&quot;: &quot;/usr/local/tomcat&quot;, # 工作目录            &quot;Entrypoint&quot;: null,             &quot;OnBuild&quot;: null,            &quot;Labels&quot;: &#123;&#125;        &#125;,        &quot;NetworkSettings&quot;: &#123;            &quot;Bridge&quot;: &quot;&quot;,            &quot;SandboxID&quot;: &quot;5ed43e901e7b9b49937e06d39a5f1fe73709437d70beaf8b07d3e56c48affcdf&quot;,            &quot;HairpinMode&quot;: false,            &quot;LinkLocalIPv6Address&quot;: &quot;&quot;,            &quot;LinkLocalIPv6PrefixLen&quot;: 0,            &quot;Ports&quot;: &#123;                &quot;8080/tcp&quot;: [                    &#123;                        &quot;HostIp&quot;: &quot;0.0.0.0&quot;,                        &quot;HostPort&quot;: &quot;49169&quot;                    &#125;,                    &#123;                        &quot;HostIp&quot;: &quot;::&quot;,                        &quot;HostPort&quot;: &quot;49169&quot;                    &#125;                ]            &#125;,            # ...            &quot;Networks&quot;: &#123;                &quot;bridge&quot;: &#123; # 桥接                    # ...                    &quot;Gateway&quot;: &quot;172.17.0.1&quot;, # 网关                    &quot;IPAddress&quot;: &quot;172.17.0.3&quot;, # ip                    # ...                &#125;            &#125;        &#125;    &#125;]</code></pre><p>​        </p><p>3、查看容器tomcat03详细信息，得到连接信息</p><pre><code>docker inspect 4e6aae2d99dd</code></pre><p>​        </p><pre><code># ...&quot;HostConfig&quot;: &#123;    # ...    &quot;Links&quot;: [                &quot;/tomcat02:/tomcat03/tomcat02&quot;            ],    # ...&#125;# ...</code></pre><p>​        </p><p>4、容器tomcat03配置了网络映射 将主机名(tomcat02)与ip地址host映射(不推荐使用)。</p><pre><code>cat /etc/hosts</code></pre><p>​        </p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406190230154.png" alt="image-20230406190230154"></div><div class="image-meta"><span class="image-caption center">image-20230406190230154</span></div></div><h2 id="16-4-自定义网络"><a href="#16-4-自定义网络" class="headerlink" title="16.4 自定义网络"></a>16.4 自定义网络</h2><p>查看所有的docker网络</p><pre><code>[root@192 ~]# docker network lsNETWORK ID     NAME      DRIVER    SCOPE297f07c51979   bridge    bridge    local # bridge:桥接 docker087a8f8309bfa   host      host      local51b67872ea20   none      null      local</code></pre><p>​        </p><blockquote><p>网络模式</p></blockquote><p>bridge ：桥接 docker（默认，自己创建也是用bridge模式）</p><p>none ：不配置网络，一般不用</p><p>host ：和所主机共享网络</p><p>container ：容器网络连通（用得少！局限很大）</p><blockquote><p>自定义一个网络</p></blockquote><p>1、默认参数 <code>-net bridge</code></p><pre><code># 启动时 --net bridge 是默认带上的,bridge就是docker0$ docker run -d -P --name tomcat01 tomcat 等价于 =&gt; docker run -d -P --name tomcat01 --net bridge tomcat</code></pre><p>​        </p><pre><code># docker0，特点：默认，域名不能访问。 --link可以打通连接，但是很麻烦！</code></pre><p>​        </p><p>2、创建网络的命令</p><pre><code>[root@192 ~]# docker network create --helpUsage:  docker network create [OPTIONS] NETWORKCreate a networkOptions:      --attachable           # 启用手动容器附件      --aux-address map      # map网络驱动使用的辅助IPv4或IPv6地址(默认map[])      --config-from string   # 要复制配置的网络      --config-only          # 创建仅配置网络  -d, --driver string        # 管理网络的驱动程序(默认为“bridge”)      --gateway strings      # IPv4或IPv6主子网网关      --ingress              # 创建群路由-mesh网络      --internal             # 限制外部用户访问网络      --ip-range strings     # 从子范围分配容器ip      --ipam-driver string   # IP地址管理驱动程序(默认为“default”)      --ipam-opt map         # map设置IPAM驱动的特定选项(default map[])      --ipv6                 # 启用ipv6组网功能      --label list           # list设置网络元数据  -o, --opt map              # 设置驱动程序的特定选项(默认map[])      --scope string         # 控制网络范围      --subnet strings       # CIDR格式的子网，表示一个网段</code></pre><p>​        </p><p>3、自定义一个网络（创建网络）,名字为mynet</p><pre><code>$ docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</code></pre><p>​        </p><pre><code>[root@192 ~]#  docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet6293fb8f0a642641dc0f6043b7a666690406db6423070b08f6af38a67e96e64f</code></pre><p>​        </p><p>4、查看自定义的网络mynet</p><pre><code>$ docker network inspect mynet</code></pre><p>​        </p><pre><code>[root@192 ~]# docker network inspect mynet[    &#123;        &quot;Name&quot;: &quot;mynet&quot;,        &quot;Id&quot;: &quot;6293fb8f0a642641dc0f6043b7a666690406db6423070b08f6af38a67e96e64f&quot;,        &quot;Created&quot;: &quot;2022-02-04T10:06:47.753633784+08:00&quot;,        &quot;Scope&quot;: &quot;local&quot;,        &quot;Driver&quot;: &quot;bridge&quot;, #网络模式 bridge(桥接)        &quot;EnableIPv6&quot;: false,        &quot;IPAM&quot;: &#123;            &quot;Driver&quot;: &quot;default&quot;,            &quot;Options&quot;: &#123;&#125;,            &quot;Config&quot;: [                &#123;                    &quot;Subnet&quot;: &quot;192.168.0.0/16&quot;, # 子网 192.168.0.2 ~ 192.168.255.254                    &quot;Gateway&quot;: &quot;192.168.0.1&quot; # 网关                &#125;            ]        &#125;,        # ...    &#125;]</code></pre><p>​        </p><blockquote><p>创建容器，配置网络</p></blockquote><p>1、创建容器01、02</p><pre><code>#  接 /bin/bash 直接进命令行docker run -it --name centos-net01 --net mynet centos docker run -it --name centos-net02 --net mynet centos </code></pre><p>​        </p><p>2、再次查看自定义的网络mynet，可见多了新增容器01、02的网络配置</p><pre><code>[root@192 ~]# docker network inspect mynet[    &#123;        &quot;Name&quot;: &quot;mynet&quot;,        # ...         &quot;Containers&quot;: &#123;            &quot;0c9e72313626017f9143fef9bfe9acb70f0ed46c352c8f6ed0612675c666379d&quot;: &#123;                &quot;Name&quot;: &quot;centos-net01&quot;, # centos-net01                &quot;EndpointID&quot;: &quot;a228cec33c9019f31999f9b8c9ced3e60d3e611ae395d147b0db2ea920fce4ed&quot;,                &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:02&quot;,                &quot;IPv4Address&quot;: &quot;192.168.0.2/16&quot;, # ip地址： 192.168.0.2                &quot;IPv6Address&quot;: &quot;&quot;            &#125;,            &quot;c31a887225dfa9572bc47703d838932590d9a5188b1fe13e82cd5851e286b497&quot;: &#123;                &quot;Name&quot;: &quot;centos-net02&quot;, # centos-net02                &quot;EndpointID&quot;: &quot;7f4864f0e52fb36149cfffa78bde3ee88e38ea20202eca4c0b4ec5136e62ec94&quot;,                &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:03&quot;,                &quot;IPv4Address&quot;: &quot;192.168.0.3/16&quot;, # ip地址： 192.168.0.3                &quot;IPv6Address&quot;: &quot;&quot;            &#125;        &#125;,        &quot;Options&quot;: &#123;&#125;,        &quot;Labels&quot;: &#123;&#125;    &#125;]</code></pre><p>​        </p><p>3、在自定义的网络下，服务可以互相ping通，不用使用<code>–link</code></p><ul><li><p>01 ping 通 02</p><p>docker exec -it centos-net01 ping centos-net02 </p><p>​    </p><p>[root@192 ~]# docker exec -it centos-net01 ping centos-net02<br>PING centos-net02 (192.168.0.3) 56(84) bytes of data.<br>64 bytes from centos-net02.mynet (192.168.0.3): icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.072 ms<br>64 bytes from centos-net02.mynet (192.168.0.3): icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;0.077 ms<br>64 bytes from centos-net02.mynet (192.168.0.3): icmp_seq&#x3D;3 ttl&#x3D;64 time&#x3D;0.081 ms<br>64 bytes from centos-net02.mynet (192.168.0.3): icmp_seq&#x3D;4 ttl&#x3D;64 time&#x3D;0.110 ms<br>^C<br>— centos-net02 ping statistics —<br>4 packets transmitted, 4 received, 0% packet loss, time 3004ms<br>rtt min&#x2F;avg&#x2F;max&#x2F;mdev &#x3D; 0.072&#x2F;0.085&#x2F;0.110&#x2F;0.014 ms</p><p>​    </p></li><li><p>反之亦然，02 ping 通 01</p><p>[root@192 ~]# docker exec -it centos-net02 ping centos-net01<br>PING centos-net01 (192.168.0.2) 56(84) bytes of data.<br>64 bytes from centos-net01.mynet (192.168.0.2): icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.049 ms<br>64 bytes from centos-net01.mynet (192.168.0.2): icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;0.095 ms<br>^C<br>— centos-net01 ping statistics —<br>2 packets transmitted, 2 received, 0% packet loss, time 1003ms<br>rtt min&#x2F;avg&#x2F;max&#x2F;mdev &#x3D; 0.049&#x2F;0.072&#x2F;0.095&#x2F;0.023 ms</p><p>​</p></li></ul><p>4、查看host映射,映射 <code>ip 对应 容器id</code></p><pre><code>[root@192 ~]# docker exec -it centos-net02 cat /etc/hosts127.0.0.1localhost# ...192.168.0.3c31a887225df # ip 对应 容器id（centos-net01 的ip）</code></pre><p>​        </p><pre><code>[root@192 ~]# docker exec -it centos-net01 cat /etc/hosts127.0.0.1localhost# ...192.168.0.20c9e72313626 # ip 对应 容器id（centos-net02 的ip）</code></pre><p>​        </p><p>我们自定义的网络docker当我们维护好了对应的关系，推荐我们平时这样使用网络！</p><p>好处：</p><p>redis -不同的集群使用不同的网络，保证集群是安全和健康的</p><p>mysql-不同的集群使用不同的网络，保证集群是安全和健康的</p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406190240143.png" alt="image-20230406190240143"></div><div class="image-meta"><span class="image-caption center">image-20230406190240143</span></div></div><h2 id="16-5-网络连通"><a href="#16-5-网络连通" class="headerlink" title="16.5 网络连通"></a>16.5 网络连通</h2><p>解决问题，网段不同如何ping通</p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406190243645.png" alt="image-20230406190243645"></div><div class="image-meta"><span class="image-caption center">image-20230406190243645</span></div></div><p>1、创建容器 centos01，测试ping 容器名失败</p><pre><code>$ docker run -dit --name centos01 centos$ docker exec -it centos01 ping centos-net01</code></pre><p>​        </p><pre><code>[root@192 ~]#  docker exec -it centos01 ping centos-net01ping: centos-net01: Name or service not known</code></pre><p>​        </p><p>2、解决方法：<code>docker network connect</code></p><pre><code>[root@192 ~]# clear[root@192 ~]# docker network connect --help# NETWORK：工作网络（mynet）Usage:  docker network connect [OPTIONS] NETWORK CONTAINERConnect a container to a network # 将容器连接到网络中Options:      --alias strings           # 为容器添加网络范围的别名      --driver-opt strings      # 网络驱动选项      --ip string               # IPv4地址(例如172.30.100.104)      --ip6 string              # IPv6地址(例如,2001:db8:: 33)      --link list               # 添加链接到另一个容器      --link-local-ip strings   # 为容器添加链路本地地址</code></pre><p>​        </p><p>3、将网络mynet与 centos01容器连通</p><pre><code>$ docker network connect mynet centos01</code></pre><p>​        </p><p>4、查看mynet</p><pre><code>[root@192 ~]# docker inspect mynet [    &#123;        &quot;Name&quot;: &quot;mynet&quot;,        # ...        &quot;Containers&quot;: &#123;            &quot;0c9e72313626017f9143fef9bfe9acb70f0ed46c352c8f6ed0612675c666379d&quot;: &#123;                &quot;Name&quot;: &quot;centos-net01&quot;,                &quot;EndpointID&quot;: &quot;b09c89b344437d0a166567d03358cdb6f2c05a6833813501285ed516abe641df&quot;,                &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:02&quot;,                &quot;IPv4Address&quot;: &quot;192.168.0.2/16&quot;,                &quot;IPv6Address&quot;: &quot;&quot;            &#125;,            &quot;c31a887225dfa9572bc47703d838932590d9a5188b1fe13e82cd5851e286b497&quot;: &#123;                &quot;Name&quot;: &quot;centos-net02&quot;,                &quot;EndpointID&quot;: &quot;eda6dd675c194a84e6d398ee8c16cc6b42d67fb91069264d00d05ada7dd5633b&quot;,                &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:04&quot;,                &quot;IPv4Address&quot;: &quot;192.168.0.4/16&quot;,                &quot;IPv6Address&quot;: &quot;&quot;            &#125;,            &quot;dac6694051750f990fa6fac796795d60b8e4578d9b72f90fbc9519b54e6498ac&quot;: &#123;                &quot;Name&quot;: &quot;centos01&quot;, # 新增centos01                &quot;EndpointID&quot;: &quot;e79c29a2d531dd69b766ee6253f1562d7a8bcbc6accfab23cb6df5cdbaa6a7a0&quot;,                &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:03&quot;,                &quot;IPv4Address&quot;: &quot;192.168.0.3/16&quot;, # 公网ip                 &quot;IPv6Address&quot;: &quot;&quot;            &#125;        &#125;,        # ...</code></pre><p>​        </p><ul><li><p>centos01容器的hosts文件(<strong>一个容器两个ip</strong>)</p><p>[root@192 ~]# docker exec -it centos01 cat &#x2F;etc&#x2F;hosts<br>127.0.0.1localhost</p><h1 id="…-2"><a href="#…-2" class="headerlink" title="…"></a>…</h1><h1 id="dac669405175-是-centos01容器自己的-容器id"><a href="#dac669405175-是-centos01容器自己的-容器id" class="headerlink" title="dac669405175 是 centos01容器自己的 容器id"></a>dac669405175 是 centos01容器自己的 容器id</h1><p>172.17.0.2dac669405175 # 私网ip &#x3D;&gt; 容器id<br>192.168.0.3dac669405175 # 公网ip &#x3D;&gt; 容器id</p><p>​    </p></li><li><p>centos-net01容器的hosts文件</p><p>[root@192 ~]# docker exec -it centos-net01 cat &#x2F;etc&#x2F;hosts<br>127.0.0.1localhost</p><h1 id="…-3"><a href="#…-3" class="headerlink" title="…"></a>…</h1><p>192.168.0.20c9e72313626  # 私网(公网)ip &#x3D;&gt; 容器id</p><p>​</p></li></ul><p>5、再次测试，centos01与 centos-net01、centos-net02 均可ping通</p><pre><code>$ docker exec -it centos01 ping centos-net01$ docker exec -it centos01 ping centos-net02$ docker exec -it centos-net01 ping centos01 $ docker exec -it centos-net02 ping centos01 </code></pre><p>​        </p><blockquote><p>结论</p></blockquote><p>假设要跨网络操作别人，就需要使用<code>docker network connect</code>连通！</p><h2 id="17、Redis集群部署实战"><a href="#17、Redis集群部署实战" class="headerlink" title="17、Redis集群部署实战"></a>17、Redis集群部署实战</h2><h2 id="17-1-部署"><a href="#17-1-部署" class="headerlink" title="17.1 部署"></a>17.1 部署</h2><blockquote><p>环境</p></blockquote><p>三主三从</p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406190250509.png" alt="image-20230406190250509"></div><div class="image-meta"><span class="image-caption center">image-20230406190250509</span></div></div><p>1、创建网卡</p><pre><code>$ docker network create redisnet --subnet 172.38.0.0/16</code></pre><p>​        </p><p>2、通过脚本创建六个redis配置文件</p><pre><code>for port in $(seq 1 6);\do \mkdir -p /mydata/redis/node-$&#123;port&#125;/conftouch /mydata/redis/node-$&#123;port&#125;/conf/redis.confcat &lt;&lt; EOF &gt;&gt; /mydata/redis/node-$&#123;port&#125;/conf/redis.confport 6379bind 0.0.0.0cluster-enabled yescluster-config-file nodes.confcluster-node-timeout 5000cluster-announce-ip 172.38.0.1$&#123;port&#125;cluster-announce-port 6379cluster-announce-bus-port 16379appendonly yesEOFdone</code></pre><p>​        </p><ul><li><p>查看redis配置文件</p><p>[root@192 ~]# cd &#x2F;mydata&#x2F;redis&#x2F;<br>[root@192 redis]# ls<br>node-1  node-2  node-3  node-4  node-5  node-6<br>[root@192 conf]# cd &#x2F;mydata&#x2F;redis&#x2F;node-1&#x2F;conf<br>[root@192 conf]# ls<br>redis.conf<br>[root@192 conf]# cat redis.conf<br>port 6379<br>bind 0.0.0.0<br>cluster-enabled yes<br>cluster-config-file nodes.conf<br>cluster-node-timeout 5000<br>cluster-announce-ip 172.38.0.11<br>cluster-announce-port 6379<br>cluster-announce-bus-port 16379<br>appendonly yes</p><p>​</p></li></ul><p>3、通过脚本创建和运行六个redis容器，<code>--ip</code> 指定ip，<code>-v</code>挂载redis配置文件和数据</p><pre><code>for port in $(seq 1 6);\do \docker run -p 637$&#123;port&#125;:6379 -p 1667$&#123;port&#125;:16379 --name redis-$&#123;port&#125; \-v /mydata/redis/node-$&#123;port&#125;/data:/data \-v /mydata/redis/node-$&#123;port&#125;/conf/redis.conf:/etc/redis/redis.conf \-d --net redisnet --ip 172.38.0.1$&#123;port&#125; redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.confdone</code></pre><p>​        </p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406190449166.png" alt="image-20230406190449166"></div><div class="image-meta"><span class="image-caption center">image-20230406190449166</span></div></div><ul><li><p>或者一个一个容器添加</p><p>docker run -p 6371:6379 -p 16671:16379 –name redis-1 <br>-v &#x2F;mydata&#x2F;redis&#x2F;node-1&#x2F;data:&#x2F;data <br>-v &#x2F;mydata&#x2F;redis&#x2F;node-1&#x2F;conf&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf <br>-d –net redisnet –ip 172.38.0.11 redis:5.0.9-alpine3.11 redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf</p><p>docker run -p 6372:6379 -p 16672:16379 –name redis-2 <br>-v &#x2F;mydata&#x2F;redis&#x2F;node-2&#x2F;data:&#x2F;data <br>-v &#x2F;mydata&#x2F;redis&#x2F;node-2&#x2F;conf&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf <br>-d –net redisnet –ip 172.38.0.12 redis:5.0.9-alpine3.11 redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf</p><p>docker run -p 6373:6379 -p 16673:16379 –name redis-3 <br>-v &#x2F;mydata&#x2F;redis&#x2F;node-3&#x2F;data:&#x2F;data <br>-v &#x2F;mydata&#x2F;redis&#x2F;node-3&#x2F;conf&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf <br>-d –net redisnet –ip 172.38.0.13 redis:5.0.9-alpine3.11 redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf</p><p>docker run -p 6374:6379 -p 16674:16379 –name redis-4 <br>-v &#x2F;mydata&#x2F;redis&#x2F;node-4&#x2F;data:&#x2F;data <br>-v &#x2F;mydata&#x2F;redis&#x2F;node-4&#x2F;conf&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf <br>-d –net redisnet –ip 172.38.0.14 redis:5.0.9-alpine3.11 redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf</p><p>docker run -p 6375:6379 -p 16675:16379 –name redis-5 <br>-v &#x2F;mydata&#x2F;redis&#x2F;node-5&#x2F;data:&#x2F;data <br>-v &#x2F;mydata&#x2F;redis&#x2F;node-5&#x2F;conf&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf <br>-d –net redisnet –ip 172.38.0.15 redis:5.0.9-alpine3.11 redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf</p><p>docker run -p 6376:6379 -p 16676:16379 –name redis-6 <br>-v &#x2F;mydata&#x2F;redis&#x2F;node-6&#x2F;data:&#x2F;data <br>-v &#x2F;mydata&#x2F;redis&#x2F;node-6&#x2F;conf&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf <br>-d –net redisnet –ip 172.38.0.16 redis:5.0.9-alpine3.11 redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf</p><p>​</p></li></ul><p>4、查看创建的redis容器</p><p>（秒退的，可以用docker logs redis-1 查看日志）</p><pre><code>[root@192 conf]#  docker ps CONTAINER ID   IMAGE                    COMMAND                  CREATED          STATUS          PORTS                                                                                      NAMES49e9e62c7fff   redis:5.0.9-alpine3.11   &quot;docker-entrypoint.s…&quot;   20 seconds ago   Up 19 seconds   0.0.0.0:6376-&gt;6379/tcp, :::6376-&gt;6379/tcp, 0.0.0.0:16676-&gt;16379/tcp, :::16676-&gt;16379/tcp   redis-6691b11db10c8   redis:5.0.9-alpine3.11   &quot;docker-entrypoint.s…&quot;   21 seconds ago   Up 20 seconds   0.0.0.0:6375-&gt;6379/tcp, :::6375-&gt;6379/tcp, 0.0.0.0:16675-&gt;16379/tcp, :::16675-&gt;16379/tcp   redis-5fc37037e7ae9   redis:5.0.9-alpine3.11   &quot;docker-entrypoint.s…&quot;   22 seconds ago   Up 20 seconds   0.0.0.0:6374-&gt;6379/tcp, :::6374-&gt;6379/tcp, 0.0.0.0:16674-&gt;16379/tcp, :::16674-&gt;16379/tcp   redis-485ef9071ac9b   redis:5.0.9-alpine3.11   &quot;docker-entrypoint.s…&quot;   22 seconds ago   Up 21 seconds   0.0.0.0:6373-&gt;6379/tcp, :::6373-&gt;6379/tcp, 0.0.0.0:16673-&gt;16379/tcp, :::16673-&gt;16379/tcp   redis-344b92119b2b3   redis:5.0.9-alpine3.11   &quot;docker-entrypoint.s…&quot;   23 seconds ago   Up 21 seconds   0.0.0.0:6372-&gt;6379/tcp, :::6372-&gt;6379/tcp, 0.0.0.0:16672-&gt;16379/tcp, :::16672-&gt;16379/tcp   redis-2269b8eb57942   redis:5.0.9-alpine3.11   &quot;docker-entrypoint.s…&quot;   23 seconds ago   Up 22 seconds   0.0.0.0:6371-&gt;6379/tcp, :::6371-&gt;6379/tcp, 0.0.0.0:16671-&gt;16379/tcp, :::16671-&gt;16379/tcp   redis-1</code></pre><p>​<br>​        </p><p>5、查看网络redisnet的信息（Containers字段内省略了数据）</p><pre><code>[root@192 conf]# docker inspect redisnet [    &#123;        &quot;Name&quot;: &quot;redisnet&quot;,        # ...        &quot;Containers&quot;: &#123;            &quot;269b8eb57942dd3c816247251c1d4a0299c86d8dbfa45c1e60fd68b1e0b5e470&quot;: &#123;                &quot;Name&quot;: &quot;redis-1&quot;,                &quot;IPv4Address&quot;: &quot;172.38.0.11/16&quot;,            &#125;,            &quot;44b92119b2b3573e1a8e15a1e435cd3c1cde30a6fc3f960189a88f715e962fec&quot;: &#123;                &quot;Name&quot;: &quot;redis-2&quot;,                &quot;IPv4Address&quot;: &quot;172.38.0.12/16&quot;,            &#125;,            &quot;49e9e62c7ffff2955194095818f4b806e609329350456e65c2bec9f5932bd8f6&quot;: &#123;                &quot;Name&quot;: &quot;redis-6&quot;,                &quot;IPv4Address&quot;: &quot;172.38.0.16/16&quot;,            &#125;,            &quot;691b11db10c8403b999386caec7ad20dad535aa0d0e3f9d98214423b328f23de&quot;: &#123;                &quot;IPv4Address&quot;: &quot;172.38.0.15/16&quot;,            &#125;,            &quot;85ef9071ac9bbacc25cda715a695819e32fa17945956ae2c744e43b841e27af6&quot;: &#123;                &quot;Name&quot;: &quot;redis-3&quot;,                &quot;IPv4Address&quot;: &quot;172.38.0.13/16&quot;,            &#125;,            &quot;fc37037e7ae9ed007bef0290f3610f3a3cbbde744189a7b3e3a112b9497e7e5a&quot;: &#123;                &quot;Name&quot;: &quot;redis-4&quot;,                &quot;IPv4Address&quot;: &quot;172.38.0.14/16&quot;,            &#125;        &#125;,        # ...</code></pre><p>​        </p><p>5、<strong>创建集群</strong>,(redis默认没有bash,所以用 &#x2F;bin&#x2F;sh)</p><p>（1）进入redis-1容器</p><pre><code>[root@192 ~]# docker exec -it redis-1 /bin/sh /data # lsappendonly.aof  nodes.conf/data # </code></pre><p>​        </p><p>（2） 创建集群</p><pre><code>redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379  --cluster-replicas 1</code></pre><p>​        </p><pre><code>/data # redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379  --cluster-replicas 1&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...Master[0] -&gt; Slots 0 - 5460 # 三主三从Master[1] -&gt; Slots 5461 - 10922Master[2] -&gt; Slots 10923 - 16383Adding replica 172.38.0.15:6379 to 172.38.0.11:6379Adding replica 172.38.0.16:6379 to 172.38.0.12:6379Adding replica 172.38.0.14:6379 to 172.38.0.13:6379M: 7866a044a62217acc264e0780724baebfcbdf9ec 172.38.0.11:6379   slots:[0-5460] (5461 slots) masterM: e2210b65a712c43fce9cb11a40605d4ae6afc61c 172.38.0.12:6379   slots:[5461-10922] (5462 slots) masterM: a2d9d996b447f724860502d4230434d8fbef45bb 172.38.0.13:6379   slots:[10923-16383] (5461 slots) masterS: eaa1f8ba8de966a6fffaed6b43e0226d95caffb9 172.38.0.14:6379   replicates a2d9d996b447f724860502d4230434d8fbef45bbS: 35fcc7906fda3c977cf6fe09ebfd4632c8288449 172.38.0.15:6379   replicates 7866a044a62217acc264e0780724baebfcbdf9ecS: 59c81a95ed20b8964246dee3bfc333e25960275a 172.38.0.16:6379   replicates e2210b65a712c43fce9cb11a40605d4ae6afc61cCan I set the above configuration? (type &#39;yes&#39; to accept): yes&gt;&gt;&gt; Nodes configuration updated&gt;&gt;&gt; Assign a different config epoch to each node&gt;&gt;&gt; Sending CLUSTER MEET messages to join the clusterWaiting for the cluster to join...&gt;&gt;&gt; Performing Cluster Check (using node 172.38.0.11:6379)M: 7866a044a62217acc264e0780724baebfcbdf9ec 172.38.0.11:6379   slots:[0-5460] (5461 slots) master   1 additional replica(s)S: 35fcc7906fda3c977cf6fe09ebfd4632c8288449 172.38.0.15:6379   slots: (0 slots) slave   replicates 7866a044a62217acc264e0780724baebfcbdf9ecM: a2d9d996b447f724860502d4230434d8fbef45bb 172.38.0.13:6379   slots:[10923-16383] (5461 slots) master   1 additional replica(s)S: 59c81a95ed20b8964246dee3bfc333e25960275a 172.38.0.16:6379   slots: (0 slots) slave   replicates e2210b65a712c43fce9cb11a40605d4ae6afc61cM: e2210b65a712c43fce9cb11a40605d4ae6afc61c 172.38.0.12:6379   slots:[5461-10922] (5462 slots) master   1 additional replica(s)S: eaa1f8ba8de966a6fffaed6b43e0226d95caffb9 172.38.0.14:6379   slots: (0 slots) slave   replicates a2d9d996b447f724860502d4230434d8fbef45bb[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered.</code></pre><p>​        </p><h2 id="17-2-测试Redis集群"><a href="#17-2-测试Redis集群" class="headerlink" title="17.2 测试Redis集群"></a>17.2 测试Redis集群</h2><p>Redis三种模式:主从模式, 哨兵模式, <strong>集群模式（推荐）</strong></p><p>1、redis-cli -c 代表进入集群</p><pre><code>/data # redis-cli -c127.0.0.1:6379&gt; </code></pre><p>​        </p><pre><code>127.0.0.1:6379&gt; cluster infocluster_state:ok# ..cluster_known_nodes:6 # 节点：6cluster_size:3 # 集群数量：3# ...</code></pre><p>​        </p><p>2、查看节点信息</p><pre><code># master(主)  slave(从)127.0.0.1:6379&gt; cluster nodes35fcc7906fda3c977cf6fe09ebfd4632c8288449 172.38.0.15:6379@16379 slave 7866a044a62217acc264e0780724baebfcbdf9ec 0 1643970509988 5 connecteda2d9d996b447f724860502d4230434d8fbef45bb 172.38.0.13:6379@16379 master - 0 1643970508952 3 connected 10923-1638359c81a95ed20b8964246dee3bfc333e25960275a 172.38.0.16:6379@16379 slave e2210b65a712c43fce9cb11a40605d4ae6afc61c 0 1643970509257 6 connectede2210b65a712c43fce9cb11a40605d4ae6afc61c 172.38.0.12:6379@16379 master - 0 1643970508000 2 connected 5461-10922eaa1f8ba8de966a6fffaed6b43e0226d95caffb9 172.38.0.14:6379@16379 slave a2d9d996b447f724860502d4230434d8fbef45bb 0 1643970509000 4 connected7866a044a62217acc264e0780724baebfcbdf9ec 172.38.0.11:6379@16379 myself,master - 0 1643970507000 1 connected 0-5460</code></pre><p>​        </p><p>3、高可用测试</p><p>（1）存值（由redis-2处理）</p><pre><code>127.0.0.1:6379&gt; set name zs-&gt; Redirected to slot [5798] located at 172.38.0.12:6379 # 12 =&gt; redis-2OK172.38.0.12:6379&gt; get name&quot;zs&quot;</code></pre><p>​        </p><p>（2）停止redis-2</p><pre><code>[root@192 ~]# docker stop redis-2redis-2</code></pre><p>​        </p><p>（3）依旧可取（此时由redis-6处理，redis-6顶上了）。高可用</p><pre><code>127.0.0.1:6379&gt; get name-&gt; Redirected to slot [5798] located at 172.38.0.16:6379 # 16 =&gt; redis-6&quot;zs&quot;</code></pre><p>​        </p><p>（4）查看节点信息<code>cluster nodes</code></p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406190301633.png" alt="image-20230406190301633"></div><div class="image-meta"><span class="image-caption center">image-20230406190301633</span></div></div><p>我们使用docker之后，所有的技术都会慢慢变得简单起来！</p><h2 id="18、SpringBoot微服务打包Docker镜像"><a href="#18、SpringBoot微服务打包Docker镜像" class="headerlink" title="18、SpringBoot微服务打包Docker镜像"></a>18、SpringBoot微服务打包Docker镜像</h2><h2 id="18-1-构建SpringBoot项目"><a href="#18-1-构建SpringBoot项目" class="headerlink" title="18.1 构建SpringBoot项目"></a>18.1 构建SpringBoot项目</h2><pre><code>package com.example.demo.colltroller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloColltroer &#123;    @RequestMapping(&quot;/hello&quot;)    public String hello()&#123;        return &quot;hello,一个平凡de人&quot;;    &#125;&#125;</code></pre><p>​        </p><ul><li>运行</li></ul><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406190458557.png" alt="image-20230406190458557"></div><div class="image-meta"><span class="image-caption center">image-20230406190458557</span></div></div><h2 id="18-2-打jar包"><a href="#18-2-打jar包" class="headerlink" title="18.2 打jar包"></a>18.2 打jar包</h2><p>1、 双击Maven package打包</p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406190305211.png" alt="image-20230406190305211"></div><div class="image-meta"><span class="image-caption center">image-20230406190305211</span></div></div><p>2、打包成功</p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406190309863.png" alt="image-20230406190309863"></div><div class="image-meta"><span class="image-caption center">image-20230406190309863</span></div></div><p>3、测试jar是否可以运行,访问<a href="http://127.0.0.1:8080/hello">127.0.0.1:8080&#x2F;hello</a>运行成功</p><pre><code>$ java -jar demo1-0.0.1-SNAPSHOT.jar</code></pre><p>​        </p><p>4、idea安装docker插件</p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406190312733.png" alt="image-20230406190312733"></div><div class="image-meta"><span class="image-caption center">image-20230406190312733</span></div></div><h2 id="18-3-上传jar包"><a href="#18-3-上传jar包" class="headerlink" title="18.3 上传jar包"></a>18.3 上传jar包</h2><p>在idea项目根目录创建并编写Dockerfile文件</p><pre><code>FROM java:11COPY *.jar /app.jarCMD [&quot;--server.port=8080&quot;]EXPOSE 8080ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;app.jar&quot;]</code></pre><p>​        </p><p>将jar包和Dockerfile上传到服务器</p><pre><code>[root@192 idea]# pwd/home/idea[root@192 idea]# lsdemo1-0.0.1-SNAPSHOT.jar  Dockerfile</code></pre><p>​        </p><h2 id="18-4-构建镜像"><a href="#18-4-构建镜像" class="headerlink" title="18.4 构建镜像"></a>18.4 构建镜像</h2><p>1、构建镜像</p><pre><code>$ docker build -t springboot .</code></pre><p>​        </p><pre><code>[root@192 idea]# docker build -t springboot .Sending build context to Docker daemon  16.57MBStep 1/5 : FROM java:8# ...Successfully built f107ab2a9246Successfully tagged springboot:latest</code></pre><p>​        </p><p>2、查看镜像</p><pre><code>[root@192 idea]# docker imagesREPOSITORY   TAG                IMAGE ID       CREATED         SIZEspringboot   latest             f107ab2a9246   2 minutes ago   660MB# ...</code></pre><p>​        </p><p>3、运行springboot容器,访问<code>127.0.0.1:8080/hello</code></p><pre><code>docker run -dit -p 8080:8080 --name hello springboot </code></pre><p>​        </p><pre><code>[root@192 idea]# docker run -dit -p 8080:8080 --name hello springboot b8d1f65da8a8b71975b336952af497ba946d801294b1ac42d266da41ba1b6a0c[root@192 idea]# curl 127.0.0.1:8080/hellohello,一个平凡de人</code></pre><p>​        </p><p>4、外网访问<a href="http://192.168.64.131:8080/hello">192.168.64.131:8080&#x2F;hello</a></p><div class="tag-plugin image"><div class="image-bg"><img src="/posts/85fe2496/image-20230406190319237.png" alt="image-20230406190319237"></div><div class="image-meta"><span class="image-caption center">image-20230406190319237</span></div></div><h2 id="18-5-发布"><a href="#18-5-发布" class="headerlink" title="18.5 发布"></a>18.5 发布</h2><p>1、 登录</p><pre><code>$ docker login -u 【你的用户名】 -p 【你的密码】</code></pre><p>​        </p><p>2、打标签</p><pre><code># docker tag 镜像id 你的账户名/镜像仓库名:tag名$ docker tag f107ab2a9246 dockerywl/springboot</code></pre><p>​        </p><p>3、再提交 push镜像</p><pre><code># docker push 作者/镜像:TAG(版本)$ docker push dockerywl/springboot</code></pre><p>​        </p><blockquote><p>总结</p></blockquote><p>以后我们使用了Docker之后，给别人交付就是一个镜像即可！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;学习资料：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1og4y1q7M4&quot;&gt;【狂神说Java】Docker最新超详细版教程通俗易懂_哔哩哔哩_bilibili&lt;/</summary>
      
    
    
    
    <category term="Docker" scheme="http://cvki.cn/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://cvki.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统完整备份及恢复</title>
    <link href="http://cvki.cn/posts/28410c70.html"/>
    <id>http://cvki.cn/posts/28410c70.html</id>
    <published>2023-03-13T08:05:28.000Z</published>
    <updated>2023-08-18T08:21:25.634Z</updated>
    
    <content type="html"><![CDATA[<p>先进入系统根目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /</span><br></pre></td></tr></table></figure><p>临时切换root用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br></pre></td></tr></table></figure><p>备份命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar cvpzf /SystemBackup.tgz --exclude=/proc --exclude=/mnt --exclude=/lost+found --exclude=/sys --exclude=/media --exclude=/run --exclude=/SystemBackup.tgz /</span><br></pre></td></tr></table></figure><p>恢复命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xvpfz SystemBackup.tgz -C /</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;先进入系统根目录：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code</summary>
      
    
    
    
    <category term="Linux" scheme="http://cvki.cn/categories/Linux/"/>
    
    
    <category term="Tips" scheme="http://cvki.cn/tags/Tips/"/>
    
  </entry>
  
  <entry>
    <title>12存储过程和函数</title>
    <link href="http://cvki.cn/posts/1ec33254.html"/>
    <id>http://cvki.cn/posts/1ec33254.html</id>
    <published>2023-02-24T17:02:12.000Z</published>
    <updated>2023-08-18T08:21:25.578Z</updated>
    
    <content type="html"><![CDATA[<h1 id="存储过程基本格式"><a href="#存储过程基本格式" class="headerlink" title="存储过程基本格式"></a>存储过程基本格式</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 名字</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">....</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h2 id="类型1-无参数无返回值"><a href="#类型1-无参数无返回值" class="headerlink" title="类型1 无参数无返回值"></a>类型1 无参数无返回值</h2><p><strong>创建一个 查询employees所有数据的存储函数 selc_all_data();</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 定义<span class="keyword">SQL</span>语句结束符号(部分<span class="keyword">SQL</span>管理工具会以分号结束会导致存储过程在运行至<span class="keyword">END</span>前就结束)</span><br><span class="line">DELIMITER $ # 重新定义<span class="keyword">SQL</span>结束符号 Navicat不支持 故注释</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> selc_all_data()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="keyword">END</span> $ # 存储过程结束</span><br><span class="line"></span><br><span class="line">DELIMITER ; # 存储过程运行完成后 再改回来 Navicat不支持 故注释</span><br></pre></td></tr></table></figure><p><strong>存储过程调用 CALL</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> selc_all_data();</span><br></pre></td></tr></table></figure><h2 id="类型2-有返回值"><a href="#类型2-有返回值" class="headerlink" title="类型2 有返回值"></a>类型2 有返回值</h2><p><strong>创建存储过程show_min_salary，查看“employees”表的最低薪资值。并将最低薪资通过OUT参数“ms”输出</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> show_min_salary ( <span class="keyword">OUT</span> ms <span class="keyword">DOUBLE</span> ) # 用ms输出</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="built_in">MIN</span>( salary ) <span class="keyword">INTO</span> ms # 用<span class="keyword">INTO</span> 将结果赋给ms</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">employees;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p><strong>调用</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> show_min_salary(<span class="variable">@ms</span>);</span><br></pre></td></tr></table></figure><p><strong>查看变量值</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="variable">@ms</span>;</span><br></pre></td></tr></table></figure><h2 id="类型3-带参数"><a href="#类型3-带参数" class="headerlink" title="类型3 带参数"></a>类型3 带参数</h2><p><strong>例：创建存储过程show_someone_salary()，查看”emps”表的某个员工的薪资，并用IN参数lname输入员工姓名。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> show_someone_salary(<span class="keyword">IN</span> lname <span class="type">VARCHAR</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SELECT</span> salary <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> last_name <span class="operator">=</span> lname;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p><strong>调用方式1</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> show_someone_salary(<span class="string">&#x27;Abel&#x27;</span>); # 查询Abel的工资</span><br></pre></td></tr></table></figure><p><strong>调用方式2 等号&#x3D; 或 赋值等号:&#x3D;</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="variable">@lname</span> <span class="operator">=</span> <span class="string">&#x27;Abel&#x27;</span>; # 等号赋值</span><br><span class="line">或</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@lname</span> :<span class="operator">=</span> <span class="string">&#x27;Abel&#x27;</span>; # 赋值等号</span><br><span class="line"><span class="keyword">CALL</span> show_someone_salary(<span class="variable">@lname</span>); # 调用变量</span><br></pre></td></tr></table></figure><h2 id="类型4-带IN-和-OUT"><a href="#类型4-带IN-和-OUT" class="headerlink" title="类型4 带IN 和 OUT"></a>类型4 带IN 和 OUT</h2><p><strong>例：创建存储过程show_someone_sly()，查看employees表的某个员工的薪资，并用IN参数lname输入员工姓名，用0UT参数sly输出员工薪资。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> show_someone_sly(<span class="keyword">IN</span> lname <span class="type">VARCHAR</span>(<span class="number">20</span>),<span class="keyword">OUT</span> sly <span class="keyword">DOUBLE</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SELECT</span> salary <span class="keyword">INTO</span> sly <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> last_name <span class="operator">=</span> lname;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@lname</span> <span class="operator">=</span> <span class="string">&#x27;Abel&#x27;</span>; # 赋值</span><br><span class="line"><span class="keyword">CALL</span> show_someone_sly(<span class="variable">@lname</span>,<span class="variable">@sly</span>); # 调用</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@sly</span>; # 查询</span><br></pre></td></tr></table></figure><h2 id="类型5-带-INOUT"><a href="#类型5-带-INOUT" class="headerlink" title="类型5 带 INOUT"></a>类型5 带 INOUT</h2><p><strong>例：创建存储过程show_mgr_name()，查询某个员工领导的姓名，并用INOUT参数“lname”输入员工姓名，输出领导的姓名。</strong></p><p><strong>方式一 自连接 + IN + OUT</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> show_mgr_name(<span class="keyword">IN</span> lname <span class="type">VARCHAR</span>(<span class="number">25</span>),<span class="keyword">OUT</span> mgr <span class="type">VARCHAR</span>(<span class="number">25</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SELECT</span> mgr.last_name <span class="keyword">INTO</span> mgr <span class="keyword">FROM</span> employees emp <span class="keyword">JOIN</span> employees mgr <span class="keyword">ON</span> mgr.employee_id <span class="operator">=</span> emp.manager_id <span class="keyword">AND</span> emp.last_name <span class="operator">=</span> lname;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><ul><li><p>赋值</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="variable">@lname</span> <span class="operator">=</span> <span class="string">&#x27;Abel&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>调用</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> show_mgr_name(<span class="variable">@lname</span>,<span class="variable">@mgr</span>);</span><br></pre></td></tr></table></figure></li><li><p>查询</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="variable">@mgr</span>;</span><br></pre></td></tr></table></figure></li></ul><p><strong>方式二 INOUT</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span>  show_mgr(<span class="keyword">INOUT</span> lname <span class="type">VARCHAR</span>(<span class="number">25</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SELECT</span> mgr.last_name <span class="keyword">INTO</span> lname <span class="keyword">FROM</span> employees emp <span class="keyword">JOIN</span> employees mgr <span class="keyword">ON</span> mgr.employee_id <span class="operator">=</span> emp.manager_id <span class="keyword">AND</span> emp.last_name <span class="operator">=</span> lname;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><ul><li>赋值</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="variable">@lname</span> <span class="operator">=</span> <span class="string">&#x27;Abel&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>调用</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> show_mgr(<span class="variable">@lname</span>);</span><br></pre></td></tr></table></figure><ul><li>查询结果</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="variable">@lname</span>;</span><br></pre></td></tr></table></figure><h1 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h1><p><strong>例：创建存储函数，名称为email_by_name()，参数定义为空，该函数查询Abel的email，并返回，数据类型为字符串型。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> eml_by_name()</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">25</span>)</span><br><span class="line"><span class="keyword">DETERMINISTIC</span> # 约束</span><br><span class="line"><span class="keyword">CONTAINS</span> <span class="keyword">SQL</span> # 约束</span><br><span class="line"><span class="keyword">READS</span> <span class="keyword">SQL</span> DATA # 约束</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">RETURN</span> (<span class="keyword">SELECT</span> email <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> last_name <span class="operator">=</span> <span class="string">&#x27;Abel&#x27;</span>);</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><ul><li>调用</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> eml_by_name();</span><br></pre></td></tr></table></figure><p><strong>举例2：创建存储函数，名称为email_by_id(), 参数传入em_id，该函数查询emp id的email，并返回，数据类型为字符串型。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#创建函数前执行此语句，保证函数的创建会成功 不用写约束</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> log_bin_trust_function_creators <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> email_by_id(em_id <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">25</span>) # 设置返回类型</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">RETURN</span> (<span class="keyword">SELECT</span> email <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> em_id);</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><ul><li>调用</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> email_by_id(<span class="number">101</span>);</span><br></pre></td></tr></table></figure><ul><li>调用2</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="variable">@emid</span> :<span class="operator">=</span> <span class="number">102</span>; # 赋值</span><br><span class="line"><span class="keyword">SELECT</span> email_by_id(<span class="variable">@emid</span>);</span><br></pre></td></tr></table></figure><p><strong>举例3：创建存储函数count_by_id()，参数传入dept_id，该函数查询dept_id部门的员工人数，并返回，数据类型为整型。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> count_by_id(dept_id <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">INT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">RETURN</span> (<span class="keyword">SELECT</span> <span class="built_in">count</span>(department_id) <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department_id <span class="operator">=</span> dept_id);</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> count_by_id(<span class="number">30</span>);</span><br></pre></td></tr></table></figure><h1 id="对比存储函数和存储过程"><a href="#对比存储函数和存储过程" class="headerlink" title="对比存储函数和存储过程"></a>对比存储函数和存储过程</h1><table><thead><tr><th align="center">对比</th><th align="center">关键字</th><th align="center">调用语法</th><th align="center">返回值</th><th align="center">应用场景</th></tr></thead><tbody><tr><td align="center">存储过程</td><td align="center">PROCEDURE</td><td align="center">CALL 存储过程</td><td align="center">0理解为有0个或多个</td><td align="center">一般用于更新</td></tr><tr><td align="center">存储函数</td><td align="center">FUNCTION</td><td align="center">SELECT 函数()</td><td align="center">只能是一个</td><td align="center">查询结果为一个值并返回时</td></tr></tbody></table><p>此外，<code>存储函数可以放在查询语句中使用，存储过程不行</code>。</p><p>反之，存储过程的功能更加强大，包括能够执行对表的操作（比如创建表，删除表等）和事务操作，这些功能是存储函数不具备的。</p><p><strong>存储过程、存储函数的查看</strong></p><ul><li>使用SHOW CREATE语句查看存储过程和函数的创建信息</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> show_mgr;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> count_by_id;</span><br></pre></td></tr></table></figure><ul><li>使用SHOW STATUS语句查看存储过程和函数的状态信息</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">PROCEDURE</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;show_min_salary&#x27;</span>;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">FUNCTION</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;email_by_id&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>存储过程 &#x2F; 存储函数 删除</strong></p><p><code>DROP FUNCTION / PROCEDURE [IF EXISTS] 存储过程名 / 函数名</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> IF <span class="keyword">EXISTS</span> count_by_id;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> IF <span class="keyword">EXISTS</span> show_mgr;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;存储过程基本格式&quot;&gt;&lt;a href=&quot;#存储过程基本格式&quot; class=&quot;headerlink&quot; title=&quot;存储过程基本格式&quot;&gt;&lt;/a&gt;存储过程基本格式&lt;/h1&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas</summary>
      
    
    
    
    <category term="Language" scheme="http://cvki.cn/categories/Language/"/>
    
    
    <category term="Database" scheme="http://cvki.cn/tags/Database/"/>
    
    <category term="MariaDB" scheme="http://cvki.cn/tags/MariaDB/"/>
    
  </entry>
  
  <entry>
    <title>11视图</title>
    <link href="http://cvki.cn/posts/c336cef3.html"/>
    <id>http://cvki.cn/posts/c336cef3.html</id>
    <published>2023-02-24T06:50:39.000Z</published>
    <updated>2023-08-18T08:21:25.578Z</updated>
    
    <content type="html"><![CDATA[<h1 id="视图的理解"><a href="#视图的理解" class="headerlink" title="视图的理解"></a>视图的理解</h1><ul><li>1 视图，可以看做是一个虚拟表，本身是不存储数据的。</li><li>2 视图的本质，就可以看做是存储起来的SELECT语句</li><li>3 视图中SELECT语句中涉及到的表，称为基表</li><li>4  针对视图做DML操作，会影响到对应的基表中的数据。反之亦然。</li><li>5 视图本身的删除，不会导致基表中数据的删除。</li><li>6 视图的应用场景：<br>针对于小型项目，不推荐使用视图。针对于大型项目，可以考虑使用视图。视图的优点：简化查询：控制数据的访问</li></ul><h1 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h1><p><code>CREATE VIEW 视图名 AS 查询语句</code></p><p><strong>别名作为视图中的字段名</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> vu1 <span class="keyword">AS</span> <span class="keyword">SELECT</span> employee_id <span class="keyword">AS</span> eid,last_name <span class="keyword">AS</span> lname,salary <span class="keyword">AS</span> sly <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> vu1;</span><br></pre></td></tr></table></figure><p><strong>创建视图时设置字段名</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> vu2(eid,lname,sly) <span class="keyword">AS</span> <span class="keyword">SELECT</span> employee_id,last_name,salary <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> vu2;</span><br></pre></td></tr></table></figure><p><strong>查询各部门平均工资 视图</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> vu_avsly(dpid,avsly) <span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> department_id,<span class="built_in">AVG</span>(salary) </span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> vu_avsly;</span><br></pre></td></tr></table></figure><p><strong>利用视图格式化数据 需求：员工姓名(员工部门)</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> vu_eminfo(eminfo) <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> CONCAT(last_name,<span class="string">&#x27; ( &#x27;</span>,department_name,<span class="string">&#x27; ) &#x27;</span>)  # 拼接</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">AS</span> el <span class="keyword">JOIN</span> departments <span class="keyword">AS</span> dp </span><br><span class="line"><span class="keyword">ON</span> el.department_id <span class="operator">=</span> dp.department_id;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> vu_eminfo;</span><br></pre></td></tr></table></figure><p><strong>也可以基于视图再创建视图 不再列举</strong></p><h1 id="查看视图"><a href="#查看视图" class="headerlink" title="查看视图"></a>查看视图</h1><p><strong>语法1：查看数据库的表对象、视图对象 SHOW TABLES;</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br></pre></td></tr></table></figure><p><strong>语法2：查看视图的结构 DESC&#x2F;DESCRIBE 视图名称;</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DESC</span> vu2;</span><br><span class="line"><span class="keyword">DESCRIBE</span> vu2;</span><br></pre></td></tr></table></figure><p><strong>语法3：查看视图的属性信息</strong></p><p>查看视图信息（显示数据表的存储引擎、版本、数据行数和数据大小等）</p><p><code>SHOW TABLE STATUS LIKE&#39;视图名称&#39;\G; </code> 执行结果显示，</p><p>注释Comment为VIEW，说明该表为视图，其他的信息为NULL，说明这是一个虚表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;vu_%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>语法4：查看视图的详细定义信息SHOW CREATE VIEW 视图名称；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> vu2;</span><br></pre></td></tr></table></figure><h1 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h1><ul><li>更新视图中的数据时, 表中的数据也会更新 包括增删改</li><li>更新表中的数据时, 视图中的数据也会更新</li><li>视图中的数据不一定能”更新”成功<br> 比如 根据部门工资算出来的平均工资所创建的视图, 是不能直接更新视图的平均工资的<br> 因为平均工资是算出来的, 是在原表里不存在的 只有一一对应的字段才能更新</li></ul><h1 id="修改视图"><a href="#修改视图" class="headerlink" title="修改视图"></a>修改视图</h1><p><strong>方式一 CREATE OR REPLACE VIEW</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> vu_1; # 查询vu_1视图, 数据<span class="number">107</span>条</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">VIEW</span> vu_1(eid,lname,sly) <span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,salary </span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> employee_id <span class="operator">&lt;</span> <span class="number">110</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> vu_1; # 再次查询vu_1视图, 数据<span class="number">10</span>条</span><br></pre></td></tr></table></figure><p><strong>方式二 ALTER VIEW</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> vu_1(eid,lname,sly) <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,salary </span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> employee_id <span class="operator">&lt;</span> <span class="number">105</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> vu_1; # 再查询 数据<span class="number">5</span>条</span><br></pre></td></tr></table></figure><h1 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h1><p><code>DROP VIEW [IF EXISTS] 视图名</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> IF <span class="keyword">EXISTS</span> vu2;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;视图的理解&quot;&gt;&lt;a href=&quot;#视图的理解&quot; class=&quot;headerlink&quot; title=&quot;视图的理解&quot;&gt;&lt;/a&gt;视图的理解&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;1 视图，可以看做是一个虚拟表，本身是不存储数据的。&lt;/li&gt;
&lt;li&gt;2 视图的本质，就可以看做是存储</summary>
      
    
    
    
    <category term="Language" scheme="http://cvki.cn/categories/Language/"/>
    
    
    <category term="Database" scheme="http://cvki.cn/tags/Database/"/>
    
    <category term="MariaDB" scheme="http://cvki.cn/tags/MariaDB/"/>
    
  </entry>
  
  <entry>
    <title>10约束</title>
    <link href="http://cvki.cn/posts/b420821e.html"/>
    <id>http://cvki.cn/posts/b420821e.html</id>
    <published>2023-02-23T08:38:55.000Z</published>
    <updated>2023-08-18T08:21:25.578Z</updated>
    
    <content type="html"><![CDATA[<h1 id="非空约束-NOT-NULL-只有列级约束"><a href="#非空约束-NOT-NULL-只有列级约束" class="headerlink" title="非空约束 NOT NULL 只有列级约束"></a>非空约束 NOT NULL 只有列级约束</h1><p><strong>建表时 CREATE TABLE</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> nnx(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">last_name <span class="type">VARCHAR</span>(<span class="number">15</span>),</span><br><span class="line">salary <span class="type">INT</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> nnx(last_name,salary) <span class="keyword">VALUES</span>(<span class="string">&#x27;Tom&#x27;</span>,<span class="number">3000</span>); # 报错,因为id有非空约束</span><br></pre></td></tr></table></figure><h2 id="修改表结构时-添加非空约束-ALTER-TABLE"><a href="#修改表结构时-添加非空约束-ALTER-TABLE" class="headerlink" title="修改表结构时 添加非空约束 ALTER TABLE"></a>修改表结构时 添加非空约束 ALTER TABLE</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> nnx MODIFY last_name <span class="type">VARCHAR</span>(<span class="number">15</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> nnx(id,salary) <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="number">3000</span>); # 报错,因为last_name加了非空约束</span><br></pre></td></tr></table></figure><h2 id="修改表结构时-删除非空约束"><a href="#修改表结构时-删除非空约束" class="headerlink" title="修改表结构时 删除非空约束"></a>修改表结构时 删除非空约束</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> nnx MODIFY last_name <span class="type">VARCHAR</span>(<span class="number">15</span>);</span><br></pre></td></tr></table></figure><h1 id="唯一性约束-UNIQUE"><a href="#唯一性约束-UNIQUE" class="headerlink" title="唯一性约束 UNIQUE"></a>唯一性约束 UNIQUE</h1><p><strong>有列级约束和表级约束 可以为NULL 多个NULL可以重复</strong><br><strong>在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同。</strong></p><h2 id="建表时"><a href="#建表时" class="headerlink" title="建表时"></a>建表时</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> nnx1(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">last_name <span class="type">VARCHAR</span>(<span class="number">15</span>),</span><br><span class="line">salary <span class="keyword">DOUBLE</span>(<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> nnx1(id,last_name,salary) <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;冰糖&#x27;</span>,<span class="number">10000</span>),(<span class="number">1</span>,<span class="string">&#x27;冰糖&#x27;</span>,<span class="number">10000</span>); # 报错,id重复</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> nnx2(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">UNIQUE</span>, # 列级约束</span><br><span class="line">last_name <span class="type">VARCHAR</span>(<span class="number">15</span>),</span><br><span class="line">email <span class="type">VARCHAR</span>(<span class="number">15</span>),</span><br><span class="line">tel <span class="type">INT</span>,</span><br><span class="line">salary <span class="keyword">DOUBLE</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line"><span class="keyword">CONSTRAINT</span> uni_e <span class="keyword">UNIQUE</span>(email) # 表级约束</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="ALTER-TABLE时添加"><a href="#ALTER-TABLE时添加" class="headerlink" title="ALTER TABLE时添加"></a>ALTER TABLE时添加</h2><p><strong>方式1 ADD</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> nnx2 <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span>(tel); # 无别名</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> nnx2 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> uni_t <span class="keyword">UNIQUE</span>(tel); # 有别名</span><br></pre></td></tr></table></figure><p><strong>方式二 MODIFY</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> nnx2 MODIFY tel <span class="type">INT</span> <span class="keyword">UNIQUE</span>;</span><br></pre></td></tr></table></figure><h1 id="组合-复合列唯一约束"><a href="#组合-复合列唯一约束" class="headerlink" title="组合&#x2F;复合列唯一约束"></a>组合&#x2F;复合列唯一约束</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> nnx3(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">uname <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">pwd <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line"><span class="keyword">CONSTRAINT</span> uni_uname_pwd  <span class="keyword">UNIQUE</span>(uname,pwd) # 用户名和密码不能同时相同</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> nnx3 <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;abc&#x27;</span>,<span class="string">&#x27;a111&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;cde&#x27;</span>,<span class="string">&#x27;a111&#x27;</span>); # 可以成功</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> nnx3 <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="string">&#x27;abc&#x27;</span>,<span class="string">&#x27;a111&#x27;</span>),(<span class="number">4</span>,<span class="string">&#x27;abc&#x27;</span>,<span class="string">&#x27;a111&#x27;</span>); # 失败,用户名和密码同时相同</span><br></pre></td></tr></table></figure><p><strong>删除唯一性约束 ALTER TABLE 表名 DROP INDEX 索引名</strong></p><ul><li>1  添加唯一性约束的列上 会 自动创建唯一索引。删除唯一约束只能通过删除唯一索引的方式删除。</li><li>2 删除时需要指定唯一索引名，唯一索引名就和唯一约束名一样。</li><li>3 如果创建唯一约束时未指定名称，如果是单列，就默认和列名相同； 如果是组合&#x2F;复合列，那么默认和（）中排在第一个的列名相同。也可以自定义唯一性约束名</li></ul><p><strong>查看表索引 SHOW INDEX FROM 表名</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> nnx3 <span class="keyword">DROP</span> INDEX id;</span><br></pre></td></tr></table></figure><h1 id="主键约束-PRIMARY-KEY"><a href="#主键约束-PRIMARY-KEY" class="headerlink" title="主键约束 PRIMARY KEY"></a>主键约束 PRIMARY KEY</h1><p><strong>一个表只能有一个主键 唯一且非空 所以 主键约束 &#x3D; 唯一约束 + 非空约束</strong><br><code>主键约束的别名总是为PRIMARY 所以无需起别名</code></p><h2 id="CREATE-TABLE时创建"><a href="#CREATE-TABLE时创建" class="headerlink" title="CREATE TABLE时创建"></a>CREATE TABLE时创建</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> nnx1(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY, # 列级约束</span><br><span class="line">uname <span class="type">VARCHAR</span>(<span class="number">15</span>),</span><br><span class="line">salary <span class="type">INT</span>,</span><br><span class="line">email <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> nnx2(</span><br><span class="line">id <span class="type">INT</span>,</span><br><span class="line">uname <span class="type">VARCHAR</span>(<span class="number">15</span>),</span><br><span class="line">salary <span class="type">INT</span>,</span><br><span class="line">email <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY(id) # 表级约束</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="ALTER-TABLE添加主键约束"><a href="#ALTER-TABLE添加主键约束" class="headerlink" title="ALTER TABLE添加主键约束"></a>ALTER TABLE添加主键约束</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> nnx2 <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY(id); # 方式一 <span class="keyword">ADD</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> nnx2 MODIFY id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY; # 方式二 MODIFY</span><br></pre></td></tr></table></figure><h2 id="删除主键-实际开发中不会这样去做"><a href="#删除主键-实际开发中不会这样去做" class="headerlink" title="删除主键(实际开发中不会这样去做)"></a>删除主键(实际开发中不会这样去做)</h2><p><code>ALTER TABLE ... DROP PRIMARY KEY</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> nnx2 <span class="keyword">DROP</span> <span class="keyword">PRIMARY</span> KEY;</span><br></pre></td></tr></table></figure><h1 id="主键自增长-AUTO-INCREMENT"><a href="#主键自增长-AUTO-INCREMENT" class="headerlink" title="主键自增长 AUTO_INCREMENT"></a>主键自增长 AUTO_INCREMENT</h1><h2 id="CREATE-TABLE-时"><a href="#CREATE-TABLE-时" class="headerlink" title="CREATE TABLE 时"></a>CREATE TABLE 时</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> nnx(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">uname <span class="type">VARCHAR</span>(<span class="number">15</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> nnx(uname)  <span class="keyword">VALUES</span> (<span class="string">&#x27;aaa&#x27;</span>),(<span class="string">&#x27;bbb&#x27;</span>); # 即使id未写也不会报错, 因为id有自增长</span><br></pre></td></tr></table></figure><h2 id="ALTER-TABLE-时增加"><a href="#ALTER-TABLE-时增加" class="headerlink" title="ALTER TABLE 时增加"></a>ALTER TABLE 时增加</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> nnx MODIFY id <span class="type">INT</span> AUTO_INCREMENT;</span><br></pre></td></tr></table></figure><h2 id="ALTER-TABLE-时删除"><a href="#ALTER-TABLE-时删除" class="headerlink" title="ALTER TABLE 时删除"></a>ALTER TABLE 时删除</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> nnx MODIFY id <span class="type">INT</span>;</span><br></pre></td></tr></table></figure><h2 id="MySQL5-7-MySQL8-0"><a href="#MySQL5-7-MySQL8-0" class="headerlink" title="MySQL5.7 &amp; MySQL8.0"></a>MySQL5.7 &amp; MySQL8.0</h2><p>** 在5.7中 删除某个自增长的值后重新插入的值会接着自增**</p><ul><li>例如, 1,2,3,4 删掉4后重新新增 下一个也为5 但是, 若是删除4后重启MySQL服务 则新增的也会4 因为MySQL5.7的记录是记录在内存里的</li></ul><p><strong>在MySQL8.0中 删除某个自增长的值后重新插入的值会接着自增</strong></p><ul><li>例如, 1,2,3,4 删掉4后重新新增 下一个也为5</li><li>但不同5.7的是 即使删除4后重启MySQL服务 下一个增加的也为5 因为MySQL8.0新特性 自增持久化 记录在了<code>重做日志</code>中</li></ul><h1 id="外键约束-FOREIGN-KEY"><a href="#外键约束-FOREIGN-KEY" class="headerlink" title="外键约束 FOREIGN KEY"></a>外键约束 FOREIGN KEY</h1><p><strong>主表和从表&#x2F;父表和子表主表（父表）：被引用的表，被参考的表</strong><br><strong>从表（子表）：引用别人的表，参考别人的表</strong></p><ul><li>例如：员工表的员工所在部门这个字段的值要参考部门表：部门表是主表，员工表是从表。</li><li>例如：学生表、课程表、选课表：选课表的学生和课程要分别参考学生表和课程表， 学生表和课程表是主表，选课表是从表。</li></ul><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>(1）从表的外键列，必须引用&#x2F;参考主表的键主键或唯一约束的列 为什么？因为被依赖&#x2F;被参考的值必须是唯一的</li><li>(2）在创建外键约束时，如果不给外键约束命名，<code>默认名不是列名，而是自动产生一个外键名</code>（例如student_.ibfk_1），也可以指定外键约束名。</li><li>(3）创建（CREATE）表时就指定外键约束的话，先创建主表，再创建从表</li><li>(4）删表时，先删从表（或先除外键约束），再删除主表</li><li>(5）当主表的记录被从表参照时，主表的记录将不允许删除，如果要删除数据，需要先删除从表中依赖该记录的数据，然后才可以删除主表的数据</li><li>(6）在“从表”中指定外键约束，并且一个表可以建立多个外键约束</li><li>(7）从表的外键列与主表被参照的列名字可以不相同，但是数据类型必须一样，逻辑意义一致。如果类型不一样会出错</li><li>(8）<code>当创建外键约束时，系统默认会在所在的列上建立对应的普通索引。</code>但是索引名是列名，不是外键的约束名。（根据外键查询效率很高）</li><li>(9）删除外键约束后，必须手动删除对应的索引</li></ul><h2 id="CREATE-TABLE-时添加外键"><a href="#CREATE-TABLE-时添加外键" class="headerlink" title="CREATE TABLE 时添加外键"></a>CREATE TABLE 时添加外键</h2><ul><li><p>先创建主表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> nnx (</span><br><span class="line">dept_id <span class="type">int</span>,</span><br><span class="line">dept_name <span class="type">VARCHAR</span>(<span class="number">15</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>ALTER TABLE 添加主键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> nnx <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY (dept_id);</span><br></pre></td></tr></table></figure></li><li><p>再创建从表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> nnx1 (</span><br><span class="line">emp_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">emp_name <span class="type">VARCHAR</span>(<span class="number">15</span>),</span><br><span class="line">department_id <span class="type">INT</span>,</span><br><span class="line"># 表级约束</span><br><span class="line"><span class="keyword">CONSTRAINT</span> fk_dept <span class="keyword">FOREIGN</span> KEY (department_id) <span class="keyword">REFERENCES</span> nnx(dept_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p></li><li><p>1 新增失败：做了外键约束后 在主表nnx内没有添加 部门ID(dept_id)时,无法在从表的department_id内插入数据 如果主表有一个部门为id为10,则可以往从表添加 department_id为10的数据</p></li><li><p>2 删除失败：当主表和从表有部门id为10, 则无法直接从主表中删除部门ID 10, 因为主表的部门id 10被从表所依赖</p></li><li><p>3 修改失败： 同理, 主表没有某某部门时, 从表也无法修改表内的部门ID为主表之外的ID</p></li></ul><h2 id="ALTER-TABLE时添加外键"><a href="#ALTER-TABLE时添加外键" class="headerlink" title="ALTER TABLE时添加外键"></a>ALTER TABLE时添加外键</h2><ul><li><p>先创建主表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> nnx (</span><br><span class="line">dept_id <span class="type">int</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">dept_name <span class="type">VARCHAR</span>(<span class="number">15</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>再创建从表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> nnx1 (</span><br><span class="line">emp_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">emp_name <span class="type">VARCHAR</span>(<span class="number">15</span>),</span><br><span class="line">department_id <span class="type">INT</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>添加外键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> nnx1 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_dept <span class="keyword">FOREIGN</span> KEY (department_id) <span class="keyword">REFERENCES</span> nnx(dept_id);</span><br></pre></td></tr></table></figure></li></ul><h1 id="约束等级"><a href="#约束等级" class="headerlink" title="约束等级"></a>约束等级</h1><ul><li>1 Cascade方式：在父表上update&#x2F;delete记录时，同步update&#x2F;delete掉子表的匹配记录</li><li>2 SET NULL方式：在父表上update&#x2F;delete记录时，将子表上匹配记录的列设为null，但是要注意子表的外键列不能为NOTNULL</li><li>3 No action方式：如果子表中有匹配的记录，则不允许对父表对应候选键进行update&#x2F;delete操作</li><li>4 Restrict方式：同no action，都是立即检查外键约束</li><li>5 Set defau1t方式（在可视化工具SQLyog中可能显示空白）：父表有变更时，子表将外键列设置成一个默认的值，但Innodb不能识别 如果没有指定等级，就相当于Restrict方式<br><code>对于外键约束，最好是采用：ON UPDATE CASCADE ON DELETE RESTRICT的方式。</code></li></ul><h2 id="演示："><a href="#演示：" class="headerlink" title="演示："></a>演示：</h2><ul><li><p>建立主表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> nnx (</span><br><span class="line">id <span class="type">INT</span>,</span><br><span class="line">departmen_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY ,</span><br><span class="line">uname <span class="type">VARCHAR</span>(<span class="number">15</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>建立从表 设置约束等级 ON UPDATE CASCADE ON DELETE RESTRICT</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> nnx1 (</span><br><span class="line">dept_id <span class="type">INT</span>,</span><br><span class="line">job_id <span class="type">INT</span>,</span><br><span class="line"><span class="keyword">FOREIGN</span> KEY (dept_id) <span class="keyword">REFERENCES</span> nnx (departmen_id) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE <span class="keyword">ON</span> <span class="keyword">DELETE</span> RESTRICT</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><h1 id="检查约束-CHECK约束"><a href="#检查约束-CHECK约束" class="headerlink" title="检查约束 CHECK约束"></a>检查约束 CHECK约束</h1><p><strong>检查是否满足XX条件(MySQL5.7不支持)</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> nnx(</span><br><span class="line">id <span class="type">INT</span>,</span><br><span class="line">uname <span class="type">VARCHAR</span>(<span class="number">15</span>),</span><br><span class="line">salary <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">CHECK</span>(salary <span class="operator">&gt;</span> <span class="number">2000</span>) # 工资大于<span class="number">2000</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> nnx(id,uname,salary) <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;冰糖&#x27;</span>,<span class="number">2500</span>); # 添加成功</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> nnx(id,uname,salary) <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="string">&#x27;nnx&#x27;</span>,<span class="number">1500</span>); # 添加失败</span><br></pre></td></tr></table></figure><h1 id="默认值约束-DEFAULT约束"><a href="#默认值约束-DEFAULT约束" class="headerlink" title="默认值约束 DEFAULT约束"></a>默认值约束 DEFAULT约束</h1><h2 id="CREATE-TABLE-时添加"><a href="#CREATE-TABLE-时添加" class="headerlink" title="CREATE TABLE 时添加"></a>CREATE TABLE 时添加</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> nnx(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY auto_increment,</span><br><span class="line">uname <span class="type">VARCHAR</span>(<span class="number">15</span>),</span><br><span class="line">salary <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="number">2000</span> # 工资默认<span class="number">2000</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> nnx(uname) <span class="keyword">VALUES</span> (<span class="string">&#x27;冰糖&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> nnx; # 添加成功 <span class="number">1</span>,冰糖,<span class="number">2000.00</span></span><br></pre></td></tr></table></figure><h2 id="ALTER-TABLE-时添加"><a href="#ALTER-TABLE-时添加" class="headerlink" title="ALTER TABLE 时添加"></a>ALTER TABLE 时添加</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> nnx1(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY auto_increment,</span><br><span class="line">uname <span class="type">VARCHAR</span>(<span class="number">15</span>),</span><br><span class="line">salary <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> nnx1 MODIFY salary <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="number">2000</span>; # 添加</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> nnx1 MODIFY salary; <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>); # 删除</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;非空约束-NOT-NULL-只有列级约束&quot;&gt;&lt;a href=&quot;#非空约束-NOT-NULL-只有列级约束&quot; class=&quot;headerlink&quot; title=&quot;非空约束 NOT NULL 只有列级约束&quot;&gt;&lt;/a&gt;非空约束 NOT NULL 只有列级约束&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="Language" scheme="http://cvki.cn/categories/Language/"/>
    
    
    <category term="Database" scheme="http://cvki.cn/tags/Database/"/>
    
    <category term="MariaDB" scheme="http://cvki.cn/tags/MariaDB/"/>
    
  </entry>
  
  <entry>
    <title>09字符集&amp;0填充&amp;无符号类型</title>
    <link href="http://cvki.cn/posts/22fc367a.html"/>
    <id>http://cvki.cn/posts/22fc367a.html</id>
    <published>2023-02-20T04:12:56.000Z</published>
    <updated>2023-08-18T08:21:25.578Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设置字符集-CHARACTER-SET-‘name’"><a href="#设置字符集-CHARACTER-SET-‘name’" class="headerlink" title="设置字符集 CHARACTER SET ‘name’"></a>设置字符集 CHARACTER SET ‘name’</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE test01 <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="string">&#x27;utf8mb4&#x27;</span>; # 给数据库设置</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE test01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> nnx5(id <span class="type">int</span>,last_name <span class="type">varchar</span>(<span class="number">20</span>)) <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="string">&#x27;utf8mb4&#x27;</span>; # 给数据表设置</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">table</span> nnx5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> nnx6(</span><br><span class="line">id <span class="type">int</span>,</span><br><span class="line">last_name <span class="type">varchar</span>(<span class="number">20</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="string">&#x27;utf8mb4&#x27;</span> # 给数据表某字段单独设置</span><br><span class="line">); </span><br></pre></td></tr></table></figure><h1 id="ZEROFILL-0填充"><a href="#ZEROFILL-0填充" class="headerlink" title="ZEROFILL 0填充"></a>ZEROFILL 0填充</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> nnx7(</span><br><span class="line">f1 <span class="type">INT</span>,</span><br><span class="line">f2 <span class="type">INT</span> ZEROFILL</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> nnx7(f1,f2) <span class="keyword">VALUES</span>(<span class="number">123</span>,<span class="number">123</span>),(<span class="number">456</span>,<span class="number">456</span>); </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> nnx7; # f1为<span class="number">123</span>和<span class="number">456</span> f2为<span class="number">0000000123</span>和<span class="number">0000000456</span></span><br></pre></td></tr></table></figure><h1 id="UNSIGNED：无符号类型（非负）"><a href="#UNSIGNED：无符号类型（非负）" class="headerlink" title="UNSIGNED：无符号类型（非负）"></a>UNSIGNED：无符号类型（非负）</h1><p><strong>所有的整数类型都有一个可选的属性UNSIGNED（无符号属性）无符号整数类型的最小取值为0.</strong><br><strong>所以，如果需要在MySQL数据库中保存非负整数值时，可以将整数类型设置为无符号类型。</strong><br><strong>int类型默认显示宽度为int（11），无符号int类型默认显示宽度为int（10）。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> nnx8(</span><br><span class="line">f1 <span class="type">INT</span> UNSIGNED</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设置字符集-CHARACTER-SET-‘name’&quot;&gt;&lt;a href=&quot;#设置字符集-CHARACTER-SET-‘name’&quot; class=&quot;headerlink&quot; title=&quot;设置字符集 CHARACTER SET ‘name’&quot;&gt;&lt;/a&gt;设置字符集 CH</summary>
      
    
    
    
    <category term="Language" scheme="http://cvki.cn/categories/Language/"/>
    
    
    <category term="Database" scheme="http://cvki.cn/tags/Database/"/>
    
    <category term="MariaDB" scheme="http://cvki.cn/tags/MariaDB/"/>
    
  </entry>
  
  <entry>
    <title>08增删改</title>
    <link href="http://cvki.cn/posts/9f7c914b.html"/>
    <id>http://cvki.cn/posts/9f7c914b.html</id>
    <published>2023-02-15T10:47:31.000Z</published>
    <updated>2023-08-18T08:21:25.578Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h1><p><strong>方式一 直接创建</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> nnx(</span><br><span class="line">id <span class="type">int</span>,</span><br><span class="line">last_name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">pro <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">birth <span class="type">DATE</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>方式二 基于现有表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> copy_table <span class="keyword">AS</span> <span class="keyword">SELECT</span> last_name,salary <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><h1 id="修改表-ALTER-TABLE"><a href="#修改表-ALTER-TABLE" class="headerlink" title="修改表 ALTER TABLE"></a>修改表 ALTER TABLE</h1><h2 id="ADD-增加字段"><a href="#ADD-增加字段" class="headerlink" title="ADD 增加字段"></a>ADD 增加字段</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> nnx <span class="keyword">ADD</span> salary <span class="keyword">DOUBLE</span> (<span class="number">10</span>,<span class="number">2</span>); # 默认添加至表最后一个字段</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> nnx <span class="keyword">ADD</span> phone_number <span class="type">VARCHAR</span>(<span class="number">15</span>) <span class="keyword">FIRST</span>; # 用<span class="keyword">FIRST</span> 将字段添加至开头</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> nnx <span class="keyword">ADD</span> address <span class="type">VARCHAR</span>(<span class="number">15</span>) AFTER phone_number; # 用AFTER 将字段放至某某字段之后 控制位置</span><br></pre></td></tr></table></figure><h2 id="MODIFY-修改某字段数据长度-类型-默认值"><a href="#MODIFY-修改某字段数据长度-类型-默认值" class="headerlink" title="MODIFY 修改某字段数据长度,类型,默认值"></a>MODIFY 修改某字段数据长度,类型,默认值</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> nnx MODIFY phone_number <span class="type">VARCHAR</span>(<span class="number">25</span>) <span class="keyword">DEFAULT</span>(<span class="number">15687654321</span>);</span><br></pre></td></tr></table></figure><h2 id="CHANGE-重命名字段"><a href="#CHANGE-重命名字段" class="headerlink" title="CHANGE 重命名字段"></a>CHANGE 重命名字段</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> nnx CHANGE last_name lst_name <span class="type">VARCHAR</span> (<span class="number">15</span>);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> nnx CHANGE salary month_salary <span class="type">VARCHAR</span> (<span class="number">20</span>);</span><br></pre></td></tr></table></figure><h2 id="DROP-删除字段"><a href="#DROP-删除字段" class="headerlink" title="DROP 删除字段"></a>DROP 删除字段</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> nnx <span class="keyword">DROP</span> address;</span><br><span class="line"><span class="keyword">DESC</span> nnx;</span><br></pre></td></tr></table></figure><h1 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h1><p><code>RENAME TABLE A TO B</code></p><p><strong>方式一 推荐</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RENAME <span class="keyword">TABLE</span> nnx1 <span class="keyword">TO</span> nnx;</span><br></pre></td></tr></table></figure><p><strong>方式二</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> nnx RENAME <span class="keyword">TO</span> nnx1;</span><br></pre></td></tr></table></figure><h1 id="删除表-DROP"><a href="#删除表-DROP" class="headerlink" title="删除表 DROP"></a>删除表 DROP</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> nnx1;</span><br></pre></td></tr></table></figure><h1 id="清空表"><a href="#清空表" class="headerlink" title="清空表"></a>清空表</h1><h2 id="DDL-定义表-结构-和-DML-管理表数据-说明"><a href="#DDL-定义表-结构-和-DML-管理表数据-说明" class="headerlink" title="DDL 定义表(结构) 和 DML(管理表数据) 说明"></a>DDL 定义表(结构) 和 DML(管理表数据) 说明</h2><p>1.DDL的操作一旦执行，就不可回滚。<br>2.DML的操作默认情况，一旦执行，也是不可回滚的<br>但是，如果在执行DML之前，执行了SET AUTOCOMMIT &#x3D; FALSE，则执行的DML操作就可以实现回滚。</p><h2 id="COMMIT-和-ROLLBACK"><a href="#COMMIT-和-ROLLBACK" class="headerlink" title="COMMIT 和 ROLLBACK"></a>COMMIT 和 ROLLBACK</h2><p><code>COMMIT 提交数据, 数据永久保存在数据库中 不可回滚</code></p><p><code>ROLLBACK 回滚数据 回滚至最近的一次COMMIT之后</code><br><strong>演示</strong><br><strong>DELETE FROM 数据可以回滚</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> nnx1 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">100</span>; # 清空指定行</span><br><span class="line"><span class="keyword">ROLLBACK</span>; # 回滚</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> nnx1; # id <span class="number">100</span>回滚失败</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> AUTOCOMMIT <span class="operator">=</span> <span class="literal">FALSE</span>; # 关闭自动提交</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> nnx1 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">101</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> nnx1; # id <span class="number">101</span>被删除</span><br><span class="line"><span class="keyword">ROLLBACK</span>; # 回滚</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> nnx1; # id <span class="number">101</span>回滚成功</span><br><span class="line"></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> nnx1; # 清空所有</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> nnx1; # 回滚成功</span><br></pre></td></tr></table></figure><h2 id="TRUNCATE-TABLE-数据不可回滚"><a href="#TRUNCATE-TABLE-数据不可回滚" class="headerlink" title="TRUNCATE TABLE 数据不可回滚"></a>TRUNCATE TABLE 数据不可回滚</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> nnx1;</span><br></pre></td></tr></table></figure><h1 id="数据新增"><a href="#数据新增" class="headerlink" title="数据新增"></a>数据新增</h1><p><code>INSERT INTO 表名(字段1,字段2) VALUES(值1,值2)</code></p><p><strong>方式1 手动添加</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> nnx <span class="keyword">VALUES</span>(<span class="number">15687654399</span>,<span class="number">1</span>,<span class="string">&#x27;NotNoneX&#x27;</span>,<span class="string">&#x27;哈哈&#x27;</span>,<span class="string">&#x27;1995-11-11&#x27;</span>,<span class="number">9999</span>); # 不指明字段</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> nnx(id,last_name,month_salary) <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="string">&#x27;冰糖2&#x27;</span>,<span class="number">12002</span>),(<span class="number">3</span>,<span class="string">&#x27;冰糖3&#x27;</span>,<span class="number">12003</span>); # 指明字段</span><br></pre></td></tr></table></figure><p><strong>方式2 查询结果添加</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> nnx(id,last_name,month_salary) </span><br><span class="line"> <span class="keyword">SELECT</span> employee_id,last_name,salary <span class="keyword">FROM</span> employees LIMIT <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h1 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h1><p><code>UPDATE 表名 SET 字段名 WHERE 条件</code><br><strong>千万别忘了WHERE 否则为批量修改所有</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> nnx <span class="keyword">SET</span> birth <span class="operator">=</span> <span class="built_in">CURRENT_DATE</span>,month_salary <span class="operator">=</span> <span class="number">8000</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">3</span>; # 修改id为<span class="number">3</span>的生日为当前日期,工资为<span class="number">8</span>K</span><br></pre></td></tr></table></figure><p><strong>题目 名字以N开头的工资 提高2000元</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> nnx <span class="keyword">SET</span> salary <span class="operator">=</span> salary <span class="operator">+</span> <span class="number">2000</span> <span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;N%&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> nnx;</span><br><span class="line"><span class="keyword">DESC</span> nnx;</span><br></pre></td></tr></table></figure><h1 id="MySQL8-新特性-计算列"><a href="#MySQL8-新特性-计算列" class="headerlink" title="MySQL8 新特性 计算列"></a>MySQL8 新特性 计算列</h1><p><strong>c列的值始终为a列和b列之和</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> nnx4 (</span><br><span class="line">a <span class="type">int</span>,</span><br><span class="line">b <span class="type">int</span>,</span><br><span class="line">c <span class="type">int</span> GENERATED ALWAYS <span class="keyword">AS</span> (a <span class="operator">+</span> b) VIRTUAL</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> nnx4(a,b) <span class="keyword">VALUES</span>(<span class="number">10</span>,<span class="number">20</span>); # 往a和b列添加数据</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> nnx4; # 查询得到a,b,c 分别为<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;创建表&quot;&gt;&lt;a href=&quot;#创建表&quot; class=&quot;headerlink&quot; title=&quot;创建表&quot;&gt;&lt;/a&gt;创建表&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;方式一 直接创建&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table</summary>
      
    
    
    
    <category term="Language" scheme="http://cvki.cn/categories/Language/"/>
    
    
    <category term="Database" scheme="http://cvki.cn/tags/Database/"/>
    
    <category term="MariaDB" scheme="http://cvki.cn/tags/MariaDB/"/>
    
  </entry>
  
  <entry>
    <title>07子查询</title>
    <link href="http://cvki.cn/posts/38ab61e7.html"/>
    <id>http://cvki.cn/posts/38ab61e7.html</id>
    <published>2023-02-13T13:47:50.000Z</published>
    <updated>2023-08-18T08:21:25.574Z</updated>
    
    <content type="html"><![CDATA[<p>2023年2月13日21:47:50</p><h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><p><strong>查询工资比Abel高的人的信息</strong><br><strong>方式一</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> salary <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> last_name <span class="operator">=</span> &quot;Abel&quot;; # 查询Abel的工资 结果<span class="number">11000</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="number">11000</span>; # 查询工资大于<span class="number">11000</span>的人</span><br></pre></td></tr></table></figure><p><strong>方式二 自连接</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e2.last_name,e2.salary <span class="keyword">FROM</span> employees e1,employees e2 <span class="keyword">WHERE</span> e1.last_name <span class="operator">=</span> &quot;Abel&quot; <span class="keyword">AND</span> e2.salary <span class="operator">&gt;</span> e1.salary;</span><br></pre></td></tr></table></figure><p><strong>方式三 子查询</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,salary <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> salary <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> last_name <span class="operator">=</span> &quot;Abel&quot;);</span><br></pre></td></tr></table></figure><h1 id="子查询分类"><a href="#子查询分类" class="headerlink" title="子查询分类"></a>子查询分类</h1><p><strong>角度一：从内查询返回的结果条目分类</strong></p><p><code>单行子查询</code>  \  <code>多行子查询</code></p><h2 id="单行子查询"><a href="#单行子查询" class="headerlink" title="单行子查询"></a>单行子查询</h2><p><strong>题目：查询与141号员工的manager_id和department_id相同的其他员工的employee_id,manager_id,department_id</strong></p><p>方式一</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,manager_id,department_id <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> manager_id <span class="operator">=</span> (<span class="keyword">SELECT</span> manager_id <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> <span class="number">141</span>) <span class="keyword">AND</span> department_id <span class="operator">=</span> (<span class="keyword">SELECT</span> department_id <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> <span class="number">141</span>) <span class="keyword">AND</span> employee_id <span class="operator">&lt;&gt;</span> <span class="number">141</span>;</span><br></pre></td></tr></table></figure><p>方式二</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,manager_id,department_id <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> (manager_id,department_id) <span class="operator">=</span> (<span class="keyword">SELECT</span> manager_id,department_id <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> <span class="number">141</span>) <span class="keyword">AND</span> employee_id <span class="operator">!=</span> <span class="number">141</span>;</span><br></pre></td></tr></table></figure><p><strong>HAVING查询题目：查询最低工资大于50号部门最低工资的部门id和其最低工资</strong><br><code>逻辑：先查询每个部门的最低工资(分组 再查部门最低) 然后过滤 最低工资 &gt; 50号部门最低工资</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(salary) <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">50</span>; # <span class="number">2100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> department_id,<span class="built_in">MIN</span>(salary) <span class="keyword">FROM</span> employees <span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id <span class="keyword">HAVING</span> <span class="built_in">MIN</span>(salary) <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">MIN</span>(salary) <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">50</span>);</span><br></pre></td></tr></table></figure><p><strong>题目：显示员工的employee_id,last_name和location。<br>其中，若员工department_id与location_id为l800的department_id相同，则location为’Canada’，其余则为’USA’。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id <span class="keyword">FROM</span> departments <span class="keyword">WHERE</span> location_id <span class="operator">=</span> <span class="number">1800</span>; # 位置id为<span class="number">1800</span>的部门id 结果<span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,<span class="keyword">CASE</span> department_id</span><br><span class="line"><span class="keyword">WHEN</span> (<span class="keyword">SELECT</span> department_id <span class="keyword">FROM</span> departments <span class="keyword">WHERE</span> location_id <span class="operator">=</span> <span class="number">1800</span>) <span class="keyword">THEN</span></span><br><span class="line"><span class="string">&#x27;Canada&#x27;</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line"><span class="string">&#x27;USA&#x27;</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">AS</span> location</span><br><span class="line"> <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><div class="tag-plugin image"><div class="image-bg"><img src="/posts/38ab61e7/image-20230213224536311.png" alt="image-20230213224536311"></div><div class="image-meta"><span class="image-caption center">image-20230213224536311</span></div></div><h2 id="多行子查询"><a href="#多行子查询" class="headerlink" title="多行子查询"></a>多行子查询</h2><p><strong>IN ANY ALL SOME(ADY的别名 等同于ANY)</strong><br><code>题目：查询平均工资最低的部门id</code><br>方式一  逻辑 先查出每个部门的平均工资, 再查出最小平均工资(将上一步的平均工资做为一张表使用 必须起别名) 最后查哪个部门的平均工资等于该部门50</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id,<span class="built_in">AVG</span>(salary) AVS <span class="keyword">FROM</span> employees <span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id; # 每个部门的平均工资</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(AVS) <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> department_id,<span class="built_in">AVG</span>(salary) AVS <span class="keyword">FROM</span> employees <span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id) <span class="keyword">AS</span> tem; # 最小的平均工资 看做一张表 必须有别名</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> department_id,<span class="built_in">AVG</span>(salary) <span class="keyword">FROM</span> employees <span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id <span class="keyword">HAVING</span> <span class="built_in">AVG</span>(salary) <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">MIN</span>(AVS) <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> department_id,<span class="built_in">AVG</span>(salary) AVS <span class="keyword">FROM</span> employees <span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id) <span class="keyword">AS</span> tem); </span><br></pre></td></tr></table></figure><div class="tag-plugin image"><div class="image-bg"><img src="/posts/38ab61e7/image-20230215153911821.png" alt="1"></div><div class="image-meta"><span class="image-caption center">1</span></div></div><div class="tag-plugin image"><div class="image-bg"><img src="/posts/38ab61e7/image-20230215154005090.png" alt="2"></div><div class="image-meta"><span class="image-caption center">2</span></div></div><div class="tag-plugin image"><div class="image-bg"><img src="/posts/38ab61e7/image-20230215154032683.png" alt="3"></div><div class="image-meta"><span class="image-caption center">3</span></div></div><p>方式二 ALL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">FROM</span> employees <span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id; # 查出所有平均工资</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> department_id,<span class="built_in">AVG</span>(salary) <span class="keyword">FROM</span> employees <span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id <span class="keyword">HAVING</span> <span class="built_in">AVG</span>(salary) <span class="operator">&lt;=</span> <span class="keyword">ALL</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">FROM</span> employees <span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id); # 查出 平均工资 <span class="operator">&lt;=</span> 所有的平均工资 的部门以及该部门的平均工资</span><br></pre></td></tr></table></figure><div class="tag-plugin image"><div class="image-bg"><img src="/posts/38ab61e7/image-20230215154105227.png" alt="1"></div><div class="image-meta"><span class="image-caption center">1</span></div></div><div class="tag-plugin image"><div class="image-bg"><img src="/posts/38ab61e7/image-20230215154128372.png" alt="2"></div><div class="image-meta"><span class="image-caption center">2</span></div></div><p><strong>角度二：内查询是否被执行多次</strong></p><p><code>相关子查询</code>  \ <code>不相关子查询</code></p><h2 id="相关子查询"><a href="#相关子查询" class="headerlink" title="相关子查询"></a>相关子查询</h2><p><strong>查询员工中工资大于本部门平均工资的员工的1ast_name,salary和其department_id</strong><br><code>方式一</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id,<span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> AVGS <span class="keyword">FROM</span> employees <span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id; # 每个部门的平均工资</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> e1.last_name,e1.salary,e1.department_id <span class="keyword">FROM</span> employees <span class="keyword">AS</span> e1,(<span class="keyword">SELECT</span> department_id,<span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> AVGS <span class="keyword">FROM</span> employees <span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id) <span class="keyword">AS</span> tem  <span class="keyword">WHERE</span> e1.salary <span class="operator">&gt;</span> AVGS <span class="keyword">AND</span> e1.department_id <span class="operator">=</span> tem.department_id;</span><br></pre></td></tr></table></figure><p><code>方式二推荐 相关子查询 内查询的department_id 等于 内查询的department_id 所以给外查询加别名</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,salary,department_id <span class="keyword">FROM</span> employees <span class="keyword">AS</span> e1 <span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">FROM</span> employees <span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id <span class="keyword">HAVING</span> department_id <span class="operator">=</span> e1.department_id);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2023年2月13日21:47:50&lt;/p&gt;
&lt;h1 id=&quot;子查询&quot;&gt;&lt;a href=&quot;#子查询&quot; class=&quot;headerlink&quot; title=&quot;子查询&quot;&gt;&lt;/a&gt;子查询&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;查询工资比Abel高的人的信息&lt;/strong&gt;&lt;br&gt;&lt;str</summary>
      
    
    
    
    <category term="Language" scheme="http://cvki.cn/categories/Language/"/>
    
    
    <category term="Database" scheme="http://cvki.cn/tags/Database/"/>
    
    <category term="MariaDB" scheme="http://cvki.cn/tags/MariaDB/"/>
    
  </entry>
  
  <entry>
    <title>06聚合函数</title>
    <link href="http://cvki.cn/posts/d7394d1d.html"/>
    <id>http://cvki.cn/posts/d7394d1d.html</id>
    <published>2023-02-11T10:31:56.000Z</published>
    <updated>2023-08-18T08:21:25.574Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用聚合函数"><a href="#常用聚合函数" class="headerlink" title="常用聚合函数"></a>常用聚合函数</h1><h2 id="AVG-平均数-SUM-求和函数"><a href="#AVG-平均数-SUM-求和函数" class="headerlink" title="AVG() 平均数 \ SUM() 求和函数"></a>AVG() 平均数 \ SUM() 求和函数</h2><p><strong>仅适用于数值类型</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> &quot;平均工资&quot;,<span class="built_in">SUM</span>(salary) <span class="keyword">AS</span> <span class="string">&#x27;公司总工资&#x27;</span> <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><div class="tag-plugin image"><div class="image-bg"><img src="/posts/d7394d1d/image-20230211170839746.png" alt="image-20230211170839746"></div><div class="image-meta"><span class="image-caption center">image-20230211170839746</span></div></div><h2 id="MAX-最大值-MIN-最小值"><a href="#MAX-最大值-MIN-最小值" class="headerlink" title="MAX() 最大值 \ MIN() 最小值"></a>MAX() 最大值 \ MIN() 最小值</h2><p><strong>适用与数值 字符串 日期类型的字段或变量</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary),<span class="built_in">MIN</span>(salary) <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><div class="tag-plugin image"><div class="image-bg"><img src="/posts/d7394d1d/image-20230211171107109.png" alt="image-20230211171107109"></div><div class="image-meta"><span class="image-caption center">image-20230211171107109</span></div></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(last_name),<span class="built_in">MIN</span>(last_name),<span class="built_in">MAX</span>(hire_date) <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><img src="/posts/d7394d1d/image-20230211171435889.png" alt="image-20230211171435889" style="zoom:80%;"><h2 id="COUNT-计算指定字段在查询结果中的次数"><a href="#COUNT-计算指定字段在查询结果中的次数" class="headerlink" title="COUNT() 计算指定字段在查询结果中的次数"></a>COUNT() 计算指定字段在查询结果中的次数</h2><p><code>注意!!! 计算的次数不包含NULL空值</code><br>**方式一：COUNT(具体字段,不一定对) **</p><p>*<em>方式二：COUNT(</em>) **</p><p><strong>方式三：COUNT(1) 任意常量</strong></p><p>方式二和方式三都是全表扫描行数, 不需要读取具体的行</p><p>在innodb中效率 方式一 &lt; 方式二 &#x3D; 方式三</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(employee_id),<span class="built_in">COUNT</span>(<span class="operator">*</span>),<span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="keyword">FROM</span> employees; # 结果均为<span class="number">107</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(commission_pct) <span class="keyword">FROM</span> employees; # 结果却只有<span class="number">35</span>条 因为其余都为空</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(IFNULL(commission_pct,<span class="number">0</span>)) <span class="keyword">FROM</span> employees; # 解决方式 IFNULL(,) 当为空时填充<span class="number">0</span> 结果<span class="number">107</span>条</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> commission_pct <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>; # <span class="number">35</span>条非空</span><br></pre></td></tr></table></figure><h2 id="GROUP-BY-分组"><a href="#GROUP-BY-分组" class="headerlink" title="GROUP BY 分组"></a>GROUP BY 分组</h2><p><strong>需求 查询各部门平均工资 最高工资</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id,<span class="built_in">AVG</span>(salary),<span class="built_in">MAX</span>(salary) <span class="keyword">FROM</span> employees <span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br></pre></td></tr></table></figure><div class="tag-plugin image"><div class="image-bg"><img src="/posts/d7394d1d/image-20230211174728448.png" alt="image-20230211174728448"></div><div class="image-meta"><span class="image-caption center">image-20230211174728448</span></div></div><p><strong>需求 多级分组 查询各部门及各工种的平均工资 最高工资</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id,job_id,<span class="built_in">AVG</span>(salary),<span class="built_in">MAX</span>(salary) <span class="keyword">FROM</span> employees <span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id,job_id;</span><br></pre></td></tr></table></figure><div class="tag-plugin image"><div class="image-bg"><img src="/posts/d7394d1d/image-20230211175246729.png" alt="image-20230211175246729"></div><div class="image-meta"><span class="image-caption center">image-20230211175246729</span></div></div><p><strong>WITH ROLLUP：在GROUP分组字段的基础上再进行统计数据,且不能和ORDER BY一起使用</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id,<span class="built_in">AVG</span>(salary),<span class="built_in">MAX</span>(salary) <span class="keyword">FROM</span> employees <span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id; # 图一 <span class="number">12</span>条</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> department_id,<span class="built_in">AVG</span>(salary),<span class="built_in">MAX</span>(salary) <span class="keyword">FROM</span> employees <span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>; # 图二 <span class="number">13</span>条</span><br></pre></td></tr></table></figure><div class="tag-plugin image"><div class="image-bg"><img src="/posts/d7394d1d/image-20230211180226153.png" alt="图一"></div><div class="image-meta"><span class="image-caption center">图一</span></div></div><div class="tag-plugin image"><div class="image-bg"><img src="/posts/d7394d1d/image-20230211180319098.png" alt="图二"></div><div class="image-meta"><span class="image-caption center">图二</span></div></div><h2 id="HAVING-过滤数据"><a href="#HAVING-过滤数据" class="headerlink" title="HAVING 过滤数据"></a>HAVING 过滤数据</h2><p><code>如果过滤条件出现了聚合函数 则必须用HAVING替换WHERE 否则报错</code></p><p><strong>练习 查询各部门中最高工资大于1w的信息</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id,<span class="built_in">MAX</span>(salary) <span class="keyword">FROM</span> employees <span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id <span class="keyword">HAVING</span> <span class="built_in">MAX</span>(salary) <span class="operator">&gt;</span> <span class="number">10000</span>; # 逻辑：先按部门分组 再求各部门最高工资 最后只显示大于<span class="number">1</span>W的部门</span><br></pre></td></tr></table></figure><div class="tag-plugin image"><div class="image-bg"><img src="/posts/d7394d1d/image-20230211181222169.png" alt="image-20230211181222169"></div><div class="image-meta"><span class="image-caption center">image-20230211181222169</span></div></div><p><strong>练习 查询 10,20,30,40这几个部门中 最高工资大于1W的信息</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 逻辑 先查询<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>这几个部门ID分组后的最高工资 最后筛选出最高工资大于<span class="number">1</span>W的部门</span><br><span class="line"></span><br><span class="line"># 方式一 过滤条件没有聚合函数时使用<span class="keyword">WHERE</span> 效率更高</span><br><span class="line"><span class="keyword">SELECT</span> department_id,<span class="built_in">MAX</span>(salary) <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department_id <span class="keyword">IN</span> (<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>) <span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id <span class="keyword">HAVING</span> <span class="built_in">MAX</span>(salary) <span class="operator">&gt;</span> <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"># 方式二 不使用<span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id,<span class="built_in">MAX</span>(salary) <span class="keyword">FROM</span> employees <span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id <span class="keyword">HAVING</span> <span class="built_in">MAX</span>(salary) <span class="operator">&gt;</span> <span class="number">10000</span> <span class="keyword">AND</span> department_id <span class="keyword">IN</span> (<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>);</span><br></pre></td></tr></table></figure><div class="tag-plugin image"><div class="image-bg"><img src="/posts/d7394d1d/image-20230211182428365.png" alt="image-20230211182428365"></div><div class="image-meta"><span class="image-caption center">image-20230211182428365</span></div></div><h1 id="MYSQL结构"><a href="#MYSQL结构" class="headerlink" title="MYSQL结构"></a>MYSQL结构</h1><div class="tag-plugin image"><div class="image-bg"><img src="/posts/d7394d1d/image-20230211183847631.png" alt="image-20230211183847631"></div><div class="image-meta"><span class="image-caption center">image-20230211183847631</span></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常用聚合函数&quot;&gt;&lt;a href=&quot;#常用聚合函数&quot; class=&quot;headerlink&quot; title=&quot;常用聚合函数&quot;&gt;&lt;/a&gt;常用聚合函数&lt;/h1&gt;&lt;h2 id=&quot;AVG-平均数-SUM-求和函数&quot;&gt;&lt;a href=&quot;#AVG-平均数-SUM-求和函数&quot; cla</summary>
      
    
    
    
    <category term="Language" scheme="http://cvki.cn/categories/Language/"/>
    
    
    <category term="Database" scheme="http://cvki.cn/tags/Database/"/>
    
    <category term="MariaDB" scheme="http://cvki.cn/tags/MariaDB/"/>
    
  </entry>
  
  <entry>
    <title>05加密解密函数</title>
    <link href="http://cvki.cn/posts/4b7c2baa.html"/>
    <id>http://cvki.cn/posts/4b7c2baa.html</id>
    <published>2023-02-11T05:15:16.000Z</published>
    <updated>2023-08-18T08:21:25.574Z</updated>
    
    <content type="html"><![CDATA[<h1 id="加密函数"><a href="#加密函数" class="headerlink" title="加密函数"></a>加密函数</h1><h2 id="PASSWORD-str"><a href="#PASSWORD-str" class="headerlink" title="PASSWORD(str)"></a>PASSWORD(str)</h2><p><strong>此函数在MySQL8.0中弃用</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> PASSWORD(<span class="string">&#x27;test&#x27;</span>) FROMd DUAL;</span><br></pre></td></tr></table></figure><h2 id="MD5-str"><a href="#MD5-str" class="headerlink" title="MD5(str)"></a>MD5(str)</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> MD5(<span class="string">&#x27;mysql&#x27;</span>) <span class="keyword">FROM</span> DUAL;</span><br></pre></td></tr></table></figure><div class="tag-plugin image"><div class="image-bg"><img src="/posts/4b7c2baa/image-20230211160650916.png" alt="image-20230211160650916"></div><div class="image-meta"><span class="image-caption center">image-20230211160650916</span></div></div><h2 id="SHA-str"><a href="#SHA-str" class="headerlink" title="SHA(str)"></a>SHA(str)</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SHA(<span class="string">&#x27;mysql&#x27;</span>) <span class="keyword">FROM</span> DUAL;</span><br></pre></td></tr></table></figure><div class="tag-plugin image"><div class="image-bg"><img src="/posts/4b7c2baa/image-20230211160801116.png" alt="image-20230211160801116"></div><div class="image-meta"><span class="image-caption center">image-20230211160801116</span></div></div><h2 id="ENCODE-A-B-DECODE-C-D"><a href="#ENCODE-A-B-DECODE-C-D" class="headerlink" title="ENCODE(A,B)  \ DECODE(C,D)"></a>ENCODE(A,B)  \ DECODE(C,D)</h2><p><code>上述两个函数在MySQL函数中均已弃用</code></p><p><strong>A为待加密内容 B为秘钥  C为待解密内容 D为秘钥</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ENCODE(<span class="string">&#x27;mysql&#x27;</span>,<span class="string">&#x27;0000&#x27;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DECODE(ENCODE(<span class="string">&#x27;mysql&#x27;</span>,<span class="string">&#x27;0000&#x27;</span>),<span class="string">&#x27;0000&#x27;</span>);</span><br></pre></td></tr></table></figure><h1 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h1><h2 id="四舍五入-FORMAT-A-B"><a href="#四舍五入-FORMAT-A-B" class="headerlink" title="四舍五入 FORMAT(A,B)"></a>四舍五入 FORMAT(A,B)</h2><p><strong>将A保留B为数字四舍五入</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> FORMAT(<span class="number">106.3654</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><div class="tag-plugin image"><div class="image-bg"><img src="/posts/4b7c2baa/image-20230211163100665.png" alt="image-20230211163100665"></div><div class="image-meta"><span class="image-caption center">image-20230211163100665</span></div></div><h2 id="进制转换-CONV-A-B-C"><a href="#进制转换-CONV-A-B-C" class="headerlink" title="进制转换 CONV(A,B,C)"></a>进制转换 CONV(A,B,C)</h2><p><strong>A为待转换数字,B为当前进制,C为目标进制</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CONV(<span class="number">201</span>,<span class="number">10</span>,<span class="number">2</span>); # 将<span class="number">201</span>从十进制转换为<span class="number">2</span>进制</span><br></pre></td></tr></table></figure><div class="tag-plugin image"><div class="image-bg"><img src="/posts/4b7c2baa/image-20230211163214182.png" alt="image-20230211163214182"></div><div class="image-meta"><span class="image-caption center">image-20230211163214182</span></div></div><h2 id="IP地址转换"><a href="#IP地址转换" class="headerlink" title="IP地址转换"></a>IP地址转换</h2><p><code>INET_ATON(A)</code>：将IP地址A转换为数字地址</p><p>如下计算方式为：192X256^3 + 168X256^2 + 1X256^1 + 100X256^0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT INET_ATON(&#x27;192.168.1.100&#x27;); # 结果：3232235876</span><br></pre></td></tr></table></figure><p><code>INET_NTOA(B)</code>：数字地址转IP</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> INET_NTOA(<span class="number">3232235876</span>); # 结果：<span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span></span><br></pre></td></tr></table></figure><div class="tag-plugin image"><div class="image-bg"><img src="/posts/4b7c2baa/image-20230211164520992.png" alt="image-20230211164520992"></div><div class="image-meta"><span class="image-caption center">image-20230211164520992</span></div></div><h2 id="重复执行表达式"><a href="#重复执行表达式" class="headerlink" title="重复执行表达式"></a>重复执行表达式</h2><p><code>BENCHMARK(N,A)</code> 重复执行表达式A,执行次数为N次用于测试表达式性能</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> BENCHMARK(<span class="number">5</span>,MD5(<span class="string">&#x27;mysql&#x27;</span>)) # 结果<span class="number">0.028</span>s</span><br><span class="line"><span class="keyword">SELECT</span> BENCHMARK(<span class="number">100000</span>,MD5(<span class="string">&#x27;mysql&#x27;</span>)); # 结果<span class="number">0.046</span>s</span><br></pre></td></tr></table></figure><h2 id="字符编码转换-CONVERT-A-USING-B"><a href="#字符编码转换-CONVERT-A-USING-B" class="headerlink" title="字符编码转换 CONVERT(A USING B)"></a>字符编码转换 CONVERT(A USING B)</h2><p><strong>将A字符的编码转换为B字符编码</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CHARSET(<span class="string">&#x27;mysql&#x27;</span>); # 查看此字符当前的编码 结果为：utf8mb4</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> CHARSET(<span class="keyword">CONVERT</span>(<span class="string">&#x27;mysql&#x27;</span> <span class="keyword">USING</span> <span class="string">&#x27;utf8mb3&#x27;</span>)); # 将mysql字符转换为utf8mb3 再查看结果 结果为utf8mb3 转换成功</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;加密函数&quot;&gt;&lt;a href=&quot;#加密函数&quot; class=&quot;headerlink&quot; title=&quot;加密函数&quot;&gt;&lt;/a&gt;加密函数&lt;/h1&gt;&lt;h2 id=&quot;PASSWORD-str&quot;&gt;&lt;a href=&quot;#PASSWORD-str&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="Language" scheme="http://cvki.cn/categories/Language/"/>
    
    
    <category term="Database" scheme="http://cvki.cn/tags/Database/"/>
    
    <category term="MariaDB" scheme="http://cvki.cn/tags/MariaDB/"/>
    
  </entry>
  
  <entry>
    <title>04函数</title>
    <link href="http://cvki.cn/posts/7cac1c60.html"/>
    <id>http://cvki.cn/posts/7cac1c60.html</id>
    <published>2023-02-10T07:30:33.000Z</published>
    <updated>2023-08-18T08:21:25.574Z</updated>
    
    <content type="html"><![CDATA[<p>2023年2月10日15:30:33</p><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="IF-条件-条件为真返回-条件为假返回"><a href="#IF-条件-条件为真返回-条件为假返回" class="headerlink" title="IF(条件,条件为真返回,条件为假返回)"></a>IF(条件,条件为真返回,条件为假返回)</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name <span class="keyword">AS</span> &quot;名字&quot;,salary <span class="keyword">AS</span> &quot;工资&quot;,IF(salary<span class="operator">&gt;=</span><span class="number">6000</span>,&quot;高工资&quot;,&quot;低工资&quot;) <span class="keyword">AS</span> &quot;工资等级&quot; <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><div class="tag-plugin image"><div class="image-bg"><img src="/posts/7cac1c60/image-20230210161452603.png" alt="image-20230210161452603"></div><div class="image-meta"><span class="image-caption center">image-20230210161452603</span></div></div><h2 id="IFNULL-A-B-如果A为空-则返回B"><a href="#IFNULL-A-B-如果A为空-则返回B" class="headerlink" title="IFNULL(A,B) 如果A为空 则返回B"></a>IFNULL(A,B) 如果A为空 则返回B</h2><h2 id="CASE-WHEN-A-THEN-B-ELSE-C-END-CASE"><a href="#CASE-WHEN-A-THEN-B-ELSE-C-END-CASE" class="headerlink" title="CASE WHEN A THEN B ELSE C END CASE"></a>CASE WHEN A THEN B ELSE C END CASE</h2><p><strong>当满足条件A的时候返回B 否则返回C</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,salary,<span class="keyword">CASE</span></span><br><span class="line"><span class="keyword">WHEN</span> salary <span class="operator">&gt;=</span> <span class="number">8000</span></span><br><span class="line"><span class="keyword">THEN</span> &quot;高工资&quot;</span><br><span class="line"><span class="keyword">WHEN</span> salary <span class="operator">&gt;=</span> <span class="number">6000</span></span><br><span class="line"><span class="keyword">THEN</span> &quot;一般工资&quot;</span><br><span class="line"><span class="keyword">ELSE</span> &quot;低工资&quot; <span class="keyword">END</span> <span class="keyword">AS</span> &quot;工资等级&quot;</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><div class="tag-plugin image"><div class="image-bg"><img src="/posts/7cac1c60/image-20230210163045164.png" alt="image-20230210163045164"></div><div class="image-meta"><span class="image-caption center">image-20230210163045164</span></div></div><h2 id="CASE-WHEN-A-THEN-B-ELSE-C-END-CASE-1"><a href="#CASE-WHEN-A-THEN-B-ELSE-C-END-CASE-1" class="headerlink" title="CASE WHEN A THEN B ELSE C END CASE"></a>CASE WHEN A THEN B ELSE C END CASE</h2><p><strong>练习：查询部门id为10,20,30的员工 部门10打印工资的1.1倍 部门20打印工资的1.2倍 部门30 打印工资的1.3倍</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,department_id,salary,<span class="keyword">CASE</span> department_id</span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">10</span> <span class="keyword">THEN</span></span><br><span class="line">salary <span class="operator">*</span> <span class="number">1.1</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">20</span> <span class="keyword">THEN</span></span><br><span class="line">  salary <span class="operator">*</span> <span class="number">1.2</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">salary <span class="operator">*</span> <span class="number">1.3</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">AS</span> &quot;工资加成&quot;</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department_id <span class="keyword">IN</span>(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br></pre></td></tr></table></figure><div class="tag-plugin image"><div class="image-bg"><img src="/posts/7cac1c60/image-20230210164005037.png" alt="image-20230210164005037"></div><div class="image-meta"><span class="image-caption center">image-20230210164005037</span></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2023年2月10日15:30:33&lt;/p&gt;
&lt;h1 id=&quot;流程控制&quot;&gt;&lt;a href=&quot;#流程控制&quot; class=&quot;headerlink&quot; title=&quot;流程控制&quot;&gt;&lt;/a&gt;流程控制&lt;/h1&gt;&lt;h2 id=&quot;IF-条件-条件为真返回-条件为假返回&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="Language" scheme="http://cvki.cn/categories/Language/"/>
    
    
    <category term="Database" scheme="http://cvki.cn/tags/Database/"/>
    
    <category term="MariaDB" scheme="http://cvki.cn/tags/MariaDB/"/>
    
  </entry>
  
  <entry>
    <title>03多表查询</title>
    <link href="http://cvki.cn/posts/4bc002fb.html"/>
    <id>http://cvki.cn/posts/4bc002fb.html</id>
    <published>2023-02-09T07:22:37.000Z</published>
    <updated>2023-08-18T08:21:25.566Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><h2 id="需求-查询名为Abel的人在哪里工作"><a href="#需求-查询名为Abel的人在哪里工作" class="headerlink" title="需求 查询名为Abel的人在哪里工作"></a>需求 查询名为Abel的人在哪里工作</h2><h3 id="正常查询"><a href="#正常查询" class="headerlink" title="正常查询"></a>正常查询</h3><p><strong>第一步 查询Able所处的部门ID</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> last_name <span class="operator">=</span> <span class="string">&#x27;Abel&#x27;</span>; # 结果<span class="number">80</span></span><br></pre></td></tr></table></figure><div class="tag-plugin image"><div class="image-bg"><img src="/posts/4bc002fb/image-20230209152705384.png" alt="img"></div><div class="image-meta"><span class="image-caption center">img</span></div></div><p><strong>第二步 查询该部门ID所对应的城市ID</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> departments <span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">80</span>; # 结果<span class="number">2500</span></span><br></pre></td></tr></table></figure><div class="tag-plugin image"><div class="image-bg"><img src="/posts/4bc002fb/image-20230209153011198.png" alt="image-20230209153011198"></div><div class="image-meta"><span class="image-caption center">image-20230209153011198</span></div></div><p><strong>第三步 通过城市ID获得具体工作地点</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> locations <span class="keyword">WHERE</span> location_id <span class="operator">=</span> <span class="number">2500</span>; # 得到结果Oxford</span><br></pre></td></tr></table></figure><h3 id="多表查询-1"><a href="#多表查询-1" class="headerlink" title="多表查询"></a>多表查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 注：如果查询的字段在多个表同时存在,必须指明此字段所在的表(建议多表查询时都加上)</span><br><span class="line"># 如下面的departments.department_id</span><br><span class="line"><span class="keyword">SELECT</span> last_name,departments.department_id,city <span class="keyword">FROM</span> employees,departments,locations <span class="keyword">WHERE</span> last_name <span class="operator">=</span> <span class="string">&#x27;Abel&#x27;</span> <span class="keyword">AND</span> employees.department_id <span class="operator">=</span> departments.department_id <span class="keyword">AND</span> departments.location_id <span class="operator">=</span> locations.location_id;</span><br></pre></td></tr></table></figure><div class="tag-plugin image"><div class="image-bg"><img src="/posts/4bc002fb/image-20230209160218764.png" alt="image-20230209160218764"></div><div class="image-meta"><span class="image-caption center">image-20230209160218764</span></div></div><p><strong>给表起别名</strong></p><p>增加可读性, 但起别名后只能用别名 原名不可使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> el.last_name,dp.department_id,lc.city <span class="keyword">FROM</span> employees <span class="keyword">AS</span> el,departments <span class="keyword">as</span> dp,locations <span class="keyword">as</span> lc <span class="keyword">WHERE</span> el.last_name <span class="operator">=</span> <span class="string">&#x27;Abel&#x27;</span> <span class="keyword">AND</span> el.department_id <span class="operator">=</span> dp.department_id <span class="keyword">AND</span> dp.location_id <span class="operator">=</span> lc.location_id;</span><br></pre></td></tr></table></figure><h1 id="多表连接"><a href="#多表连接" class="headerlink" title="多表连接"></a>多表连接</h1><h2 id="等值连接-非等值连接"><a href="#等值连接-非等值连接" class="headerlink" title="等值连接 \ 非等值连接"></a><strong>等值连接 \ 非等值连接</strong></h2><p><strong>非等值连接例子</strong></p><p>查询el表中的所有人工资所对应的jbg表中的工资等级</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> el.last_name,el.salary,jbg.grade_level <span class="keyword">FROM</span> job_grades <span class="keyword">as</span> jbg,employees <span class="keyword">AS</span> el <span class="keyword">WHERE</span> el.salary <span class="operator">&gt;=</span> jbg.lowest_sal <span class="keyword">AND</span> el.salary <span class="operator">&lt;=</span> jbg.highest_sal;</span><br></pre></td></tr></table></figure><div class="tag-plugin image"><div class="image-bg"><img src="/posts/4bc002fb/image-20230209163819456.png" alt="image-20230209163819456"></div><div class="image-meta"><span class="image-caption center">image-20230209163819456</span></div></div><p>用between … and ….</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> el.last_name,el.salary,jbg.grade_level <span class="keyword">FROM</span> job_grades <span class="keyword">as</span> jbg,employees <span class="keyword">AS</span> el <span class="keyword">WHERE</span> el.salary <span class="keyword">BETWEEN</span> jbg.lowest_sal <span class="keyword">AND</span> jbg.highest_sal;</span><br></pre></td></tr></table></figure><div class="tag-plugin image"><div class="image-bg"><img src="/posts/4bc002fb/image-20230209163806690.png" alt="image-20230209163806690"></div><div class="image-meta"><span class="image-caption center">image-20230209163806690</span></div></div><h2 id="自连接-非自连接"><a href="#自连接-非自连接" class="headerlink" title="自连接 \ 非自连接"></a>自连接 \ 非自连接</h2><p><strong>自连接(自我引用)</strong></p><p>自连接例子 查询el表中员工对应的管理者</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> elyg.last_name &quot;员工名字&quot;,elyg.employee_id <span class="keyword">AS</span> &quot;员工ID&quot;,elgl.last_name <span class="keyword">AS</span> &quot;管理者名字&quot;,elgl.employee_id <span class="keyword">AS</span> &quot;管理者ID&quot; <span class="keyword">FROM</span> employees <span class="keyword">as</span> elyg,employees <span class="keyword">AS</span> elgl <span class="keyword">WHERE</span> elyg.manager_id <span class="operator">=</span> elgl.employee_id;</span><br></pre></td></tr></table></figure><div class="tag-plugin image"><div class="image-bg"><img src="/posts/4bc002fb/image-20230209164300811.png" alt="image-20230209164300811"></div><div class="image-meta"><span class="image-caption center">image-20230209164300811</span></div></div><h2 id="内连接-外连接"><a href="#内连接-外连接" class="headerlink" title="内连接 \ 外连接"></a>内连接 \ 外连接</h2><p><strong>内连接：合并具有同一列的两个以上的表的行, 结果集中不包含一个表与另一个表不匹配的行</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e,departments d</span><br><span class="line"><span class="keyword">WHERE</span> e.`department_id` <span class="operator">=</span> d.department_id;</span><br></pre></td></tr></table></figure><div class="tag-plugin image"><div class="image-bg"><img src="/posts/4bc002fb/image-20230209180814479.png" alt="image-20230209180814479"></div><div class="image-meta"><span class="image-caption center">image-20230209180814479</span></div></div><p><strong>外连接：合并具有同一列的两个以上的表的行, 结果集中除了包含一个表与另一个表匹配的行之外,还查询到了左表 或 右表中不匹配的行。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 外连接的分类：左外连接、右外连接、满外连接</span><br><span class="line"></span><br><span class="line"># 左外连接：两个表在连接过程中除了返回满足连接条件的行以外还返回左表中不满足条件的行，这种连接称为左外连接。</span><br><span class="line"># 右外连接：两个表在连接过程中除了返回满足连接条件的行以外还返回右表中不满足条件的行，这种连接称为右外连接。</span><br></pre></td></tr></table></figure><p><strong>左外连接 … LEFT JOIN … ON …</strong><div class="tag-plugin image"><div class="image-bg"><img src="/posts/4bc002fb/image-20230209180124050.png" alt="image-20230209180124050"></div><div class="image-meta"><span class="image-caption center">image-20230209180124050</span></div></div></p><p><strong>右外连接 … RIGHT JOIN … ON …</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> el.employee_id,el.last_name,dp.department_id <span class="keyword">FROM</span> employees <span class="keyword">AS</span> el <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments <span class="keyword">AS</span> dp <span class="keyword">ON</span> el.department_id <span class="operator">=</span> dp.department_id;</span><br></pre></td></tr></table></figure><div class="tag-plugin image"><div class="image-bg"><img src="/posts/4bc002fb/image-20230209180435649.png" alt="image-20230209180435649"></div><div class="image-meta"><span class="image-caption center">image-20230209180435649</span></div></div><p><strong>满外连接(MySQL不支持)</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> el.employee_id,el.last_name,dp.department_id <span class="keyword">FROM</span> employees <span class="keyword">AS</span> el <span class="keyword">FULL</span> <span class="keyword">JOIN</span> departments <span class="keyword">AS</span> dp <span class="keyword">ON</span> el.department_id <span class="operator">=</span> dp.department_id;</span><br></pre></td></tr></table></figure><h1 id="7种SQL-JOIN实现"><a href="#7种SQL-JOIN实现" class="headerlink" title="7种SQL JOIN实现"></a>7种SQL JOIN实现</h1><div class="tag-plugin image"><div class="image-bg"><img src="/posts/4bc002fb/image-20230209181311179.png" alt="image-20230209181311179"></div><div class="image-meta"><span class="image-caption center">image-20230209181311179</span></div></div><h2 id="中图"><a href="#中图" class="headerlink" title="中图"></a>中图</h2><p>内连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> el.employee_id,el.last_name,dp.department_id <span class="keyword">FROM</span> employees el,departments dp <span class="keyword">WHERE</span> el.department_id <span class="operator">=</span> dp.department_id; # <span class="number">106</span>条</span><br></pre></td></tr></table></figure><h2 id="左上图"><a href="#左上图" class="headerlink" title="左上图"></a>左上图</h2><p>左外连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> el.employee_id,el.last_name,dp.department_id <span class="keyword">FROM</span> employees el <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments dp <span class="keyword">ON</span> el.department_id <span class="operator">=</span> dp.department_id; # <span class="number">107</span>条</span><br></pre></td></tr></table></figure><h2 id="右上图"><a href="#右上图" class="headerlink" title="右上图"></a>右上图</h2><p>右外连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> el.employee_id,el.last_name,dp.department_id <span class="keyword">FROM</span> employees el <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments dp <span class="keyword">ON</span> el.department_id <span class="operator">=</span> dp.department_id; # <span class="number">122</span>条</span><br></pre></td></tr></table></figure><h2 id="左中图"><a href="#左中图" class="headerlink" title="左中图"></a>左中图</h2><p>左外连接去交集</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> el.employee_id,el.last_name,el.department_id <span class="keyword">FROM</span> employees el <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments dp <span class="keyword">ON</span> el.department_id <span class="operator">=</span> dp.department_id <span class="keyword">WHERE</span> dp.department_id <span class="keyword">IS</span> <span class="keyword">NULL</span>; # <span class="number">1</span>条</span><br></pre></td></tr></table></figure><div class="tag-plugin image"><div class="image-bg"><img src="/posts/4bc002fb/image-20230210142608821.png" alt="image-20230210142608821"></div><div class="image-meta"><span class="image-caption center">image-20230210142608821</span></div></div><h2 id="右中图"><a href="#右中图" class="headerlink" title="右中图"></a>右中图</h2><p>右外连接去交集</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> el.employee_id,el.last_name,el.department_id <span class="keyword">FROM</span> employees el <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments dp <span class="keyword">ON</span> el.department_id <span class="operator">=</span> dp.department_id <span class="keyword">WHERE</span> el.department_id <span class="keyword">IS</span> <span class="keyword">NULL</span>; # <span class="number">16</span>条</span><br></pre></td></tr></table></figure><div class="tag-plugin image"><div class="image-bg"><img src="/posts/4bc002fb/image-20230210142634148.png" alt="image-20230210142634148"></div><div class="image-meta"><span class="image-caption center">image-20230210142634148</span></div></div><h2 id="左下图"><a href="#左下图" class="headerlink" title="左下图"></a>左下图</h2><p>满外连接：左上图 UNION ALL 右中图 (直接用UNION ALL 在中间连接即可)</p><p>可以用UNION连接 也可以用 UNION ALL </p><p>但UNION比UNION ALL多了去重操作 相对较慢 所以优先使用UNION ALL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> el.employee_id,el.last_name,dp.department_id <span class="keyword">FROM</span> employees el <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments dp <span class="keyword">ON</span> el.department_id <span class="operator">=</span> dp.department_id</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> el.employee_id,el.last_name,el.department_id <span class="keyword">FROM</span> employees el <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments dp <span class="keyword">ON</span> el.department_id <span class="operator">=</span> dp.department_id <span class="keyword">WHERE</span> el.department_id <span class="keyword">IS</span> <span class="keyword">NULL</span>; # <span class="number">123</span>条</span><br></pre></td></tr></table></figure><div class="tag-plugin image"><div class="image-bg"><img src="/posts/4bc002fb/image-20230210142827221.png" alt="image-20230210142827221"></div><div class="image-meta"><span class="image-caption center">image-20230210142827221</span></div></div><h1 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h1><p>NATURAL JOIN：自动查询两张表中<code>所有相同的字段</code> 并进行<code>等值连接</code></p><p>所以也不够灵活, 但只有单个连接或只需要单个连接时推荐使用等值连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> el.employee_id,el.last_name <span class="keyword">FROM</span> employees el, departments dp <span class="keyword">WHERE</span> el.department_id <span class="operator">=</span> dp.department_id <span class="keyword">AND</span> el.manager_id <span class="operator">=</span> dp.manager_id; # <span class="number">32</span>条</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> el.employee_id,el.last_name <span class="keyword">FROM</span> employees el <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> departments dp; # <span class="number">32</span>条</span><br></pre></td></tr></table></figure><div class="tag-plugin image"><div class="image-bg"><img src="/posts/4bc002fb/image-20230210144127963.png" alt="image-20230210144127963"></div><div class="image-meta"><span class="image-caption center">image-20230210144127963</span></div></div><h1 id="USING连接"><a href="#USING连接" class="headerlink" title="USING连接"></a>USING连接</h1><p>仅支持同名字段连接 较为局限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees el,departments dp <span class="keyword">WHERE</span> el.department_id <span class="operator">=</span> dp.department_id; # <span class="number">106</span>条</span><br></pre></td></tr></table></figure><p>等价</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">JOIN</span> departments <span class="keyword">USING</span>(department_id); # <span class="number">106</span>条</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多表查询&quot;&gt;&lt;a href=&quot;#多表查询&quot; class=&quot;headerlink&quot; title=&quot;多表查询&quot;&gt;&lt;/a&gt;多表查询&lt;/h1&gt;&lt;h2 id=&quot;需求-查询名为Abel的人在哪里工作&quot;&gt;&lt;a href=&quot;#需求-查询名为Abel的人在哪里工作&quot; class=&quot;</summary>
      
    
    
    
    <category term="Language" scheme="http://cvki.cn/categories/Language/"/>
    
    
    <category term="Database" scheme="http://cvki.cn/tags/Database/"/>
    
    <category term="MariaDB" scheme="http://cvki.cn/tags/MariaDB/"/>
    
  </entry>
  
</feed>
