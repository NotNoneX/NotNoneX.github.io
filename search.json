[{"title":"Docker快速入门&备份和迁移数据","path":"/posts/eee57fff.html","content":"🎯备份和迁移数据迁移方式介绍容器中的数据，如果没有用挂载目录，删除容器后就会丢失数据。前面我们已经讲解了如何 挂载目录如果你是用bind mount直接把宿主机的目录挂进去容器，那迁移数据很方便，直接复制目录就好了如果你是用volume方式挂载的，由于数据是由容器创建和管理的，需要用特殊的方式把数据弄出来。 备份和导入 Volume 的流程备份： 运行一个 ubuntu 的容器，挂载需要备份的 volume 到容器，并且挂载宿主机目录到容器里的备份目录。 运行 tar 命令把数据压缩为一个文件 把备份文件复制到需要导入的机器 导入： 运行 ubuntu 容器，挂载容器的 volume，并且挂载宿主机备份文件所在目录到容器里 运行 tar 命令解压备份文件到指定目录 备份 MongoDB 数据演示 运行一个 mongodb，创建一个名叫mongo-data的 volume 指向容器的 &#x2F;data 目录docker run -p 27018:27017 --name mongo -v mongo-data:/data -d mongo:4.4 运行一个 Ubuntu 的容器，挂载mongo容器的所有 volume，映射宿主机的 backup 目录到容器里面的 &#x2F;backup 目录，然后运行 tar 命令把数据压缩打包docker run --rm --volumes-from mongo -v d:/backup:/backup ubuntu tar cvf /backup/backup.tar /data/ 最后你就可以拿着这个 backup.tar 文件去其他地方导入了。 恢复 Volume 数据演示 运行一个 ubuntu 容器，挂载 mongo 容器的所有 volumes，然后读取 &#x2F;backup 目录中的备份文件，解压到 &#x2F;data&#x2F; 目录docker run --rm --volumes-from mongo -v d:/backup:/backup ubuntu bash -c &quot;cd /data/ &amp;&amp; tar xvf /backup/backup.tar --strip 1&quot; 注意，volumes-from 指定的是容器名字strip 1 表示解压时去掉前面1层目录，因为压缩时包含了绝对路径","tags":["Docker","Docker快速入门"],"categories":["Docker"]},{"title":"Docker快速入门&发布和部署","path":"/posts/a502abd5.html","content":"🚚发布和部署镜像仓库介绍镜像仓库用来存储我们 build 出来的“安装包”，Docker 官方提供了一个 镜像库，里面包含了大量镜像，基本各种软件所需依赖都有，要什么直接上去搜索。 我们也可以把自己 build 出来的镜像上传到 docker 提供的镜像库中，方便传播。当然你也可以搭建自己的私有镜像库，或者使用国内各种大厂提供的镜像托管服务，例如：阿里云、腾讯云 上传我们的镜像 首先你要先 注册一个账号 创建一个镜像库image.png 命令行登录账号：docker login -u username 新建一个tag，名字必须跟你注册账号一样docker tag test:v1 username/test:v1 推上去docker push username/test:v1 部署试下docker run -dp 8080:8080 username/test:v1 docker-compose 中也可以直接用这个镜像了123456789101112131415161718192021version: &quot;3.7&quot;services: app:# build: ./ image: helloguguji/test:v1 ports: - 80:8080 volumes: - ./:/app environment: - TZ=Asia/Shanghai redis: image: redis:5.0.13 volumes: - redis:/data environment: - TZ=Asia/Shanghaivolumes: redis: 阿里云容器托管docker 官方的镜像托管有时候上传和下载都太慢了，如果你想要更快的速度，可以使用阿里云的免费镜像托管登录 阿里云 image.png","tags":["Docker","Docker快速入门"],"categories":["Docker"]},{"title":"Docker快速入门&Docker-Compose","path":"/posts/31e1fdfd.html","content":"🍁Docker-Compose现存问题在上节，我们运行了两个容器：Web 项目 + Redis如果项目依赖更多的第三方软件，我们需要管理的容器就更加多，每个都要单独配置运行，指定网络。这节，我们使用 docker-compose 把项目的多个服务集合到一起，一键运行。 安装 Docker Compose 如果你是安装的桌面版 Docker，不需要额外安装，已经包含了。 如果是没图形界面的服务器版 Docker，你需要单独安装 安装文档 运行docker-compose检查是否安装成功 编写脚本要把项目依赖的多个服务集合到一起，我们需要编写一个docker-compose.yml文件，描述依赖哪些服务参考文档：https://docs.docker.com/compose/ 1234567891011121314151617181920version: &quot;3.7&quot;services: app: build: ./ ports: - 80:8080 volumes: - ./:/app environment: - TZ=Asia/Shanghai redis: image: redis:5.0.13 volumes: - redis:/data environment: - TZ=Asia/Shanghaivolumes: redis: 容器默认时间不是北京时间，增加 TZ&#x3D;Asia&#x2F;Shanghai 可以改为北京时间 跑起来在docker-compose.yml 文件所在目录，执行：docker-compose up就可以跑起来了。命令参考：https://docs.docker.com/compose/reference/up/ 在后台运行只需要加一个 -d 参数docker-compose up -d查看运行状态：docker-compose ps停止运行：docker-compose stop重启：docker-compose restart重启单个服务：docker-compose restart service-name进入容器命令行：docker-compose exec service-name sh查看容器运行log：&#96;docker-compose logs [service-name]","tags":["Docker","Docker快速入门"],"categories":["Docker"]},{"title":"Docker快速入门&多容器通信","path":"/posts/36d19d1c.html","content":"👨‍👦‍👦多容器通信学习目标项目往往都不是独立运行的，需要数据库、缓存这些东西配合运作。这节我们把前面的 Web 项目增加一个 Redis 依赖，多跑一个 Redis 容器，演示如何多容器之间的通信。 创建虚拟网络要想多容器之间互通，从 Web 容器访问 Redis 容器，我们只需要把他们放到同个网络中就可以了。 文档参考：https://docs.docker.com/engine/reference/commandline/network/ 演示创建一个名为test-net的网络：1docker network create test-net 运行 Redis 在 test-net 网络中，别名redis1docker run -d --name redis --network test-net --network-alias redis redis:latest 修改代码中访问redis的地址为网络别名image.png 运行 Web 项目，使用同个网络1docker run -p 8080:8080 --name test -v D:/test:/app --network test-net -d test:v1 查看数据http://localhost:8080/redis容器终端查看数据是否一致 更多相关命令docker ps 查看当前运行中的容器docker images 查看镜像列表docker rm container-id 删除指定 id 的容器docker stop/start container-id 停止&#x2F;启动指定 id 的容器docker rmi image-id 删除指定 id 的镜像docker volume ls 查看 volume 列表docker network ls 查看网络列表","tags":["Docker","Docker快速入门"],"categories":["Docker"]},{"title":"Docker快速入门&目录挂载","path":"/posts/b03c4432.html","content":"🥙目录挂载现存问题 使用 Docker 运行后，我们改了项目代码不会立刻生效，需要重新build和run，很是麻烦。 容器里面产生的数据，例如 log 文件，数据库备份文件，容器删除后就丢失了。 目录挂载解决以上问题 几种挂载方式 bind mount 直接把宿主机目录映射到容器内，适合挂代码目录和配置文件。可挂到多个容器上 volume 由容器创建和管理，创建在宿主机，所以删除容器不会丢失，官方推荐，更高效，Linux 文件系统，适合存储数据库数据。可挂到多个容器上 tmpfs mount 适合存储临时文件，存宿主机内存中。不可多容器共享。 文档参考：https://docs.docker.com/storage/ image.png 挂载演示12bind mount` 方式用绝对路径 `-v D:/code:/appvolume` 方式，只需要一个名字 `-v db-data:/app 示例：docker run -p 8080:8080 --name test-hello -v D:/code:/app -d test:v1 注意！因为挂载后，容器里的代码就会替换为你本机的代码了，如果你代码目录没有node_modules目录，你需要在代码目录执行下npm install --registry=https://registry.npm.taobao.org确保依赖库都已经安装，否则可能会提示“Error: Cannot find module ‘koa’”如果你的电脑没有安装 nodejs，你需要安装一下才能执行上面的命令。","tags":["Docker","Docker快速入门"],"categories":["Docker"]},{"title":"Docker快速入门&制作自己的镜像","path":"/posts/118ee6c6.html","content":"💽制作自己的镜像为自己的 Web 项目构建镜像示例项目代码：https://github.com/gzyunke/test-docker这是一个 Nodejs + Koa2 写的 Web 项目，提供了简单的两个演示页面。软件依赖：nodejs项目依赖库：koa、log4js、koa-router 编写 Dockerfile123456789101112131415161718FROM node:11MAINTAINER notnonex&lt;notnonex@gmail.com&gt;# 复制代码ADD . /app# 设置容器启动后的默认运行目录WORKDIR /app# 运行命令，安装依赖# RUN 命令可以有多个，但是可以用 &amp;&amp; 连接多个命令来减少层级。# 例如 RUN npm install &amp;&amp; cd /app &amp;&amp; mkdir logsRUN npm install --registry=https://registry.npm.taobao.org# CMD 指令只能一个，是容器启动后执行的命令，算是程序的入口。# 如果还需要运行其他命令可以用 &amp;&amp; 连接，也可以写成一个shell脚本去执行。# 例如 CMD cd /app &amp;&amp; ./start.shCMD node app.js Dockerfile文档 实用技巧：如果你写 Dockerfile 时经常遇到一些运行错误，依赖错误等，你可以直接运行一个依赖的底，然后进入终端进行配置环境，成功后再把做过的步骤命令写道 Dockerfile 文件中，这样编写调试会快很多。例如上面的底是node:11，我们可以运行docker run -it -d node:11 bash，跑起来后进入容器终端配置依赖的软件，然后尝试跑起来自己的软件，最后把所有做过的步骤写入到 Dockerfile 就好了。掌握好这个技巧，你的 Dockerfile 文件编写起来就非常的得心应手了。 Build 为镜像（安装包）和运行编译 docker build -t test:v1 . -t 设置镜像名字和版本号命令参考：https://docs.docker.com/engine/reference/commandline/build/ 运行 docker run -p 8080:8080 --name test-hello test:v1 -p 映射容器内端口到宿主机--name 容器名字-d 后台运行命令参考文档：https://docs.docker.com/engine/reference/run/ 更多相关命令docker ps 查看当前运行中的容器docker images 查看镜像列表docker rm container-id 删除指定 id 的容器docker stop/start container-id 停止&#x2F;启动指定 id 的容器docker rmi image-id 删除指定 id 的镜像docker volume ls 查看 volume 列表docker network ls 查看网络列表","tags":["Docker","Docker快速入门"],"categories":["Docker"]},{"title":"Docker快速入门&Docker 快速安装软件","path":"/posts/887b1872.html","content":"💻Docker 快速安装软件直接安装的缺点 安装麻烦，可能有各种依赖，运行报错。例如：WordPress，ElasticSearch，Redis，ELK 可能对 Windows 并不友好，运行有各种兼容问题，软件只支持 Linux 上跑 不方便安装多版本软件，不能共存。 电脑安装了一堆软件，拖慢电脑速度。 不同系统和硬件，安装方式不一样 Docker 安装的优点 一个命令就可以安装好，快速方便 有大量的镜像，可直接使用 没有系统兼容问题，Linux 专享软件也照样跑 支持软件多版本共存 用完就丢，不拖慢电脑速度 不同系统和硬件，只要安装好 Docker 其他都一样了，一个命令搞定所有 演示 Docker 安装 RedisRedis 官网：https://redis.io/ 官网下载安装教程只有源码安装方式，没有 Windows 版本。想要自己安装 windows 版本需要去找别人编译好的安装包。 Docker 官方镜像仓库查找 Redis ：https://hub.docker.com/ Docker镜像官网 一个命令跑起来：docker run -d -p 6379:6379 --name redis redis:latest命令参考：https://docs.docker.com/engine/reference/commandline/run/ Docker运行Redis后 安装 Wordpressdocker-compose.yml 12345678910111213141516171819202122232425262728293031version: &#x27;3.1&#x27;services: wordpress: image: wordpress restart: always ports: - 8080:80 environment: WORDPRESS_DB_HOST: db WORDPRESS_DB_USER: exampleuser WORDPRESS_DB_PASSWORD: examplepass WORDPRESS_DB_NAME: exampledb volumes: - wordpress:/var/www/html db: image: mysql:5.7 restart: always environment: MYSQL_DATABASE: exampledb MYSQL_USER: exampleuser MYSQL_PASSWORD: examplepass MYSQL_RANDOM_ROOT_PASSWORD: &#x27;1&#x27; volumes: - db:/var/lib/mysqlvolumes: wordpress: db: 安装 ELK1docker run -p 5601:5601 -p 9200:9200 -p 5044:5044 -it --name elk sebp/elk 内存不够解决方法转到用户目录 cd ~，路径类似这个：C:\\Users\\&lt;UserName&gt;创建 .wslconfig 文件填入以下内容 123[wsl2]memory=10GB # Limits VM memory in WSL 2 to 4 GBprocessors=2 # Makes the WSL 2 VM use two virtual processors 生效配置，命令行运行 wsl --shutdown 更多相关命令docker ps 查看当前运行中的容器docker images 查看镜像列表docker rm container-id 删除指定 id 的容器docker stop/start container-id 停止&#x2F;启动指定 id 的容器docker rmi image-id 删除指定 id 的镜像docker volume ls 查看 volume 列表docker network ls 查看网络列表","tags":["Docker","Docker快速入门"],"categories":["Docker"]},{"title":"Docker快速入门&Docker 简介和安装","path":"/posts/87fcc52f.html","content":"🎉Docker 简介和安装Docker 是什么Docker 是一个应用打包、分发、部署的工具你也可以把它理解为一个轻量的虚拟机，它只虚拟你软件需要的运行环境，多余的一点都不要，而普通虚拟机则是一个完整而庞大的系统，包含各种不管你要不要的软件。 跟普通虚拟机的对比 特性 普通虚拟机 Docker 跨平台 通常只能在桌面级系统运行，例如 Windows&#x2F;Mac，无法在不带图形界面的服务器上运行 支持的系统非常多，各类 windows 和 Linux 都支持 性能 性能损耗大，内存占用高，因为是把整个完整系统都虚拟出来了 性能好，只虚拟软件所需运行环境，最大化减少没用的配置 自动化 需要手动安装所有东西 一个命令就可以自动部署好所需环境 稳定性 稳定性不高，不同系统差异大 稳定性好，不同系统都一样部署方式 打包、分发、部署打包：就是把你软件运行所需的依赖、第三方库、软件打包到一起，变成一个安装包分发：你可以把你打包好的“安装包”上传到一个镜像仓库，其他人可以非常方便的获取和安装部署：拿着“安装包”就可以一个命令运行起来你的应用，自动模拟出一摸一样的运行环境，不管是在 Windows&#x2F;Mac&#x2F;Linux。 image.png Docker 部署的优势常规应用开发部署方式：自己在 Windows 上开发、测试 –&gt; 到 Linux 服务器配置运行环境部署。 问题：我机器上跑都没问题，怎么到服务器就各种问题了 用 Docker 开发部署流程：自己在 Windows 上开发、测试 –&gt; 打包为 Docker 镜像（可以理解为软件安装包） –&gt; 各种服务器上只需要一个命令部署好 优点：确保了不同机器上跑都是一致的运行环境，不会出现我机器上跑正常，你机器跑就有问题的情况。 例如 易文档，SVNBucket 的私有化部署就是用 Docker，轻松应对客户的各种服务器。 Docker 通常用来做什么 应用分发、部署，方便传播给他人安装。特别是开源软件和提供私有部署的应用 快速安装测试&#x2F;学习软件，用完就丢（类似小程序），不把时间浪费在安装软件上。例如 Redis &#x2F; MongoDB &#x2F; ElasticSearch &#x2F; ELK 多个版本软件共存，不污染系统，例如 Python2、Python3，Redis4.0，Redis5.0 Windows 上体验&#x2F;学习各种 Linux 系统 重要概念：镜像、容器镜像：可以理解为软件安装包，可以方便的进行传播和安装。容器：软件安装后的状态，每个软件运行环境都是独立的、隔离的，称之为容器。 安装桌面版：https://www.docker.com/products/docker-desktop服务器版：https://docs.docker.com/engine/install/#server 启动报错解决报错截图 **解决方法**： 控制面板->程序->启用或关闭 windows 功能，开启 Windows 虚拟化和 Linux 子系统（WSL2 image.png image.png 命令行安装 Linux 内核wsl.exe --install -d Ubuntu 你也可以打开微软商店 Microsoft Store 搜索 Linux 进行安装，选择一个最新版本的 Ubuntu 或者 Debian 都可以 上面命令很可能你安装不了，微软商店你也可能打不开，如果遇到这个问题，参考：https://blog.csdn.net/qq_42220935/article/details/104714114 设置开机启动 Hypervisorbcdedit /set hypervisorlaunchtype auto 注意要用管理员权限打开 PowerShell 设置默认使用版本2wsl.exe --set-default-version 2 查看 WSL 是否安装正确wsl.exe --list --verbose应该如下图，可以看到一个 Linux 系统，名字你的不一定跟我的一样，看你安装的是什么版本。并且 VERSION 是 2 image.png 确保 BIOS 已开启虚拟化，下图检查是否已开启好 如果是已禁用，请在开机时按 F2 进入 BIOS 开启一下，不会设置的可以网上搜索下自己主板的设置方法，Intel 和 AMD 的设置可能稍有不同 image.png 出现下图错误，点击链接安装最新版本的 WSL2https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi image.png 镜像加速源 镜像加速器 镜像加速器地址 Docker 中国官方镜像 https://registry.docker-cn.com DaoCloud 镜像站 http://f1361db2.m.daocloud.io Azure 中国镜像 https://dockerhub.azk8s.cn 科大镜像站 https://docker.mirrors.ustc.edu.cn 阿里云 https://ud6340vz.mirror.aliyuncs.com 七牛云 https://reg-mirror.qiniu.com 网易云 https://hub-mirror.c.163.com 腾讯云 https://mirror.ccs.tencentyun.com 1&quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;] 1.png","tags":["Docker","Docker快速入门"],"categories":["Docker"]},{"title":"Docker学习笔记之基础篇","path":"/posts/85fe2496.html","content":"学习资料： 【狂神说Java】Docker最新超详细版教程通俗易懂_哔哩哔哩_bilibili Docker快速入门总结笔记_huangjhai的博客-CSDN博客 docker 进阶 之容器数据卷 DockerFile Docker网络 — 狂神说_cheng的博客-CSDN博客 官网：https://www.docker.com/ 文档地址： https://docs.docker.com/ （Docker 官网文档超级详细） 仓库地址：https://hub.docker.com/ Docker中文文档 Docker概述-DockerInfo Docker 中文文档（译）_nickDaDa的博客-CSDN博客_docker中文文档 1、Docker概述1.1 Docker 为什么会出现 一款产品上线：面临问题： 问题1：开发 和 上线 俩套环境 问题2：开发人员 和 运维人员 ，开发测试可运行，上线就运行不了 问题3：环境配置十分麻烦，每个机器都要部署环境（集群 Redis、ES、Hadoop 等等） 问题4： 发布 jar包 时 又要 部署（Mysql、ES、Redis、jdk 等等）费时的环境，希望jar + 环境一起发布 问题5：部署的环境不能跨平台 windows 与 Linux Docker 给以上问题提出了解决方案 传统：开发打jar包 给运维来部署 现在：开发即负责打包又负责部署，全栈开发 开发人员 打jar包带上环境（这里的环境称为镜像） – Docker 仓库（商店） – 运维人员下载 镜像 可直接运行 image-20230406171433771 docker 的 思想 来源于 集装箱 ，打包装箱，相互隔离 虚拟机非常笨重，而docker十分小巧。 开源：开放源代码 1.2 Docker的概述 1、基本介绍 Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。 Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。 容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。 Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版），我们用社区版就可以了。 官网：https://www.docker.com/ 文档地址： https://docs.docker.com/ （Docker 官网文档超级详细） 仓库地址：https://hub.docker.com/ 2、应用场景 Web 应用的自动化打包和发布。 自动化测试和持续集成、发布。 在服务型环境中部署和调整数据库或其他的后台应用。 从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。 3、Docker 的优势 Docker 是一个用于开发，交付和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助 Docker，您可以与管理应用程序相同的方式来管理基础架构。通过利用 Docker 的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。 (1) 快速，一致地交付您的应用程序。 Docker 允许开发人员使用您提供的应用程序或服务的本地容器在标准化环境中工作，从而简化了开发的生命周期。 容器非常适合持续集成和持续交付（CI &#x2F; CD）工作流程，请考虑以下示例方案： 您的开发人员在本地编写代码，并使用 Docker 容器与同事共享他们的工作。他们使用 Docker 将其应用程序推送到测试环境中，并执行自动或手动测试。当开发人员发现错误时，他们可以在开发环境中对其进行修复，然后将其重新部署到测试环境中，以进行测试和验证。测试完成后，将修补程序推送给生产环境，就像将更新的镜像推送到生产环境一样简单。 (2) 响应式部署和扩展-Docker 是基于容器的平台，允许高度可移植的工作负载。Docker 容器可以在开发人员的本机上，数据中心的物理或虚拟机上，云服务上或混合环境中运行。 Docker 的可移植性和轻量级的特性，还可以使您轻松地完成动态管理的工作负担，并根据业务需求指示，实时扩展或拆除应用程序和服务。 (3) 在同一硬件上运行更多工作负载-Docker 轻巧快速。它为基于虚拟机管理程序的虚拟机提供了可行、经济、高效的替代方案，因此您可以利用更多的计算能力来实现业务目标。Docker 非常适合于高密度环境以及中小型部署，而您可以用更少的资源做更多的事情。 2、 虚拟化技术和容器化技术 虚拟化技术特点：1.资源占用多 2.冗余步骤多 3.启动很慢 容器化技术：容器化技术不是模拟的一个完整的操作系统 虚拟机非常笨重，而docker十分小巧。 比较Docker和虚拟机的不同： 传统虚拟机： 虚拟出硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件。 Docker容器 ： Docker容器内的应用直接运行在宿主机的内容，容器是没有自己的内核的，也没有虚拟硬件。 每个容器都是相互隔离的，每个容器都有属于自己的文件系统，互不影响。 DevOps (Dev:开发，Ops:运维) 容器化带来的好处： 应用更快速的交付和部署-传统：一堆帮助文档，安装程序-Docker :打包镜像发布测试，一键运行 更便捷的升级和扩缩容-使用了Docker之后，我们部署应用就和搭积木一样！-项目打包为一个镜像，扩展服务器A !服务器B 更简单的系统运维-在容器化之后，我们的开发，测试环境都是高度一致的. 更高效的计算资源利用：-Docker是内核级别的虚拟化，可以再一个物理机上可以运行很多的容器实例！服务器的性能可以被压榨到极致。 3、 Docker的基本组成 Docker的基本组成图如下： Client:客户端 DOCKER_HOST:docker的主机（服务器） Registry: 远程仓库 image-20230406171444126 基本组成 镜像(image ):-docker镜像就好比是一个模板，可以通过这个模板来创建容器服务，tomcat镜像&#x3D;&#x3D;&gt; run &#x3D;&#x3D;&gt; tomcatOI容器(提供服务器)，通过这个镜像可以创建多个容器(最终服务运行或者项目运行就是在容器中的). 开发人员 打jar包带上环境（这里的环境称为镜像） 容器(container ):-Docker用容器技术，独立运行Y或者一个组应用，通过镜像来创建的。启动，停止，删除，基本命令！目前就可以把这个容器理解为就是一个简易的linux系统 镜像启动后出现容器 （镜像相当于类，容器相当于实例。一个镜像可以创建多个容器） 仓库(repository ):-仓库就是存放镜像的地方！仓库分为公有仓库和私有仓库！Docker Hub (默认是国外的) 4、 Docker的安装在 CentOS | 上安装 Docker 引擎Docker 文档 环境准备 Linux CentOS7 1、查看系统的内核：uname -r 系统内核版本为3.10.0 [root@192 ~]# uname -r 3.10.0-1160.el7.x86_64 ​ 2、查看系统配置cat /etc/os-release [root@192 ~]# cat /etc/os-release NAME=&quot;CentOS Linux&quot; VERSION=&quot;7 (Core)&quot; ID=&quot;centos&quot; ID_LIKE=&quot;rhel fedora&quot; VERSION_ID=&quot;7&quot; PRETTY_NAME=&quot;CentOS Linux 7 (Core)&quot; ANSI_COLOR=&quot;0;31&quot; CPE_NAME=&quot;cpe:/o:centos:centos:7&quot; HOME_URL=&quot;https://www.centos.org/&quot; BUG_REPORT_URL=&quot;https://bugs.centos.org/&quot; CENTOS_MANTISBT_PROJECT=&quot;CentOS-7&quot; CENTOS_MANTISBT_PROJECT_VERSION=&quot;7&quot; REDHAT_SUPPORT_PRODUCT=&quot;centos&quot; REDHAT_SUPPORT_PRODUCT_VERSION=&quot;7&quot; ​ 卸载旧版本 旧版本的 Docker 被称为 或 .如果已安装这些项，请将其以及关联的依赖项一起卸载。 [root@192 ~]# sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine ​ 4.1 开始安装 Docker的安装步骤 1、下载需要的安装包 yum install -y yum-utils ​ 2、设置阿里云的Docker镜像仓库 yum-config-manager \\ --add-repo \\ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo ​ 3、更新yum软件包索引 yum makecache fast ​ 4、安装docker相关的配置 docker-ce 是社区版，docker-ee 企业版 yum install docker-ce docker-ce-cli containerd.io ​ 出现了completed（或 完毕！）即安装成功。 5、启动Docker # 启动Docker systemctl start docker # 查看当前版本号，是否启动成功 docker version # 设置开机自启动 systemctl enable docker ​ 4.2 hello-world镜像测试1、下载hello-world镜像进行测试 docker run hello-world ​ [root@192 ~]# clear [root@192 ~]# docker run hello-world Unable to find image &#39;hello-world:latest&#39; locally //本地没在到 hello-world 镜像 latest: Pulling from library/hello-world // pull 远程拉取 hello-world 镜像 2db29710123e: Pull complete // pull完成 Digest: sha256:507ecde44b8eb741278274653120c2bf793b174c06ff4eaa672b713b3263477b Status: Downloaded newer image for hello-world:latest Hello from Docker! //运行成功 This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/ For more examples and ideas, visit: https://docs.docker.com/get-started/ ​ 2、查看下载的hello-world镜像 [root@192 ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE hello-world latest feb5d9fea6a5 4 months ago 13.3kB //hello-world镜像 ​ Docker的卸载 1、卸载依赖 yum remove docker-ce docker-ce-cli containerd.io ​ 2、删除资源 ./var/lib/docker是docker的默认工作路径 rm -rf /var/lib/docker ​ 5、配置阿里云镜像加速本地机器无法使用 1、进入阿里云官网，搜索容器镜像服务 image-20230406171456451 2、同时执行官方的命令 sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39; &#123; &quot;registry-mirrors&quot;: [&quot;https://2y5oty1p.mirror.aliyuncs.com&quot;] &#125; EOF sudo systemctl daemon-reload sudo systemctl restart docke ​ 3、查看配置命令docker info，配置成功- image-20230406171511070 6、Docker原理6.1 Docker容器运行流程启动一个容器，docker run的运行流程如下图： image-20230406171517262 6.2 底层原理Docker是一个Client-Server（客户端-服务器）结构的系统，Docker的守护进程运行在主机上，通过Socker从客户端访问！Docker Server(服务器)接收到Docker-Client(客户端)的指令，就会执行这个指令！ image-20230406171533139 Docker为什么比VMWare(虚拟机)快？ 1、Docker比虚拟机更少的抽象层 2、docker利用宿主机的内核，而VM需要的是Guest OS（虚拟机操作系统） image-20230406171547989 Docker新建一个容器的时候，不需要像虚拟机一样重新加载一个操作系统内核，直接利用宿主机的操作系统，而虚拟机是需要加载Guest OS（虚拟机操作系统）。Docker和VM的对比如下： image-20230406171551174 7、Docker常用命令命令的帮助文档地址:https://docs.docker.com/engine/reference/commandline/docker/ 7.1 全部命令[root@192 ~]# docker --help Usage: docker [OPTIONS] COMMAND // docker [选项] 命令 A self-sufficient runtime for containers //翻译：容器的自给自足运行时 ​​ Options:【选项】​ –config string &#x2F;&#x2F;客户端配置文件的位置 (default “&#x2F;root&#x2F;.docker”)​ -c, –context string &#x2F;&#x2F;用于连接到守护进程的上下文的名称(覆盖DOCKER_HOST env变量和默认上下文设置 “docker context use”)​ -D, –debug &#x2F;&#x2F;启用调试模式​ -H, –host list &#x2F;&#x2F;守护进程 socket(s) 连接​ -l, –log-level string &#x2F;&#x2F;设置日志级别 (“debug”|”info”|”warn”|”error”|”fatal”) (default “info”)​ –tls &#x2F;&#x2F;使用 TLS; 隐含 –tlsverify​ –tlscacert string &#x2F;&#x2F;仅由此CA签名的信任证书(default “&#x2F;root&#x2F;.docker&#x2F;ca.pem”)​ –tlscert string &#x2F;&#x2F;TLS证书文件路径 (default “&#x2F;root&#x2F;.docker&#x2F;cert.pem”)​ –tlskey string &#x2F;&#x2F;TLS密钥文件的路径 (default “&#x2F;root&#x2F;.docker&#x2F;key.pem”)​ –tlsverify &#x2F;&#x2F;使用TLS并验证远端​ -v, –version &#x2F;&#x2F;打印版本信息并退出​​ Management Commands:【管理命令】​ app* Docker App (Docker Inc., v0.9.1-beta3)​ builder Manage(管理) builds​ buildx* Docker Buildx (Docker Inc., v0.7.1-docker)​ config Manage Docker configs​ container Manage containers &#x2F;&#x2F;containers:容器​ context Manage contexts​ image Manage images​ manifest Manage Docker image manifests and manifest lists &#x2F;&#x2F;管理Docker镜像清单和清单列表​ network Manage networks​ node Manage Swarm nodes &#x2F;&#x2F;群节点​ plugin Manage plugins &#x2F;&#x2F;插件​ scan* Docker Scan (Docker Inc., v0.12.0) &#x2F;&#x2F;Scan:扫描​ secret Manage Docker secrets &#x2F;&#x2F;密码​ service Manage services​ stack Manage Docker stacks​ swarm Manage Swarm &#x2F;&#x2F;群​ system Manage Docker​ trust Manage trust on Docker images &#x2F;&#x2F; trust:信任​ volume Manage volumes &#x2F;&#x2F;卷​​ Commands:【命令】​ attach &#x2F;&#x2F;将本地标准输入、输出和错误流附加到运行的容器 attach:附加​ build &#x2F;&#x2F;从Dockerfile构建一个映像​ commit &#x2F;&#x2F;根据容器的更改创建一个新镜像​ cp &#x2F;&#x2F;在容器和本地文件系统之间复制文件&#x2F;文件夹​ create &#x2F;&#x2F;创建一个新容器​ diff &#x2F;&#x2F;检查容器文件系统中文件或目录的更改​ events &#x2F;&#x2F;从服务器获取实时事件 events:事件​ exec &#x2F;&#x2F;在运行的容器中运行命令 exec:执行​ export &#x2F;&#x2F;将容器的文件系统导出为tar存档文件 export:导出​ history &#x2F;&#x2F;显示一个镜像的历史​ images &#x2F;&#x2F;镜像的列表​ import &#x2F;&#x2F;从tarball文件中导入内容以创建文件系统映像​ info &#x2F;&#x2F;显示整个系统的信息​ inspect &#x2F;&#x2F;返回Docker对象的底层信息 inspect:检查​ kill &#x2F;&#x2F;杀死一个或多个正在运行的容器​ load &#x2F;&#x2F;从tar存档文件或STDIN加载镜像​ login &#x2F;&#x2F;登录到Docker注册表​ logout &#x2F;&#x2F;从Docker注册表注销​ logs &#x2F;&#x2F;获取容器的日志​ pause &#x2F;&#x2F;暂停一个或多个容器中的所有进程 pause:暂停​ port &#x2F;&#x2F;列出容器的端口映射或特定映射​ ps &#x2F;&#x2F;容器的列表​ pull &#x2F;&#x2F;从仓库（registry）中拉取镜像或存储库​ push &#x2F;&#x2F;将镜像或存储库推送到仓库（registry）​ rename &#x2F;&#x2F;重命名一个容器​ restart &#x2F;&#x2F;重新启动一个或多个容器​ rm &#x2F;&#x2F;移除一个或多个容器​ rmi &#x2F;&#x2F;移除一个或多个镜像​ run &#x2F;&#x2F;在新容器中运行命令​ save &#x2F;&#x2F;将一个或多个镜像保存到tar存档文件(默认情况下流到STDOUT)​ search &#x2F;&#x2F;在Docker Hub搜索镜像​ start &#x2F;&#x2F;启动一个或多个停止的容器​ stats &#x2F;&#x2F;显示容器资源使用统计的实时流​ stop &#x2F;&#x2F;停止一个或多个正在运行的容器​ tag &#x2F;&#x2F;创建引用SOURCE_IMAGE的标记TARGET_IMAGE​ top &#x2F;&#x2F;显示容器的运行进程​ unpause &#x2F;&#x2F;取消暂停一个或多个容器中的所有进程 unpause:不暂停​ update &#x2F;&#x2F;更新一个或多个容器的配置​ version &#x2F;&#x2F;查看Docker版本信息​ wait &#x2F;&#x2F;阻塞直到一个或多个容器停止，然后打印它们的退出代码​​ Run ‘docker COMMAND –help’ for more information on a command. ​ 7.2 基础命令docker version #查看docker的版本信息 docker info #查看docker的系统信息,包括镜像和容器的数量 docker 命令 --help #帮助命令(可查看可选的参数) docker COMMAND --help docker --help #列出所有命令 ​ 7.3 镜像命令 拉取(下载)一个镜像 //docker pull 镜像[:tag] tag:版本（版本默认最新） docker pull mysql docker pull mysql:5.7 //指定版本 ​ [root@192 ~]# docker pull mysql Using default tag: latest latest: Pulling from library/mysql # == 分层下载，docker iamge的核心联合文件系统 == 6552179c3509: Pull complete d69aa66e4482: Pull complete 3b19465b002b: Pull complete #... Digest: sha256:92d27b8222bbcf53bc42c70ca7cd1010d6c0527efc61f14980ce77c50932bef4 # 签名 Status: Downloaded newer image for mysql:latest docker.io/library/mysql:latest #真实地址 # 下载成功 [root@192 ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE mysql latest d1dc36cf8d9e 3 days ago 519MB hello-world latest feb5d9fea6a5 4 months ago 13.3kB #等价于 docker pull mysql 等价于 docker pull docker.io/library/mysqlzlatest ​ 分层下载,比如mysql5.7 与 mysql 8.0 有层一致就不用重新下载 docker images 查看本地主机的所有镜像 [root@iZwz99sm8v95sckz8bd2c4Z ~]# docker images [镜像的仓库源 镜像的标签 镜像的id 镜像的创建时间 镜像的大小] REPOSITORY TAG IMAGE ID CREATED SIZE hello-world latest bf756fb1ae65 11 months ago 13.3kB ​​ # 可选参数​​ -a&#x2F;–all 列出所有镜像​ -q&#x2F;–quiet 只显示镜像的id ​ docker search 搜索镜像 [root@192 ~]# docker search mysql NAME DESCRIPTION STARS OFFICIAL AUTOMATED mysql MySQL is a widely used, open-source relation… 12043 [OK] mariadb MariaDB Server is a high performing open sou… 4613 [OK] mysql/mysql-server Optimized MySQL Server Docker images. Create… 901 [OK] phpmyadmin phpMyAdmin - A web interface for MySQL and M… 439 [OK] //... // STARS:收藏数 ​ 查看其可选参数 [root@192 ~]# docker search --help Usage: docker search [OPTIONS] TERM Search the Docker Hub for images Options: -f, --filter filter //根据所提供的条件过滤输出 --format string //使用Go模板的漂亮打印搜索 --limit int //搜索结果的最大数目(默认25个) --no-trunc //不截断输出 ​ 搜索收藏数大于3000的镜像 // STARS:收藏数 [root@192 ~]# docker search mysql --filter=STARS=3000 NAME DESCRIPTION STARS OFFICIAL AUTOMATED mysql MySQL is a widely used, open-source relation… 12043 [OK] mariadb MariaDB Server is a high performing open sou… 4613 [OK] ​ 在仓库搜索 https://hub.docker.com/search?q=mysql&amp;type=image image-20230406171559287 删除镜像 docker rmi -f 【镜像id】 ​ [root@192 ~]# clear [root@192 ~]# docker rmi -f feb5d9fea6a5 Untagged: hello-world:latest Untagged: hello-world@sha256:507ecde44b8eb741278274653120c2bf793b174c06ff4eaa672b713b3263477b Deleted: sha256:feb5d9fea6a5e9606aa995e879d862b825965ba48de054caab5ef356dc6b3412 ​ 删除多个镜像 docker rmi -f 【镜像id】 【镜像id】 【镜像id】 … ​ 删除所有镜像 docker rmi -f $(docker images) ​ 7.4 容器命令镜像启动后出现容器 （镜像相当于类，容器相当于实例。一个镜像可以创建多个容器） （镜像相当于你安装系统时下载的镜像文件，而容器呢就相当于你安装好的系统） 1、先拉取一个centos镜像 docker pull centos ​ [root@192 ~]# docker pull centos Using default tag: latest latest: Pulling from library/centos a1d0c7532777: Pull complete Digest: sha256:a27fd8080b517143cbbbab9dfb7c8571c40d67d534bbdee55bd6c473f432b177 Status: Downloaded newer image for centos:latest docker.io/library/centos:latest ​ 运行容器 run是新建一个容器(直接使用容器会自动退出)，start是启动一个已经存在的容器 //image：镜像名字或id docker run [可选参数] image //参数说明 --name=&quot;名字&quot; //指定容器名字 -d //后台方式运行 若没有提供服务则自动退出（停止） -it //使用交互方式运行,进入容器查看内容 -p //指定容器的端口(小写的P) -p ip:主机端口:容器端口 //配置主机端口映射到容器端口(小写的P) -p 主机端口:容器端口 -p 容器端口 -P //随机指定端口(大写的P) ​ [root@192 ~]# docker start --help // CONTAINER:容器id Usage: docker start [OPTIONS] CONTAINER:容器id [CONTAINER...] //启动一个或多个停止的容器 Options: -a, --attach //附加STDOUT/STDERR和前向信号 --detach-keys string //覆盖用于分离容器的键序列 -i, --interactive //将容器的STDIN ​ 进入容器 docker run -it centos /bin/bash ​ 容器内就是一个独立和隔离的centos环境 [root@192 ~]# docker run -it centos &#x2F;bin&#x2F;bash[root@b8f211692996 &#x2F;]# lsbin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var ​ 退出容器exit # exit 停止并退出容器（后台方式运行则仅退出） # Ctrl+P+Q 不停止容器退出 [root@b8f211692996 /]# exit exit ​ 列出容器 docker ps // 列出当前正在运行的容器 docker ps -a // 列出所有容器的运行记录 docker ps -n=? // 显示最近创建的n个容器 docker ps -q // 只显示容器的编号 ​ [root@192 ~]# docker ps #列出当前正在运行的容器 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES b8f211692996 centos &quot;/bin/bash&quot; 14 minutes ago Up 14 minutes zealous_lichterman [root@192 ~]# docker ps -a # 列出所有容器的运行记录 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 0f009b5ce7d7 centos &quot;/bin/bash&quot; 3 minutes ago Exited (0) About a minute ago cool_lovelace b8f211692996 centos &quot;/bin/bash&quot; 14 minutes ago Up 14 minutes zealous_lichterman 9d6d432cfc32 feb5d9fea6a5 &quot;/hello&quot; 19 hours ago Exited (0) 19 hours ago wizardly_booth 53ef5a5247a6 feb5d9fea6a5 &quot;/hello&quot; 19 hours ago Exited (0) 19 hours ago eloquent_chatterjee ​ 停止容器 [root@192 ~]# docker stop --help // CONTAINER：容器(但要用容器id才行) Usage: docker stop [OPTIONS] CONTAINER [CONTAINER...] //翻译：停止一个或多个正在运行的容器 Stop one or more running containers Options: -t, --time int //在杀死它之前等待几秒钟 (default 10) ​ [root@192 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES eb679ca2e254 centos &quot;/bin/bash&quot; 4 minutes ago Up 4 minutes blissful_robinson b8f211692996 centos &quot;/bin/bash&quot; 26 minutes ago Up 26 minutes zealous_lichterman [root@192 ~]# docker stop centos Error response from daemon: No such container: centos [root@192 ~]# docker stop eb679ca2e254 eb679ca2e254 [root@192 ~]# docker stop b8f211692996 b8f211692996 [root@192 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ​ 删除容器 docker rm 容器id # 删除指定的容器,不能删除正在运行的容器 docker rm -f 容器id # 强制删除，包括正在运行的容器 docker rm -f $(docker ps -aq) # 删除所有的容器 docker ps -a -q|xargs docker rm # 删除所有的容器 ​ 启动和停止容器 docker start 容器id #启动容器 docker restart 容器id #重启容器 docker stop 容器id #停止当前运行的容器 docker kill 容器id #强制停止当前容器 ​ 7.5 其他常用命令 日志的查看 [root@192 ~]# docker logs --help Usage: docker logs [OPTIONS] CONTAINER //获取容器的日志 Options: --details //显示提供给日志的额外细节 -f, --follow //跟踪日志输出 --since string //显示自定义时间戳以来的日志 (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes) -n, --tail string 、、从日志的末尾显示的行数(default &quot;all&quot;) -t, --timestamps //显示时间戳 --until string //在时间戳之前显示日志 (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes) //常用： docker logs -tf 【容器id】 docker logs --tail number 【容器id】 //num为要显示的日志条数 ​ #docker容器后台运行，必须要有一个前台的进程，否则会自动停止 #编写shell脚本循环执行，使得centos容器保持运行状态 [root@192 ~]# docker run -d centos /bin/sh -c &quot;while true;do echo hi;sleep 5;done&quot; 2b8ed9e4dcb655547b3c2aa28cd849179190ec03ecca2aabf9c7a44155b13097 [root@192 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 2b8ed9e4dcb6 centos &quot;/bin/sh -c &#39;while t…&quot; 3 seconds ago Up 2 seconds beautiful_elion [root@192 ~]# docker logs -tf --tail 10 2b8ed9e4dcb6 2022-01-31T02:32:36.215664841Z hi 2022-01-31T02:32:41.224798220Z hi 2022-01-31T02:32:46.227706348Z hi 2022-01-31T02:32:51.243402617Z hi 2022-01-31T02:32:56.257314943Z hi 2022-01-31T02:33:01.284139739Z hi 2022-01-31T02:33:06.294600809Z hi # Ctrl + Shift + c 退出 ​ 查看容器中进程信息 docker top 容器id ​ [root@192 ~]# docker top 2b8ed9e4dcb6 UID PID PPID C STIME TTY TIME CMD root 11156 11135 0 11:31 ? 00:00:00 /bin/sh -c while true;do echo hi;sleep 5;done root 11886 11156 0 11:43 ? 00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 5 ​ 查看容器的元数据 docker inspect 容器id ​ [root@192 ~]# docker inspect 2b8ed9e4dcb6 # 显示的id是 真实id 的 缩写 [ &#123; &quot;Id&quot;: &quot;2b8ed9e4dcb655547b3c2aa28cd849179190ec03ecca2aabf9c7a44155b13097&quot;,# 真实id &quot;Created&quot;: &quot;2022-01-31T02:32:35.769096414Z&quot;, &quot;Path&quot;: &quot;/bin/sh&quot;, &quot;Args&quot;: [ &quot;-c&quot;, &quot;while true;do echo hi;sleep 5;done&quot; ], &quot;State&quot;: &#123; &quot;Status&quot;: &quot;running&quot;, &quot;Running&quot;: true, &quot;Paused&quot;: false, ​​ 进入当前正在运行的容器 因为通常我们的容器都是使用后台方式来运行的，有时需要进入容器修改配置 // 方式一 docker exec -it 【容器id】 /bin/bash // 方式二 docker attach 【容器id】 ​ 方式一：进入容器后开启一个新的终端，可以在里面操作 （常用） [root@192 ~]# docker exec -it 2b8ed9e4dcb6 /bin/bash [root@2b8ed9e4dcb6 /]# ls bin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var # 查看进程 [root@48c706c3a876 /]# ps -ef UID PID PPID C STIME TTY TIME CMD root 1 0 0 03:38 ? 00:00:00 /bin/sh -c while true;do echo hi;sleep 5;done root 12 0 0 03:38 pts/0 00:00:00 /bin/bash root 28 1 0 03:38 ? 00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 5 root 29 12 0 03:38 pts/0 00:00:00 ps -ef ​ 方式二：进入容器正在执行的终端，不会启动新的进程 [root@192 ~]# docker attach 2b8ed9e4dcb6 hi hi hi //... ​ 拷贝操作 （还可以使用 -v 卷技术） 拷贝操作的命令如下： //将容器的文件拷贝到主机中 docker cp 容器id:容器内路径 目的主机路径 //docker cp 7b605b457f23:/home/Hello.txt hello.txt //将宿主机的文件拷贝到容器中 docker cp 目的主机路径 容器id:容器内路径 ​ 将容器的文件拷贝到主机中 [root@192 ~]# docker run -it centos &#x2F;bin&#x2F;bash[root@7b605b457f23 &#x2F;]# cd home&#x2F;[root@7b605b457f23 home]# touch Hello.txt[root@7b605b457f23 home]# lsHello.txt ​ 1、在容器中新建文件 [root@iZwz99sm8v95sckz8bd2c4Z ~]# docker exec -it c703b5b1911f /bin/bash [root@c703b5b1911f /]# cd home [root@c703b5b1911f home]# ls #touch 新建文件 [root@c703b5b1911f home]# touch test.java [root@c703b5b1911f home]# ls test.java [root@c703b5b1911f home]# exit exit [root@iZwz99sm8v95sckz8bd2c4Z ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES c703b5b1911f centos &quot;/bin/sh -c &#39;while t…&quot; 35 minutes ago Up 35 minutes pedantic_banach [root@iZwz99sm8v95sckz8bd2c4Z ~]# docker cp c703b5b1911f:/home/test.java /home [root@iZwz99sm8v95sckz8bd2c4Z ~]# ls /home hai pan test.java [root@7b605b457f23 home]# exit exit ​ 2.copy文件 [root@192 ~]# cd 桌面 [root@192 桌面]# ls Kuang [root@192 桌面]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES [root@192 桌面]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7b605b457f23 centos &quot;/bin/bash&quot; 3 minutes ago Exited (0) 2 minutes ago tender_burnell # ... [root@192 桌面]# docker cp 7b605b457f23:/home/Hello.txt hello.txt [root@192 桌面]# ls hello.txt Kuang # 成功 ​ 常用命令小节 image-20230406171613580 8、docker 练习8.1 部署Nginx（Nginx：是一个高性能的HTTP和反向代理web服务器） 1、搜索nginx https://hub.docker.com/\\_/nginx [root@192 ~]# docker search nginx NAME DESCRIPTION STARS OFFICIAL AUTOMATED nginx Official build of Nginx. 16232 [OK] //... ​ 2、拉取nginx [root@192 ~]# docker pull nginx Using default tag: latest latest: Pulling from library/nginx 5eb5b503b376: Pull complete 1ae07ab881bd: Pull complete 78091884b7be: Pull complete 091c283c6a66: Pull complete 55de5851019b: Pull complete b559bad762be: Pull complete Digest: sha256:2834dc507516af02784808c5f48b7cbe38b8ed5d0f4837f16e78d00deb7e7767 Status: Downloaded newer image for nginx:latest docker.io/library/nginx:latest [root@192 ~]# docker images # 下载成功 REPOSITORY TAG IMAGE ID CREATED SIZE nginx latest c316d5a335a5 4 days ago 142MB ​ 3、启动nginx镜像 [root@192 ~]# docker run -d --name nginx01 -p 8801:80 nginx b93af0c28d2baca7b03dc34eaf6d0b8778abdb989e091d9461351a48b12fb706 [root@192 ~]# docker ps #运行成功 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES b93af0c28d2b nginx &quot;/docker-entrypoint.…&quot; 13 seconds ago Up 11 seconds 0.0.0.0:8801-&gt;80/tcp, :::8801-&gt;80/tcp nginx01 ​​ -p 8801:80通过端口映射将 主机的8801端口 与 容器的80端口 连通，从而暴露 容器的80端口 4、测试连接nginx [root@192 ~]# curl localhost:8801 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Welcome to nginx!&lt;/title&gt; &lt;style&gt; html &#123; color-scheme: light dark; &#125; body &#123; width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Welcome to nginx!&lt;/h1&gt; # 连接成功 &lt;p&gt;If you see this page, the nginx web server is successfully installed and working. Further configuration is required.&lt;/p&gt; &lt;p&gt;For online documentation and support please refer to &lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt; Commercial support is available at &lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; ​ windows（外网）上访问成功 image-20230406171622920 5、进入nginx容器 [root@192 ~]# docker exec -it nginx01 /bin/bash root@b93af0c28d2b:/# whereis nginx nginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx ​ 8.2 部署Tomcat1、搜索tomcat [root@192 ~]# docker search tomcat NAME DESCRIPTION STARS OFFICIAL AUTOMATED tomcat Apache Tomcat is an open source implementati… 3248 [OK] ​ 2、拉取tomcat docker pull tomcat:9.0 ​ [root@192 ~]# docker pull tomcat:9.0 9.0: Pulling from library/tomcat 0c6b8ff8c37e: Pull complete # ... Digest: sha256:c1cbd0fcc6d937c79d9f84ad6747b8ace4846a7ddf44f9344695c61f7443fa02 Status: Downloaded newer image for tomcat:9.0 docker.io/library/tomcat:9.0 ​ 3、启动Tomcat docker run -d -p 8002:8080 --name tomcat01 tomcat ​ docker 自动给我下载最新版（启动成功） [root@192 ~]# docker run -d -p 8002:8080 –name tomcat01 tomcatUnable to find image ‘tomcat:latest’ locally # 没有发现最新版latest: Pulling from library&#x2F;tomcat0c6b8ff8c37e: Already exists # 下载Tomcat9.0时已下载 …bc5c573a9ab7: Pull complete # 补充下载f9f34f3a3d27: Pull completeDigest: sha256:28ef9f9a08f812de2f7f1de9076f39c911e5f92615ea168693964fbc2247701cStatus: Downloaded newer image for tomcat:latestb55631abdbffbe3bf156050846e71f03834f8984bf4fe96952ddda46e209967b #启动成功，容器id ​ 启动成功 [root@192 ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESb55631abdbff tomcat “catalina.sh run” 33 seconds ago Up 30 seconds 0.0.0.0:8002-&gt;8080&#x2F;tcp, :::8002-&gt;8080&#x2F;tcp tomcat01 ​ 4、测试，windows(外网)访问成功- image-20230406171634897 5、进入tomcat容器 docker exec -it nginx01 /bin/bash ​ [root@192 ~]# docker exec -it tomcat01 /bin/bash root@b55631abdbff:/usr/local/tomcat# ls BUILDING.txt LICENSE README.md RUNNING.txt conf logs temp webapps.dist CONTRIBUTING.md NOTICE RELEASE-NOTES bin lib native-jni-lib webapps work ​ (容器中的命令是少了,阿里云镜像默认下载的是最小的镜像，保证最小的运行环境。) 6、部署网站 在webapps.dist文件在个tomcat网站代码 root@b55631abdbff:/usr/local/tomcat# cd webapps.dist/ root@b55631abdbff:/usr/local/tomcat/webapps.dist# ls ROOT docs examples host-manager manager root@b55631abdbff:/usr/local/tomcat/webapps.dist# cd examples/ root@b55631abdbff:/usr/local/tomcat/webapps.dist/examples# ls META-INF WEB-INF index.html jsp servlets websocket root@b55631abdbff:/usr/local/tomcat/webapps.dist/examples# cat index.html &lt;!-- # ... --&gt; &lt;!DOCTYPE HTML&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Apache Tomcat Examples&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; &lt;h3&gt;Apache Tomcat Examples&lt;/H3&gt; &lt;p&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;servlets&quot;&gt;Servlets examples&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;jsp&quot;&gt;JSP Examples&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;websocket/index.xhtml&quot;&gt;WebSocket Examples&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; ​ 将webapps.dist的网站代码copy到webapps中让服务器运行 root@b55631abdbff:/usr/local/tomcat# cp -r webapps.dist/* webapps ​ 测试，windows(外网)访问成功 image-20230406171640413 思考问题 每次部署项目都要进入容器是不是太麻烦，可以通过修改外部影响容器内部就好了。 8.3 部署 ElasticSearch+Kibana 部署难点 ElasticSearch是什么： ElasticSearch从入门到精通，史上最全（持续更新，未完待续，每天一点点）_Null的博客-CSDN博客 ElasticSearch是 智能搜索，分布式的搜索引擎 ElasticSearch暴露的端口多、十分耗内存、数据一定要放安全目录 ElasticSearch是一个日志切割管理的工具 部署 ElasticSearch 正常安装ElasticSearch后太消耗内存,导致Linux太卡了，需要添加 -e ES_JAVA_OPTS=&quot;-Xms128m -Xmx512m&quot; 配置ElasticSearch的虚拟机占用的内存大小。 1、安装并启动 docker run -d --name elasticsearch01 -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms128m -Xmx512m&quot; elasticsearch:7.6.2 ​ [root@192 ~]# docker run -d --name elasticsearch01 -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms128m -Xmx512m&quot; elasticsearch:7.6.2 Unable to find image &#39;elasticsearch:7.6.2&#39; locally 7.6.2: Pulling from library/elasticsearch ab5ef0e58194: Pull complete c4d1ca5c8a25: Pull complete 941a3cc8e7b8: Pull complete 43ec483d9618: Pull complete c486fd200684: Pull complete 1b960df074b2: Pull complete 1719d48d6823: Pull complete Digest: sha256:1b09dbd93085a1e7bca34830e77d2981521a7210e11f11eda997add1c12711fa Status: Downloaded newer image for elasticsearch:7.6.2 c097654fbab08d26f803e150b54c471336a9ba24283595ba64f33d87aba33c62 [root@192 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES c097654fbab0 elasticsearch:7.6.2 &quot;/usr/local/bin/dock…&quot; 2 minutes ago Up 2 minutes 0.0.0.0:9200-&gt;9200/tcp, :::9200-&gt;9200/tcp, 0.0.0.0:9300-&gt;9300/tcp, :::9300-&gt;9300/tcp elasticsearch01 ​ 2、测试连接ElasticSearch [root@192 ~]# curl localhost:9200 &#123; &quot;name&quot; : &quot;c097654fbab0&quot;, &quot;cluster_name&quot; : &quot;docker-cluster&quot;, &quot;cluster_uuid&quot; : &quot;HtBpQlrcR_mI-Suj8qzW8w&quot;, &quot;version&quot; : &#123; &quot;number&quot; : &quot;7.6.2&quot;, &quot;build_flavor&quot; : &quot;default&quot;, &quot;build_type&quot; : &quot;docker&quot;, &quot;build_hash&quot; : &quot;ef48eb35cf30adf4db14086e8aabd07ef6fb113f&quot;, &quot;build_date&quot; : &quot;2020-03-26T06:34:37.794943Z&quot;, &quot;build_snapshot&quot; : false, &quot;lucene_version&quot; : &quot;8.4.0&quot;, &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;, &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot; &#125;, &quot;tagline&quot; : &quot;You Know, for Search&quot; &#125; ​ 3、查看资源占用情况 docker stats ​ [root@192 ~]# docker stats CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS c097654fbab0 elasticsearch01 0.25% 420MiB / 2.406GiB 17.05% 3.71kB / 2.75kB 0B / 1.74MB 44 ​ Kibana Kibana 是一款开源的数据分析和可视化平台，它是 Elastic Stack 成员之一，设计用于和 Elasticsearch 协作。您可以使用 Kibana 对 Elasticsearch 索引中的数据进行搜索、查看、交互操作。您可以很方便的利用图表、表格及地图对数据进行多元化的分析和呈现。 9、图形化管理工具Portaniner安装Portaniner是Docker的图形化管理工具，类似的工具还有Rancher(CI&#x2F;CD再用) （Portaniner平时比较少用） 1、下载运行Portaniner镜像并运行，设置本机映射端口为8088 docker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer ​ [root@192 ~]# docker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer Unable to find image &#39;portainer/portainer:latest&#39; locally latest: Pulling from portainer/portainer 94cfa856b2b1: Pull complete 49d59ee0881a: Pull complete a2300fd28637: Pull complete Digest: sha256:fb45b43738646048a0a0cc74fcee2865b69efde857e710126084ee5de9be0f3f Status: Downloaded newer image for portainer/portainer:latest b3b421cc14a11d7a4119eb8b3144c8f4796d7ad078ff9e1ecbdf8044b3e1a4cd [root@192 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES b3b421cc14a1 portainer/portainer &quot;/portainer&quot; 29 seconds ago Up 27 seconds 0.0.0.0:8088-&gt;9000/tcp, :::8088-&gt;9000/tcp flamboyant_cray ​ 2、windows(外网)访问成功 (1) 第一次登录设置admin用户的密码 (测试中为了好记可以设置成12345678) image-20230406185947485 (2) 选择Local(本地) image-20230406185950988 # 安装时要加上 -v &quot;/var/run/docker.sock:/var/run/docker.sock&quot; ​ (3) 主页 image-20230406185955884 （4） 查看镜像列表 image-20230406190000461 10、Docker镜像详解10.1 什么是镜像 镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需要的所有内容，包括代码，运行时（一个程序在运行或者在被执行的依赖）、库，环境变量和配置文件。 所以应用直接打包镜像，就可以用于运行 获得镜像的途径： - 自己制作镜像DockerFile - 远程仓库下载 - 别人copy给你 ​ 10.2 联合文件系统 UnionFS （联合文件系统） Docker的镜像实际上由一层一层的文件系统组成(下载镜像时分层下载可印证)，这种层级的文件系统是UnionFS联合文件系统。 image-20230406190005007 UnionFS （联合文件系统）是一种分层、轻量级并且高性能的文件系统，它支持对文研系统的修改- 作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下，Union文件系统是Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。- 特性：一次同时加载多个文件系统，但从外面看起来，只能看到外文件系统，联合加载会把各层文件系统叠加起来,这样最终的文件系统会包含所有底层的文件和目录 作用：比如tomcat下载了centos,则mysql就不用下载了。相同层可复用 思考：为什么Docke也像要采用这种分层的结构呢？-最大的好处，莫过于是资源共享了 ！比如有多个镜像都从相同的Base镜像构建而来，那么宿主机只需在磁盘上保留一份base镜像，同时内存中也只高要加载一份base镜像,这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享.-查看镜像分层的方式可以通过docker image inspect命令! docker image inspect redis ​ [root@192 ~]# docker image inspect redis [ &#123; &quot;Id&quot;: &quot;sha256:f1b6973564e91aecb808142499829a15798fdc783a30de902bb0c4133fee19ad&quot;, &quot;RepoTags&quot;: [ &quot;redis:latest&quot; ], # ... &quot;RootFS&quot;: &#123; &quot;Type&quot;: &quot;layers&quot;, &quot;Layers&quot;: [ # 这里指示了分层信息 &quot;sha256:7d0ebbe3f5d26c1b5ec4d5dbb6fe3205d7061f9735080b0162d550530328abd6&quot;, &quot;sha256:92b6c42121d80f330a80c20afa928e19c31ab3a5fe7cf9c91517fa8cc468b33f&quot;, &quot;sha256:65845b69eb5c3291dd610ddf2f61f524ab206f9754900d9f3512fcbc2d38604f&quot;, &quot;sha256:7048818d16571a765e2b0cf82c20d627abebccec73ac3d7b7973501000e6e05d&quot;, &quot;sha256:c61d5cbf862134aad34822e96d9efc009cca19ad604419cb3f8cf8857eb18372&quot;, &quot;sha256:ff503dae4eb68eb7a71095e5b1b1b123f42d37e923222038b64fba5a80b13307&quot; ] &#125;, &quot;Metadata&quot;: &#123; &quot;LastTagTime&quot;: &quot;0001-01-01T00:00:00Z&quot; &#125; &#125; ] ​ 所有的Docker镜像都起始于一个基础镜像层，当进行修改或增加新的内容时，就会在当前镜像层之上,创建新的镜像层.-举一个简单的例子，假如基于Ubuntu Linux 16.04创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加Python包，-就会在基础镜像层之上创建第二个镜像层;如果继续添加一个安全补丁，就会创建第三个镜像层。-该镜像当前已经包含3个镜像层，如下图所示（这只是一个用于演示的很简单的例子）. image-20230406190010300 在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合，理解这一点非常里要.下图中举了一个简单的例子，每个镜像层包含3个文件，而镜像包含了来自两个镜像层的6个文件. image-20230406190014018 这种情况下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新镜像层添加到镜像当中。- Docker通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统。-Linux上可用的存储引擎有AUFS、Overlay2. Device hopper、Btrfs以及ZFS。顾名思义，每种存储引擎都基于Linux中对应的-文件系统或者块设备技术，并且每种存储引擎都有其独有的性能特点。 image-20230406190018074 Docker在Windows上仅支持windowsfilter 一种存储引擎，该引擎基于NTFS文件系统之上实现了分层和CoW［ 1］ 0-下图展示了与系统显示相同的三层镜像。所有镜像层堆叠并合并，对外提供统一的视图。- image-20230406190021861 特点 Docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部！这一层就是我们通常说的容器层，容器之下的都叫镜像层！ image-20230406190024959 11、提交自己镜像使用docker commit命令提交容器成为一个新的版本 docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器id 目标镜像名:[TAG] ​ 由于默认的Tomcat镜像的webapps文件夹中没有任何内容，需要从webapps.dist中拷贝文件到webapps文件夹。下面自行制作镜像：就是从webapps.dist中拷贝文件到webapps文件夹下，并提交该镜像作为一个新的镜像。使得该镜像默认的webapps文件夹下就有文件。具体步骤如下： 1、启动Tomcat // 启动Tomcat 一定要配置端口映射 `-p 8080:8080` docker run -it -p 8080:8080 tomcat //开多一个终端 // 进入容器 docker exec -it d55df6cdafe8 /bin/bash ​ 2、制作（修改）镜像，拷贝cp -r webapps.dist/* webapps root@d55df6cdafe8:/usr/local/tomcat# cd webapps root@d55df6cdafe8:/usr/local/tomcat/webapps# ls root@d55df6cdafe8:/usr/local/tomcat/webapps# cd .. root@d55df6cdafe8:/usr/local/tomcat# ls BUILDING.txt LICENSE README.md RUNNING.txt conf logs temp webapps.dist CONTRIBUTING.md NOTICE RELEASE-NOTES bin lib native-jni-lib webapps work root@d55df6cdafe8:/usr/local/tomcat# cp -r webapps.dist/* webapps root@d55df6cdafe8:/usr/local/tomcat# cd webapps root@d55df6cdafe8:/usr/local/tomcat/webapps# ls ROOT docs examples host-manager manager ​ 3、windows访问 image-20230406190029165 4、提交自己镜像,提交到本地（之后再发布到远程仓库） //docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器id 目标镜像名:[TAG] docker commit -m=&quot;add webapps app&quot; -a=&quot;一个平凡de人&quot; 6df1e2c4a350 tomcat02:1.0 ​ [root@192 ~]# docker commit -m=&quot;add webapps app&quot; -a=&quot;一个平凡de人&quot; 6df1e2c4a350 tomcat02:1.0 sha256:e699f08da20e848d7a9bd7c8953b63500abe1ea6a6605838dc9f97876857c229 [root@192 ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE tomcat02 1.0 e699f08da20e 35 seconds ago 684MB # 自己镜像 tomcat latest 413407dddb5e 4 days ago 680MB redis latest f1b6973564e9 5 days ago 113MB portainer/portainer latest 580c0e4e98b0 10 months ago 79.1MB elasticsearch 7.6.2 f29a1ee41030 22 months ago 791MB ​ 5、测试 （1）启动 docker run -it -p 8080:8080 tomcat02:1.0 ​ （2）windows访问，测试成功 image-20230406190033178 小节 如果你想要保存当前容器的状态，就可以通过commit来提交，获得一个镜像,就好比我们以前学习VM时候，快照保存虚拟机状态，之后可状态回滚！ 12、容器数据卷 docker的理念回顾 将应用和环境打包成一个镜像 数据？如果数据都在容器中，那么我们容器删除，数据就会丢失！需求：数据可以持久化 MySQL，容器删除了，删库跑路！需求：MySQL数据可以存储在本地！ 容器之间可以有一个数据共享的技术！Docker容器中产生的数据，同步到本地！ 这就是卷技术！目录的挂载，将我们容器内的目录，挂载到Linux上面！ image-20230406190037262 使用卷技术的原因：容器的持久化和同步操作！容器间也是可以数据共享的！ 12.1 使用数据卷挂载后 主机目录和容器目录共享一个目录资源，容器目录也可以理解为是主机目录的快捷方式 方式一 ：直接使用命令挂载 -v //-v, --volume list 绑定挂载卷 docker run -it -v 主机目录:容器目录 -p 主机端口:容器内端口 //通过 查看挂载 docker inspect 容器id ​ 1、挂载并进入命令行/bin/bash docker run -it -v /home/ceshi:/home centos /bin/bash ​ [root@192 ~]# docker run -it -v /home/ceshi:/home centos /bin/bash [root@a40aea147d6d /]# cd /home [root@a40aea147d6d home]# ls # 空 ​ [root@192 ~]# cd /home [root@192 home]# ls ceshi # 找到ceshi目录 ​ 2、查看挂载 docker inspect 【容器id】 ​ [root@192 home]# docker inspect a40aea147d6d # ... &quot;Mounts&quot;: [ &#123; &quot;Type&quot;: &quot;bind&quot;, &quot;Source&quot;: &quot;/home/ceshi&quot;, # 挂载成功 主机目录 &quot;Destination&quot;: &quot;/home&quot;, # 挂载成功 容器目录 &quot;Mode&quot;: &quot;&quot;, &quot;RW&quot;: true, &quot;Propagation&quot;: &quot;rprivate&quot; &#125; ], # ... ​ 3、测试挂载 挂载后 主机目录和容器目录共享一个目录资源，容器目录也可以理解为是主机目录的快捷方式 [root@a40aea147d6d home]# touch test.txt # 创建文件 [root@a40aea147d6d home]# ls test.txt ​ [root@192 home]# ls ceshi [root@192 home]# cd ceshi/ [root@192 ceshi]# ls test.txt # 挂载成功，也test.txt文件 # 向文件写入数据 [root@192 ceshi]# echo &quot;This is test data&quot; &gt; test.txt [root@192 ceshi]# cat test.txt This is test data ​ # 容器内目录也有数据 [root@a40aea147d6d home]# cat test.txt This is test data ​ 就算容器关闭，数据依旧一致。 12.2 MySQL同步数据实战1、获取mysql镜像 docker pull mysql ​ 2、运行容器,挂载倆个数据目录，配置密码-e MYSQL_ROOT_PASSWORD=password # -e 环境配置，配置mysql密码 docker run -d -p 3306:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql ​ [root@192 ~]# docker run -d -p 3306:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql 05574ce7407c7745ee28951f5ccc032062b83b9d9486ef6062a1d321df2ad0c8 ​ # 启动成功之后，我们在本地使用sqlyog来测试一下 # sqlyog-连接到服务器的3306--和容器内的3306映射 # 在本地测试创建一个数据库，查看一下我们映射的路径是否ok！ ​ 3、测试连接，在windows上用数据库连接工具测试连接mysql容器· image-20230406190044355 连接成功 image-20230406190048110 4、文件目录映射成功 [root@192 mysql]# cd /home/mysql/ [root@192 mysql]# ls conf data [root@192 mysql]# cd data [root@192 data]# ls auto.cnf ca-key.pem #ib_16384_0.dblwr ib_logfile0 mysql public_key.pem undo_001 binlog.000001 ca.pem #ib_16384_1.dblwr ib_logfile1 mysql.ibd server-cert.pem undo_002 binlog.000002 client-cert.pem ib_buffer_pool ibtmp1 performance_schema server-key.pem binlog.index client-key.pem ibdata1 #innodb_temp private_key.pem sys ​ 5、linux中，一个数据库对应一个目录，一个数据表对应一个文件 （1）创建数据库 image-20230406190051764 （2）成功看到test目录 image-20230406190057738 （3）创建数据表 image-20230406190102699 （4）成功看到文件 容器数据持久化 假设我们将容器删除，发现我们挂载到本地的数据卷依旧没有丢失，这就实现了容器数据持久化功能。 12.3 具名挂载和匿名挂载卷指容器被挂载的主机目录 匿名挂载 1、匿名挂载就是不指定主机目录进行挂载（没有给卷（主机目录）起名就是匿名） # -v 容器内路径! docker run -d -P --name nginx01 -v /etc/nginx nginx ​ 2、查看所有的volume（卷）的情况 docker volume ls ​ [root@192 ~]# docker volume ls DRIVER VOLUME NAME local 7ef9dee8a0efcf74601d3ce615fc1a74a96008d861648d5f415c581ce426b44c #这些字符串就代表匿名卷(目录),是匿名挂载 local 8ecbc00746d9bea6a8095e65ead44e30b5cbf49f7409bc58aff9fab4b10cf0f4 local d745315f9e2d743c1a83edc5312809efba67693b8a01a27eb0a49a4ff572a450 ​ 3、指定卷来查看挂载 docker volume inspect 7ef9dee8a0efcf74601d3ce615fc1a74a96008d861648d5f415c581ce426b44c ​ [root@192 ~]# docker volume inspect 7ef9dee8a0efcf74601d3ce615fc1a74a96008d861648d5f415c581ce426b44c [ &#123; &quot;CreatedAt&quot;: &quot;2022-02-01T21:04:59+08:00&quot;, &quot;Driver&quot;: &quot;local&quot;, &quot;Labels&quot;: null, &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/7ef9dee8a0efcf74601d3ce615fc1a74a96008d861648d5f415c581ce426b44c/_data&quot;,# 挂载的目录 &quot;Name&quot;: &quot;7ef9dee8a0efcf74601d3ce615fc1a74a96008d861648d5f415c581ce426b44c&quot;, &quot;Options&quot;: null, &quot;Scope&quot;: &quot;local&quot; &#125; ] ​​ 具名挂载 1、具名挂载就是指定了主机目录进行挂载（有给卷（主机目录）起名就是具名（有具体的名）） docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx ​ 2、查看所有的volume（卷）的情况 [root@192 home]# docker volume ls DRIVER VOLUME NAME local 7ef9dee8a0efcf74601d3ce615fc1a74a96008d861648d5f415c581ce426b44c local 8ecbc00746d9bea6a8095e65ead44e30b5cbf49f7409bc58aff9fab4b10cf0f4 local d745315f9e2d743c1a83edc5312809efba67693b8a01a27eb0a49a4ff572a450 local juming-nginx #有具体的名,具名挂载 ​ 3、指定卷来查看挂载 [root@192 home]# docker volume inspect juming-nginx [ &#123; &quot;CreatedAt&quot;: &quot;2022-02-01T21:16:26+08:00&quot;, &quot;Driver&quot;: &quot;local&quot;, &quot;Labels&quot;: null, &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/juming-nginx/_data&quot;, # 挂载的目录 &quot;Name&quot;: &quot;juming-nginx&quot;, &quot;Options&quot;: null, &quot;Scope&quot;: &quot;local&quot; &#125; ] ​ 所有的docker容器内的卷，没有指定绝对路径的目录的情况下都是在/var/lib/docker/volumes/xxxx/_data下的，-如果指定了目录，docker volume ls 是查看不到的。 小节 # 三种挂载： 匿名挂载、具名挂载、指定路径挂载 -v 容器内路径 #匿名挂载 -v 卷名：容器内路径 #具名挂载 -v /宿主机路径：容器内路径 #指定路径挂载 docker volume ls 是查看不到的 ​ 拓展 通过 -v 容器内路径： ro rw 改变读写权限 ro #readonly 只读 rw #readwrite 可读可写 docker run -d -P --name nginx05 -v juming:/etc/nginx:ro nginx docker run -d -P --name nginx05 -v juming:/etc/nginx:rw nginx ​ ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内部是无法操作！ 13、 初始Dockerfile 什么是Dockerfile Dockerfile 是用来构建docker镜像的构建文件，是一段命令脚本。 创建Dockerfile 1、创建docker的测试目录 [root@192 _data]# cd /home [root@192 home]# mkdir docker-test-volume ​ 2、创建Dockerfile脚本文件，通过这个脚本可以生成镜像, Dockerfile脚本文件内容分析: # 文件中的内容 指令(大写) 参数 #镜像是一层一层的，这里的每个命令，就是镜像的一层！ FROM centos # 指定镜像 VOLUME [&quot;volume01&quot;,&quot;volume02&quot;] # 挂载目录 CMD echo &quot;----end----&quot; # CMD 执行命令行命令 CMD /bin/bash ​ [root@192 docker-test-volume]# vim dockerfile01 [root@192 docker-test-volume]# cat dockerfile01 FROM centos VOLUME [&quot;volume01&quot;,&quot;volume02&quot;] CMD echo &quot;----end----&quot; CMD /bin/bash ​ 3、执行Dockerfile脚本文件，构建镜像 docker build -f /home/docker-test-volume dockerfile01 -t /kuangshen/centos . ​ [root@192 ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE kuangshen/centos latest 6b3e9b445d81 3 hours ago 231MB #构建成功 # ... ​ 4、启动镜像，查看容器 docker run -it /kuangshen/centos /bin/bash ​ [root@b68f2c5c965b /]# ls bin etc lib lost+found mnt proc run srv tmp var volume02 dev home lib64 media opt root sbin sys usr volume01 # 找到挂载的目录volume01、volume02 ​ 14、 数据卷容器14.1 数据卷容器容器挂载数据卷,实现容器间的数据同步和资源共享！ 1、启动父容器docker01 docker run -it --name docker01 kuangshen/centos ​ 2、启动容器docker02并挂载到父容器docker01的共享卷,命令`--volumes-from 容器列表` docker run -it --name docker02 --volumes-from docker01 kuangshen/centos ​ 3、查看容器运行 [root@192 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES fa68f1afa235 kuangshen/centos /bin/sh -c /bin/bash 11 seconds ago Up 10 seconds docker02 eb991bf17656 kuangshen/centos /bin/sh -c /bin/bash 2 minutes ago Up 2 minutes docker01 ​ 4、在父容器docker01的共享卷中创建文件，看docker02共享卷的变化 [root@eb991bf17656 /]# cd volume01 [root@eb991bf17656 volume01]# touch docker.txt ​ * docker02容器内成功看到docker01创建的文件 [root@fa68f1afa235 /]# cd volume01 [root@fa68f1afa235 volume01]# ls docker.txt ​ 5、再加个docker03试试，也有docker01创建的文件 docker run -it --name docker03 --volumes-from docker01 kuangshen/centos ​ [root@e4ad9cb37d01 /]# cd volume01 [root@e4ad9cb37d01 volume01]# ls docker.txt ​ 6、小结 * docker03创建的文件docker01、docker02也同步共享。 * 删除docker01，docker02和docker03依旧保持数据同步和资源共享。 * 容器挂载后双向资源绑定，双向拷贝。 ## 14.2 Mysql容器实现数据同步 1、启动mysql01,绑定端口3306,配置密码`-e MYSQL_ROOT_PASSWORD=password`,挂载卷`-v` docker run -it --name mysql01 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -v /etc/mysql/conf.d -v /var/lib/mysql mysql ​ 2、启动mysql02（绑定端口3307）、mysql03（绑定端口3308） # mysql02 docker run -it --name mysql02 --volumes-from mysql01 -p 3100:3306 -e MYSQL_ROOT_PASSWORD=123456 -v /etc/mysql/conf.d -v /var/lib/mysql mysql # mysql03 docker run -it --name mysql03 --volumes-from mysql01 -p 330:3306 -e MYSQL_ROOT_PASSWORD=123456 -v /etc/mysql/conf.d -v /var/lib/mysql mysql ​ 3、连接数据库测试 > 结论 容器之间的配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止。 但是一旦你持久化到了本地，这个时候，本地的数据是不会删除的！ ## 15、Dockerfile（重点） dockerfile是用来构建docker镜像的文件！命令参数脚本！ > 构建步骤： 1、 编写一个dockerfile文件 2、 docker build 构建称为一个镜像 3、 docker run运行镜像 4、 docker push发布镜像（DockerHub 、阿里云仓库 image-20230406190112408 官方的镜像 官方仓库搜索：https://hub.docker.com/\\_/centos image-20230406190118318 点击版本跳转到Github,看到dockerfile文件： docker 99%的镜像都是从FROM scratch（基础镜像）开始- image-20230406190600870 很多官方镜像都是基础包，很多功能没有，我们通常会自己搭建自己的镜像！ 官方既然可以制作镜像，那我们也可以！ 15.1 DockerFile构建过程 DockerFile脚本文件语法 1、每个保留关键字(指令）都是必须是大写字母 2、执行从上到下顺序 3、#表示注释 4、每一个指令都会创建提交一个新的镜像曾，并提交！ Dockerfile image-20230406190121577 Dockerfile是面向开发的，我们以后要发布项目，做镜像，就需要编写dockerfile文件，这个文件十分简单！ Docker镜像逐渐成企业交付的标准，必须要掌握！ DockerFile：构建文件，定义了一切的步骤，源代码 DockerImages：通过DockerFile构建生成的镜像，最终发布和运行产品。 Docker容器：容器就是镜像运行起来提供服务。 DockerFile的指令 1234567891011121314151617181920212223242526指令 解释FROM\t基础镜像，一切从这里开始构建MAINTAINER\t镜像是谁写的， 姓名+邮箱(翻译：维护人员)RUN 镜像构建的时候需要运行的命令ADD 步骤，tomcat镜像，这个tomcat压缩包！添加内容 添加同目录WORKDIR 镜像的工作目录VOLUME 挂载的目录EXPOSE 保留端口配置（开放的端口）CMD 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代。ENTRYPOINT\t指定这个容器启动的时候要运行的命令，可以追加命令（入口点）ONBUILD 当构建一个被继承 DockerFile 这个时候就会运行ONBUILD的指令，触发指令。COPY 类似ADD，将我们文件拷贝到镜像中ENV 构建的时候设置环境变量！ 15.2 Dockerfile实战 创建一个自己的centos镜像 官方的centos许多命令都没有，所以我们创建一个自己的centos镜像 1、创建工作目录 [root@192 dockerfile]# pwd /home/dockerfile [root@192 dockerfile]# vim centos-dockerfile ​ 2、编写Dockerfile文件 (文件名：centos-dockerfile) FROM centos MAINTAINER root&lt;id_07221888@qq.com&gt; ENV MYPATH /usr/local # 设置环境变量 WORKDIR $MYPATH # 镜像的工作目录，进入镜像的初始目录 # RUN: 镜像构建的时候需要运行的命令 RUN yum -y install vim # 新增 vim 工具 RUN yum -y install net-tools # 新增 网络 工具 有ifconfig命令 EXPOSE 80 # 开放的端口 CMD echo $MYPATH # CMD：容器启动的时候要运行的命令 CMD echo &quot;-----end----&quot; CMD /bin/bash ​ FROM centos MAINTAINER root&lt;id_07221888@qq.com&gt; ENV MYPATH /usr/local WORKDIR $MYPATH RUN yum -y install vim RUN yum -y install net-tools EXPOSE 80 CMD echo $MYPATH CMD echo &quot;-----end----&quot; CMD /bin/bash ​ 3、通过这个文件构建镜像 # 命令 docker build -f 文件路径 -t 镜像名:[tag] . docker build -f /home/dockerfile/centos-dockerfile -t mycentos:0.1 . ​ Step 5/10 : RUN yum -y install vim ---&gt; Running in 64495d343335 CentOS Linux 8 - AppStream 68 B/s | 38 B 00:00 Error: Failed to download metadata for repo &#39;appstream&#39;: Cannot prepare internal mirrorlist: No URLs in mirrorlist The command &#39;/bin/sh -c yum -y install vim&#39; returned a non-zero code: 1 ​ 因为没有vim这个rpm包。vim命令在vim-ehanced这个包内。 yum失败的可以在yum之前加一个更新软件源 ​ systemctl stop firewalld.service # 停止防火墙 ​ 4、启动镜像 列出镜像的变更历史 docker history 镜像 ​ [root@192 dockerfile]# docker history mysql IMAGE CREATED CREATED BY SIZE COMMENT d1dc36cf8d9e 6 days ago /bin/sh -c #(nop) CMD [&quot;mysqld&quot;] 0B &lt;missing&gt; 6 days ago /bin/sh -c #(nop) EXPOSE 3306 33060 0B &lt;missing&gt; 6 days ago /bin/sh -c #(nop) ENTRYPOINT [&quot;docker-entry… 0B &lt;missing&gt; 6 days ago /bin/sh -c ln -s usr/local/bin/docker-entryp… 34B &lt;missing&gt; 6 days ago /bin/sh -c #(nop) COPY file:c112ec3a02a7b818… 13.2kB &lt;missing&gt; 6 days ago /bin/sh -c #(nop) COPY dir:2e040acc386ebd23b… 1.12kB &lt;missing&gt; 6 days ago /bin/sh -c #(nop) VOLUME [/var/lib/mysql] 0B &lt;missing&gt; 6 days ago /bin/sh -c &#123; echo mysql-community-server m… 384MB &lt;missing&gt; 6 days ago /bin/sh -c echo &#39;deb http://repo.mysql.com/a… 55B &lt;missing&gt; 6 days ago /bin/sh -c #(nop) ENV MYSQL_VERSION=8.0.28-… 0B &lt;missing&gt; 6 days ago /bin/sh -c #(nop) ENV MYSQL_MAJOR=8.0 0B &lt;missing&gt; 6 days ago /bin/sh -c set -ex; key=&#39;859BE8D7C586F53843… 2.29kB &lt;missing&gt; 6 days ago /bin/sh -c apt-get update &amp;&amp; apt-get install… 52.2MB &lt;missing&gt; 6 days ago /bin/sh -c mkdir /docker-entrypoint-initdb.d 0B &lt;missing&gt; 6 days ago /bin/sh -c set -eux; savedAptMark=&quot;$(apt-ma… 4.06MB &lt;missing&gt; 6 days ago /bin/sh -c #(nop) ENV GOSU_VERSION=1.14 0B &lt;missing&gt; 6 days ago /bin/sh -c apt-get update &amp;&amp; apt-get install… 9.34MB &lt;missing&gt; 6 days ago /bin/sh -c groupadd -r mysql &amp;&amp; useradd -r -… 329kB &lt;missing&gt; 7 days ago /bin/sh -c #(nop) CMD [&quot;bash&quot;] 0B &lt;missing&gt; 7 days ago /bin/sh -c #(nop) ADD file:c51141702f568a28a… 69.3MB ​ 使用我们平时拿到一个镜像，可以研究一下是什么做的 15.3 CMD 和 ENTRYPOINT区别 CMD : 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代。(替代的方式) ENTRYPOINT : 指定这个容器启动的时候要运行的命令，可以追加命令。(追加的方式) 测试cmd 1、编写dockerfile文件 [root@192 dockerfile]# cat dockerfile-test-cmd FROM centos CMD [&quot;ls&quot;,&quot;-a&quot;] ​ 2、 构建镜像 docker build -f dockerfile-test-cmd -t cmd-test:0.1 . ​ [root@192 dockerfile]# docker build -f dockerfile-test-cmd -t cmd-test:0.1 . Sending build context to Docker daemon 3.072kB Step 1/2 : FROM centos ---&gt; 5d0da3dc9764 Step 2/2 : CMD [&quot;ls&quot;,&quot;-a&quot;] ---&gt; Running in 462edab225f4 Removing intermediate container 462edab225f4 ---&gt; 3a12f3d5b2a5 Successfully built 3a12f3d5b2a5 Successfully tagged cmd-test:0.1 ​​ 3、运行镜像 [root@192 dockerfile]# docker run cmd-test:0.1 . .. .dockerenv bin dev etc # .. # 列出了 容器内 根目录所有文件夹 ​ 4、想追加一个命令 -l 成为ls -al docker run cmd-test:0.1 ls -al ​ [root@192 ~]# docker run cmd-test:0.1 ls -al total 0 drwxr-xr-x. 1 root root 6 Feb 2 13:53 . drwxr-xr-x. 1 root root 6 Feb 2 13:53 .. -rwxr-xr-x. 1 root root 0 Feb 2 13:53 .dockerenv lrwxrwxrwx. 1 root root 7 Nov 3 2020 bin -&gt; usr/bin drwxr-xr-x. 5 root root 340 Feb 2 13:53 dev # ... ​ 测试ENTRYPOINT 1、编写dockerfile文件 vim dockerfile-test-entrypoint FROM centos ENTRYPOINT [&quot;ls&quot;,&quot;-a&quot;] ​ 2、构建镜像 docker build -f dockerfile-test-entrypoint -t entrypoint-test:0.1 . ​ [root@192 dockerfile]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE entrypoint-test 0.1 390f47c46bdd 9 seconds ago 231MB ​ 3、想追加一个命令 -l docker run entrypoint-test:0.1 -l ​ 成功 [root@192 dockerfile]# docker run entrypoint-test:0.1 -ltotal 0drwxr-xr-x. 1 root root 6 Feb 2 13:59 .drwxr-xr-x. 1 root root 6 Feb 2 13:59 ..-rwxr-xr-x. 1 root root 0 Feb 2 13:59 .dockerenvlrwxrwxrwx. 1 root root 7 Nov 3 2020 bin -&gt; usr&#x2F;bin …​ 15.4 Dockerfile制作tomcat镜像1、准备镜像文件 准备tomcat 和 jdk到当前目录，编写好README Apache Tomcat® - Apache Tomcat 9 Software Downloads [root@192 tomcat]# ls apache-tomcat-9.0.58.tar.gz jdk-8u60-linux-x64.tar.gz [root@192 tomcat]# pwd /root/桌面/Kuang/tomcat ​ 创建readme.txt文件 [root@192 tomcat]# lsapache-tomcat-9.0.58.tar.gz Dockerfile jdk-8u60-linux-x64.tar.gz readme.txt ​ 2、编写dokerfile，官方命名Dockerfile,build 会自动寻找,就不用-f 指定了 image-20230406190440376 FROM centos MAINTAINER root&lt;id_07221888@qq.com&gt; COPY readme.txt /usr/local/readme.txt #复制文件 ADD jdk-8u60-linux-x64.tar.gz /usr/local/ #复制解压 ADD apache-tomcat-9.0.58.tar.gz /usr/local/ ENV MYPATH /usr/local #设置环境变量 WORKDIR $MYPATH #设置工作目录 ENV JAVA_HOME /usr/local/jdk1.8.0_60 #设置环境变量 ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools/jar ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.58 #设置环境变量 ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.58 ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin #设置环境变量 分隔符是： EXPOSE 8080 #设置暴露的端口 CMD /usr/local/apache-tomcat-9.0.58/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.58/bin/logs/catalina.out # 设置默认命令 ​ FROM centos # MAINTAINER cheng&lt;1204598429@qq.com&gt; COPY README /usr/local/README #复制文件 ADD jdk-8u231-linux-x64.tar.gz /usr/local/ #复制解压 ADD apache-tomcat-9.0.35.tar.gz /usr/local/ #复制解压 RUN yum -y install vim ENV MYPATH /usr/local #设置环境变量 WORKDIR $MYPATH #设置工作目录 ENV JAVA_HOME /usr/local/jdk1.8.0_231 #设置环境变量 ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.35 #设置环境变量 ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib #设置环境变量 分隔符是： EXPOSE 8080 #设置暴露的端口 CMD /usr/local/apache-tomcat-9.0.35/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.35/logs/catalina.out # 设置默认命令 ​​ 3、构造镜像 docker build -t diytomcat . ​ 构建失败 4、运行镜像 docker run -d -p 8080:8080 --name tomcat01 -v /home/kuangshen/build/tomcat/test:/usr/local/apache-tomcat-9.0.35/webapps/test -v /home/kuangshen/build/tomcat/tomcatlogs/:/usr/local/apache-tomcat-9.0.35/logs mytomcat:0.1 ​ 5、访问测试 6、发布项目(由于做了卷挂载，我们直接在本地编写项目就可以发布了！) 发现：项目部署成功，可以直接访问！ 我们以后开发的步骤：需要掌握Dockerfile的编写！我们之后的一切都是使用docker镜像来发布运行！ 15.5 发布镜像到DockerHub(常用)1、登录远程仓库（ https://hub.docker.com/） image-20230406190151990 2、终端登录 [root@192 ~]# docker login --help Usage: docker login [OPTIONS] [SERVER] 登录到Docker注册表。 如果没有指定服务器，则由守护进程定义默认值。 Options: -p, --password string Password --password-stdin 从stdin获取密码 -u, --username string Username ​ 3、登录成功 docker login -u 【你的用户名】 -p 【你的密码】 ​ [root@192 ~]# docker login -u 【你的用户名】 -p 【你的密码】 WARNING! Using --password via the CLI is insecure. Use --password-stdin. WARNING! Your password will be stored unencrypted in /root/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded ​ 4、提交 push镜像 [root@192 ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE cmd-test 0.1 3a12f3d5b2a5 18 hours ago 231MB # ... ​ (1) 先打标签 # docker tag 镜像id 你的账户名/镜像仓库名:tag名 docker tag 3a12f3d5b2a5 dockerywl/cmd-test:0.1 ​ (2) 再提交 push镜像 # docker push 作者/镜像:TAG(版本) docker push dockerywl/cmd-test:0.1 ​ [root@192 ~]# docker push dockerywl/cmd-test:0.1 The push refers to repository [docker.io/dockerywl/cmd-test] 74ddd0ec08fa: Pushing [================&gt; ] 77.74MB/231.3MB ​ (3) push成功 image-20230406190157116 发布到阿里云镜像服务上 看官网 很详细https://cr.console.aliyun.com/repository/ 15.6 保存传输保存后拷贝的U盘交给别人使用 1、保存(压缩)成backup.tar [root@192 ~]# docker save --help Usage: docker save [OPTIONS] IMAGE [IMAGE...] 将一个或多个镜像保存到tar存档文件(默认情况下流到STDOUT) Options: -o, --output string 写入一个文件，而不是STDOUT ​ docker save 镜像 -o 文件名 ​ [root@192 ~]# docker save redis -o backup.tar [root@192 ~]# ls backup.tar # 成功 ​ 2、加载（解压）镜像压缩文件backup.tar [root@192 ~]# docker load --help Usage: docker load [OPTIONS] 从tar存档文件或STDIN加载镜像 Options: -i, --input string 从tar存档文件读取，而不是STDIN -q, --quiet 抑制负载输出 ​ docker load -i backup.tar ​ [root@192 ~]# docker load -i backup.tar 92b6c42121d8: Loading layer [==================================================&gt;] 338.4kB/338.4kB 65845b69eb5c: Loading layer [==================================================&gt;] 4.274MB/4.274MB 7048818d1657: Loading layer [==================================================&gt;] 27.8MB/27.8MB c61d5cbf8621: Loading layer [==================================================&gt;] 2.048kB/2.048kB ff503dae4eb6: Loading layer [==================================================&gt;] 3.584kB/3.584kB Loaded image: redis:latest # 成功 ​ 15.7 Docker所有流程小结（重点）image-20230406190204844 = 容器内安装工具 &#x3D;tomcat 容器 Linux apt 命令 | 菜鸟教程 (runoob.com) # 先执行 apt update # 安装 ip 查看工具 apt install -y iproute2 # 安装 ping 命令工具 apt-get install inetutils-ping # 安装 vim 命令工具 apt install vim apt update &amp;&amp; apt install -y iproute2 &amp;&amp; apt-get install inetutils-ping ​ 16、Docker网络详解容器编排、集群部署 16.1 理解Docker 0(不推荐使用)不推荐使用：Docker 0 不支持 ping 容器名 清空所有环境 # 删除所有镜像 docker rmi -f $(docker images) # 删除所有的容器 docker rm -f $(docker ps -aq) ​ [root@192 ~]# ifconfig # docker0地址 有路由器的功能。 docker0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt; mtu 1500 inet 172.17.0.1 netmask 255.255.0.0 broadcast 172.17.255.255 # ... # 本机地址 ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.64.130 netmask 255.255.255.0 broadcast 192.168.64.255 # ... # 本机回环地址 lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 # ... ​ Linux主机 与 容器 互相ping通 1、新建容器 docker pull tomcat docker run -it -d -P --name tomcat01 tomcat /bin/bash ​ 2、进入为容器安装 ip 查看工具 docker attath 容器id # 常用 apt update &amp;&amp; apt install -y iproute2 ​ 3、查看容器内网ip docker分配的容器内网ip ： 172.17.0.2 root@138f304dfa38:/usr/local/tomcat# ip addr 1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever # veth-pair技术 6 与 7 成对 6: eth0@if7: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever ​ 4、可以ping通 (毕竟tomcat提供的服务外网都可以访问，肯定ping的通) [root@192 ~]# ping 172.17.0.2 PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data. 64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.048 ms 64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.052 ms 64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.085 ms ^C --- 172.17.0.2 ping statistics --- 3 packets transmitted, 3 received, 0% packet loss, time 2001ms rtt min/avg/max/mdev = 0.048/0.061/0.085/0.018 ms ​ 5、进入为容器安装 ping 命令工具 apt-get install inetutils-ping ​ 6、 容器 ping通 Linux主机 root@138f304dfa38:/usr/local/tomcat# ping 192.168.64.130 PING 192.168.64.130 (192.168.64.130): 56 data bytes 64 bytes from 192.168.64.130: icmp_seq=0 ttl=64 time=0.294 ms 64 bytes from 192.168.64.130: icmp_seq=1 ttl=64 time=0.125 ms ^C--- 192.168.64.130 ping statistics --- 7 packets transmitted, 7 packets received, 0% packet loss round-trip min/avg/max/stddev = 0.125/0.181/0.294/0.056 ms ​ 原理 1、我们每启动一个docker容器，docker就会给docker容器分配一个ip，我们只要按照了docker，就会有一个docker0桥接模式，使用的技术是veth-pair技术！ https://www.cnblogs.com/bakari/p/10613710.html veth-pair 就是一对的虚拟设备接口，和 tap&#x2F;tun 设备不同的是，它都是成对出现的。一端连着协议栈，一端彼此相连着。 （成对：Linux 主机网卡 6,7成对，则容器网卡7，6成对） Linux 主机 再次执行 ip addr，多了个网卡 [root@192 ~]# ip addr 1: lo: # ... 2: ens33: # ... 3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:a4:0b:89:6b brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 # ... # 多了个网卡 7: veth568cc5e@if6: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default link/ether de:55:c0:b4:58:42 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet6 fe80::dc55:c0ff:feb4:5842/64 scope link valid_lft forever preferred_lft forever ​ 2、再启动一个tocmat02容器，执行 ip addr，又多了个网卡 docker run -it -d -P --name tomcat02 tomcat ​ [root@192 ~]# ip addr # ... # veth-pair技术 7 与 6 成对，Linux主机则为6 与 7成对 7: veth568cc5e@if6: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default link/ether de:55:c0:b4:58:42 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet6 fe80::dc55:c0ff:feb4:5842/64 scope link valid_lft forever preferred_lft forever # veth-pair技术 9 与 8 成对 9: veth7668013@if8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default link/ether 7a:c2:eb:86:ae:9f brd ff:ff:ff:ff:ff:ff link-netnsid 1 inet6 fe80::78c2:ebff:fe86:ae9f/64 scope link valid_lft forever preferred_lft forever ​ 3、进入tocmat02容器，为容器安装 ip 查看工具,ip:172.17.0.2 apt update &amp;&amp; apt install -y iproute2 ​ root@443a02110963:/usr/local/tomcat# ip addr 1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 10: eth0@if11: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever root@443a02110963:/usr/local/tomcat# ​ 4、tomcat01与tocmat02 可以相互ping 通 root@443a02110963:/usr/local/tomcat# ping 172.17.0.2 PING 172.17.0.2 (172.17.0.2): 56 data bytes 64 bytes from 172.17.0.2: icmp_seq=0 ttl=64 time=0.129 ms 64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.279 ms 64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.142 ms ^C--- 172.17.0.2 ping statistics --- 3 packets transmitted, 3 packets received, 0% packet loss round-trip min/avg/max/stddev = 0.129/0.183/0.279/0.068 ms ​ 结论 tomcat01和tomcat02公用一个路由器，docker0。 所有的容器不指定网络的情况下，都是docker0路由的，docker会给我们的容器分配一个默认的可用ip。 image-20230406190216290 Docker使用的是Linux的桥接，宿主机是一个Docker容器的网桥 docker0 image-20230406190219194 Docker中所有网络接口都是虚拟的，虚拟的转发效率高（内网传递文件） 只要容器删除，对应的网桥一对就没了！ 16.2 –link（不推荐使用） 思考一个场景 我们编写了一个微服务，database url&#x3D;ip: 项目不重启，数据库ip换了，我们希望可以处理这个问题，可以通过名字来进行访问容器？（高可用） 实现ping 通 容器名 –link 作用 docker run –link可以用来链接2个容器，使得源容器（被链接的容器）和接收容器（主动去链接的容器）之间可以互相通信，并且接收容器可以获取源容器的一些数据，如源容器的环境变量。 测试 1、准备centos01、centos02 $ docker run -it -d --name centos01 centos $ docker run -it -d --name centos02 centos ​ 2、实现ping不通容器名 $ docker exec -it centos02 ping centos01 ​ [root@192 ~]# docker exec -it centos02 ping centos01 ping: centos01: Name or service not known ​ 3、运行一个tomcat03 ,加上参数--link centos02，连接centos02 $ docker run -it --name centos03 --link centos02 centos /bin/bash ​ [root@a04540580e1b /]# ping centos02 PING centos02 (172.17.0.3) 56(84) bytes of data. 64 bytes from centos02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.118 ms 64 bytes from centos02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.110 ms ^C --- centos02 ping statistics --- 2 packets transmitted, 2 received, 0% packet loss, time 1003ms rtt min/avg/max/mdev = 0.110/0.114/0.118/0.004 ms [root@a04540580e1b /]# ​ 4、用centos03 ping centos02 可以ping通 docker exec -it centos03 ping centos02 ​ [root@192 ~]# docker exec -it centos03 ping centos02 PING centos02 (172.17.0.3) 56(84) bytes of data. 64 bytes from centos02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.071 ms 64 bytes from centos02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.154 ms ^C --- centos02 ping statistics --- 2 packets transmitted, 2 received, 0% packet loss, time 1003ms rtt min/avg/max/mdev = 0.071/0.112/0.154/0.042 ms ​ 但是用tomcat02 ping tomcat03 ping不通 16.3 Docker网络探究docker network [root@192 ~]# docker network ls NETWORK ID NAME DRIVER SCOPE 297f07c51979 bridge bridge local # bridge:桥接 docker0 87a8f8309bfa host host local 51b67872ea20 none null local ​ [root@192 ~]# docker network --help Usage: docker network COMMAND Manage networks # 管理网络 Commands: connect # 将容器连接到网络 create # 创建网络 disconnect # 断开一个容器与网络的连接 inspect # 显示一个或多个网络的详细信息 ls # 网络列表 prune # 删除所有未使用的网络 rm # 删除一个或多个网络 ​ 1、查看docker0的网络信息 docker network inspect 297f07c51979 ​ [root@192 ~]# docker network inspect 297f07c51979 [ &#123; &quot;Name&quot;: &quot;bridge&quot;, &quot;Id&quot;: &quot;297f07c5197942c2a4bc867abd31c61f6f804f1b7fc08b6e7b3da2839c77bc34&quot;, &quot;Created&quot;: &quot;2022-02-03T17:50:16.517397962+08:00&quot;, &quot;Scope&quot;: &quot;local&quot;, &quot;Driver&quot;: &quot;bridge&quot;, &quot;EnableIPv6&quot;: false, &quot;IPAM&quot;: &#123; &quot;Driver&quot;: &quot;default&quot;, # default &quot;Options&quot;: null, &quot;Config&quot;: [ &#123; &quot;Subnet&quot;: &quot;172.17.0.0/16&quot;, # 网段 &quot;Gateway&quot;: &quot;172.17.0.1&quot; &#125; ] &#125;, &quot;Internal&quot;: false, &quot;Attachable&quot;: false, &quot;Ingress&quot;: false, &quot;ConfigFrom&quot;: &#123; &quot;Network&quot;: &quot;&quot; &#125;, &quot;ConfigOnly&quot;: false, &quot;Containers&quot;: &#123; &quot;78904cf546599b37473b34ff4a5bf5f1af3a632e5bd80ff8e72904d7ed339c45&quot;: &#123; &quot;Name&quot;: &quot;tomcat02&quot;, # tomcat02 &quot;EndpointID&quot;: &quot;ea7126991ab6eab6d65f0bc8c0135d014446c919c9ceee1e94d1ddd8c07e5c80&quot;, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:03&quot;, &quot;IPv4Address&quot;: &quot;172.17.0.3/16&quot;, # tomcat02 的 ip 地址 &quot;IPv6Address&quot;: &quot;&quot; &#125;, &quot;95cac41f93906a08c79b49e84ed490b220032ee954c27b243835de6cb035bb56&quot;: &#123; &quot;Name&quot;: &quot;tomcat01&quot;, # tomcat01 &quot;EndpointID&quot;: &quot;4c10c4fe891272787fc69121be3f929a830fef79eca92c507f5fdccad9d83145&quot;, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;, &quot;IPv4Address&quot;: &quot;172.17.0.2/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125; &#125;, &quot;Options&quot;: &#123; # ... &#125;, &quot;Labels&quot;: &#123;&#125; &#125; ] ​​ 2、查看容器tomcat02详细信息 docker inspect 容器id ​ [root@192 ~]# docker inspect 78904cf54659 [ &#123; &quot;Id&quot;: &quot;78904cf546599b37473b34ff4a5bf5f1af3a632e5bd80ff8e72904d7ed339c45&quot;, &quot;Created&quot;: &quot;2022-02-03T12:13:25.377988982Z&quot;, &quot;Path&quot;: &quot;/bin/bash&quot;, &quot;Args&quot;: [], &quot;State&quot;: &#123; # 主题 &quot;Status&quot;: &quot;running&quot;, &quot;Running&quot;: true, # 运行 &quot;Paused&quot;: false, &quot;Restarting&quot;: false, &quot;OOMKilled&quot;: false, &quot;Dead&quot;: false, &quot;Pid&quot;: 9965, &quot;ExitCode&quot;: 0, &quot;Error&quot;: &quot;&quot;, &quot;StartedAt&quot;: &quot;2022-02-03T12:44:20.630270698Z&quot;, &quot;FinishedAt&quot;: &quot;2022-02-03T12:34:37.648949082Z&quot; &#125;, &quot;Config&quot;: &#123; &quot;Hostname&quot;: &quot;78904cf54659&quot;, &quot;Domainname&quot;: &quot;&quot;, &quot;User&quot;: &quot;&quot;, # ... &quot;Env&quot;: [# 环境配置 &quot;PATH=/usr/local/tomcat/bin:/usr/local/openjdk-11/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;, &quot;JAVA_HOME=/usr/local/openjdk-11&quot;, &quot;LANG=C.UTF-8&quot;, &quot;JAVA_VERSION=11.0.13&quot;, # ... ], &quot;Cmd&quot;: [ &quot;/bin/bash&quot; ], &quot;Image&quot;: &quot;tomcat&quot;, # 镜像 &quot;Volumes&quot;: null, &quot;WorkingDir&quot;: &quot;/usr/local/tomcat&quot;, # 工作目录 &quot;Entrypoint&quot;: null, &quot;OnBuild&quot;: null, &quot;Labels&quot;: &#123;&#125; &#125;, &quot;NetworkSettings&quot;: &#123; &quot;Bridge&quot;: &quot;&quot;, &quot;SandboxID&quot;: &quot;5ed43e901e7b9b49937e06d39a5f1fe73709437d70beaf8b07d3e56c48affcdf&quot;, &quot;HairpinMode&quot;: false, &quot;LinkLocalIPv6Address&quot;: &quot;&quot;, &quot;LinkLocalIPv6PrefixLen&quot;: 0, &quot;Ports&quot;: &#123; &quot;8080/tcp&quot;: [ &#123; &quot;HostIp&quot;: &quot;0.0.0.0&quot;, &quot;HostPort&quot;: &quot;49169&quot; &#125;, &#123; &quot;HostIp&quot;: &quot;::&quot;, &quot;HostPort&quot;: &quot;49169&quot; &#125; ] &#125;, # ... &quot;Networks&quot;: &#123; &quot;bridge&quot;: &#123; # 桥接 # ... &quot;Gateway&quot;: &quot;172.17.0.1&quot;, # 网关 &quot;IPAddress&quot;: &quot;172.17.0.3&quot;, # ip # ... &#125; &#125; &#125; &#125; ] ​ 3、查看容器tomcat03详细信息，得到连接信息 docker inspect 4e6aae2d99dd ​ # ... &quot;HostConfig&quot;: &#123; # ... &quot;Links&quot;: [ &quot;/tomcat02:/tomcat03/tomcat02&quot; ], # ... &#125; # ... ​ 4、容器tomcat03配置了网络映射 将主机名(tomcat02)与ip地址host映射(不推荐使用)。 cat /etc/hosts ​ image-20230406190230154 16.4 自定义网络查看所有的docker网络 [root@192 ~]# docker network ls NETWORK ID NAME DRIVER SCOPE 297f07c51979 bridge bridge local # bridge:桥接 docker0 87a8f8309bfa host host local 51b67872ea20 none null local ​ 网络模式 bridge ：桥接 docker（默认，自己创建也是用bridge模式） none ：不配置网络，一般不用 host ：和所主机共享网络 container ：容器网络连通（用得少！局限很大） 自定义一个网络 1、默认参数 -net bridge # 启动时 --net bridge 是默认带上的,bridge就是docker0 $ docker run -d -P --name tomcat01 tomcat 等价于 =&gt; docker run -d -P --name tomcat01 --net bridge tomcat ​ # docker0，特点：默认，域名不能访问。 --link可以打通连接，但是很麻烦！ ​ 2、创建网络的命令 [root@192 ~]# docker network create --help Usage: docker network create [OPTIONS] NETWORK Create a network Options: --attachable # 启用手动容器附件 --aux-address map # map网络驱动使用的辅助IPv4或IPv6地址(默认map[]) --config-from string # 要复制配置的网络 --config-only # 创建仅配置网络 -d, --driver string # 管理网络的驱动程序(默认为“bridge”) --gateway strings # IPv4或IPv6主子网网关 --ingress # 创建群路由-mesh网络 --internal # 限制外部用户访问网络 --ip-range strings # 从子范围分配容器ip --ipam-driver string # IP地址管理驱动程序(默认为“default”) --ipam-opt map # map设置IPAM驱动的特定选项(default map[]) --ipv6 # 启用ipv6组网功能 --label list # list设置网络元数据 -o, --opt map # 设置驱动程序的特定选项(默认map[]) --scope string # 控制网络范围 --subnet strings # CIDR格式的子网，表示一个网段 ​ 3、自定义一个网络（创建网络）,名字为mynet $ docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet ​ [root@192 ~]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet 6293fb8f0a642641dc0f6043b7a666690406db6423070b08f6af38a67e96e64f ​ 4、查看自定义的网络mynet $ docker network inspect mynet ​ [root@192 ~]# docker network inspect mynet [ &#123; &quot;Name&quot;: &quot;mynet&quot;, &quot;Id&quot;: &quot;6293fb8f0a642641dc0f6043b7a666690406db6423070b08f6af38a67e96e64f&quot;, &quot;Created&quot;: &quot;2022-02-04T10:06:47.753633784+08:00&quot;, &quot;Scope&quot;: &quot;local&quot;, &quot;Driver&quot;: &quot;bridge&quot;, #网络模式 bridge(桥接) &quot;EnableIPv6&quot;: false, &quot;IPAM&quot;: &#123; &quot;Driver&quot;: &quot;default&quot;, &quot;Options&quot;: &#123;&#125;, &quot;Config&quot;: [ &#123; &quot;Subnet&quot;: &quot;192.168.0.0/16&quot;, # 子网 192.168.0.2 ~ 192.168.255.254 &quot;Gateway&quot;: &quot;192.168.0.1&quot; # 网关 &#125; ] &#125;, # ... &#125; ] ​ 创建容器，配置网络 1、创建容器01、02 # 接 /bin/bash 直接进命令行 docker run -it --name centos-net01 --net mynet centos docker run -it --name centos-net02 --net mynet centos ​ 2、再次查看自定义的网络mynet，可见多了新增容器01、02的网络配置 [root@192 ~]# docker network inspect mynet [ &#123; &quot;Name&quot;: &quot;mynet&quot;, # ... &quot;Containers&quot;: &#123; &quot;0c9e72313626017f9143fef9bfe9acb70f0ed46c352c8f6ed0612675c666379d&quot;: &#123; &quot;Name&quot;: &quot;centos-net01&quot;, # centos-net01 &quot;EndpointID&quot;: &quot;a228cec33c9019f31999f9b8c9ced3e60d3e611ae395d147b0db2ea920fce4ed&quot;, &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:02&quot;, &quot;IPv4Address&quot;: &quot;192.168.0.2/16&quot;, # ip地址： 192.168.0.2 &quot;IPv6Address&quot;: &quot;&quot; &#125;, &quot;c31a887225dfa9572bc47703d838932590d9a5188b1fe13e82cd5851e286b497&quot;: &#123; &quot;Name&quot;: &quot;centos-net02&quot;, # centos-net02 &quot;EndpointID&quot;: &quot;7f4864f0e52fb36149cfffa78bde3ee88e38ea20202eca4c0b4ec5136e62ec94&quot;, &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:03&quot;, &quot;IPv4Address&quot;: &quot;192.168.0.3/16&quot;, # ip地址： 192.168.0.3 &quot;IPv6Address&quot;: &quot;&quot; &#125; &#125;, &quot;Options&quot;: &#123;&#125;, &quot;Labels&quot;: &#123;&#125; &#125; ] ​ 3、在自定义的网络下，服务可以互相ping通，不用使用–link 01 ping 通 02 docker exec -it centos-net01 ping centos-net02 ​ [root@192 ~]# docker exec -it centos-net01 ping centos-net02PING centos-net02 (192.168.0.3) 56(84) bytes of data.64 bytes from centos-net02.mynet (192.168.0.3): icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.072 ms64 bytes from centos-net02.mynet (192.168.0.3): icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;0.077 ms64 bytes from centos-net02.mynet (192.168.0.3): icmp_seq&#x3D;3 ttl&#x3D;64 time&#x3D;0.081 ms64 bytes from centos-net02.mynet (192.168.0.3): icmp_seq&#x3D;4 ttl&#x3D;64 time&#x3D;0.110 ms^C— centos-net02 ping statistics —4 packets transmitted, 4 received, 0% packet loss, time 3004msrtt min&#x2F;avg&#x2F;max&#x2F;mdev &#x3D; 0.072&#x2F;0.085&#x2F;0.110&#x2F;0.014 ms ​ 反之亦然，02 ping 通 01 [root@192 ~]# docker exec -it centos-net02 ping centos-net01PING centos-net01 (192.168.0.2) 56(84) bytes of data.64 bytes from centos-net01.mynet (192.168.0.2): icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.049 ms64 bytes from centos-net01.mynet (192.168.0.2): icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;0.095 ms^C— centos-net01 ping statistics —2 packets transmitted, 2 received, 0% packet loss, time 1003msrtt min&#x2F;avg&#x2F;max&#x2F;mdev &#x3D; 0.049&#x2F;0.072&#x2F;0.095&#x2F;0.023 ms ​ 4、查看host映射,映射 ip 对应 容器id [root@192 ~]# docker exec -it centos-net02 cat /etc/hosts 127.0.0.1\tlocalhost # ... 192.168.0.3\tc31a887225df # ip 对应 容器id（centos-net01 的ip） ​ [root@192 ~]# docker exec -it centos-net01 cat /etc/hosts 127.0.0.1\tlocalhost # ... 192.168.0.2\t0c9e72313626 # ip 对应 容器id（centos-net02 的ip） ​ 我们自定义的网络docker当我们维护好了对应的关系，推荐我们平时这样使用网络！ 好处： redis -不同的集群使用不同的网络，保证集群是安全和健康的 mysql-不同的集群使用不同的网络，保证集群是安全和健康的 image-20230406190240143 16.5 网络连通解决问题，网段不同如何ping通 image-20230406190243645 1、创建容器 centos01，测试ping 容器名失败 $ docker run -dit --name centos01 centos $ docker exec -it centos01 ping centos-net01 ​ [root@192 ~]# docker exec -it centos01 ping centos-net01 ping: centos-net01: Name or service not known ​ 2、解决方法：docker network connect [root@192 ~]# clear [root@192 ~]# docker network connect --help # NETWORK：工作网络（mynet） Usage: docker network connect [OPTIONS] NETWORK CONTAINER Connect a container to a network # 将容器连接到网络中 Options: --alias strings # 为容器添加网络范围的别名 --driver-opt strings # 网络驱动选项 --ip string # IPv4地址(例如172.30.100.104) --ip6 string # IPv6地址(例如,2001:db8:: 33) --link list # 添加链接到另一个容器 --link-local-ip strings # 为容器添加链路本地地址 ​ 3、将网络mynet与 centos01容器连通 $ docker network connect mynet centos01 ​ 4、查看mynet [root@192 ~]# docker inspect mynet [ &#123; &quot;Name&quot;: &quot;mynet&quot;, # ... &quot;Containers&quot;: &#123; &quot;0c9e72313626017f9143fef9bfe9acb70f0ed46c352c8f6ed0612675c666379d&quot;: &#123; &quot;Name&quot;: &quot;centos-net01&quot;, &quot;EndpointID&quot;: &quot;b09c89b344437d0a166567d03358cdb6f2c05a6833813501285ed516abe641df&quot;, &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:02&quot;, &quot;IPv4Address&quot;: &quot;192.168.0.2/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125;, &quot;c31a887225dfa9572bc47703d838932590d9a5188b1fe13e82cd5851e286b497&quot;: &#123; &quot;Name&quot;: &quot;centos-net02&quot;, &quot;EndpointID&quot;: &quot;eda6dd675c194a84e6d398ee8c16cc6b42d67fb91069264d00d05ada7dd5633b&quot;, &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:04&quot;, &quot;IPv4Address&quot;: &quot;192.168.0.4/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125;, &quot;dac6694051750f990fa6fac796795d60b8e4578d9b72f90fbc9519b54e6498ac&quot;: &#123; &quot;Name&quot;: &quot;centos01&quot;, # 新增centos01 &quot;EndpointID&quot;: &quot;e79c29a2d531dd69b766ee6253f1562d7a8bcbc6accfab23cb6df5cdbaa6a7a0&quot;, &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:03&quot;, &quot;IPv4Address&quot;: &quot;192.168.0.3/16&quot;, # 公网ip &quot;IPv6Address&quot;: &quot;&quot; &#125; &#125;, # ... ​ centos01容器的hosts文件(一个容器两个ip) [root@192 ~]# docker exec -it centos01 cat &#x2F;etc&#x2F;hosts127.0.0.1\tlocalhost …dac669405175 是 centos01容器自己的 容器id172.17.0.2\tdac669405175 # 私网ip &#x3D;&gt; 容器id192.168.0.3\tdac669405175 # 公网ip &#x3D;&gt; 容器id ​ centos-net01容器的hosts文件 [root@192 ~]# docker exec -it centos-net01 cat &#x2F;etc&#x2F;hosts127.0.0.1\tlocalhost …192.168.0.2\t0c9e72313626 # 私网(公网)ip &#x3D;&gt; 容器id ​ 5、再次测试，centos01与 centos-net01、centos-net02 均可ping通 $ docker exec -it centos01 ping centos-net01 $ docker exec -it centos01 ping centos-net02 $ docker exec -it centos-net01 ping centos01 $ docker exec -it centos-net02 ping centos01 ​ 结论 假设要跨网络操作别人，就需要使用docker network connect连通！ 17、Redis集群部署实战17.1 部署 环境 三主三从 image-20230406190250509 1、创建网卡 $ docker network create redisnet --subnet 172.38.0.0/16 ​ 2、通过脚本创建六个redis配置文件 for port in $(seq 1 6);\\ do \\ mkdir -p /mydata/redis/node-$&#123;port&#125;/conf touch /mydata/redis/node-$&#123;port&#125;/conf/redis.conf cat &lt;&lt; EOF &gt;&gt; /mydata/redis/node-$&#123;port&#125;/conf/redis.conf port 6379 bind 0.0.0.0 cluster-enabled yes cluster-config-file nodes.conf cluster-node-timeout 5000 cluster-announce-ip 172.38.0.1$&#123;port&#125; cluster-announce-port 6379 cluster-announce-bus-port 16379 appendonly yes EOF done ​ 查看redis配置文件 [root@192 ~]# cd &#x2F;mydata&#x2F;redis&#x2F;[root@192 redis]# lsnode-1 node-2 node-3 node-4 node-5 node-6[root@192 conf]# cd &#x2F;mydata&#x2F;redis&#x2F;node-1&#x2F;conf[root@192 conf]# lsredis.conf[root@192 conf]# cat redis.confport 6379bind 0.0.0.0cluster-enabled yescluster-config-file nodes.confcluster-node-timeout 5000cluster-announce-ip 172.38.0.11cluster-announce-port 6379cluster-announce-bus-port 16379appendonly yes ​ 3、通过脚本创建和运行六个redis容器，--ip 指定ip，-v挂载redis配置文件和数据 for port in $(seq 1 6);\\ do \\ docker run -p 637$&#123;port&#125;:6379 -p 1667$&#123;port&#125;:16379 --name redis-$&#123;port&#125; \\ -v /mydata/redis/node-$&#123;port&#125;/data:/data \\ -v /mydata/redis/node-$&#123;port&#125;/conf/redis.conf:/etc/redis/redis.conf \\ -d --net redisnet --ip 172.38.0.1$&#123;port&#125; redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf done ​ image-20230406190449166 或者一个一个容器添加 docker run -p 6371:6379 -p 16671:16379 –name redis-1 -v &#x2F;mydata&#x2F;redis&#x2F;node-1&#x2F;data:&#x2F;data -v &#x2F;mydata&#x2F;redis&#x2F;node-1&#x2F;conf&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf -d –net redisnet –ip 172.38.0.11 redis:5.0.9-alpine3.11 redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf docker run -p 6372:6379 -p 16672:16379 –name redis-2 -v &#x2F;mydata&#x2F;redis&#x2F;node-2&#x2F;data:&#x2F;data -v &#x2F;mydata&#x2F;redis&#x2F;node-2&#x2F;conf&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf -d –net redisnet –ip 172.38.0.12 redis:5.0.9-alpine3.11 redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf docker run -p 6373:6379 -p 16673:16379 –name redis-3 -v &#x2F;mydata&#x2F;redis&#x2F;node-3&#x2F;data:&#x2F;data -v &#x2F;mydata&#x2F;redis&#x2F;node-3&#x2F;conf&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf -d –net redisnet –ip 172.38.0.13 redis:5.0.9-alpine3.11 redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf docker run -p 6374:6379 -p 16674:16379 –name redis-4 -v &#x2F;mydata&#x2F;redis&#x2F;node-4&#x2F;data:&#x2F;data -v &#x2F;mydata&#x2F;redis&#x2F;node-4&#x2F;conf&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf -d –net redisnet –ip 172.38.0.14 redis:5.0.9-alpine3.11 redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf docker run -p 6375:6379 -p 16675:16379 –name redis-5 -v &#x2F;mydata&#x2F;redis&#x2F;node-5&#x2F;data:&#x2F;data -v &#x2F;mydata&#x2F;redis&#x2F;node-5&#x2F;conf&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf -d –net redisnet –ip 172.38.0.15 redis:5.0.9-alpine3.11 redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf docker run -p 6376:6379 -p 16676:16379 –name redis-6 -v &#x2F;mydata&#x2F;redis&#x2F;node-6&#x2F;data:&#x2F;data -v &#x2F;mydata&#x2F;redis&#x2F;node-6&#x2F;conf&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf -d –net redisnet –ip 172.38.0.16 redis:5.0.9-alpine3.11 redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf ​ 4、查看创建的redis容器 （秒退的，可以用docker logs redis-1 查看日志） [root@192 conf]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 49e9e62c7fff redis:5.0.9-alpine3.11 &quot;docker-entrypoint.s…&quot; 20 seconds ago Up 19 seconds 0.0.0.0:6376-&gt;6379/tcp, :::6376-&gt;6379/tcp, 0.0.0.0:16676-&gt;16379/tcp, :::16676-&gt;16379/tcp redis-6 691b11db10c8 redis:5.0.9-alpine3.11 &quot;docker-entrypoint.s…&quot; 21 seconds ago Up 20 seconds 0.0.0.0:6375-&gt;6379/tcp, :::6375-&gt;6379/tcp, 0.0.0.0:16675-&gt;16379/tcp, :::16675-&gt;16379/tcp redis-5 fc37037e7ae9 redis:5.0.9-alpine3.11 &quot;docker-entrypoint.s…&quot; 22 seconds ago Up 20 seconds 0.0.0.0:6374-&gt;6379/tcp, :::6374-&gt;6379/tcp, 0.0.0.0:16674-&gt;16379/tcp, :::16674-&gt;16379/tcp redis-4 85ef9071ac9b redis:5.0.9-alpine3.11 &quot;docker-entrypoint.s…&quot; 22 seconds ago Up 21 seconds 0.0.0.0:6373-&gt;6379/tcp, :::6373-&gt;6379/tcp, 0.0.0.0:16673-&gt;16379/tcp, :::16673-&gt;16379/tcp redis-3 44b92119b2b3 redis:5.0.9-alpine3.11 &quot;docker-entrypoint.s…&quot; 23 seconds ago Up 21 seconds 0.0.0.0:6372-&gt;6379/tcp, :::6372-&gt;6379/tcp, 0.0.0.0:16672-&gt;16379/tcp, :::16672-&gt;16379/tcp redis-2 269b8eb57942 redis:5.0.9-alpine3.11 &quot;docker-entrypoint.s…&quot; 23 seconds ago Up 22 seconds 0.0.0.0:6371-&gt;6379/tcp, :::6371-&gt;6379/tcp, 0.0.0.0:16671-&gt;16379/tcp, :::16671-&gt;16379/tcp redis-1 ​​ 5、查看网络redisnet的信息（Containers字段内省略了数据） [root@192 conf]# docker inspect redisnet [ &#123; &quot;Name&quot;: &quot;redisnet&quot;, # ... &quot;Containers&quot;: &#123; &quot;269b8eb57942dd3c816247251c1d4a0299c86d8dbfa45c1e60fd68b1e0b5e470&quot;: &#123; &quot;Name&quot;: &quot;redis-1&quot;, &quot;IPv4Address&quot;: &quot;172.38.0.11/16&quot;, &#125;, &quot;44b92119b2b3573e1a8e15a1e435cd3c1cde30a6fc3f960189a88f715e962fec&quot;: &#123; &quot;Name&quot;: &quot;redis-2&quot;, &quot;IPv4Address&quot;: &quot;172.38.0.12/16&quot;, &#125;, &quot;49e9e62c7ffff2955194095818f4b806e609329350456e65c2bec9f5932bd8f6&quot;: &#123; &quot;Name&quot;: &quot;redis-6&quot;, &quot;IPv4Address&quot;: &quot;172.38.0.16/16&quot;, &#125;, &quot;691b11db10c8403b999386caec7ad20dad535aa0d0e3f9d98214423b328f23de&quot;: &#123; &quot;IPv4Address&quot;: &quot;172.38.0.15/16&quot;, &#125;, &quot;85ef9071ac9bbacc25cda715a695819e32fa17945956ae2c744e43b841e27af6&quot;: &#123; &quot;Name&quot;: &quot;redis-3&quot;, &quot;IPv4Address&quot;: &quot;172.38.0.13/16&quot;, &#125;, &quot;fc37037e7ae9ed007bef0290f3610f3a3cbbde744189a7b3e3a112b9497e7e5a&quot;: &#123; &quot;Name&quot;: &quot;redis-4&quot;, &quot;IPv4Address&quot;: &quot;172.38.0.14/16&quot;, &#125; &#125;, # ... ​ 5、创建集群,(redis默认没有bash,所以用 &#x2F;bin&#x2F;sh) （1）进入redis-1容器 [root@192 ~]# docker exec -it redis-1 /bin/sh /data # ls appendonly.aof nodes.conf /data # ​ （2） 创建集群 redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --cluster-replicas 1 ​ /data # redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:637 9 172.38.0.16:6379 --cluster-replicas 1 &gt;&gt;&gt; Performing hash slots allocation on 6 nodes... Master[0] -&gt; Slots 0 - 5460 # 三主三从 Master[1] -&gt; Slots 5461 - 10922 Master[2] -&gt; Slots 10923 - 16383 Adding replica 172.38.0.15:6379 to 172.38.0.11:6379 Adding replica 172.38.0.16:6379 to 172.38.0.12:6379 Adding replica 172.38.0.14:6379 to 172.38.0.13:6379 M: 7866a044a62217acc264e0780724baebfcbdf9ec 172.38.0.11:6379 slots:[0-5460] (5461 slots) master M: e2210b65a712c43fce9cb11a40605d4ae6afc61c 172.38.0.12:6379 slots:[5461-10922] (5462 slots) master M: a2d9d996b447f724860502d4230434d8fbef45bb 172.38.0.13:6379 slots:[10923-16383] (5461 slots) master S: eaa1f8ba8de966a6fffaed6b43e0226d95caffb9 172.38.0.14:6379 replicates a2d9d996b447f724860502d4230434d8fbef45bb S: 35fcc7906fda3c977cf6fe09ebfd4632c8288449 172.38.0.15:6379 replicates 7866a044a62217acc264e0780724baebfcbdf9ec S: 59c81a95ed20b8964246dee3bfc333e25960275a 172.38.0.16:6379 replicates e2210b65a712c43fce9cb11a40605d4ae6afc61c Can I set the above configuration? (type &#39;yes&#39; to accept): yes &gt;&gt;&gt; Nodes configuration updated &gt;&gt;&gt; Assign a different config epoch to each node &gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster Waiting for the cluster to join ... &gt;&gt;&gt; Performing Cluster Check (using node 172.38.0.11:6379) M: 7866a044a62217acc264e0780724baebfcbdf9ec 172.38.0.11:6379 slots:[0-5460] (5461 slots) master 1 additional replica(s) S: 35fcc7906fda3c977cf6fe09ebfd4632c8288449 172.38.0.15:6379 slots: (0 slots) slave replicates 7866a044a62217acc264e0780724baebfcbdf9ec M: a2d9d996b447f724860502d4230434d8fbef45bb 172.38.0.13:6379 slots:[10923-16383] (5461 slots) master 1 additional replica(s) S: 59c81a95ed20b8964246dee3bfc333e25960275a 172.38.0.16:6379 slots: (0 slots) slave replicates e2210b65a712c43fce9cb11a40605d4ae6afc61c M: e2210b65a712c43fce9cb11a40605d4ae6afc61c 172.38.0.12:6379 slots:[5461-10922] (5462 slots) master 1 additional replica(s) S: eaa1f8ba8de966a6fffaed6b43e0226d95caffb9 172.38.0.14:6379 slots: (0 slots) slave replicates a2d9d996b447f724860502d4230434d8fbef45bb [OK] All nodes agree about slots configuration. &gt;&gt;&gt; Check for open slots... &gt;&gt;&gt; Check slots coverage... [OK] All 16384 slots covered. ​ 17.2 测试Redis集群Redis三种模式:主从模式, 哨兵模式, 集群模式（推荐） 1、redis-cli -c 代表进入集群 /data # redis-cli -c 127.0.0.1:6379&gt; ​ 127.0.0.1:6379&gt; cluster info cluster_state:ok # .. cluster_known_nodes:6 # 节点：6 cluster_size:3 # 集群数量：3 # ... ​ 2、查看节点信息 # master(主) slave(从) 127.0.0.1:6379&gt; cluster nodes 35fcc7906fda3c977cf6fe09ebfd4632c8288449 172.38.0.15:6379@16379 slave 7866a044a62217acc264e0780724baebfcbdf9ec 0 1643970509988 5 connected a2d9d996b447f724860502d4230434d8fbef45bb 172.38.0.13:6379@16379 master - 0 1643970508952 3 connected 10923-16383 59c81a95ed20b8964246dee3bfc333e25960275a 172.38.0.16:6379@16379 slave e2210b65a712c43fce9cb11a40605d4ae6afc61c 0 1643970509257 6 connected e2210b65a712c43fce9cb11a40605d4ae6afc61c 172.38.0.12:6379@16379 master - 0 1643970508000 2 connected 5461-10922 eaa1f8ba8de966a6fffaed6b43e0226d95caffb9 172.38.0.14:6379@16379 slave a2d9d996b447f724860502d4230434d8fbef45bb 0 1643970509000 4 connected 7866a044a62217acc264e0780724baebfcbdf9ec 172.38.0.11:6379@16379 myself,master - 0 1643970507000 1 connected 0-5460 ​ 3、高可用测试 （1）存值（由redis-2处理） 127.0.0.1:6379&gt; set name zs -&gt; Redirected to slot [5798] located at 172.38.0.12:6379 # 12 =&gt; redis-2 OK 172.38.0.12:6379&gt; get name &quot;zs&quot; ​ （2）停止redis-2 [root@192 ~]# docker stop redis-2 redis-2 ​ （3）依旧可取（此时由redis-6处理，redis-6顶上了）。高可用 127.0.0.1:6379&gt; get name -&gt; Redirected to slot [5798] located at 172.38.0.16:6379 # 16 =&gt; redis-6 &quot;zs&quot; ​ （4）查看节点信息cluster nodes image-20230406190301633 我们使用docker之后，所有的技术都会慢慢变得简单起来！ 18、SpringBoot微服务打包Docker镜像18.1 构建SpringBoot项目package com.example.demo.colltroller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class HelloColltroer &#123; @RequestMapping(&quot;/hello&quot;) public String hello()&#123; return &quot;hello,一个平凡de人&quot;; &#125; &#125; ​ 运行 image-20230406190458557 18.2 打jar包1、 双击Maven package打包 image-20230406190305211 2、打包成功 image-20230406190309863 3、测试jar是否可以运行,访问127.0.0.1:8080&#x2F;hello运行成功 $ java -jar demo1-0.0.1-SNAPSHOT.jar ​ 4、idea安装docker插件 image-20230406190312733 18.3 上传jar包在idea项目根目录创建并编写Dockerfile文件 FROM java:11 COPY *.jar /app.jar CMD [&quot;--server.port=8080&quot;] EXPOSE 8080 ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;app.jar&quot;] ​ 将jar包和Dockerfile上传到服务器 [root@192 idea]# pwd /home/idea [root@192 idea]# ls demo1-0.0.1-SNAPSHOT.jar Dockerfile ​ 18.4 构建镜像1、构建镜像 $ docker build -t springboot . ​ [root@192 idea]# docker build -t springboot . Sending build context to Docker daemon 16.57MB Step 1/5 : FROM java:8 # ... Successfully built f107ab2a9246 Successfully tagged springboot:latest ​ 2、查看镜像 [root@192 idea]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE springboot latest f107ab2a9246 2 minutes ago 660MB # ... ​ 3、运行springboot容器,访问127.0.0.1:8080/hello docker run -dit -p 8080:8080 --name hello springboot ​ [root@192 idea]# docker run -dit -p 8080:8080 --name hello springboot b8d1f65da8a8b71975b336952af497ba946d801294b1ac42d266da41ba1b6a0c [root@192 idea]# curl 127.0.0.1:8080/hello hello,一个平凡de人 ​ 4、外网访问192.168.64.131:8080&#x2F;hello image-20230406190319237 18.5 发布1、 登录 $ docker login -u 【你的用户名】 -p 【你的密码】 ​ 2、打标签 # docker tag 镜像id 你的账户名/镜像仓库名:tag名 $ docker tag f107ab2a9246 dockerywl/springboot ​ 3、再提交 push镜像 # docker push 作者/镜像:TAG(版本) $ docker push dockerywl/springboot ​ 总结 以后我们使用了Docker之后，给别人交付就是一个镜像即可！","tags":["Docker"],"categories":["Docker"]},{"title":"Linux系统完整备份及恢复","path":"/posts/28410c70.html","content":"先进入系统根目录： 1cd / 临时切换root用户 1sudo su 备份命令： 1tar cvpzf /SystemBackup.tgz --exclude=/proc --exclude=/mnt --exclude=/lost+found --exclude=/sys --exclude=/media --exclude=/run --exclude=/SystemBackup.tgz / 恢复命令： 1tar xvpfz SystemBackup.tgz -C /","tags":["Tips"],"categories":["Linux"]},{"title":"12存储过程和函数","path":"/posts/1ec33254.html","content":"存储过程基本格式1234CREATE PROCEDURE 名字BEGIN\t....END; 类型1 无参数无返回值创建一个 查询employees所有数据的存储函数 selc_all_data(); 123456789# 定义SQL语句结束符号(部分SQL管理工具会以分号结束会导致存储过程在运行至END前就结束)DELIMITER $ # 重新定义SQL结束符号 Navicat不支持 故注释CREATE PROCEDURE selc_all_data()BEGIN SELECT * FROM employees;END $ # 存储过程结束DELIMITER ; # 存储过程运行完成后 再改回来 Navicat不支持 故注释 存储过程调用 CALL 1CALL selc_all_data(); 类型2 有返回值创建存储过程show_min_salary，查看“employees”表的最低薪资值。并将最低薪资通过OUT参数“ms”输出 12345678CREATE PROCEDURE show_min_salary ( OUT ms DOUBLE ) # 用ms输出BEGIN\tSELECT MIN( salary ) INTO ms # 用INTO 将结果赋给ms\tFROM employees;\tEND; 调用 1CALL show_min_salary(@ms); 查看变量值 1SELECT @ms; 类型3 带参数例：创建存储过程show_someone_salary()，查看”emps”表的某个员工的薪资，并用IN参数lname输入员工姓名。 1234CREATE PROCEDURE show_someone_salary(IN lname VARCHAR(20))BEGIN\tSELECT salary FROM employees WHERE last_name = lname;END; 调用方式1 1CALL show_someone_salary(&#x27;Abel&#x27;); # 查询Abel的工资 调用方式2 等号&#x3D; 或 赋值等号:&#x3D; 1234SET @lname = &#x27;Abel&#x27;; # 等号赋值或SET @lname := &#x27;Abel&#x27;; # 赋值等号CALL show_someone_salary(@lname); # 调用变量 类型4 带IN 和 OUT例：创建存储过程show_someone_sly()，查看employees表的某个员工的薪资，并用IN参数lname输入员工姓名，用0UT参数sly输出员工薪资。 1234567CREATE PROCEDURE show_someone_sly(IN lname VARCHAR(20),OUT sly DOUBLE)BEGIN\tSELECT salary INTO sly FROM employees WHERE last_name = lname;END;SET @lname = &#x27;Abel&#x27;; # 赋值CALL show_someone_sly(@lname,@sly); # 调用SELECT @sly; # 查询 类型5 带 INOUT例：创建存储过程show_mgr_name()，查询某个员工领导的姓名，并用INOUT参数“lname”输入员工姓名，输出领导的姓名。 方式一 自连接 + IN + OUT 1234CREATE PROCEDURE show_mgr_name(IN lname VARCHAR(25),OUT mgr VARCHAR(25))BEGIN\tSELECT mgr.last_name INTO mgr FROM employees emp JOIN employees mgr ON mgr.employee_id = emp.manager_id AND emp.last_name = lname;END; 赋值 1SET @lname = &#x27;Abel&#x27;; 调用 1CALL show_mgr_name(@lname,@mgr); 查询 1SELECT @mgr; 方式二 INOUT 1234CREATE PROCEDURE show_mgr(INOUT lname VARCHAR(25))BEGIN\tSELECT mgr.last_name INTO lname FROM employees emp JOIN employees mgr ON mgr.employee_id = emp.manager_id AND emp.last_name = lname;END; 赋值 1SET @lname = &#x27;Abel&#x27;; 调用 1CALL show_mgr(@lname); 查询结果 1SELECT @lname; 存储函数例：创建存储函数，名称为email_by_name()，参数定义为空，该函数查询Abel的email，并返回，数据类型为字符串型。 12345678CREATE FUNCTION eml_by_name()RETURNS VARCHAR(25) DETERMINISTIC # 约束 CONTAINS SQL # 约束 READS SQL DATA # 约束BEGIN\tRETURN (SELECT email FROM employees WHERE last_name = &#x27;Abel&#x27;);END; 调用 1SELECT eml_by_name(); 举例2：创建存储函数，名称为email_by_id(), 参数传入em_id，该函数查询emp id的email，并返回，数据类型为字符串型。 12345678#创建函数前执行此语句，保证函数的创建会成功 不用写约束SET GLOBAL log_bin_trust_function_creators = 1;CREATE FUNCTION email_by_id(em_id INT)RETURNS VARCHAR(25) # 设置返回类型BEGIN\tRETURN (SELECT email FROM employees WHERE employee_id = em_id);END; 调用 1SELECT email_by_id(101); 调用2 12SET @emid := 102; # 赋值SELECT email_by_id(@emid); 举例3：创建存储函数count_by_id()，参数传入dept_id，该函数查询dept_id部门的员工人数，并返回，数据类型为整型。 1234567CREATE FUNCTION count_by_id(dept_id INT)RETURNS INTBEGIN\tRETURN (SELECT count(department_id) FROM employees WHERE department_id = dept_id);END;SELECT count_by_id(30); 对比存储函数和存储过程 对比 关键字 调用语法 返回值 应用场景 存储过程 PROCEDURE CALL 存储过程 0理解为有0个或多个 一般用于更新 存储函数 FUNCTION SELECT 函数() 只能是一个 查询结果为一个值并返回时 此外，存储函数可以放在查询语句中使用，存储过程不行。 反之，存储过程的功能更加强大，包括能够执行对表的操作（比如创建表，删除表等）和事务操作，这些功能是存储函数不具备的。 存储过程、存储函数的查看 使用SHOW CREATE语句查看存储过程和函数的创建信息 12SHOW CREATE PROCEDURE show_mgr;SHOW CREATE FUNCTION count_by_id; 使用SHOW STATUS语句查看存储过程和函数的状态信息 12SHOW PROCEDURE STATUS LIKE &#x27;show_min_salary&#x27;;SHOW FUNCTION STATUS LIKE &#x27;email_by_id&#x27;; 存储过程 &#x2F; 存储函数 删除 DROP FUNCTION / PROCEDURE [IF EXISTS] 存储过程名 / 函数名 12DROP FUNCTION IF EXISTS count_by_id;DROP PROCEDURE IF EXISTS show_mgr;","tags":["Database","MariaDB"],"categories":["Language"]},{"title":"11视图","path":"/posts/c336cef3.html","content":"视图的理解 1 视图，可以看做是一个虚拟表，本身是不存储数据的。 2 视图的本质，就可以看做是存储起来的SELECT语句 3 视图中SELECT语句中涉及到的表，称为基表 4 针对视图做DML操作，会影响到对应的基表中的数据。反之亦然。 5 视图本身的删除，不会导致基表中数据的删除。 6 视图的应用场景：针对于小型项目，不推荐使用视图。针对于大型项目，可以考虑使用视图。视图的优点：简化查询：控制数据的访问 创建视图CREATE VIEW 视图名 AS 查询语句 别名作为视图中的字段名 12CREATE VIEW vu1 AS SELECT employee_id AS eid,last_name AS lname,salary AS sly FROM employees;SELECT * FROM vu1; 创建视图时设置字段名 12CREATE VIEW vu2(eid,lname,sly) AS SELECT employee_id,last_name,salary FROM employees;SELECT * FROM vu2; 查询各部门平均工资 视图 123456CREATE VIEW vu_avsly(dpid,avsly) AS SELECT department_id,AVG(salary) FROM employees WHERE department_id IS NOT NULL GROUP BY department_id;SELECT * FROM vu_avsly; 利用视图格式化数据 需求：员工姓名(员工部门) 12345CREATE VIEW vu_eminfo(eminfo) AS SELECT CONCAT(last_name,&#x27; ( &#x27;,department_name,&#x27; ) &#x27;) # 拼接 FROM employees AS el JOIN departments AS dp ON el.department_id = dp.department_id;SELECT * FROM vu_eminfo; 也可以基于视图再创建视图 不再列举 查看视图语法1：查看数据库的表对象、视图对象 SHOW TABLES; 1SHOW TABLES; 语法2：查看视图的结构 DESC&#x2F;DESCRIBE 视图名称; 12DESC vu2;DESCRIBE vu2; 语法3：查看视图的属性信息 查看视图信息（显示数据表的存储引擎、版本、数据行数和数据大小等） SHOW TABLE STATUS LIKE&#39;视图名称&#39;\\G; 执行结果显示， 注释Comment为VIEW，说明该表为视图，其他的信息为NULL，说明这是一个虚表。 1SHOW TABLE STATUS LIKE &#x27;vu_%&#x27;; 语法4：查看视图的详细定义信息SHOW CREATE VIEW 视图名称； 1SHOW CREATE VIEW vu2; 更新视图 更新视图中的数据时, 表中的数据也会更新 包括增删改 更新表中的数据时, 视图中的数据也会更新 视图中的数据不一定能”更新”成功 比如 根据部门工资算出来的平均工资所创建的视图, 是不能直接更新视图的平均工资的 因为平均工资是算出来的, 是在原表里不存在的 只有一一对应的字段才能更新 修改视图方式一 CREATE OR REPLACE VIEW 123456SELECT * FROM vu_1; # 查询vu_1视图, 数据107条CREATE OR REPLACE VIEW vu_1(eid,lname,sly) AS SELECT employee_id,last_name,salary FROM employees WHERE employee_id &lt; 110;SELECT * FROM vu_1; # 再次查询vu_1视图, 数据10条 方式二 ALTER VIEW 12345ALTER VIEW vu_1(eid,lname,sly) AS SELECT employee_id,last_name,salary FROM employees WHERE employee_id &lt; 105;SELECT * FROM vu_1; # 再查询 数据5条 删除视图DROP VIEW [IF EXISTS] 视图名 1DROP VIEW IF EXISTS vu2;","tags":["Database","MariaDB"],"categories":["Language"]},{"title":"10约束","path":"/posts/b420821e.html","content":"非空约束 NOT NULL 只有列级约束建表时 CREATE TABLE 1234567CREATE TABLE nnx(id INT NOT NULL,last_name VARCHAR(15),salary INT);INSERT INTO nnx(last_name,salary) VALUES(&#x27;Tom&#x27;,3000); # 报错,因为id有非空约束 修改表结构时 添加非空约束 ALTER TABLE12ALTER TABLE nnx MODIFY last_name VARCHAR(15) NOT NULL;INSERT INTO nnx(id,salary) VALUES(2,3000); # 报错,因为last_name加了非空约束 修改表结构时 删除非空约束1ALTER TABLE nnx MODIFY last_name VARCHAR(15); 唯一性约束 UNIQUE有列级约束和表级约束 可以为NULL 多个NULL可以重复在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同。 建表时123456789101112131415CREATE TABLE nnx1(id INT UNIQUE,last_name VARCHAR(15),salary DOUBLE(10,2));INSERT INTO nnx1(id,last_name,salary) VALUES(1,&#x27;冰糖&#x27;,10000),(1,&#x27;冰糖&#x27;,10000); # 报错,id重复CREATE TABLE nnx2(id INT UNIQUE, # 列级约束last_name VARCHAR(15),email VARCHAR(15),tel INT,salary DOUBLE(10,2),CONSTRAINT uni_e UNIQUE(email) # 表级约束); ALTER TABLE时添加方式1 ADD 12ALTER TABLE nnx2 ADD UNIQUE(tel); # 无别名ALTER TABLE nnx2 ADD CONSTRAINT uni_t UNIQUE(tel); # 有别名 方式二 MODIFY 1ALTER TABLE nnx2 MODIFY tel INT UNIQUE; 组合&#x2F;复合列唯一约束12345678CREATE TABLE nnx3(id INT UNIQUE,uname VARCHAR(10),pwd VARCHAR(20),CONSTRAINT uni_uname_pwd UNIQUE(uname,pwd) # 用户名和密码不能同时相同);INSERT INTO nnx3 VALUES(1,&#x27;abc&#x27;,&#x27;a111&#x27;),(2,&#x27;cde&#x27;,&#x27;a111&#x27;); # 可以成功INSERT INTO nnx3 VALUES(3,&#x27;abc&#x27;,&#x27;a111&#x27;),(4,&#x27;abc&#x27;,&#x27;a111&#x27;); # 失败,用户名和密码同时相同 删除唯一性约束 ALTER TABLE 表名 DROP INDEX 索引名 1 添加唯一性约束的列上 会 自动创建唯一索引。删除唯一约束只能通过删除唯一索引的方式删除。 2 删除时需要指定唯一索引名，唯一索引名就和唯一约束名一样。 3 如果创建唯一约束时未指定名称，如果是单列，就默认和列名相同； 如果是组合&#x2F;复合列，那么默认和（）中排在第一个的列名相同。也可以自定义唯一性约束名 查看表索引 SHOW INDEX FROM 表名 1ALTER TABLE nnx3 DROP INDEX id; 主键约束 PRIMARY KEY一个表只能有一个主键 唯一且非空 所以 主键约束 &#x3D; 唯一约束 + 非空约束主键约束的别名总是为PRIMARY 所以无需起别名 CREATE TABLE时创建12345678910111213CREATE TABLE nnx1(id INT PRIMARY KEY, # 列级约束uname VARCHAR(15),salary INT,email VARCHAR(20));CREATE TABLE nnx2(id INT,uname VARCHAR(15),salary INT,email VARCHAR(20),PRIMARY KEY(id) # 表级约束); ALTER TABLE添加主键约束12ALTER TABLE nnx2 ADD PRIMARY KEY(id); # 方式一 ADDALTER TABLE nnx2 MODIFY id INT PRIMARY KEY; # 方式二 MODIFY 删除主键(实际开发中不会这样去做)ALTER TABLE ... DROP PRIMARY KEY 1ALTER TABLE nnx2 DROP PRIMARY KEY; 主键自增长 AUTO_INCREMENTCREATE TABLE 时12345CREATE TABLE nnx(id INT PRIMARY KEY AUTO_INCREMENT,uname VARCHAR(15));INSERT INTO nnx(uname) VALUES (&#x27;aaa&#x27;),(&#x27;bbb&#x27;); # 即使id未写也不会报错, 因为id有自增长 ALTER TABLE 时增加1ALTER TABLE nnx MODIFY id INT AUTO_INCREMENT; ALTER TABLE 时删除1ALTER TABLE nnx MODIFY id INT; MySQL5.7 &amp; MySQL8.0** 在5.7中 删除某个自增长的值后重新插入的值会接着自增** 例如, 1,2,3,4 删掉4后重新新增 下一个也为5 但是, 若是删除4后重启MySQL服务 则新增的也会4 因为MySQL5.7的记录是记录在内存里的 在MySQL8.0中 删除某个自增长的值后重新插入的值会接着自增 例如, 1,2,3,4 删掉4后重新新增 下一个也为5 但不同5.7的是 即使删除4后重启MySQL服务 下一个增加的也为5 因为MySQL8.0新特性 自增持久化 记录在了重做日志中 外键约束 FOREIGN KEY主表和从表&#x2F;父表和子表主表（父表）：被引用的表，被参考的表从表（子表）：引用别人的表，参考别人的表 例如：员工表的员工所在部门这个字段的值要参考部门表：部门表是主表，员工表是从表。 例如：学生表、课程表、选课表：选课表的学生和课程要分别参考学生表和课程表， 学生表和课程表是主表，选课表是从表。 特点 (1）从表的外键列，必须引用&#x2F;参考主表的键主键或唯一约束的列 为什么？因为被依赖&#x2F;被参考的值必须是唯一的 (2）在创建外键约束时，如果不给外键约束命名，默认名不是列名，而是自动产生一个外键名（例如student_.ibfk_1），也可以指定外键约束名。 (3）创建（CREATE）表时就指定外键约束的话，先创建主表，再创建从表 (4）删表时，先删从表（或先除外键约束），再删除主表 (5）当主表的记录被从表参照时，主表的记录将不允许删除，如果要删除数据，需要先删除从表中依赖该记录的数据，然后才可以删除主表的数据 (6）在“从表”中指定外键约束，并且一个表可以建立多个外键约束 (7）从表的外键列与主表被参照的列名字可以不相同，但是数据类型必须一样，逻辑意义一致。如果类型不一样会出错 (8）当创建外键约束时，系统默认会在所在的列上建立对应的普通索引。但是索引名是列名，不是外键的约束名。（根据外键查询效率很高） (9）删除外键约束后，必须手动删除对应的索引 CREATE TABLE 时添加外键 先创建主表 1234CREATE TABLE nnx (dept_id int,dept_name VARCHAR(15)); ALTER TABLE 添加主键 1ALTER TABLE nnx ADD PRIMARY KEY (dept_id); 再创建从表 1234567CREATE TABLE nnx1 (emp_id INT PRIMARY KEY AUTO_INCREMENT,emp_name VARCHAR(15),department_id INT,# 表级约束CONSTRAINT fk_dept FOREIGN KEY (department_id) REFERENCES nnx(dept_id)); 注： 1 新增失败：做了外键约束后 在主表nnx内没有添加 部门ID(dept_id)时,无法在从表的department_id内插入数据 如果主表有一个部门为id为10,则可以往从表添加 department_id为10的数据 2 删除失败：当主表和从表有部门id为10, 则无法直接从主表中删除部门ID 10, 因为主表的部门id 10被从表所依赖 3 修改失败： 同理, 主表没有某某部门时, 从表也无法修改表内的部门ID为主表之外的ID ALTER TABLE时添加外键 先创建主表 1234CREATE TABLE nnx (dept_id int PRIMARY KEY,dept_name VARCHAR(15)); 再创建从表 12345CREATE TABLE nnx1 (emp_id INT PRIMARY KEY AUTO_INCREMENT,emp_name VARCHAR(15),department_id INT); 添加外键 1ALTER TABLE nnx1 ADD CONSTRAINT fk_dept FOREIGN KEY (department_id) REFERENCES nnx(dept_id); 约束等级 1 Cascade方式：在父表上update&#x2F;delete记录时，同步update&#x2F;delete掉子表的匹配记录 2 SET NULL方式：在父表上update&#x2F;delete记录时，将子表上匹配记录的列设为null，但是要注意子表的外键列不能为NOTNULL 3 No action方式：如果子表中有匹配的记录，则不允许对父表对应候选键进行update&#x2F;delete操作 4 Restrict方式：同no action，都是立即检查外键约束 5 Set defau1t方式（在可视化工具SQLyog中可能显示空白）：父表有变更时，子表将外键列设置成一个默认的值，但Innodb不能识别 如果没有指定等级，就相当于Restrict方式对于外键约束，最好是采用：ON UPDATE CASCADE ON DELETE RESTRICT的方式。 演示： 建立主表 12345CREATE TABLE nnx (id INT,departmen_id INT PRIMARY KEY ,uname VARCHAR(15)); 建立从表 设置约束等级 ON UPDATE CASCADE ON DELETE RESTRICT 12345CREATE TABLE nnx1 (dept_id INT,job_id INT,FOREIGN KEY (dept_id) REFERENCES nnx (departmen_id) ON UPDATE CASCADE ON DELETE RESTRICT); 检查约束 CHECK约束检查是否满足XX条件(MySQL5.7不支持) 1234567CREATE TABLE nnx(id INT,uname VARCHAR(15),salary DECIMAL(10,2) CHECK(salary &gt; 2000) # 工资大于2000);INSERT INTO nnx(id,uname,salary) VALUES(1,&#x27;冰糖&#x27;,2500); # 添加成功INSERT INTO nnx(id,uname,salary) VALUES(2,&#x27;nnx&#x27;,1500); # 添加失败 默认值约束 DEFAULT约束CREATE TABLE 时添加12345678CREATE TABLE nnx(id INT PRIMARY KEY auto_increment,uname VARCHAR(15),salary DECIMAL(10,2) DEFAULT 2000 # 工资默认2000);INSERT INTO nnx(uname) VALUES (&#x27;冰糖&#x27;);SELECT * FROM nnx; # 添加成功 1,冰糖,2000.00 ALTER TABLE 时添加12345678CREATE TABLE nnx1(id INT PRIMARY KEY auto_increment,uname VARCHAR(15),salary DECIMAL(10,2));ALTER TABLE nnx1 MODIFY salary DECIMAL(10,2) DEFAULT 2000; # 添加ALTER TABLE nnx1 MODIFY salary; DECIMAL(10,2); # 删除","tags":["Database","MariaDB"],"categories":["Language"]},{"title":"09字符集&0填充&无符号类型","path":"/posts/22fc367a.html","content":"设置字符集 CHARACTER SET ‘name’12345678910CREATE DATABASE test01 CHARACTER SET &#x27;utf8mb4&#x27;; # 给数据库设置SHOW CREATE DATABASE test01;CREATE TABLE nnx5(id int,last_name varchar(20)) CHARACTER SET &#x27;utf8mb4&#x27;; # 给数据表设置SHOW CREATE table nnx5;CREATE TABLE nnx6(id int,last_name varchar(20) CHARACTER SET &#x27;utf8mb4&#x27; # 给数据表某字段单独设置); ZEROFILL 0填充123456CREATE TABLE nnx7(f1 INT,f2 INT ZEROFILL);INSERT INTO nnx7(f1,f2) VALUES(123,123),(456,456); SELECT * FROM nnx7; # f1为123和456 f2为0000000123和0000000456 UNSIGNED：无符号类型（非负）所有的整数类型都有一个可选的属性UNSIGNED（无符号属性）无符号整数类型的最小取值为0.所以，如果需要在MySQL数据库中保存非负整数值时，可以将整数类型设置为无符号类型。int类型默认显示宽度为int（11），无符号int类型默认显示宽度为int（10）。 123CREATE TABLE nnx8(f1 INT UNSIGNED);","tags":["Database","MariaDB"],"categories":["Language"]},{"title":"08增删改","path":"/posts/9f7c914b.html","content":"创建表方式一 直接创建 123456CREATE TABLE IF NOT EXISTS nnx(id int,last_name VARCHAR(20),pro VARCHAR(20),birth DATE); 方式二 基于现有表 1CREATE TABLE copy_table AS SELECT last_name,salary FROM employees; 修改表 ALTER TABLEADD 增加字段123ALTER TABLE nnx ADD salary DOUBLE (10,2); # 默认添加至表最后一个字段ALTER TABLE nnx ADD phone_number VARCHAR(15) FIRST; # 用FIRST 将字段添加至开头ALTER TABLE nnx ADD address VARCHAR(15) AFTER phone_number; # 用AFTER 将字段放至某某字段之后 控制位置 MODIFY 修改某字段数据长度,类型,默认值1ALTER TABLE nnx MODIFY phone_number VARCHAR(25) DEFAULT(15687654321); CHANGE 重命名字段12ALTER TABLE nnx CHANGE last_name lst_name VARCHAR (15);ALTER TABLE nnx CHANGE salary month_salary VARCHAR (20); DROP 删除字段12ALTER TABLE nnx DROP address;DESC nnx; 重命名表RENAME TABLE A TO B 方式一 推荐 1RENAME TABLE nnx1 TO nnx; 方式二 1ALTER TABLE nnx RENAME TO nnx1; 删除表 DROP1DROP TABLE IF EXISTS nnx1; 清空表DDL 定义表(结构) 和 DML(管理表数据) 说明1.DDL的操作一旦执行，就不可回滚。2.DML的操作默认情况，一旦执行，也是不可回滚的但是，如果在执行DML之前，执行了SET AUTOCOMMIT &#x3D; FALSE，则执行的DML操作就可以实现回滚。 COMMIT 和 ROLLBACKCOMMIT 提交数据, 数据永久保存在数据库中 不可回滚 ROLLBACK 回滚数据 回滚至最近的一次COMMIT之后演示DELETE FROM 数据可以回滚 12345678910111213DELETE FROM nnx1 WHERE id = 100; # 清空指定行ROLLBACK; # 回滚SELECT * FROM nnx1; # id 100回滚失败SET AUTOCOMMIT = FALSE; # 关闭自动提交DELETE FROM nnx1 WHERE id = 101;SELECT * FROM nnx1; # id 101被删除ROLLBACK; # 回滚SELECT * FROM nnx1; # id 101回滚成功DELETE FROM nnx1; # 清空所有ROLLBACK;SELECT * FROM nnx1; # 回滚成功 TRUNCATE TABLE 数据不可回滚1TRUNCATE TABLE nnx1; 数据新增INSERT INTO 表名(字段1,字段2) VALUES(值1,值2) 方式1 手动添加 12INSERT INTO nnx VALUES(15687654399,1,&#x27;NotNoneX&#x27;,&#x27;哈哈&#x27;,&#x27;1995-11-11&#x27;,9999); # 不指明字段INSERT INTO nnx(id,last_name,month_salary) VALUES(2,&#x27;冰糖2&#x27;,12002),(3,&#x27;冰糖3&#x27;,12003); # 指明字段 方式2 查询结果添加 12INSERT INTO nnx(id,last_name,month_salary) SELECT employee_id,last_name,salary FROM employees LIMIT 5; 更新数据UPDATE 表名 SET 字段名 WHERE 条件千万别忘了WHERE 否则为批量修改所有 1UPDATE nnx SET birth = CURRENT_DATE,month_salary = 8000 WHERE id = 3; # 修改id为3的生日为当前日期,工资为8K 题目 名字以N开头的工资 提高2000元 1234UPDATE nnx SET salary = salary + 2000 WHERE last_name LIKE &#x27;N%&#x27;; SELECT * FROM nnx;DESC nnx; MySQL8 新特性 计算列c列的值始终为a列和b列之和 1234567CREATE TABLE nnx4 (a int,b int,c int GENERATED ALWAYS AS (a + b) VIRTUAL);INSERT INTO nnx4(a,b) VALUES(10,20); # 往a和b列添加数据SELECT * FROM nnx4; # 查询得到a,b,c 分别为10,20,30","tags":["Database","MariaDB"],"categories":["Language"]},{"title":"07子查询","path":"/posts/38ab61e7.html","content":"2023年2月13日21:47:50 子查询查询工资比Abel高的人的信息方式一 12SELECT salary FROM employees WHERE last_name = &quot;Abel&quot;; # 查询Abel的工资 结果11000SELECT last_name,salary FROM employees WHERE salary &gt; 11000; # 查询工资大于11000的人 方式二 自连接 1SELECT e2.last_name,e2.salary FROM employees e1,employees e2 WHERE e1.last_name = &quot;Abel&quot; AND e2.salary &gt; e1.salary; 方式三 子查询 1SELECT last_name,salary FROM employees WHERE salary &gt; (SELECT salary FROM employees WHERE last_name = &quot;Abel&quot;); 子查询分类角度一：从内查询返回的结果条目分类 单行子查询 \\ 多行子查询 单行子查询题目：查询与141号员工的manager_id和department_id相同的其他员工的employee_id,manager_id,department_id 方式一 1SELECT employee_id,manager_id,department_id FROM employees WHERE manager_id = (SELECT manager_id FROM employees WHERE employee_id = 141) AND department_id = (SELECT department_id FROM employees WHERE employee_id = 141) AND employee_id &lt;&gt; 141; 方式二 1SELECT employee_id,manager_id,department_id FROM employees WHERE (manager_id,department_id) = (SELECT manager_id,department_id FROM employees WHERE employee_id = 141) AND employee_id != 141; HAVING查询题目：查询最低工资大于50号部门最低工资的部门id和其最低工资逻辑：先查询每个部门的最低工资(分组 再查部门最低) 然后过滤 最低工资 &gt; 50号部门最低工资 123SELECT MIN(salary) FROM employees WHERE department_id = 50; # 2100SELECT department_id,MIN(salary) FROM employees GROUP BY department_id HAVING MIN(salary) &gt; (SELECT MIN(salary) FROM employees WHERE department_id = 50); 题目：显示员工的employee_id,last_name和location。其中，若员工department_id与location_id为l800的department_id相同，则location为’Canada’，其余则为’USA’。 123456789SELECT department_id FROM departments WHERE location_id = 1800; # 位置id为1800的部门id 结果20SELECT employee_id,last_name,CASE department_id\tWHEN (SELECT department_id FROM departments WHERE location_id = 1800) THEN &#x27;Canada&#x27;\tELSE &#x27;USA&#x27;END AS location FROM employees; image-20230213224536311 多行子查询IN ANY ALL SOME(ADY的别名 等同于ANY)题目：查询平均工资最低的部门id方式一 逻辑 先查出每个部门的平均工资, 再查出最小平均工资(将上一步的平均工资做为一张表使用 必须起别名) 最后查哪个部门的平均工资等于该部门50 12345SELECT department_id,AVG(salary) AVS FROM employees GROUP BY department_id; # 每个部门的平均工资SELECT MIN(AVS) FROM (SELECT department_id,AVG(salary) AVS FROM employees GROUP BY department_id) AS tem; # 最小的平均工资 看做一张表 必须有别名SELECT department_id,AVG(salary) FROM employees GROUP BY department_id HAVING AVG(salary) = (SELECT MIN(AVS) FROM (SELECT department_id,AVG(salary) AVS FROM employees GROUP BY department_id) AS tem); 1 2 3 方式二 ALL 123SELECT AVG(salary) FROM employees GROUP BY department_id; # 查出所有平均工资SELECT department_id,AVG(salary) FROM employees GROUP BY department_id HAVING AVG(salary) &lt;= ALL (SELECT AVG(salary) FROM employees GROUP BY department_id); # 查出 平均工资 &lt;= 所有的平均工资 的部门以及该部门的平均工资 1 2 角度二：内查询是否被执行多次 相关子查询 \\ 不相关子查询 相关子查询查询员工中工资大于本部门平均工资的员工的1ast_name,salary和其department_id方式一 123SELECT department_id,AVG(salary) AS AVGS FROM employees GROUP BY department_id; # 每个部门的平均工资SELECT e1.last_name,e1.salary,e1.department_id FROM employees AS e1,(SELECT department_id,AVG(salary) AS AVGS FROM employees GROUP BY department_id) AS tem WHERE e1.salary &gt; AVGS AND e1.department_id = tem.department_id; 方式二推荐 相关子查询 内查询的department_id 等于 内查询的department_id 所以给外查询加别名 1SELECT last_name,salary,department_id FROM employees AS e1 WHERE salary &gt; (SELECT AVG(salary) FROM employees GROUP BY department_id HAVING department_id = e1.department_id);","tags":["Database","MariaDB"],"categories":["Language"]},{"title":"06聚合函数","path":"/posts/d7394d1d.html","content":"常用聚合函数AVG() 平均数 \\ SUM() 求和函数仅适用于数值类型 1SELECT AVG(salary) AS &quot;平均工资&quot;,SUM(salary) AS &#x27;公司总工资&#x27; FROM employees; image-20230211170839746 MAX() 最大值 \\ MIN() 最小值适用与数值 字符串 日期类型的字段或变量 1SELECT MAX(salary),MIN(salary) FROM employees; image-20230211171107109 1SELECT MAX(last_name),MIN(last_name),MAX(hire_date) FROM employees; COUNT() 计算指定字段在查询结果中的次数注意!!! 计算的次数不包含NULL空值**方式一：COUNT(具体字段,不一定对) ** *方式二：COUNT() ** 方式三：COUNT(1) 任意常量 方式二和方式三都是全表扫描行数, 不需要读取具体的行 在innodb中效率 方式一 &lt; 方式二 &#x3D; 方式三 123456SELECT COUNT(employee_id),COUNT(*),COUNT(1) FROM employees; # 结果均为107SELECT COUNT(commission_pct) FROM employees; # 结果却只有35条 因为其余都为空SELECT COUNT(IFNULL(commission_pct,0)) FROM employees; # 解决方式 IFNULL(,) 当为空时填充0 结果107条SELECT commission_pct FROM employees WHERE commission_pct IS NOT NULL; # 35条非空 GROUP BY 分组需求 查询各部门平均工资 最高工资 1SELECT department_id,AVG(salary),MAX(salary) FROM employees GROUP BY department_id; image-20230211174728448 需求 多级分组 查询各部门及各工种的平均工资 最高工资 1SELECT department_id,job_id,AVG(salary),MAX(salary) FROM employees GROUP BY department_id,job_id; image-20230211175246729 WITH ROLLUP：在GROUP分组字段的基础上再进行统计数据,且不能和ORDER BY一起使用 123SELECT department_id,AVG(salary),MAX(salary) FROM employees GROUP BY department_id; # 图一 12条SELECT department_id,AVG(salary),MAX(salary) FROM employees GROUP BY department_id WITH ROLLUP; # 图二 13条 图一 图二 HAVING 过滤数据如果过滤条件出现了聚合函数 则必须用HAVING替换WHERE 否则报错 练习 查询各部门中最高工资大于1w的信息 1SELECT department_id,MAX(salary) FROM employees GROUP BY department_id HAVING MAX(salary) &gt; 10000; # 逻辑：先按部门分组 再求各部门最高工资 最后只显示大于1W的部门 image-20230211181222169 练习 查询 10,20,30,40这几个部门中 最高工资大于1W的信息 1234567# 逻辑 先查询10,20,30,40这几个部门ID分组后的最高工资 最后筛选出最高工资大于1W的部门# 方式一 过滤条件没有聚合函数时使用WHERE 效率更高SELECT department_id,MAX(salary) FROM employees WHERE department_id IN (10,20,30,40) GROUP BY department_id HAVING MAX(salary) &gt; 10000;# 方式二 不使用WHERESELECT department_id,MAX(salary) FROM employees GROUP BY department_id HAVING MAX(salary) &gt; 10000 AND department_id IN (10,20,30,40); image-20230211182428365 MYSQL结构image-20230211183847631","tags":["Database","MariaDB"],"categories":["Language"]},{"title":"05加密解密函数","path":"/posts/4b7c2baa.html","content":"加密函数PASSWORD(str)此函数在MySQL8.0中弃用 1SELECT PASSWORD(&#x27;test&#x27;) FROMd DUAL; MD5(str)1SELECT MD5(&#x27;mysql&#x27;) FROM DUAL; image-20230211160650916 SHA(str)1SELECT SHA(&#x27;mysql&#x27;) FROM DUAL; image-20230211160801116 ENCODE(A,B) \\ DECODE(C,D)上述两个函数在MySQL函数中均已弃用 A为待加密内容 B为秘钥 C为待解密内容 D为秘钥 1SELECT ENCODE(&#x27;mysql&#x27;,&#x27;0000&#x27;); 1SELECT DECODE(ENCODE(&#x27;mysql&#x27;,&#x27;0000&#x27;),&#x27;0000&#x27;); 其他函数四舍五入 FORMAT(A,B)将A保留B为数字四舍五入 1SELECT FORMAT(106.3654,2); image-20230211163100665 进制转换 CONV(A,B,C)A为待转换数字,B为当前进制,C为目标进制 1SELECT CONV(201,10,2); # 将201从十进制转换为2进制 image-20230211163214182 IP地址转换INET_ATON(A)：将IP地址A转换为数字地址 如下计算方式为：192X256^3 + 168X256^2 + 1X256^1 + 100X256^0 1SELECT INET_ATON(&#x27;192.168.1.100&#x27;); # 结果：3232235876 INET_NTOA(B)：数字地址转IP 1SELECT INET_NTOA(3232235876); # 结果：192.168.1.100 image-20230211164520992 重复执行表达式BENCHMARK(N,A) 重复执行表达式A,执行次数为N次\t用于测试表达式性能 12SELECT BENCHMARK(5,MD5(&#x27;mysql&#x27;)) # 结果0.028sSELECT BENCHMARK(100000,MD5(&#x27;mysql&#x27;)); # 结果0.046s 字符编码转换 CONVERT(A USING B)将A字符的编码转换为B字符编码 123SELECT CHARSET(&#x27;mysql&#x27;); # 查看此字符当前的编码 结果为：utf8mb4SELECT CHARSET(CONVERT(&#x27;mysql&#x27; USING &#x27;utf8mb3&#x27;)); # 将mysql字符转换为utf8mb3 再查看结果 结果为utf8mb3 转换成功","tags":["Database","MariaDB"],"categories":["Language"]},{"title":"04函数","path":"/posts/7cac1c60.html","content":"2023年2月10日15:30:33 流程控制IF(条件,条件为真返回,条件为假返回)1SELECT last_name AS &quot;名字&quot;,salary AS &quot;工资&quot;,IF(salary&gt;=6000,&quot;高工资&quot;,&quot;低工资&quot;) AS &quot;工资等级&quot; FROM employees; image-20230210161452603 IFNULL(A,B) 如果A为空 则返回BCASE WHEN A THEN B ELSE C END CASE当满足条件A的时候返回B 否则返回C 1234567SELECT last_name,salary,CASE\tWHEN salary &gt;= 8000\tTHEN &quot;高工资&quot;\tWHEN salary &gt;= 6000\tTHEN &quot;一般工资&quot;\tELSE &quot;低工资&quot; END AS &quot;工资等级&quot;FROM employees; image-20230210163045164 CASE WHEN A THEN B ELSE C END CASE练习：查询部门id为10,20,30的员工 部门10打印工资的1.1倍 部门20打印工资的1.2倍 部门30 打印工资的1.3倍 123456789SELECT last_name,department_id,salary,CASE department_id\tWHEN 10 THEN salary * 1.1\tWHEN 20 THEN salary * 1.2\tELSE salary * 1.3END AS &quot;工资加成&quot;FROM employees WHERE department_id IN(10,20,30); image-20230210164005037","tags":["Database","MariaDB"],"categories":["Language"]},{"title":"03多表查询","path":"/posts/4bc002fb.html","content":"多表查询需求 查询名为Abel的人在哪里工作正常查询第一步 查询Able所处的部门ID 1SELECT * FROM employees WHERE last_name = &#x27;Abel&#x27;; # 结果80 img 第二步 查询该部门ID所对应的城市ID 1SELECT * FROM departments WHERE department_id = 80; # 结果2500 image-20230209153011198 第三步 通过城市ID获得具体工作地点 1SELECT * FROM locations WHERE location_id = 2500; # 得到结果Oxford 多表查询123# 注：如果查询的字段在多个表同时存在,必须指明此字段所在的表(建议多表查询时都加上)# 如下面的departments.department_idSELECT last_name,departments.department_id,city FROM employees,departments,locations WHERE last_name = &#x27;Abel&#x27; AND employees.department_id = departments.department_id AND departments.location_id = locations.location_id; image-20230209160218764 给表起别名 增加可读性, 但起别名后只能用别名 原名不可使用 1SELECT el.last_name,dp.department_id,lc.city FROM employees AS el,departments as dp,locations as lc WHERE el.last_name = &#x27;Abel&#x27; AND el.department_id = dp.department_id AND dp.location_id = lc.location_id; 多表连接等值连接 \\ 非等值连接非等值连接例子 查询el表中的所有人工资所对应的jbg表中的工资等级 1SELECT el.last_name,el.salary,jbg.grade_level FROM job_grades as jbg,employees AS el WHERE el.salary &gt;= jbg.lowest_sal AND el.salary &lt;= jbg.highest_sal; image-20230209163819456 用between … and …. 1SELECT el.last_name,el.salary,jbg.grade_level FROM job_grades as jbg,employees AS el WHERE el.salary BETWEEN jbg.lowest_sal AND jbg.highest_sal; image-20230209163806690 自连接 \\ 非自连接自连接(自我引用) 自连接例子 查询el表中员工对应的管理者 1SELECT elyg.last_name &quot;员工名字&quot;,elyg.employee_id AS &quot;员工ID&quot;,elgl.last_name AS &quot;管理者名字&quot;,elgl.employee_id AS &quot;管理者ID&quot; FROM employees as elyg,employees AS elgl WHERE elyg.manager_id = elgl.employee_id; image-20230209164300811 内连接 \\ 外连接内连接：合并具有同一列的两个以上的表的行, 结果集中不包含一个表与另一个表不匹配的行 123SELECT employee_id,department_nameFROM employees e,departments dWHERE e.`department_id` = d.department_id; image-20230209180814479 外连接：合并具有同一列的两个以上的表的行, 结果集中除了包含一个表与另一个表匹配的行之外,还查询到了左表 或 右表中不匹配的行。 1234# 外连接的分类：左外连接、右外连接、满外连接# 左外连接：两个表在连接过程中除了返回满足连接条件的行以外还返回左表中不满足条件的行，这种连接称为左外连接。# 右外连接：两个表在连接过程中除了返回满足连接条件的行以外还返回右表中不满足条件的行，这种连接称为右外连接。 左外连接 … LEFT JOIN … ON …image-20230209180124050 右外连接 … RIGHT JOIN … ON … 1SELECT el.employee_id,el.last_name,dp.department_id FROM employees AS el RIGHT JOIN departments AS dp ON el.department_id = dp.department_id; image-20230209180435649 满外连接(MySQL不支持) 1SELECT el.employee_id,el.last_name,dp.department_id FROM employees AS el FULL JOIN departments AS dp ON el.department_id = dp.department_id; 7种SQL JOIN实现image-20230209181311179 中图内连接 1SELECT el.employee_id,el.last_name,dp.department_id FROM employees el,departments dp WHERE el.department_id = dp.department_id; # 106条 左上图左外连接 1SELECT el.employee_id,el.last_name,dp.department_id FROM employees el LEFT JOIN departments dp ON el.department_id = dp.department_id; # 107条 右上图右外连接 1SELECT el.employee_id,el.last_name,dp.department_id FROM employees el RIGHT JOIN departments dp ON el.department_id = dp.department_id; # 122条 左中图左外连接去交集 1SELECT el.employee_id,el.last_name,el.department_id FROM employees el LEFT JOIN departments dp ON el.department_id = dp.department_id WHERE dp.department_id IS NULL; # 1条 image-20230210142608821 右中图右外连接去交集 1SELECT el.employee_id,el.last_name,el.department_id FROM employees el RIGHT JOIN departments dp ON el.department_id = dp.department_id WHERE el.department_id IS NULL; # 16条 image-20230210142634148 左下图满外连接：左上图 UNION ALL 右中图 (直接用UNION ALL 在中间连接即可) 可以用UNION连接 也可以用 UNION ALL 但UNION比UNION ALL多了去重操作 相对较慢 所以优先使用UNION ALL 123SELECT el.employee_id,el.last_name,dp.department_id FROM employees el LEFT JOIN departments dp ON el.department_id = dp.department_idUNION ALLSELECT el.employee_id,el.last_name,el.department_id FROM employees el RIGHT JOIN departments dp ON el.department_id = dp.department_id WHERE el.department_id IS NULL; # 123条 image-20230210142827221 自然连接NATURAL JOIN：自动查询两张表中所有相同的字段 并进行等值连接 所以也不够灵活, 但只有单个连接或只需要单个连接时推荐使用等值连接 1SELECT el.employee_id,el.last_name FROM employees el, departments dp WHERE el.department_id = dp.department_id AND el.manager_id = dp.manager_id; # 32条 等价于 1SELECT el.employee_id,el.last_name FROM employees el NATURAL JOIN departments dp; # 32条 image-20230210144127963 USING连接仅支持同名字段连接 较为局限 1SELECT * FROM employees el,departments dp WHERE el.department_id = dp.department_id; # 106条 等价 1SELECT * FROM employees JOIN departments USING(department_id); # 106条","tags":["Database","MariaDB"],"categories":["Language"]},{"title":"02排序分页","path":"/posts/b6e9a883.html","content":"排序升序 ASC (ascend) 默认 \\ 降序 DESC (descend)12SELECT * FROM employees;SELECT * FROM employees ORDER BY salary DESC; 多级排序：同时多个条件排序显示员工信息,按照department_id降序排序,salary的升序排 1SELECT department_id,first_name,salary FROM employees ORDER BY department_id DESC , salary ASC; #直接逗号后跟字段名和排序方式 image-20230209144937961 分页全部数据1SELECT employee_id,last_name FROM employees; LIMIT 起点,数量LIMIT 起点行(为0时可省略),数量 ：LIMIT 0,20 等价于 LIMIT 20 1SELECT employee_id,last_name FROM employees LIMIT 20; # 第一页数据 image-20230209145716523 1SELECT employee_id,last_name FROM employees LIMIT 20,20; # 第二页数据 image-20230209150221040 WHERE \\ ORDER BY \\ LIMIT 申明顺序1SELECT employee_id,first_name,salary FROM employees WHERE salary &gt; 6000 ORDER BY salary DESC LIMIT 0,20; image-20230209150548531","tags":["Database","MariaDB"],"categories":["Language"]},{"title":"01过滤比较","path":"/posts/feab7780.html","content":"列的别名 去重 NULL DESC别名 AS12# 注意：列的别名只能在ORDER BY 中使用,不能在WHERE中使用SELECT employee_id AS eid FROM employees; 去重 DISTINCT1SELECT DISTINCT department_id FROM employees; NULL 空值, 不等同于0和’’12# NULL 参与运算：结果一定是NULLSELECT employee_id, salary AS &quot;工资&quot;,salary * (1 + commission_pct) * 12 AS 年工资 FROM employees; 12# 解决方式：IFNULL(某某字段为空,则重新赋值)SELECT employee_id,salary as &quot;工资&quot;,salary * (1 + IFNULL(commission_pct,0)) * 12 AS 年工资 FROM employees; 着重号&#96;&#96;(反引号)当表名 字段名等使用了关键字 则必须使用着重号 1SELECT * FROM `order`; 显示表结构：DESC 全称：Describe意为”描述” 12DESC `order`;DESCRIBE `order`; WHERE过滤数据查询 last_name为King的数据 1SELECT * FROM employees WHERE last_name = &#x27;King&#x27;; 比较运算符比较运算符 结果1表示True 0表示False 其它情况为NULL 等于 &#x3D;1SELECT 2=2,2!=2; 安全等于 &lt;&#x3D;&gt;在没使用NULL比较时 所有与NULL比较的运算结果都为NULL,比如 SELECT NULL &#x3D; NULL; 结果为NULL而不是1 1SELECT NULL = NULL; 在使用安全等于以后可以正常使用NULL进行比较, SELECT NULL &lt;&#x3D;&gt; NULL; 结果则为1 1SELECT NULL &lt;=&gt; NULL; 关键字IS NULL为空 \\ IS NOT NULL 不为空\\ ISNULL(expr) 空函数 123SELECT NULL IS NULL; # 结果1SELECT NULL IS NOT NULL; # 结果0SELECT ISNULL(NULL); # 结果1 最小值：LEAST(value1,value2,…) \\ 最大值：GREATEST(value1,value2,…) 12SELECT LEAST(3,2,4); # 结果2SELECT GREATEST(&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;); # 结果c 区间 BETWEEN 条件1 AND 条件2 ：左右闭合区间 条件1为下限 条件2为上限 不可交换 12SELECT * FROM employees WHERE salary BETWEEN 6000 AND 8000;SELECT * FROM employees WHERE salary &gt;= 6000 AND salary &lt;= 8000; # 等价 集合i IN(SET) \\ NOT IN(SET) 12SELECT * FROM employees WHERE employee_id IN(106,108,109,125);SELECT * FROM employees WHERE employee_id NOT IN(106,108,109,125); 模糊查询 LIKE 12345# 通配符 % 不确定数量的字符 \\ _一个字符# 转义字符 \\ # ESCAPE 让某个符号变成转义字符SELECT employee_id,last_name,job_id FROM employees WHERE job_id LIKE &#x27;AD\\_%&#x27;; # 默认转义字符SELECT employee_id,last_name,job_id FROM employees WHERE job_id LIKE &#x27;AD@_%&#x27; ESCAPE &#x27;@&#x27; ; # 让艾特符号变成转义字符 正则表达式 REGEXP 12SELECT &#x27;Rock Candy&#x27; REGEXP &#x27;^R&#x27;; # 是否以R字母开头SELECT * FROM employees WHERE email REGEXP &#x27;^A&#x27;; # 匹配所有邮箱以A开头的数据 逻辑运算符AND与&amp;&amp; \\ OR 或 \\ NOT非! \\ XOR 逻辑异或 123SELECT 5=5 XOR 6=6; # 结果0 同为真则为假SELECT 5=6 XOR 7=8; # 结果0 同为假则为假SELECT 5=6 XOR 6=6; # 结果1 不同结果为真","tags":["Database","MariaDB"],"categories":["Language"]},{"title":"00数据准备","path":"/posts/f16f1253.html","content":"复制后重命名为sql文件 直接导入即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228/*SQLyog Ultimate v12.08 (64 bit)MySQL - 5.7.28-log : Database - atguigudb**********************************************************************//*!40101 SET NAMES utf8 */;/*!40101 SET SQL_MODE=&#x27;&#x27;*/;/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=&#x27;NO_AUTO_VALUE_ON_ZERO&#x27; */;/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;CREATE DATABASE /*!32312 IF NOT EXISTS*/`atguigudb` /*!40100 DEFAULT CHARACTER SET utf8 */;USE `atguigudb`;/*Table structure for table `countries` */DROP TABLE IF EXISTS `countries`;CREATE TABLE `countries` ( `country_id` char(2) NOT NULL, `country_name` varchar(40) DEFAULT NULL, `region_id` int(11) DEFAULT NULL, PRIMARY KEY (`country_id`), KEY `countr_reg_fk` (`region_id`), CONSTRAINT `countr_reg_fk` FOREIGN KEY (`region_id`) REFERENCES `regions` (`region_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;/*Data for the table `countries` */insert into `countries`(`country_id`,`country_name`,`region_id`) values (&#x27;AR&#x27;,&#x27;Argentina&#x27;,2),(&#x27;AU&#x27;,&#x27;Australia&#x27;,3),(&#x27;BE&#x27;,&#x27;Belgium&#x27;,1),(&#x27;BR&#x27;,&#x27;Brazil&#x27;,2),(&#x27;CA&#x27;,&#x27;Canada&#x27;,2),(&#x27;CH&#x27;,&#x27;Switzerland&#x27;,1),(&#x27;CN&#x27;,&#x27;China&#x27;,3),(&#x27;DE&#x27;,&#x27;Germany&#x27;,1),(&#x27;DK&#x27;,&#x27;Denmark&#x27;,1),(&#x27;EG&#x27;,&#x27;Egypt&#x27;,4),(&#x27;FR&#x27;,&#x27;France&#x27;,1),(&#x27;HK&#x27;,&#x27;HongKong&#x27;,3),(&#x27;IL&#x27;,&#x27;Israel&#x27;,4),(&#x27;IN&#x27;,&#x27;India&#x27;,3),(&#x27;IT&#x27;,&#x27;Italy&#x27;,1),(&#x27;JP&#x27;,&#x27;Japan&#x27;,3),(&#x27;KW&#x27;,&#x27;Kuwait&#x27;,4),(&#x27;MX&#x27;,&#x27;Mexico&#x27;,2),(&#x27;NG&#x27;,&#x27;Nigeria&#x27;,4),(&#x27;NL&#x27;,&#x27;Netherlands&#x27;,1),(&#x27;SG&#x27;,&#x27;Singapore&#x27;,3),(&#x27;UK&#x27;,&#x27;United Kingdom&#x27;,1),(&#x27;US&#x27;,&#x27;United States of America&#x27;,2),(&#x27;ZM&#x27;,&#x27;Zambia&#x27;,4),(&#x27;ZW&#x27;,&#x27;Zimbabwe&#x27;,4);/*Table structure for table `departments` */DROP TABLE IF EXISTS `departments`;CREATE TABLE `departments` ( `department_id` int(4) NOT NULL DEFAULT &#x27;0&#x27;, `department_name` varchar(30) NOT NULL, `manager_id` int(6) DEFAULT NULL, `location_id` int(4) DEFAULT NULL, PRIMARY KEY (`department_id`), UNIQUE KEY `dept_id_pk` (`department_id`), KEY `dept_loc_fk` (`location_id`), KEY `dept_mgr_fk` (`manager_id`), CONSTRAINT `dept_loc_fk` FOREIGN KEY (`location_id`) REFERENCES `locations` (`location_id`), CONSTRAINT `dept_mgr_fk` FOREIGN KEY (`manager_id`) REFERENCES `employees` (`employee_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;/*Data for the table `departments` */insert into `departments`(`department_id`,`department_name`,`manager_id`,`location_id`) values (10,&#x27;Administration&#x27;,200,1700),(20,&#x27;Marketing&#x27;,201,1800),(30,&#x27;Purchasing&#x27;,114,1700),(40,&#x27;Human Resources&#x27;,203,2400),(50,&#x27;Shipping&#x27;,121,1500),(60,&#x27;IT&#x27;,103,1400),(70,&#x27;Public Relations&#x27;,204,2700),(80,&#x27;Sales&#x27;,145,2500),(90,&#x27;Executive&#x27;,100,1700),(100,&#x27;Finance&#x27;,108,1700),(110,&#x27;Accounting&#x27;,205,1700),(120,&#x27;Treasury&#x27;,NULL,1700),(130,&#x27;Corporate Tax&#x27;,NULL,1700),(140,&#x27;Control And Credit&#x27;,NULL,1700),(150,&#x27;Shareholder Services&#x27;,NULL,1700),(160,&#x27;Benefits&#x27;,NULL,1700),(170,&#x27;Manufacturing&#x27;,NULL,1700),(180,&#x27;Construction&#x27;,NULL,1700),(190,&#x27;Contracting&#x27;,NULL,1700),(200,&#x27;Operations&#x27;,NULL,1700),(210,&#x27;IT Support&#x27;,NULL,1700),(220,&#x27;NOC&#x27;,NULL,1700),(230,&#x27;IT Helpdesk&#x27;,NULL,1700),(240,&#x27;Government Sales&#x27;,NULL,1700),(250,&#x27;Retail Sales&#x27;,NULL,1700),(260,&#x27;Recruiting&#x27;,NULL,1700),(270,&#x27;Payroll&#x27;,NULL,1700);/*Table structure for table `employees` */DROP TABLE IF EXISTS `employees`;CREATE TABLE `employees` ( `employee_id` int(6) NOT NULL DEFAULT &#x27;0&#x27;, `first_name` varchar(20) DEFAULT NULL, `last_name` varchar(25) NOT NULL, `email` varchar(25) NOT NULL, `phone_number` varchar(20) DEFAULT NULL, `hire_date` date NOT NULL, `job_id` varchar(10) NOT NULL, `salary` double(8,2) DEFAULT NULL, `commission_pct` double(2,2) DEFAULT NULL, `manager_id` int(6) DEFAULT NULL, `department_id` int(4) DEFAULT NULL, PRIMARY KEY (`employee_id`), UNIQUE KEY `emp_email_uk` (`email`), UNIQUE KEY `emp_emp_id_pk` (`employee_id`), KEY `emp_dept_fk` (`department_id`), KEY `emp_job_fk` (`job_id`), KEY `emp_manager_fk` (`manager_id`), CONSTRAINT `emp_dept_fk` FOREIGN KEY (`department_id`) REFERENCES `departments` (`department_id`), CONSTRAINT `emp_job_fk` FOREIGN KEY (`job_id`) REFERENCES `jobs` (`job_id`), CONSTRAINT `emp_manager_fk` FOREIGN KEY (`manager_id`) REFERENCES `employees` (`employee_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;/*Data for the table `employees` */insert into `employees`(`employee_id`,`first_name`,`last_name`,`email`,`phone_number`,`hire_date`,`job_id`,`salary`,`commission_pct`,`manager_id`,`department_id`) values (100,&#x27;Steven&#x27;,&#x27;King&#x27;,&#x27;SKING&#x27;,&#x27;515.123.4567&#x27;,&#x27;1987-06-17&#x27;,&#x27;AD_PRES&#x27;,24000.00,NULL,NULL,90),(101,&#x27;Neena&#x27;,&#x27;Kochhar&#x27;,&#x27;NKOCHHAR&#x27;,&#x27;515.123.4568&#x27;,&#x27;1989-09-21&#x27;,&#x27;AD_VP&#x27;,17000.00,NULL,100,90),(102,&#x27;Lex&#x27;,&#x27;De Haan&#x27;,&#x27;LDEHAAN&#x27;,&#x27;515.123.4569&#x27;,&#x27;1993-01-13&#x27;,&#x27;AD_VP&#x27;,17000.00,NULL,100,90),(103,&#x27;Alexander&#x27;,&#x27;Hunold&#x27;,&#x27;AHUNOLD&#x27;,&#x27;590.423.4567&#x27;,&#x27;1990-01-03&#x27;,&#x27;IT_PROG&#x27;,9000.00,NULL,102,60),(104,&#x27;Bruce&#x27;,&#x27;Ernst&#x27;,&#x27;BERNST&#x27;,&#x27;590.423.4568&#x27;,&#x27;1991-05-21&#x27;,&#x27;IT_PROG&#x27;,6000.00,NULL,103,60),(105,&#x27;David&#x27;,&#x27;Austin&#x27;,&#x27;DAUSTIN&#x27;,&#x27;590.423.4569&#x27;,&#x27;1997-06-25&#x27;,&#x27;IT_PROG&#x27;,4800.00,NULL,103,60),(106,&#x27;Valli&#x27;,&#x27;Pataballa&#x27;,&#x27;VPATABAL&#x27;,&#x27;590.423.4560&#x27;,&#x27;1998-02-05&#x27;,&#x27;IT_PROG&#x27;,4800.00,NULL,103,60),(107,&#x27;Diana&#x27;,&#x27;Lorentz&#x27;,&#x27;DLORENTZ&#x27;,&#x27;590.423.5567&#x27;,&#x27;1999-02-07&#x27;,&#x27;IT_PROG&#x27;,4200.00,NULL,103,60),(108,&#x27;Nancy&#x27;,&#x27;Greenberg&#x27;,&#x27;NGREENBE&#x27;,&#x27;515.124.4569&#x27;,&#x27;1994-08-17&#x27;,&#x27;FI_MGR&#x27;,12000.00,NULL,101,100),(109,&#x27;Daniel&#x27;,&#x27;Faviet&#x27;,&#x27;DFAVIET&#x27;,&#x27;515.124.4169&#x27;,&#x27;1994-08-16&#x27;,&#x27;FI_ACCOUNT&#x27;,9000.00,NULL,108,100),(110,&#x27;John&#x27;,&#x27;Chen&#x27;,&#x27;JCHEN&#x27;,&#x27;515.124.4269&#x27;,&#x27;1997-09-28&#x27;,&#x27;FI_ACCOUNT&#x27;,8200.00,NULL,108,100),(111,&#x27;Ismael&#x27;,&#x27;Sciarra&#x27;,&#x27;ISCIARRA&#x27;,&#x27;515.124.4369&#x27;,&#x27;1997-09-30&#x27;,&#x27;FI_ACCOUNT&#x27;,7700.00,NULL,108,100),(112,&#x27;Jose Manuel&#x27;,&#x27;Urman&#x27;,&#x27;JMURMAN&#x27;,&#x27;515.124.4469&#x27;,&#x27;1998-03-07&#x27;,&#x27;FI_ACCOUNT&#x27;,7800.00,NULL,108,100),(113,&#x27;Luis&#x27;,&#x27;Popp&#x27;,&#x27;LPOPP&#x27;,&#x27;515.124.4567&#x27;,&#x27;1999-12-07&#x27;,&#x27;FI_ACCOUNT&#x27;,6900.00,NULL,108,100),(114,&#x27;Den&#x27;,&#x27;Raphaely&#x27;,&#x27;DRAPHEAL&#x27;,&#x27;515.127.4561&#x27;,&#x27;1994-12-07&#x27;,&#x27;PU_MAN&#x27;,11000.00,NULL,100,30),(115,&#x27;Alexander&#x27;,&#x27;Khoo&#x27;,&#x27;AKHOO&#x27;,&#x27;515.127.4562&#x27;,&#x27;1995-05-18&#x27;,&#x27;PU_CLERK&#x27;,3100.00,NULL,114,30),(116,&#x27;Shelli&#x27;,&#x27;Baida&#x27;,&#x27;SBAIDA&#x27;,&#x27;515.127.4563&#x27;,&#x27;1997-12-24&#x27;,&#x27;PU_CLERK&#x27;,2900.00,NULL,114,30),(117,&#x27;Sigal&#x27;,&#x27;Tobias&#x27;,&#x27;STOBIAS&#x27;,&#x27;515.127.4564&#x27;,&#x27;1997-07-24&#x27;,&#x27;PU_CLERK&#x27;,2800.00,NULL,114,30),(118,&#x27;Guy&#x27;,&#x27;Himuro&#x27;,&#x27;GHIMURO&#x27;,&#x27;515.127.4565&#x27;,&#x27;1998-11-15&#x27;,&#x27;PU_CLERK&#x27;,2600.00,NULL,114,30),(119,&#x27;Karen&#x27;,&#x27;Colmenares&#x27;,&#x27;KCOLMENA&#x27;,&#x27;515.127.4566&#x27;,&#x27;1999-08-10&#x27;,&#x27;PU_CLERK&#x27;,2500.00,NULL,114,30),(120,&#x27;Matthew&#x27;,&#x27;Weiss&#x27;,&#x27;MWEISS&#x27;,&#x27;650.123.1234&#x27;,&#x27;1996-07-18&#x27;,&#x27;ST_MAN&#x27;,8000.00,NULL,100,50),(121,&#x27;Adam&#x27;,&#x27;Fripp&#x27;,&#x27;AFRIPP&#x27;,&#x27;650.123.2234&#x27;,&#x27;1997-04-10&#x27;,&#x27;ST_MAN&#x27;,8200.00,NULL,100,50),(122,&#x27;Payam&#x27;,&#x27;Kaufling&#x27;,&#x27;PKAUFLIN&#x27;,&#x27;650.123.3234&#x27;,&#x27;1995-05-01&#x27;,&#x27;ST_MAN&#x27;,7900.00,NULL,100,50),(123,&#x27;Shanta&#x27;,&#x27;Vollman&#x27;,&#x27;SVOLLMAN&#x27;,&#x27;650.123.4234&#x27;,&#x27;1997-10-10&#x27;,&#x27;ST_MAN&#x27;,6500.00,NULL,100,50),(124,&#x27;Kevin&#x27;,&#x27;Mourgos&#x27;,&#x27;KMOURGOS&#x27;,&#x27;650.123.5234&#x27;,&#x27;1999-11-16&#x27;,&#x27;ST_MAN&#x27;,5800.00,NULL,100,50),(125,&#x27;Julia&#x27;,&#x27;Nayer&#x27;,&#x27;JNAYER&#x27;,&#x27;650.124.1214&#x27;,&#x27;1997-07-16&#x27;,&#x27;ST_CLERK&#x27;,3200.00,NULL,120,50),(126,&#x27;Irene&#x27;,&#x27;Mikkilineni&#x27;,&#x27;IMIKKILI&#x27;,&#x27;650.124.1224&#x27;,&#x27;1998-09-28&#x27;,&#x27;ST_CLERK&#x27;,2700.00,NULL,120,50),(127,&#x27;James&#x27;,&#x27;Landry&#x27;,&#x27;JLANDRY&#x27;,&#x27;650.124.1334&#x27;,&#x27;1999-01-14&#x27;,&#x27;ST_CLERK&#x27;,2400.00,NULL,120,50),(128,&#x27;Steven&#x27;,&#x27;Markle&#x27;,&#x27;SMARKLE&#x27;,&#x27;650.124.1434&#x27;,&#x27;2000-03-08&#x27;,&#x27;ST_CLERK&#x27;,2200.00,NULL,120,50),(129,&#x27;Laura&#x27;,&#x27;Bissot&#x27;,&#x27;LBISSOT&#x27;,&#x27;650.124.5234&#x27;,&#x27;1997-08-20&#x27;,&#x27;ST_CLERK&#x27;,3300.00,NULL,121,50),(130,&#x27;Mozhe&#x27;,&#x27;Atkinson&#x27;,&#x27;MATKINSO&#x27;,&#x27;650.124.6234&#x27;,&#x27;1997-10-30&#x27;,&#x27;ST_CLERK&#x27;,2800.00,NULL,121,50),(131,&#x27;James&#x27;,&#x27;Marlow&#x27;,&#x27;JAMRLOW&#x27;,&#x27;650.124.7234&#x27;,&#x27;1997-02-16&#x27;,&#x27;ST_CLERK&#x27;,2500.00,NULL,121,50),(132,&#x27;TJ&#x27;,&#x27;Olson&#x27;,&#x27;TJOLSON&#x27;,&#x27;650.124.8234&#x27;,&#x27;1999-04-10&#x27;,&#x27;ST_CLERK&#x27;,2100.00,NULL,121,50),(133,&#x27;Jason&#x27;,&#x27;Mallin&#x27;,&#x27;JMALLIN&#x27;,&#x27;650.127.1934&#x27;,&#x27;1996-06-14&#x27;,&#x27;ST_CLERK&#x27;,3300.00,NULL,122,50),(134,&#x27;Michael&#x27;,&#x27;Rogers&#x27;,&#x27;MROGERS&#x27;,&#x27;650.127.1834&#x27;,&#x27;1998-08-26&#x27;,&#x27;ST_CLERK&#x27;,2900.00,NULL,122,50),(135,&#x27;Ki&#x27;,&#x27;Gee&#x27;,&#x27;KGEE&#x27;,&#x27;650.127.1734&#x27;,&#x27;1999-12-12&#x27;,&#x27;ST_CLERK&#x27;,2400.00,NULL,122,50),(136,&#x27;Hazel&#x27;,&#x27;Philtanker&#x27;,&#x27;HPHILTAN&#x27;,&#x27;650.127.1634&#x27;,&#x27;2000-02-06&#x27;,&#x27;ST_CLERK&#x27;,2200.00,NULL,122,50),(137,&#x27;Renske&#x27;,&#x27;Ladwig&#x27;,&#x27;RLADWIG&#x27;,&#x27;650.121.1234&#x27;,&#x27;1995-07-14&#x27;,&#x27;ST_CLERK&#x27;,3600.00,NULL,123,50),(138,&#x27;Stephen&#x27;,&#x27;Stiles&#x27;,&#x27;SSTILES&#x27;,&#x27;650.121.2034&#x27;,&#x27;1997-10-26&#x27;,&#x27;ST_CLERK&#x27;,3200.00,NULL,123,50),(139,&#x27;John&#x27;,&#x27;Seo&#x27;,&#x27;JSEO&#x27;,&#x27;650.121.2019&#x27;,&#x27;1998-02-12&#x27;,&#x27;ST_CLERK&#x27;,2700.00,NULL,123,50),(140,&#x27;Joshua&#x27;,&#x27;Patel&#x27;,&#x27;JPATEL&#x27;,&#x27;650.121.1834&#x27;,&#x27;1998-04-06&#x27;,&#x27;ST_CLERK&#x27;,2500.00,NULL,123,50),(141,&#x27;Trenna&#x27;,&#x27;Rajs&#x27;,&#x27;TRAJS&#x27;,&#x27;650.121.8009&#x27;,&#x27;1995-10-17&#x27;,&#x27;ST_CLERK&#x27;,3500.00,NULL,124,50),(142,&#x27;Curtis&#x27;,&#x27;Davies&#x27;,&#x27;CDAVIES&#x27;,&#x27;650.121.2994&#x27;,&#x27;1997-01-29&#x27;,&#x27;ST_CLERK&#x27;,3100.00,NULL,124,50),(143,&#x27;Randall&#x27;,&#x27;Matos&#x27;,&#x27;RMATOS&#x27;,&#x27;650.121.2874&#x27;,&#x27;1998-03-15&#x27;,&#x27;ST_CLERK&#x27;,2600.00,NULL,124,50),(144,&#x27;Peter&#x27;,&#x27;Vargas&#x27;,&#x27;PVARGAS&#x27;,&#x27;650.121.2004&#x27;,&#x27;1998-07-09&#x27;,&#x27;ST_CLERK&#x27;,2500.00,NULL,124,50),(145,&#x27;John&#x27;,&#x27;Russell&#x27;,&#x27;JRUSSEL&#x27;,&#x27;011.44.1344.429268&#x27;,&#x27;1996-10-01&#x27;,&#x27;SA_MAN&#x27;,14000.00,0.40,100,80),(146,&#x27;Karen&#x27;,&#x27;Partners&#x27;,&#x27;KPARTNER&#x27;,&#x27;011.44.1344.467268&#x27;,&#x27;1997-01-05&#x27;,&#x27;SA_MAN&#x27;,13500.00,0.30,100,80),(147,&#x27;Alberto&#x27;,&#x27;Errazuriz&#x27;,&#x27;AERRAZUR&#x27;,&#x27;011.44.1344.429278&#x27;,&#x27;1997-03-10&#x27;,&#x27;SA_MAN&#x27;,12000.00,0.30,100,80),(148,&#x27;Gerald&#x27;,&#x27;Cambrault&#x27;,&#x27;GCAMBRAU&#x27;,&#x27;011.44.1344.619268&#x27;,&#x27;1999-10-15&#x27;,&#x27;SA_MAN&#x27;,11000.00,0.30,100,80),(149,&#x27;Eleni&#x27;,&#x27;Zlotkey&#x27;,&#x27;EZLOTKEY&#x27;,&#x27;011.44.1344.429018&#x27;,&#x27;2000-01-29&#x27;,&#x27;SA_MAN&#x27;,10500.00,0.20,100,80),(150,&#x27;Peter&#x27;,&#x27;Tucker&#x27;,&#x27;PTUCKER&#x27;,&#x27;011.44.1344.129268&#x27;,&#x27;1997-01-30&#x27;,&#x27;SA_REP&#x27;,10000.00,0.30,145,80),(151,&#x27;David&#x27;,&#x27;Bernstein&#x27;,&#x27;DBERNSTE&#x27;,&#x27;011.44.1344.345268&#x27;,&#x27;1997-03-24&#x27;,&#x27;SA_REP&#x27;,9500.00,0.25,145,80),(152,&#x27;Peter&#x27;,&#x27;Hall&#x27;,&#x27;PHALL&#x27;,&#x27;011.44.1344.478968&#x27;,&#x27;1997-08-20&#x27;,&#x27;SA_REP&#x27;,9000.00,0.25,145,80),(153,&#x27;Christopher&#x27;,&#x27;Olsen&#x27;,&#x27;COLSEN&#x27;,&#x27;011.44.1344.498718&#x27;,&#x27;1998-03-30&#x27;,&#x27;SA_REP&#x27;,8000.00,0.20,145,80),(154,&#x27;Nanette&#x27;,&#x27;Cambrault&#x27;,&#x27;NCAMBRAU&#x27;,&#x27;011.44.1344.987668&#x27;,&#x27;1998-12-09&#x27;,&#x27;SA_REP&#x27;,7500.00,0.20,145,80),(155,&#x27;Oliver&#x27;,&#x27;Tuvault&#x27;,&#x27;OTUVAULT&#x27;,&#x27;011.44.1344.486508&#x27;,&#x27;1999-11-23&#x27;,&#x27;SA_REP&#x27;,7000.00,0.15,145,80),(156,&#x27;Janette&#x27;,&#x27;King&#x27;,&#x27;JKING&#x27;,&#x27;011.44.1345.429268&#x27;,&#x27;1996-01-30&#x27;,&#x27;SA_REP&#x27;,10000.00,0.35,146,80),(157,&#x27;Patrick&#x27;,&#x27;Sully&#x27;,&#x27;PSULLY&#x27;,&#x27;011.44.1345.929268&#x27;,&#x27;1996-03-04&#x27;,&#x27;SA_REP&#x27;,9500.00,0.35,146,80),(158,&#x27;Allan&#x27;,&#x27;McEwen&#x27;,&#x27;AMCEWEN&#x27;,&#x27;011.44.1345.829268&#x27;,&#x27;1996-08-01&#x27;,&#x27;SA_REP&#x27;,9000.00,0.35,146,80),(159,&#x27;Lindsey&#x27;,&#x27;Smith&#x27;,&#x27;LSMITH&#x27;,&#x27;011.44.1345.729268&#x27;,&#x27;1997-03-10&#x27;,&#x27;SA_REP&#x27;,8000.00,0.30,146,80),(160,&#x27;Louise&#x27;,&#x27;Doran&#x27;,&#x27;LDORAN&#x27;,&#x27;011.44.1345.629268&#x27;,&#x27;1997-12-15&#x27;,&#x27;SA_REP&#x27;,7500.00,0.30,146,80),(161,&#x27;Sarath&#x27;,&#x27;Sewall&#x27;,&#x27;SSEWALL&#x27;,&#x27;011.44.1345.529268&#x27;,&#x27;1998-11-03&#x27;,&#x27;SA_REP&#x27;,7000.00,0.25,146,80),(162,&#x27;Clara&#x27;,&#x27;Vishney&#x27;,&#x27;CVISHNEY&#x27;,&#x27;011.44.1346.129268&#x27;,&#x27;1997-11-11&#x27;,&#x27;SA_REP&#x27;,10500.00,0.25,147,80),(163,&#x27;Danielle&#x27;,&#x27;Greene&#x27;,&#x27;DGREENE&#x27;,&#x27;011.44.1346.229268&#x27;,&#x27;1999-03-19&#x27;,&#x27;SA_REP&#x27;,9500.00,0.15,147,80),(164,&#x27;Mattea&#x27;,&#x27;Marvins&#x27;,&#x27;MMARVINS&#x27;,&#x27;011.44.1346.329268&#x27;,&#x27;2000-01-24&#x27;,&#x27;SA_REP&#x27;,7200.00,0.10,147,80),(165,&#x27;David&#x27;,&#x27;Lee&#x27;,&#x27;DLEE&#x27;,&#x27;011.44.1346.529268&#x27;,&#x27;2000-02-23&#x27;,&#x27;SA_REP&#x27;,6800.00,0.10,147,80),(166,&#x27;Sundar&#x27;,&#x27;Ande&#x27;,&#x27;SANDE&#x27;,&#x27;011.44.1346.629268&#x27;,&#x27;2000-03-24&#x27;,&#x27;SA_REP&#x27;,6400.00,0.10,147,80),(167,&#x27;Amit&#x27;,&#x27;Banda&#x27;,&#x27;ABANDA&#x27;,&#x27;011.44.1346.729268&#x27;,&#x27;2000-04-21&#x27;,&#x27;SA_REP&#x27;,6200.00,0.10,147,80),(168,&#x27;Lisa&#x27;,&#x27;Ozer&#x27;,&#x27;LOZER&#x27;,&#x27;011.44.1343.929268&#x27;,&#x27;1997-03-11&#x27;,&#x27;SA_REP&#x27;,11500.00,0.25,148,80),(169,&#x27;Harrison&#x27;,&#x27;Bloom&#x27;,&#x27;HBLOOM&#x27;,&#x27;011.44.1343.829268&#x27;,&#x27;1998-03-23&#x27;,&#x27;SA_REP&#x27;,10000.00,0.20,148,80),(170,&#x27;Tayler&#x27;,&#x27;Fox&#x27;,&#x27;TFOX&#x27;,&#x27;011.44.1343.729268&#x27;,&#x27;1998-01-24&#x27;,&#x27;SA_REP&#x27;,9600.00,0.20,148,80),(171,&#x27;William&#x27;,&#x27;Smith&#x27;,&#x27;WSMITH&#x27;,&#x27;011.44.1343.629268&#x27;,&#x27;1999-02-23&#x27;,&#x27;SA_REP&#x27;,7400.00,0.15,148,80),(172,&#x27;Elizabeth&#x27;,&#x27;Bates&#x27;,&#x27;EBATES&#x27;,&#x27;011.44.1343.529268&#x27;,&#x27;1999-03-24&#x27;,&#x27;SA_REP&#x27;,7300.00,0.15,148,80),(173,&#x27;Sundita&#x27;,&#x27;Kumar&#x27;,&#x27;SKUMAR&#x27;,&#x27;011.44.1343.329268&#x27;,&#x27;2000-04-21&#x27;,&#x27;SA_REP&#x27;,6100.00,0.10,148,80),(174,&#x27;Ellen&#x27;,&#x27;Abel&#x27;,&#x27;EABEL&#x27;,&#x27;011.44.1644.429267&#x27;,&#x27;1996-05-11&#x27;,&#x27;SA_REP&#x27;,11000.00,0.30,149,80),(175,&#x27;Alyssa&#x27;,&#x27;Hutton&#x27;,&#x27;AHUTTON&#x27;,&#x27;011.44.1644.429266&#x27;,&#x27;1997-03-19&#x27;,&#x27;SA_REP&#x27;,8800.00,0.25,149,80),(176,&#x27;Jonathon&#x27;,&#x27;Taylor&#x27;,&#x27;JTAYLOR&#x27;,&#x27;011.44.1644.429265&#x27;,&#x27;1998-03-24&#x27;,&#x27;SA_REP&#x27;,8600.00,0.20,149,80),(177,&#x27;Jack&#x27;,&#x27;Livingston&#x27;,&#x27;JLIVINGS&#x27;,&#x27;011.44.1644.429264&#x27;,&#x27;1998-04-23&#x27;,&#x27;SA_REP&#x27;,8400.00,0.20,149,80),(178,&#x27;Kimberely&#x27;,&#x27;Grant&#x27;,&#x27;KGRANT&#x27;,&#x27;011.44.1644.429263&#x27;,&#x27;1999-05-24&#x27;,&#x27;SA_REP&#x27;,7000.00,0.15,149,NULL),(179,&#x27;Charles&#x27;,&#x27;Johnson&#x27;,&#x27;CJOHNSON&#x27;,&#x27;011.44.1644.429262&#x27;,&#x27;2000-01-04&#x27;,&#x27;SA_REP&#x27;,6200.00,0.10,149,80),(180,&#x27;Winston&#x27;,&#x27;Taylor&#x27;,&#x27;WTAYLOR&#x27;,&#x27;650.507.9876&#x27;,&#x27;1998-01-24&#x27;,&#x27;SH_CLERK&#x27;,3200.00,NULL,120,50),(181,&#x27;Jean&#x27;,&#x27;Fleaur&#x27;,&#x27;JFLEAUR&#x27;,&#x27;650.507.9877&#x27;,&#x27;1998-02-23&#x27;,&#x27;SH_CLERK&#x27;,3100.00,NULL,120,50),(182,&#x27;Martha&#x27;,&#x27;Sullivan&#x27;,&#x27;MSULLIVA&#x27;,&#x27;650.507.9878&#x27;,&#x27;1999-06-21&#x27;,&#x27;SH_CLERK&#x27;,2500.00,NULL,120,50),(183,&#x27;Girard&#x27;,&#x27;Geoni&#x27;,&#x27;GGEONI&#x27;,&#x27;650.507.9879&#x27;,&#x27;2000-02-03&#x27;,&#x27;SH_CLERK&#x27;,2800.00,NULL,120,50),(184,&#x27;Nandita&#x27;,&#x27;Sarchand&#x27;,&#x27;NSARCHAN&#x27;,&#x27;650.509.1876&#x27;,&#x27;1996-01-27&#x27;,&#x27;SH_CLERK&#x27;,4200.00,NULL,121,50),(185,&#x27;Alexis&#x27;,&#x27;Bull&#x27;,&#x27;ABULL&#x27;,&#x27;650.509.2876&#x27;,&#x27;1997-02-20&#x27;,&#x27;SH_CLERK&#x27;,4100.00,NULL,121,50),(186,&#x27;Julia&#x27;,&#x27;Dellinger&#x27;,&#x27;JDELLING&#x27;,&#x27;650.509.3876&#x27;,&#x27;1998-06-24&#x27;,&#x27;SH_CLERK&#x27;,3400.00,NULL,121,50),(187,&#x27;Anthony&#x27;,&#x27;Cabrio&#x27;,&#x27;ACABRIO&#x27;,&#x27;650.509.4876&#x27;,&#x27;1999-02-07&#x27;,&#x27;SH_CLERK&#x27;,3000.00,NULL,121,50),(188,&#x27;Kelly&#x27;,&#x27;Chung&#x27;,&#x27;KCHUNG&#x27;,&#x27;650.505.1876&#x27;,&#x27;1997-06-14&#x27;,&#x27;SH_CLERK&#x27;,3800.00,NULL,122,50),(189,&#x27;Jennifer&#x27;,&#x27;Dilly&#x27;,&#x27;JDILLY&#x27;,&#x27;650.505.2876&#x27;,&#x27;1997-08-13&#x27;,&#x27;SH_CLERK&#x27;,3600.00,NULL,122,50),(190,&#x27;Timothy&#x27;,&#x27;Gates&#x27;,&#x27;TGATES&#x27;,&#x27;650.505.3876&#x27;,&#x27;1998-07-11&#x27;,&#x27;SH_CLERK&#x27;,2900.00,NULL,122,50),(191,&#x27;Randall&#x27;,&#x27;Perkins&#x27;,&#x27;RPERKINS&#x27;,&#x27;650.505.4876&#x27;,&#x27;1999-12-19&#x27;,&#x27;SH_CLERK&#x27;,2500.00,NULL,122,50),(192,&#x27;Sarah&#x27;,&#x27;Bell&#x27;,&#x27;SBELL&#x27;,&#x27;650.501.1876&#x27;,&#x27;1996-02-04&#x27;,&#x27;SH_CLERK&#x27;,4000.00,NULL,123,50),(193,&#x27;Britney&#x27;,&#x27;Everett&#x27;,&#x27;BEVERETT&#x27;,&#x27;650.501.2876&#x27;,&#x27;1997-03-03&#x27;,&#x27;SH_CLERK&#x27;,3900.00,NULL,123,50),(194,&#x27;Samuel&#x27;,&#x27;McCain&#x27;,&#x27;SMCCAIN&#x27;,&#x27;650.501.3876&#x27;,&#x27;1998-07-01&#x27;,&#x27;SH_CLERK&#x27;,3200.00,NULL,123,50),(195,&#x27;Vance&#x27;,&#x27;Jones&#x27;,&#x27;VJONES&#x27;,&#x27;650.501.4876&#x27;,&#x27;1999-03-17&#x27;,&#x27;SH_CLERK&#x27;,2800.00,NULL,123,50),(196,&#x27;Alana&#x27;,&#x27;Walsh&#x27;,&#x27;AWALSH&#x27;,&#x27;650.507.9811&#x27;,&#x27;1998-04-24&#x27;,&#x27;SH_CLERK&#x27;,3100.00,NULL,124,50),(197,&#x27;Kevin&#x27;,&#x27;Feeney&#x27;,&#x27;KFEENEY&#x27;,&#x27;650.507.9822&#x27;,&#x27;1998-05-23&#x27;,&#x27;SH_CLERK&#x27;,3000.00,NULL,124,50),(198,&#x27;Donald&#x27;,&#x27;OConnell&#x27;,&#x27;DOCONNEL&#x27;,&#x27;650.507.9833&#x27;,&#x27;1999-06-21&#x27;,&#x27;SH_CLERK&#x27;,2600.00,NULL,124,50),(199,&#x27;Douglas&#x27;,&#x27;Grant&#x27;,&#x27;DGRANT&#x27;,&#x27;650.507.9844&#x27;,&#x27;2000-01-13&#x27;,&#x27;SH_CLERK&#x27;,2600.00,NULL,124,50),(200,&#x27;Jennifer&#x27;,&#x27;Whalen&#x27;,&#x27;JWHALEN&#x27;,&#x27;515.123.4444&#x27;,&#x27;1987-09-17&#x27;,&#x27;AD_ASST&#x27;,4400.00,NULL,101,10),(201,&#x27;Michael&#x27;,&#x27;Hartstein&#x27;,&#x27;MHARTSTE&#x27;,&#x27;515.123.5555&#x27;,&#x27;1996-02-17&#x27;,&#x27;MK_MAN&#x27;,13000.00,NULL,100,20),(202,&#x27;Pat&#x27;,&#x27;Fay&#x27;,&#x27;PFAY&#x27;,&#x27;603.123.6666&#x27;,&#x27;1997-08-17&#x27;,&#x27;MK_REP&#x27;,6000.00,NULL,201,20),(203,&#x27;Susan&#x27;,&#x27;Mavris&#x27;,&#x27;SMAVRIS&#x27;,&#x27;515.123.7777&#x27;,&#x27;1994-06-07&#x27;,&#x27;HR_REP&#x27;,6500.00,NULL,101,40),(204,&#x27;Hermann&#x27;,&#x27;Baer&#x27;,&#x27;HBAER&#x27;,&#x27;515.123.8888&#x27;,&#x27;1994-06-07&#x27;,&#x27;PR_REP&#x27;,10000.00,NULL,101,70),(205,&#x27;Shelley&#x27;,&#x27;Higgins&#x27;,&#x27;SHIGGINS&#x27;,&#x27;515.123.8080&#x27;,&#x27;1994-06-07&#x27;,&#x27;AC_MGR&#x27;,12000.00,NULL,101,110),(206,&#x27;William&#x27;,&#x27;Gietz&#x27;,&#x27;WGIETZ&#x27;,&#x27;515.123.8181&#x27;,&#x27;1994-06-07&#x27;,&#x27;AC_ACCOUNT&#x27;,8300.00,NULL,205,110);/*Table structure for table `job_grades` */DROP TABLE IF EXISTS `job_grades`;CREATE TABLE `job_grades` ( `grade_level` varchar(3) DEFAULT NULL, `lowest_sal` int(11) DEFAULT NULL, `highest_sal` int(11) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8;/*Data for the table `job_grades` */insert into `job_grades`(`grade_level`,`lowest_sal`,`highest_sal`) values (&#x27;A&#x27;,1000,2999),(&#x27;B&#x27;,3000,5999),(&#x27;C&#x27;,6000,9999),(&#x27;D&#x27;,10000,14999),(&#x27;E&#x27;,15000,24999),(&#x27;F&#x27;,25000,40000);/*Table structure for table `job_history` */DROP TABLE IF EXISTS `job_history`;CREATE TABLE `job_history` ( `employee_id` int(6) NOT NULL, `start_date` date NOT NULL, `end_date` date NOT NULL, `job_id` varchar(10) NOT NULL, `department_id` int(4) DEFAULT NULL, PRIMARY KEY (`employee_id`,`start_date`), UNIQUE KEY `jhist_emp_id_st_date_pk` (`employee_id`,`start_date`), KEY `jhist_job_fk` (`job_id`), KEY `jhist_dept_fk` (`department_id`), CONSTRAINT `jhist_dept_fk` FOREIGN KEY (`department_id`) REFERENCES `departments` (`department_id`), CONSTRAINT `jhist_emp_fk` FOREIGN KEY (`employee_id`) REFERENCES `employees` (`employee_id`), CONSTRAINT `jhist_job_fk` FOREIGN KEY (`job_id`) REFERENCES `jobs` (`job_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;/*Data for the table `job_history` */insert into `job_history`(`employee_id`,`start_date`,`end_date`,`job_id`,`department_id`) values (101,&#x27;1989-09-21&#x27;,&#x27;1993-10-27&#x27;,&#x27;AC_ACCOUNT&#x27;,110),(101,&#x27;1993-10-28&#x27;,&#x27;1997-03-15&#x27;,&#x27;AC_MGR&#x27;,110),(102,&#x27;1993-01-13&#x27;,&#x27;1998-07-24&#x27;,&#x27;IT_PROG&#x27;,60),(114,&#x27;1998-03-24&#x27;,&#x27;1999-12-31&#x27;,&#x27;ST_CLERK&#x27;,50),(122,&#x27;1999-01-01&#x27;,&#x27;1999-12-31&#x27;,&#x27;ST_CLERK&#x27;,50),(176,&#x27;1998-03-24&#x27;,&#x27;1998-12-31&#x27;,&#x27;SA_REP&#x27;,80),(176,&#x27;1999-01-01&#x27;,&#x27;1999-12-31&#x27;,&#x27;SA_MAN&#x27;,80),(200,&#x27;1987-09-17&#x27;,&#x27;1993-06-17&#x27;,&#x27;AD_ASST&#x27;,90),(200,&#x27;1994-07-01&#x27;,&#x27;1998-12-31&#x27;,&#x27;AC_ACCOUNT&#x27;,90),(201,&#x27;1996-02-17&#x27;,&#x27;1999-12-19&#x27;,&#x27;MK_REP&#x27;,20);/*Table structure for table `jobs` */DROP TABLE IF EXISTS `jobs`;CREATE TABLE `jobs` ( `job_id` varchar(10) NOT NULL DEFAULT &#x27;&#x27;, `job_title` varchar(35) NOT NULL, `min_salary` int(6) DEFAULT NULL, `max_salary` int(6) DEFAULT NULL, PRIMARY KEY (`job_id`), UNIQUE KEY `job_id_pk` (`job_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;/*Data for the table `jobs` */insert into `jobs`(`job_id`,`job_title`,`min_salary`,`max_salary`) values (&#x27;AC_ACCOUNT&#x27;,&#x27;Public Accountant&#x27;,4200,9000),(&#x27;AC_MGR&#x27;,&#x27;Accounting Manager&#x27;,8200,16000),(&#x27;AD_ASST&#x27;,&#x27;Administration Assistant&#x27;,3000,6000),(&#x27;AD_PRES&#x27;,&#x27;President&#x27;,20000,40000),(&#x27;AD_VP&#x27;,&#x27;Administration Vice President&#x27;,15000,30000),(&#x27;FI_ACCOUNT&#x27;,&#x27;Accountant&#x27;,4200,9000),(&#x27;FI_MGR&#x27;,&#x27;Finance Manager&#x27;,8200,16000),(&#x27;HR_REP&#x27;,&#x27;Human Resources Representative&#x27;,4000,9000),(&#x27;IT_PROG&#x27;,&#x27;Programmer&#x27;,4000,10000),(&#x27;MK_MAN&#x27;,&#x27;Marketing Manager&#x27;,9000,15000),(&#x27;MK_REP&#x27;,&#x27;Marketing Representative&#x27;,4000,9000),(&#x27;PR_REP&#x27;,&#x27;Public Relations Representative&#x27;,4500,10500),(&#x27;PU_CLERK&#x27;,&#x27;Purchasing Clerk&#x27;,2500,5500),(&#x27;PU_MAN&#x27;,&#x27;Purchasing Manager&#x27;,8000,15000),(&#x27;SA_MAN&#x27;,&#x27;Sales Manager&#x27;,10000,20000),(&#x27;SA_REP&#x27;,&#x27;Sales Representative&#x27;,6000,12000),(&#x27;SH_CLERK&#x27;,&#x27;Shipping Clerk&#x27;,2500,5500),(&#x27;ST_CLERK&#x27;,&#x27;Stock Clerk&#x27;,2000,5000),(&#x27;ST_MAN&#x27;,&#x27;Stock Manager&#x27;,5500,8500);/*Table structure for table `locations` */DROP TABLE IF EXISTS `locations`;CREATE TABLE `locations` ( `location_id` int(4) NOT NULL DEFAULT &#x27;0&#x27;, `street_address` varchar(40) DEFAULT NULL, `postal_code` varchar(12) DEFAULT NULL, `city` varchar(30) NOT NULL, `state_province` varchar(25) DEFAULT NULL, `country_id` char(2) DEFAULT NULL, PRIMARY KEY (`location_id`), UNIQUE KEY `loc_id_pk` (`location_id`), KEY `loc_c_id_fk` (`country_id`), CONSTRAINT `loc_c_id_fk` FOREIGN KEY (`country_id`) REFERENCES `countries` (`country_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;/*Data for the table `locations` */insert into `locations`(`location_id`,`street_address`,`postal_code`,`city`,`state_province`,`country_id`) values (1000,&#x27;1297 Via Cola di Rie&#x27;,&#x27;00989&#x27;,&#x27;Roma&#x27;,NULL,&#x27;IT&#x27;),(1100,&#x27;93091 Calle della Testa&#x27;,&#x27;10934&#x27;,&#x27;Venice&#x27;,NULL,&#x27;IT&#x27;),(1200,&#x27;2017 Shinjuku-ku&#x27;,&#x27;1689&#x27;,&#x27;Tokyo&#x27;,&#x27;Tokyo Prefecture&#x27;,&#x27;JP&#x27;),(1300,&#x27;9450 Kamiya-cho&#x27;,&#x27;6823&#x27;,&#x27;Hiroshima&#x27;,NULL,&#x27;JP&#x27;),(1400,&#x27;2014 Jabberwocky Rd&#x27;,&#x27;26192&#x27;,&#x27;Southlake&#x27;,&#x27;Texas&#x27;,&#x27;US&#x27;),(1500,&#x27;2011 Interiors Blvd&#x27;,&#x27;99236&#x27;,&#x27;South San Francisco&#x27;,&#x27;California&#x27;,&#x27;US&#x27;),(1600,&#x27;2007 Zagora St&#x27;,&#x27;50090&#x27;,&#x27;South Brunswick&#x27;,&#x27;New Jersey&#x27;,&#x27;US&#x27;),(1700,&#x27;2004 Charade Rd&#x27;,&#x27;98199&#x27;,&#x27;Seattle&#x27;,&#x27;Washington&#x27;,&#x27;US&#x27;),(1800,&#x27;147 Spadina Ave&#x27;,&#x27;M5V 2L7&#x27;,&#x27;Toronto&#x27;,&#x27;Ontario&#x27;,&#x27;CA&#x27;),(1900,&#x27;6092 Boxwood St&#x27;,&#x27;YSW 9T2&#x27;,&#x27;Whitehorse&#x27;,&#x27;Yukon&#x27;,&#x27;CA&#x27;),(2000,&#x27;40-5-12 Laogianggen&#x27;,&#x27;190518&#x27;,&#x27;Beijing&#x27;,NULL,&#x27;CN&#x27;),(2100,&#x27;1298 Vileparle (E)&#x27;,&#x27;490231&#x27;,&#x27;Bombay&#x27;,&#x27;Maharashtra&#x27;,&#x27;IN&#x27;),(2200,&#x27;12-98 Victoria Street&#x27;,&#x27;2901&#x27;,&#x27;Sydney&#x27;,&#x27;New South Wales&#x27;,&#x27;AU&#x27;),(2300,&#x27;198 Clementi North&#x27;,&#x27;540198&#x27;,&#x27;Singapore&#x27;,NULL,&#x27;SG&#x27;),(2400,&#x27;8204 Arthur St&#x27;,NULL,&#x27;London&#x27;,NULL,&#x27;UK&#x27;),(2500,&#x27;Magdalen Centre, The Oxford Science Park&#x27;,&#x27;OX9 9ZB&#x27;,&#x27;Oxford&#x27;,&#x27;Oxford&#x27;,&#x27;UK&#x27;),(2600,&#x27;9702 Chester Road&#x27;,&#x27;09629850293&#x27;,&#x27;Stretford&#x27;,&#x27;Manchester&#x27;,&#x27;UK&#x27;),(2700,&#x27;Schwanthalerstr. 7031&#x27;,&#x27;80925&#x27;,&#x27;Munich&#x27;,&#x27;Bavaria&#x27;,&#x27;DE&#x27;),(2800,&#x27;Rua Frei Caneca 1360 &#x27;,&#x27;01307-002&#x27;,&#x27;Sao Paulo&#x27;,&#x27;Sao Paulo&#x27;,&#x27;BR&#x27;),(2900,&#x27;20 Rue des Corps-Saints&#x27;,&#x27;1730&#x27;,&#x27;Geneva&#x27;,&#x27;Geneve&#x27;,&#x27;CH&#x27;),(3000,&#x27;Murtenstrasse 921&#x27;,&#x27;3095&#x27;,&#x27;Bern&#x27;,&#x27;BE&#x27;,&#x27;CH&#x27;),(3100,&#x27;Pieter Breughelstraat 837&#x27;,&#x27;3029SK&#x27;,&#x27;Utrecht&#x27;,&#x27;Utrecht&#x27;,&#x27;NL&#x27;),(3200,&#x27;Mariano Escobedo 9991&#x27;,&#x27;11932&#x27;,&#x27;Mexico City&#x27;,&#x27;Distrito Federal,&#x27;,&#x27;MX&#x27;);/*Table structure for table `order` */DROP TABLE IF EXISTS `order`;CREATE TABLE `order` ( `order_id` int(11) DEFAULT NULL, `order_name` varchar(15) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8;/*Data for the table `order` */insert into `order`(`order_id`,`order_name`) values (1,&#x27;shkstart&#x27;),(2,&#x27;tomcat&#x27;),(3,&#x27;dubbo&#x27;);/*Table structure for table `regions` */DROP TABLE IF EXISTS `regions`;CREATE TABLE `regions` ( `region_id` int(11) NOT NULL, `region_name` varchar(25) DEFAULT NULL, PRIMARY KEY (`region_id`), UNIQUE KEY `reg_id_pk` (`region_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;/*Data for the table `regions` */insert into `regions`(`region_id`,`region_name`) values (1,&#x27;Europe&#x27;),(2,&#x27;Americas&#x27;),(3,&#x27;Asia&#x27;),(4,&#x27;Middle East and Africa&#x27;);/*Table structure for table `emp_details_view` */DROP TABLE IF EXISTS `emp_details_view`;/*!50001 DROP VIEW IF EXISTS `emp_details_view` */;/*!50001 DROP TABLE IF EXISTS `emp_details_view` */;/*!50001 CREATE TABLE `emp_details_view`( `employee_id` int(6) , `job_id` varchar(10) , `manager_id` int(6) , `department_id` int(4) , `location_id` int(4) , `country_id` char(2) , `first_name` varchar(20) , `last_name` varchar(25) , `salary` double(8,2) , `commission_pct` double(2,2) , `department_name` varchar(30) , `job_title` varchar(35) , `city` varchar(30) , `state_province` varchar(25) , `country_name` varchar(40) , `region_name` varchar(25) )*/;/*View structure for view emp_details_view *//*!50001 DROP TABLE IF EXISTS `emp_details_view` */;/*!50001 DROP VIEW IF EXISTS `emp_details_view` */;/*!50001 CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `emp_details_view` AS select `e`.`employee_id` AS `employee_id`,`e`.`job_id` AS `job_id`,`e`.`manager_id` AS `manager_id`,`e`.`department_id` AS `department_id`,`d`.`location_id` AS `location_id`,`l`.`country_id` AS `country_id`,`e`.`first_name` AS `first_name`,`e`.`last_name` AS `last_name`,`e`.`salary` AS `salary`,`e`.`commission_pct` AS `commission_pct`,`d`.`department_name` AS `department_name`,`j`.`job_title` AS `job_title`,`l`.`city` AS `city`,`l`.`state_province` AS `state_province`,`c`.`country_name` AS `country_name`,`r`.`region_name` AS `region_name` from (((((`employees` `e` join `departments` `d`) join `jobs` `j`) join `locations` `l`) join `countries` `c`) join `regions` `r`) where ((`e`.`department_id` = `d`.`department_id`) and (`d`.`location_id` = `l`.`location_id`) and (`l`.`country_id` = `c`.`country_id`) and (`c`.`region_id` = `r`.`region_id`) and (`j`.`job_id` = `e`.`job_id`)) */;/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;","tags":["Database","MariaDB"],"categories":["Language"]},{"title":"Docker部署Bitwarden","path":"/posts/bee90e33.html","content":"安装Bitwarden我们先部署bitwarden，然后使用Nginx作为反向代理，将请求转发到bitwarden服务器上。 Docker部署bitwarden 12345678910111213141516171819202122232425262728293031323334353637383940414243mkdir /data/bitwardendocker run -d \\ --rm \\ --name bitwarden \\ -p 8080:80 \\ -p 3012:3012 \\ -e SIGNUPS_ALLOWED=true \\ -e WEB_VAULT_ENABLED=true \\ -e DOMAIN=https://mydomain.cn \\ -v /data/bitwarden:/data \\ vaultwarden/server:latest上面命令的各个参数含义如下：-d 在后台运行--rm 容器停止运行后，自动删除容器文件--name bitwarden容器的名字为bitwarden-p 8080:80 容器的端口80映射到8080，在Nginx配置-p 3012:3012 容器的端口3012映射到3012-e SIGNUPS_ALLOWED=true 设置环境变量SIGNUPS_ALLOWED=true允许用户注册-e WBE_VAULT_ENABLE=true 设置环境变量WBE_VAULT_ENABLE=true-e DOMAIN=https://mydomain.cn设置域名,需要替换成自己申请的域名-v /data/bitwarden:/data 容器的/data/目录映射到宿主机的/data/bitwarden目录 Bitwarden部署安装教程 解析域名Bitwarden部署安装教程 解析一个域名到你的服务器上， 配置反向代理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859server&#123; listen 80; server_name password.example.com; index index.php index.html index.htm default.php default.htm default.html; root /www/wwwroot/password.imcahron.com; location / &#123; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header Range $http_range; proxy_set_header If-Range $http_if_range; proxy_redirect off; proxy_pass http://127.0.0.1:8080; &#125; #禁止访问的文件或目录 location ~ ^/(\\.user.ini|\\.htaccess|\\.git|\\.svn|\\.project|LICENSE|README.md) &#123; return 404; &#125; #一键申请SSL证书验证目录相关设置 location ~ \\.well-known&#123; allow all; &#125; access_log /www/wwwlogs/password.imcahron.com.log; error_log /www/wwwlogs/password.imcahron.com.error.log;&#125; 因为我用的cloudflare，所以没有https的设置，你们在宝塔配置完直接把我的反代贴上去就行。 注册账户Bitwarden部署安装教程 访问你的bitwarden，创建一个账户。 Bitwarden部署安装教程 填写相应的信息，进行注册。 Bitwarden部署安装教程 注册完登录出现界面，表示成功。 禁止其他人注册 由于这个bitwarden服务器是供个人使用，我们在注册完账号后，要关闭注册功能，防止他人注册。 12345678910111213141516171819202122232425# 先停止bitwarden容器docker stop bitwarden# 设置环境变量不允许注册用户-e SIGNUPS_ALLOWED=false，再启动bitwarden容器docker run -d \\ --rm \\ --name bitwarden \\ -p 8080:80 \\ -p 3012:3012 \\ -e SIGNUPS_ALLOWED=false \\ -e WEB_VAULT_ENABLED=true \\ -e DOMAIN=https://mydomain \\ -v /data/bitwarden:/data \\ vaultwarden/server:latest 此时再注册账号时，会提示不允许注册或用户已存在.这样的错误。 Bitwarden部署安装教程 Chrome上使用bitwardenBitwarden部署安装教程 前往chrome商店安装最新的bitwarden插件。 Bitwarden部署安装教程 然后把插件钉住在常用栏。 Bitwarden部署安装教程 Bitwarden部署安装教程 点击设置，输入我们的私有服务地址。然后返回主页面登录。 Bitwarden部署安装教程 成功部署完毕。 其他平台客户端直接前往 https://bitwarden.com/download 进行下载其他平台客户端，和插件设置方法相似，设置完url直接登录即可。","tags":["Docker","Bitwarden"],"categories":["WebSite"]},{"title":"Linux常用命令大全","path":"/posts/44b30305.html","content":"Linux命令 — 系统信息 命令代码 注释说明 arch 显示机器的处理器架构（1） uname -m 显示机器的处理器架构（2） uname -r 显示正在使用的内核版本 dmidecode -q 显示硬件系统部件 - (SMBIOS &#x2F; DMI) hdparm -i &#x2F;dev&#x2F;hda 罗列一个磁盘的架构特性 hdparm -tT &#x2F;dev&#x2F;sda 在磁盘上执行测试性读取操作 cat &#x2F;proc&#x2F;cpuinfo 显示CPU info的信息 cat &#x2F;proc&#x2F;interrupts 显示中断 cat &#x2F;proc&#x2F;meminfo 校验内存使用 cat &#x2F;proc&#x2F;swaps 显示哪些swap被使用 cat &#x2F;proc&#x2F;version 显示内核的版本 cat &#x2F;proc&#x2F;net&#x2F;dev 显示网络适配器及统计 cat &#x2F;proc&#x2F;mounts 显示已加载的文件系统 lspci -tv 罗列 PCI 设备 lsusb -tv 显示 USB 设备 date 显示系统日期 cal 2007 显示2007年的日历表 date 041217002007.00 设置日期和时间 - 月日时分年.秒 clock -w 将时间修改保存到 BIOS Linux命令 — 系统关机 (关机、重启以及登出 ) 命令代码 注释说明 shutdown -h now 关闭系统 init 0 关闭系统 telinit 0 关闭系统 shutdown -h hours:minutes &amp; 按预定时间关闭系统 shutdown -c 取消按预定时间关闭系统 shutdown -r now 重启 reboot 重启 logout 注销 Linux命令 — 文件和目录 命令代码 注释说明 cd &#x2F;home 进入 ‘&#x2F; home’ 目录’ cd .. 返回上一级目录 cd ..&#x2F;.. 返回上两级目录 cd 进入个人的主目录 cd ~user1 进入个人的主目录 cd - 返回上次所在的目录 pwd 显示工作路径 ls 查看目录中的文件 ls -F 查看目录中的文件 ls -l 显示文件和目录的详细资料 ls -a 显示隐藏文件 ls [0-9] 显示包含数字的文件名和目录名 tree 显示文件和目录由根目录开始的树形结构 lstree 显示文件和目录由根目录开始的树形结构 mkdir dir1 创建一个叫做 ‘dir1’ 的目录’ mkdir dir1 dir2 同时创建两个目录 mkdir -p &#x2F;tmp&#x2F;dir1&#x2F;dir2 创建一个目录树 rm -f file1 删除一个叫做 ‘file1’ 的文件’ rmdir dir1 删除一个叫做 ‘dir1’ 的目录’ rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容 rm -rf dir1 dir2 同时删除两个目录及它们的内容 mv dir1 new_dir 重命名&#x2F;移动 一个目录 cp file1 file2 复制一个文件 cp dir&#x2F;* . 复制一个目录下的所有文件到当前工作目录 cp -a &#x2F;tmp&#x2F;dir1 . 复制一个目录到当前工作目录 cp -a dir1 dir2 复制一个目录 ln -s file1 lnk1 创建一个指向文件或目录的软链接 ln file1 lnk1 创建一个指向文件或目录的物理链接 touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm) iconv -l 列出已知的编码 iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile 改变字符的编码 find . -maxdepth 1 -name *.jpg -print -exec convert 批量调整当前目录中的文件大小并将其发送到缩略图目录（需要从ImageMagick转换） Linux命令 — 文件搜索 命令代码 注释说明 find &#x2F; -name file1 从 ‘&#x2F;‘ 开始进入根文件系统搜索文件和目录 find &#x2F; -user user1 搜索属于用户 ‘user1’ 的文件和目录 find &#x2F;home&#x2F;user1 -name *.bin 在目录 ‘&#x2F; home&#x2F;user1’ 中搜索带有’.bin’ 结尾的文件 find &#x2F;usr&#x2F;bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件 find &#x2F;usr&#x2F;bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件 find &#x2F; -name *.rpm -exec chmod 755 ‘{}’ ; 搜索以 ‘.rpm’ 结尾的文件并定义其权限 find &#x2F; -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备 locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令 whereis halt 显示一个二进制文件、源码或man的位置 which halt 显示一个二进制文件或可执行文件的完整路径 Linux命令 — 挂载一个文件系统 命令代码 注释说明 mount &#x2F;dev&#x2F;hda2 &#x2F;mnt&#x2F;hda2 挂载一个叫做hda2的盘 - 确定目录 ‘&#x2F; mnt&#x2F;hda2’ 已经存在 umount &#x2F;dev&#x2F;hda2 卸载一个叫做hda2的盘 - 先从挂载点 ‘&#x2F; mnt&#x2F;hda2’ 退出 fuser -km &#x2F;mnt&#x2F;hda2 当设备繁忙时强制卸载 umount -n &#x2F;mnt&#x2F;hda2 运行卸载操作而不写入 &#x2F;etc&#x2F;mtab 文件- 当文件为只读或当磁盘写满时非常有用 mount &#x2F;dev&#x2F;fd0 &#x2F;mnt&#x2F;floppy 挂载一个软盘 mount &#x2F;dev&#x2F;cdrom &#x2F;mnt&#x2F;cdrom 挂载一个cdrom或dvdrom mount &#x2F;dev&#x2F;hdc &#x2F;mnt&#x2F;cdrecorder 挂载一个cdrw或dvdrom mount &#x2F;dev&#x2F;hdb &#x2F;mnt&#x2F;cdrecorder 挂载一个cdrw或dvdrom mount -o loop file.iso &#x2F;mnt&#x2F;cdrom 挂载一个文件或ISO镜像文件 mount -t vfat &#x2F;dev&#x2F;hda5 &#x2F;mnt&#x2F;hda5 挂载一个Windows FAT32文件系统 mount &#x2F;dev&#x2F;sda1 &#x2F;mnt&#x2F;usbdisk 挂载一个usb 捷盘或闪存设备 mount -t smbfs -o username&#x3D;user,password&#x3D;pass &#x2F;&#x2F;WinClient&#x2F;share &#x2F;mnt&#x2F;share 挂载一个windows网络共享 Linux命令 — 磁盘空间 命令代码 注释说明 df -h 显示已经挂载的分区列表 ls -lSr |more 以尺寸大小排列文件和目录 du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’ du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小 rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统) dpkg-query -W -f&#x3D;’${Installed-Size;10}t${Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) Linux命令 — 用户和群组 命令代码 注释说明 groupadd group_name 创建一个新用户组 groupdel group_name 删除一个用户组 groupmod -n new_group_name old_group_name 重命名一个用户组 useradd -c “Name Surname “ -g admin -d &#x2F;home&#x2F;user1 -s &#x2F;bin&#x2F;bash user1 创建一个属于 “admin” 用户组的用户 useradd user1 创建一个新用户 userdel -r user1 删除一个用户 ( ‘-r’ 排除主目录) usermod -c “User FTP” -g system -d &#x2F;ftp&#x2F;user1 -s &#x2F;bin&#x2F;nologin user1 修改用户属性 passwd 修改口令 passwd user1 修改一个用户的口令 (只允许root执行) chage -E 2020-12-31 user1 设置用户口令的失效期限 pwck 检查 ‘&#x2F;etc&#x2F;passwd’ 的文件格式和语法修正以及存在的用户 grpck 检查 ‘&#x2F;etc&#x2F;passwd’ 的文件格式和语法修正以及存在的群组 newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组 Linux命令 — 文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消 命令代码 注释说明 ls -lh 显示权限 ls &#x2F;tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示 chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限 chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限 chown user1 file1 改变一个文件的所有人属性 chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性 chgrp group1 file1 改变文件的群组 chown user1:group1 file1 改变一个文件的所有人和群组属性 find &#x2F; -perm -u+s 罗列一个系统中所有使用了SUID控制的文件 chmod u+s &#x2F;bin&#x2F;file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限 chmod u-s &#x2F;bin&#x2F;file1 禁用一个二进制文件的 SUID位 chmod g+s &#x2F;home&#x2F;public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的 chmod g-s &#x2F;home&#x2F;public 禁用一个目录的 SGID 位 chmod o+t &#x2F;home&#x2F;public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件 chmod o-t &#x2F;home&#x2F;public 禁用一个目录的 STIKY 位 Linux命令 — 文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消 命令代码 注释说明 chattr +a file1 只允许以追加方式读写文件 chattr +c file1 允许这个文件能被内核自动压缩&#x2F;解压 chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件 chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接 chattr +s file1 允许一个文件被安全地删除 chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘 chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件 lsattr 显示特殊的属性 Linux命令 — 打包和压缩文件 命令代码 注释说明 bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件 bzip2 file1 压缩一个叫做 ‘file1’ 的文件 gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件 gzip file1 压缩一个叫做 ‘file1’的文件 gzip -9 file1 最大程度压缩 rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包 rar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’ rar x file1.rar 解压rar包 unrar x file1.rar 解压rar包 tar -cvf archive.tar file1 创建一个非压缩的 tarball tar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件 tar -tf archive.tar 显示一个包中的内容 tar -xvf archive.tar 释放一个包 tar -xvf archive.tar -C &#x2F;tmp 将压缩包释放到 &#x2F;tmp目录下 tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包 tar -jxvf archive.tar.bz2 解压一个bzip2格式的压缩包 tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包 tar -zxvf archive.tar.gz 解压一个gzip格式的压缩包 zip file1.zip file1 创建一个zip格式的压缩包 zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包 unzip file1.zip 解压一个zip格式压缩包 Linux命令 — RPM 包 - （Fedora, Redhat及类似系统） 命令代码 注释说明 rpm -ivh package.rpm 安装一个rpm包 rpm -ivh –nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告 rpm -U package.rpm 更新一个rpm包但不改变其配置文件 rpm -F package.rpm 更新一个确定已经安装的rpm包 rpm -e package_name.rpm 删除一个rpm包 rpm -qa 显示系统中所有已经安装的rpm包 rpm -qa | grep httpd 显示所有名称中包含 “httpd” 字样的rpm包 rpm -qi package_name 获取一个已安装包的特殊信息 rpm -qg “System Environment&#x2F;Daemons” 显示一个组件的rpm包 rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表 rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表 rpm -q package_name –whatrequires 显示与一个rpm包存在依赖关系的列表 rpm -q package_name –whatprovides 显示一个rpm包所占的体积 rpm -q package_name –scripts 显示在安装&#x2F;删除期间所执行的脚本l rpm -q package_name –changelog 显示一个rpm包的修改历史 rpm -qf &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf 确认所给的文件由哪个rpm包所提供 rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表 rpm –import &#x2F;media&#x2F;cdrom&#x2F;RPM-GPG-KEY 导入公钥数字证书 rpm –checksig package.rpm 确认一个rpm包的完整性 rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性 rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间 rpm -Va 检查系统中所有已安装的rpm包- 小心使用 rpm -Vp package.rpm 确认一个rpm包还未安装 rpm2cpio package.rpm | cpio –extract –make-directories bin 从一个rpm包运行可执行文件 rpm -ivh &#x2F;usr&#x2F;src&#x2F;redhat&#x2F;RPMS&#x2F;arch&#x2F;package.rpm 从一个rpm源码安装一个构建好的包 rpmbuild –rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包 Linux命令 — YUM 软件包升级器 - （Fedora, RedHat及类似系统） 命令代码 注释说明 yum install package_name 下载并安装一个rpm包 yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系 yum update package_name.rpm 更新当前系统中所有安装的rpm包 yum update package_name 更新一个rpm包 yum remove package_name 删除一个rpm包 yum list 列出当前系统中安装的所有包 yum search package_name 在rpm仓库中搜寻软件包 yum clean packages 清理rpm缓存删除下载的包 yum clean headers 删除所有头文件 yum clean all 删除所有缓存的包和头文件 Linux命令 — DEB 包 (Debian, Ubuntu 以及类似系统) 命令代码 注释说明 dpkg -i package.deb 安装&#x2F;更新一个 deb 包 dpkg -r package_name 从系统删除一个 deb 包 dpkg -l 显示系统中所有已经安装的 deb 包 dpkg -l | grep httpd 显示所有名称中包含 “httpd” 字样的deb包 dpkg -s package_name 获得已经安装在系统中一个特殊包的信息 dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表 dpkg –contents package.deb 显示尚未安装的一个包所提供的文件列表 dpkg -S &#x2F;bin&#x2F;ping 确认所给的文件由哪个deb包提供 Linux命令 — APT 软件工具 (Debian, Ubuntu 以及类似系统) 命令代码 注释说明 apt-get install package_name 安装&#x2F;更新一个 deb 包 apt-cdrom install package_name 从光盘安装&#x2F;更新一个 deb 包 apt-get update 升级列表中的软件包 apt-get upgrade 升级所有已安装的软件 apt-get remove package_name 从系统删除一个deb包 apt-get check 确认依赖的软件仓库正确 apt-get clean 从下载的软件包中清理缓存 apt-cache search searched-package 返回包含所要搜索字符串的软件包名称 Linux命令 — 查看文件内容 命令代码 注释说明 cat file1 从第一个字节开始正向查看文件的内容 tac file1 从最后一行开始反向查看一个文件的内容 more file1 查看一个长文件的内容 less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作 head -2 file1 查看一个文件的前两行 tail -2 file1 查看一个文件的最后两行 tail -f &#x2F;var&#x2F;log&#x2F;messages 实时查看被添加到一个文件中的内容 Linux命令 — 文本处理 命令代码 注释说明 cat file1 | command( sed, grep, awk, grep, etc…) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中 cat file1 | command( sed, grep, awk, grep, etc…) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中 grep Aug &#x2F;var&#x2F;log&#x2F;messages 在文件 ‘&#x2F;var&#x2F;log&#x2F;messages’中查找关键词”Aug” grep ^Aug &#x2F;var&#x2F;log&#x2F;messages 在文件 ‘&#x2F;var&#x2F;log&#x2F;messages’中查找以”Aug”开始的词汇 grep [0-9] &#x2F;var&#x2F;log&#x2F;messages 选择 ‘&#x2F;var&#x2F;log&#x2F;messages’ 文件中所有包含数字的行 grep Aug -R &#x2F;var&#x2F;log&#x2F;* 在目录 ‘&#x2F;var&#x2F;log’ 及随后的目录中搜索字符串”Aug” sed ‘s&#x2F;stringa1&#x2F;stringa2&#x2F;g’ example.txt 将example.txt文件中的 “string1” 替换成 “string2” sed ‘&#x2F;^$&#x2F;d’ example.txt 从example.txt文件中删除所有空白行 sed ‘&#x2F; *#&#x2F;d; &#x2F;^$&#x2F;d’ example.txt 从example.txt 文件中删除所有注释和空白行 echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’ 合并上下单元格内容 sed -e ‘1d’ result.txt 从文件example.txt 中排除第一行 sed -n ‘&#x2F;stringa1&#x2F;p’ 查看只包含词汇 “string1”的行 sed -e ‘s&#x2F; *$&#x2F;&#x2F;‘ example.txt 删除每一行最后的空白字符 sed -e ‘s&#x2F;stringa1&#x2F;&#x2F;g’ example.txt 从文档中只删除词汇 “string1” 并保留剩余全部 sed -n ‘1,5p;5q’ example.txt 查看从第一行到第5行内容 sed -n ‘5p;5q’ example.txt 查看第5行 sed -e ‘s&#x2F;00*&#x2F;0&#x2F;g’ example.txt 用单个零替换多个零 cat -n file1 标示文件的行数 cat example.txt | awk ‘NR%2&#x3D;&#x3D;1’ 删除example.txt文件中的所有偶数行 echo a b c | awk ‘{print $1}’ 查看一行第一栏 echo a b c | awk ‘{print $1,$3}’ 查看一行的第一和第三栏 paste file1 file2 合并两个文件或两栏的内容 paste -d ‘+’ file1 file2 合并两个文件或两栏的内容，中间用”+”区分 sort file1 file2 排序两个文件的内容 sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份) sort file1 file2 | uniq -u 删除交集，留下其他的行 sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件) comm -1 file1 file2 比较两个文件的内容只删除 ‘file1’ 所包含的内容 comm -2 file1 file2 比较两个文件的内容只删除 ‘file2’ 所包含的内容 comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 Linux命令 — 字符设置和文件格式转换 命令代码 注释说明 dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS recode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成html recode -l | more 显示所有允许的转换格式 Linux命令 — 文件系统分析 命令代码 注释说明 badblocks -v &#x2F;dev&#x2F;hda1 检查磁盘hda1上的坏磁块 fsck &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上linux文件系统的完整性 fsck.ext2 &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上ext2文件系统的完整性 e2fsck &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上ext2文件系统的完整性 e2fsck -j &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上ext3文件系统的完整性 fsck.ext3 &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上ext3文件系统的完整性 fsck.vfat &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上fat文件系统的完整性 fsck.msdos &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上dos文件系统的完整性 dosfsck &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上dos文件系统的完整性 Linux命令 — 初始化一个文件系统 命令代码 注释说明 mkfs &#x2F;dev&#x2F;hda1 在hda1分区创建一个文件系统 mke2fs &#x2F;dev&#x2F;hda1 在hda1分区创建一个linux ext2的文件系统 mke2fs -j &#x2F;dev&#x2F;hda1 在hda1分区创建一个linux ext3(日志型)的文件系统 mkfs -t vfat 32 -F &#x2F;dev&#x2F;hda1 创建一个 FAT32 文件系统 fdformat -n &#x2F;dev&#x2F;fd0 格式化一个软盘 mkswap &#x2F;dev&#x2F;hda3 创建一个swap文件系统 Linux命令 — SWAP文件系统 命令代码 注释说明 mkswap &#x2F;dev&#x2F;hda3 创建一个swap文件系统 swapon &#x2F;dev&#x2F;hda3 启用一个新的swap文件系统 swapon &#x2F;dev&#x2F;hda2 &#x2F;dev&#x2F;hdb3 启用两个swap分区 Linux命令 — 备份 命令代码 注释说明 dump -0aj -f &#x2F;tmp&#x2F;home0.bak &#x2F;home 制作一个 ‘&#x2F;home’ 目录的完整备份 dump -1aj -f &#x2F;tmp&#x2F;home0.bak &#x2F;home 制作一个 ‘&#x2F;home’ 目录的交互式备份 restore -if &#x2F;tmp&#x2F;home0.bak 还原一个交互式备份 rsync -rogpav –delete &#x2F;home &#x2F;tmp 同步两边的目录 rsync -rogpav -e ssh –delete &#x2F;home ip_address:&#x2F;tmp 通过SSH通道rsync rsync -az -e ssh –delete ip_addr:&#x2F;home&#x2F;public &#x2F;home&#x2F;local 通过ssh和压缩将一个远程目录同步到本地目录 rsync -az -e ssh –delete &#x2F;home&#x2F;local ip_addr:&#x2F;home&#x2F;public 通过ssh和压缩将本地目录同步到远程目录 dd bs&#x3D;1M if&#x3D;&#x2F;dev&#x2F;hda | gzip | ssh user@ip_addr ‘dd of&#x3D;hda.gz’ 通过ssh在远程主机上执行一次备份本地磁盘的操作 dd if&#x3D;&#x2F;dev&#x2F;sda of&#x3D;&#x2F;tmp&#x2F;file1 备份磁盘内容到一个文件 tar -Puf backup.tar &#x2F;home&#x2F;user 执行一次对 ‘&#x2F;home&#x2F;user’ 目录的交互式备份操作 ( cd &#x2F;tmp&#x2F;local&#x2F; &amp;&amp; tar c . ) | ssh -C user@ip_addr ‘cd &#x2F;home&#x2F;share&#x2F; &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个目录内容 ( tar c &#x2F;home ) | ssh -C user@ip_addr ‘cd &#x2F;home&#x2F;backup-home &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个本地目录 tar cf - . | (cd &#x2F;tmp&#x2F;backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接 find &#x2F;home&#x2F;user1 -name ‘*.txt’ | xargs cp -av –target-directory&#x3D;&#x2F;home&#x2F;backup&#x2F; –parents 从一个目录查找并复制所有以 ‘.txt’ 结尾的文件到另一个目录 find &#x2F;var&#x2F;log -name ‘*.log’ | tar cv –files-from&#x3D;- | bzip2 &gt; log.tar.bz2 查找所有以 ‘.log’ 结尾的文件并做成一个bzip包 dd if&#x3D;&#x2F;dev&#x2F;hda of&#x3D;&#x2F;dev&#x2F;fd0 bs&#x3D;512 count&#x3D;1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作 dd if&#x3D;&#x2F;dev&#x2F;fd0 of&#x3D;&#x2F;dev&#x2F;hda bs&#x3D;512 count&#x3D;1 从已经保存到软盘的备份中恢复MBR内容 Linux命令 — 光盘 命令代码 注释说明 cdrecord -v gracetime&#x3D;2 dev&#x3D;&#x2F;dev&#x2F;cdrom -eject blank&#x3D;fast -force 清空一个可复写的光盘内容 mkisofs &#x2F;dev&#x2F;cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件 mkisofs &#x2F;dev&#x2F;cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件 mkisofs -J -allow-leading-dots -R -V “Label CD” -iso-level 4 -o .&#x2F;cd.iso data_cd 创建一个目录的iso镜像文件 cdrecord -v dev&#x3D;&#x2F;dev&#x2F;cdrom cd.iso 刻录一个ISO镜像文件 gzip -dc cd_iso.gz | cdrecord dev&#x3D;&#x2F;dev&#x2F;cdrom - 刻录一个压缩了的ISO镜像文件 mount -o loop cd.iso &#x2F;mnt&#x2F;iso 挂载一个ISO镜像文件 cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中 cd-paranoia – “-3” 从一个CD光盘转录音轨到 wav 文件中（参数-3） cdrecord –scanbus 扫描总线以识别scsi通道 dd if&#x3D;&#x2F;dev&#x2F;hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD Linux命令 — 网络 - （以太网和WIFI无线） 命令代码 注释说明 dhclient eth0 以dhcp模式启用‘eth0’网络设备 ethtool eth0 显示网卡‘eth0’的流量统计 host www.example.com 查找主机名以解析名称与IP地址及镜像 hostname 显示主机名 ifconfig eth0 显示一个以太网卡的配置 ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址 ifconfig eth0 promisc 设置‘eth0’成混杂模式以嗅探数据包（sniffing） ifdown eth0 禁用一个‘eth0’网络设备 ifup eth0 启用一个‘eth0’网络设备 ip link show 显示所有网络设备的连接状态 iwconfig eth1 显示一个无线网卡的配置 iwlist scan 显示无线网络 mii-tool eth0 显示‘eth0’的连接状态 netstat -tup 显示所有启用的网络连接和他们的PID netstat -tup1 显示系统中所有监听的网络服务和他们的PID netstat -rn 显示路由表，类似于“route -n”命令 nslookup www.example.com 查找主机名以解析名称与IP地址及镜像 route -n 显示路由表 route add -net 0&#x2F;0 gw IP Gateway 控制预设网关 route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 控制通向网络‘192.168.0.0&#x2F;16’的静态路由 route del 0&#x2F;0 gw IP gateway 删除静态路由 echo “1”&gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_foward 激活IP转发 tcpdump tcp port 80 显示所有HTTP回环 whois www.example.com 在Whois数据库中查找 Linux命令 — Microsoft Windows 网络 命令代码 注释说明 mount -t smbfs -o username&#x3D;user,password&#x3D;pass &#x2F;&#x2F;WinClient&#x2F;share&#x2F;mnt&#x2F;share 挂载一个windows网络共享 nbtscan ip addr netbios名解析 nmblookup -A ip addr netbios名解析 smbclient -L ip addr&#x2F;hostname 显示一台windows主机的远程共享 smbget -Rr smb:&#x2F;&#x2F;ip addr&#x2F;share 像wget一样能够通过smb从一台windows主机上下载文件 Linux命令 — IPTABLES(firewall) 命令代码 注释说明 iptables -t filter -L 显示过滤表的所有链路 iptables -t nae -L 显示nat表的所有链路 iptables -t filter -F 以过滤表为依据清理所有规则 iptables -t nat -F 以nat表为依据清理所有规则 iptables -t filter -X 删除所有由用户创建的链路 iptables -t filter -A INPUT -p tcp –dport telnet -j ACCEPT 允许telnet接入 iptables -t filter -A OUTPUT -p tcp –dport telnet -j DROP 阻止telnet接入 iptables -t filter -A FORWARD -p tcp –dport pop3 -j ACCEPT 允许转发链路上的POP3连接 iptables -t filter -A INPUT -j LOG –log-prefix 记录所有链路中被查封的包 iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE 设置一个PAT（端口地址转换）在eth0掩盖发出包 iptables -t nat -A POSTROUTING -d 192.168.0.1 -p tcp -m tcp –dport 22-j DNAT –to-destination 10.0.0.2:22 将发往一个主机地址的包转向到其他主机 Linux命令 — 监视和调试 命令代码 注释说明 free -m 以兆为单位罗列RAM状态 kill -9 process id 强行关闭进程并结束它 kill -1 process id 强制一个进程重载其配置 last reboot 显示重启历史 lsmod 罗列状态的内核模块 lsof -p process id 罗列一个由进程打开的文件列表 lsof &#x2F;home&#x2F;user1 罗列所给系统路径中的所打开的文件的列表 ps -eafw 罗列linux任务 ps -e -o pid,args –forest 以分级的方式罗列linux任务 pstress 以树状图显示程序 smartctl -A &#x2F;dev&#x2F;hda 通过启用SMART监控硬盘设备的可靠性 smartctl -i &#x2F;dev&#x2F;hda 检查一个硬盘设备的SMART是否启用 strace -c ls &gt;&#x2F;dev&#x2F;null 罗列系统calls made并用一个进程接收 strace -f -e open ls &gt;&#x2F;dev&#x2F;null 罗列库调用 tail &#x2F;var&#x2F;log&#x2F;dmesg 显示内核引导过程中的内部事件 tail &#x2F;val&#x2F;log&#x2F;messages 显示系统事件 top 罗列使用CPU资源最多的linux任务 watch -nl ‘cat &#x2F;proc&#x2F;interrupts’ 罗列实时中断 Linux命令 — 其他常用命令 命令代码 注释说明 alias hh&#x3D;’history’ 为命令history（历史）设置一个别名 apropos …keyword 罗列一个包括程序关键词的命令列表，当你仅知晓程序是干什么，而又不记得命令时特别有用 chsh 改变shell命令 chsh –list-shells 用于了解你是否必须远程连接到别的机器的不错的命令 gpg -c filel 用GNU Privacy Guard加密一个文件 gpg filel.gpg 用GNU Privacy Guard解密一个文件","tags":["CLI"],"categories":["Linux"]},{"title":"Python下载文件的11种方法","path":"/posts/d5e6fbba.html","content":"Python下载文件的11种方法 今天我们一起学习如何使用不同的Python模块从web下载文件。此外，你将下载常规文件、web页面、Amazon S3和其他资源。 最后，你将学习例如下载重定向的文件、下载大型文件、完成一个多线程下载以及其他策略。 1、使用requests你可以使用requests模块从一个URL下载文件。 考虑以下代码: 你只需使用requests模块的get方法获取URL，并将结果存储到一个名为“myfile”的变量中。然后，将这个变量的内容写入文件。 2、使用wgetimage-20230127160722241 你还可以使用Python的wget模块从一个URL下载文件。你可以使用pip按以下命令安装wget模块: 考虑以下代码，我们将使用它下载Python的logo图像。 image-20230127160728384 在这段代码中，URL和路径(图像将存储在其中)被传递给wget模块的download方法。 3、下载重定向的文件在本节中，你将学习如何使用requests从一个URL下载文件，该URL会被重定向到另一个带有一个.pdf文件的URL。该URL看起来如下: image-20230127160733931 要下载这个pdf文件，请使用以下代码: image-20230127160739216 在这段代码中，我们第一步指定的是URL。然后，我们使用request模块的get方法来获取该URL。在get方法中，我们将allow_redirects设置为True，这将允许URL中的重定向，并且重定向后的内容将被分配给变量myfile。 最后，我们打开一个文件来写入获取的内容。 4、分块下载大文件考虑下面的代码: image-20230127160743732 首先，我们像以前一样使用requests模块的get方法，但是这一次，我们将把stream属性设置为True。 接着，我们在当前工作目录中创建一个名为PythonBook.pdf的文件，并打开它进行写入。 然后，我们指定每次要下载的块大小。我们已经将其设置为1024字节，接着遍历每个块，并在文件中写入这些块，直到块结束。 不漂亮吗?不要担心，稍后我们将显示一个下载过程的进度条。 5、下载多个文件(并行&#x2F;批量下载)要同时下载多个文件，请导入以下模块: image-20230127160838912 我们导入了os和time模块来检查下载文件需要多少时间。ThreadPool模块允许你使用池运行多个线程或进程。 让我们创建一个简单的函数，将响应分块发送到一个文件: image-20230127160843388 这个URL是一个二维数组，它指定了你要下载的页面的路径和URL。 image-20230127160847218 就像在前一节中所做的那样，我们将这个URL传递给requests.get。最后，我们打开文件(URL中指定的路径)并写入页面内容。 现在，我们可以分别为每个URL调用这个函数，我们也可以同时为所有URL调用这个函数。让我们在for循环中分别为每个URL调用这个函数，注意计时器: image-20230127160852469 现在，使用以下代码行替换for循环： image-20230127160856593 运行该脚本。 6、使用进度条进行下载进度条是clint模块的一个UI组件。输入以下命令来安装clint模块： image-20230127160901074 考虑以下代码: image-20230127160904820 在这段代码中，我们首先导入了requests模块，然后，我们从clint.textui导入了进度组件。唯一的区别是在for循环中。在将内容写入文件时，我们使用了进度条模块的bar方法。 7、使用urllib下载网页在本节中，我们将使用urllib下载一个网页。 urllib库是Python的标准库，因此你不需要安装它。 以下代码行可以轻松地下载一个网页: image-20230127160910282 在这里指定你想将文件保存为什么以及你想将它存储在哪里的URL。 image-20230127160916091 在这段代码中，我们使用了urlretrieve方法并传递了文件的URL，以及保存文件的路径。文件扩展名将是.html。 8、通过代理下载如果你需要使用代理下载你的文件，你可以使用urllib模块的ProxyHandler。请看以下代码： image-20230127160920455 在这段代码中，我们创建了代理对象，并通过调用urllib的build_opener方法来打开该代理，并传入该代理对象。然后，我们创建请求来获取页面。 此外，你还可以按照官方文档的介绍来使用requests模块: image-20230127160925715 你只需要导入requests模块并创建你的代理对象。然后，你就可以获取文件了。 9、使用urllib3urllib3是urllib模块的改进版本。你可以使用pip下载并安装它: image-20230127160929745 我们将通过使用urllib3来获取一个网页并将它存储在一个文本文件中。 导入以下模块: image-20230127160935313 在处理文件时，我们使用了shutil模块。 现在，我们像这样来初始化URL字符串变量： image-20230127160940362 然后，我们使用了urllib3的PoolManager ，它会跟踪必要的连接池。 image-20230127160949189 创建一个文件: image-20230127160952758 最后，我们发送一个GET请求来获取该URL并打开一个文件，接着将响应写入该文件: image-20230127160957311 10、使用Boto3从S3下载文件要从Amazon S3下载文件，你可以使用Python boto3模块。 在开始之前，你需要使用pip安装awscli模块: image-20230127161002148 对于AWS配置，请运行以下命令： image-20230127161006082 现在，按以下命令输入你的详细信息： image-20230127161009195 要从Amazon S3下载文件，你需要导入boto3和botocore。Boto3是一个Amazon SDK，它允许Python访问Amazon web服务(如S3)。 Botocore提供了与Amazon web服务进行交互的命令行服务。 Botocore自带了awscli。要安装boto3，请运行以下命令: image-20230127161013411 现在，导入这两个模块： image-20230127161016950 在从Amazon下载文件时，我们需要三个参数： Bucket名称 你需要下载的文件名称 文件下载之后的名称 初始化变量： image-20230127161021017 现在，我们初始化一个变量来使用会话的资源。 为此，我们将调用boto3的resource()方法并传入服务，即s3: image-20230127161024681 最后，使用download_file方法下载文件并传入变量: image-20230127161028702 11、使用asyncioasyncio模块主要用于处理系统事件。 它围绕一个事件循环进行工作，该事件循环会等待事件发生，然后对该事件作出反应。这个反应可以是调用另一个函数。这个过程称为事件处理。asyncio模块使用协同程序进行事件处理。 要使用asyncio事件处理和协同功能，我们将导入asyncio模块: image-20230127161035734 现在，像这样定义asyncio协同方法： image-20230127161038759 关键字async表示这是一个原生asyncio协同程序。在协同程序的内部，我们有一个await关键字，它会返回一个特定的值。我们也可以使用return关键字。 现在，让我们使用协同创建一段代码来从网站下载一个文件: image-20230127161042939 在这段代码中，我们创建了一个异步协同函数，它会下载我们的文件并返回一条消息。 然后，我们使用另一个异步协同程序调用main_func，它会等待URL并将所有URL组成一个队列。 asyncio的wait函数会等待协同程序完成。 现在，为了启动协同程序，我们必须使用asyncio的get_event_loop()方法将协同程序放入事件循环中，最后，我们使用asyncio的run_until_complete()方法执行该事件循环。","tags":["Python","Urllib","Requests","Wget","Boto3","Asyncio"],"categories":["Language"]},{"title":"GitHub之Dependabot介绍","path":"/posts/f6beace3.html","content":"背景你可能常常会在你的某一个Github仓库上发现这样的通知 img 这是Github给你发送的Dependabot alerts。 什么是Dependabot?Github Dependabot 是一个GitHub的工具，他可以帮助你检测你的仓库， 并且做一些工作保证你仓库的安全性。Dependabot可以为你仓库做的事情主要分成三大类： Keep all your dependencies updated： 实时检测你的仓库，并保证你所有的依赖都能被更新 Detection of vulnerable dependencies send Dependabot alert：检测到有漏洞的依赖并发送Dependabot通知 Stop using vulnerable dependencies and keep security updates: 帮助你停止使用易受攻击的依赖并保证安全更新 保证你所有依赖的更新Dependabot除了可以帮助我们处理漏洞以外，还有一个非常重要的作用，就是帮助我们检测我们所使用的依赖中是否有可以更新的版本，如果有，它也可以帮助我们实现自动更新。 在仓库中启用了Dependabot之后，可以时刻的保证我们仓库中使用的依赖都是最新的 检测到有漏洞的依赖并发送Dependabot通知Github会检测易受攻击的依赖，如果发现就会发出Dependabot通知, 这种检测机制在以下几种情况下被触发： 当GitHub告警数据库中又收录了一个新的漏洞 GitHub 告警数据库中包含了所有目前发现的漏洞。Github也为了方便开发者查询漏洞而开发了 –&gt; GitHub Advisory Database, 这里你可以浏览或搜索影响GitHub上开源项目的漏洞。 来自WhiteSource的新的漏洞被处理 WhiteSource DB也是一个用于存储 开放源代码的安全漏洞 的数据库 仓库中添加了新的依赖或者升级了某一个依赖的版本，或者说依赖统计发生了改变。 默认情况下，Github会检测所有的公开仓库，当发现漏洞的时候通知仓库的维护者，通知中会包含被影响的文件链接，以及漏洞修复的版本和信息。 对于一些私有仓库就需要维护者手动的启用 dependency graph 和 GitHub Dependabot alerts img 对于那些启用Dependabot安全更新的仓库，Dependabot会自动的将漏洞修复，并且给你的仓库提PR。 停止使用有漏洞的依赖: Dependabot安全更新当你的仓库 启用Dependabot安全更新 之后，Github会找到没有漏洞的版本，将漏洞修复，并且给你的查看提一个PR 你的仓库就可以实现自动的安全更新 怎样使用 Dependabot ?Dependabot的检测功能对于公开仓库是默认开启的，如何开启已经在上面提过了，这部分主要会说明如何配置Dependabot的自动更新。 如果想要Dependabot帮你安全更新，需要两个步骤： 在仓库中首先启用 Dependabot安全更新 img 在仓库根目录下创建.github文件夹，并且在文件夹下添加dependabot.yml（Dependabot配置文件） img 这个config主要配置： 那些漏洞需要被自动修复 多久进行一次自动修复工作 12345678910111213141516171819# 基础dependabot.yml文件# 两个软件包管理器的最基础配置version: 2updates: # 启用NPM版本更新 - package-ecosystem: &quot;npm&quot; #查看`根目录`的 `package.json` 和 `lock`文件 directory: &quot;/&quot; # 每天检查一次NPM仓库更新 schedule: interval: &quot;daily&quot; # 启用Docker版本更新 - package-ecosystem: &quot;docker&quot; # 查看`根目录`下的 `Dockerfile` directory: &quot;/&quot; # 每周检查一次更新 schedule: interval: &quot;weekly&quot;","tags":["Dependabot"],"categories":["GitHub"]},{"title":"Python批量删除GitHub仓库","path":"/posts/96beed1a.html","content":"背景：Github没有提供统一的删除接口，页面删除流程较多 开始：创建 具有删除权限的 tokensettings -&gt; Developer settings -&gt; Personal access tokens -&gt; Generate new token选择delete_repoAPI文档中的删除接口（了解即可）https://docs.github.com/en/rest/reference/repos#delete-a-repository 123456curl \\ -X DELETE \\ -H &quot;Accept: application/vnd.github+json&quot; \\ -H &quot;Authorization: Bearer &lt;YOUR-TOKEN&gt;&quot;\\ -H &quot;X-GitHub-Api-Version: 2022-11-28&quot; \\ https://api.github.com/repos/OWNER/REPO 源码成品读取指定文件中的所有仓库名 1234567891011121314151617181920212223242526272829# -*- coding: UTF-8 -*-# @Time: 2023/1/22 19:26# @Author: Crystal Sugar# @E-mail: NotNoneX@Gmail.com# @File: deleRepo.py&quot;&quot;&quot; GitHub仓库批量删除 &quot;&quot;&quot;from time import sleepimport requestsheaders = &#123; &quot;Accept&quot;: &quot;application/vnd.github+json&quot;, &quot;Authorization&quot;: &quot;Bearer &lt;XXXXXXX&gt;&quot;, # 此处的XXX代表上面的token &quot;X-GitHub-Api-Version&quot;: &quot;2022-11-28&quot;&#125;# 从文件读取仓库名with open(&#x27;./repolist.txt&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: data = f.readlines()# 请求接口url = &quot;https://api.github.com/repos/&#123;&#125;/&#123;&#125;&quot;urls = []for line in data: name, repo = line.strip().split(&quot;/&quot;) urls.append(url.format(name, repo))for ul in urls: print(&#x27;开始删除&#x27;, ul) result = requests.delete(url=ul, headers=headers) print(&#x27;删除结果:&#x27;, result) sleep(2) 仓库文件写法(repolist.txt)12你的用户名/你的仓库名1你的用户名/你的仓库名2","tags":["Python","GitHub"],"categories":["Source"]},{"title":"NPM模块更新","path":"/posts/dcf8ee2a.html","content":"使用npm-check-updates模块升级插件 安装1npm install -g npm-check-updates 查看安装版本1ncu - v # ncu是npm-check-updates的缩写命令 查看帮助1ncu --help 12345678910111213141516171819202122232425262728293031323334353637Usage: ncu [options] [filter][filter] is a list or regex of package names to check (all others will be ignored).Options: -d, --dev check only devDependencies -e, --error-level &lt;n&gt; set the error-level. 1: exits with error code 0 if no errors occur. 2: exits with error code 0 if no packages need updating (useful for continuous integration). Default is 1. (default: 1) -f, --filter &lt;matches&gt; include only package names matching the given string, comma-delimited list, or regex -g, --global check global packages instead of in the current project -j, --jsonAll output new package file instead of human-readable message --jsonUpgraded output upgraded dependencies in json -l, --loglevel &lt;n&gt; what level of logs to report: silent, error, minimal, warn, info, verbose, silly (default: warn) (default: warn) -m, --packageManager &lt;name&gt; npm (default) or bower (default: npm) -n, --newest find the newest versions available instead of the latest stable versions -o, --optional check only optionalDependencies --packageData include stringified package file (use stdin instead) --packageFile &lt;filename&gt; package file location (default: ./package.json) --packageFileDir use same directory as packageFile to compare against installed modules. See #201. -p, --prod check only dependencies (not devDependencies) --peer check only peerDependencies -r, --registry &lt;url&gt; specify third-party npm registry --configFilePath &lt;path&gt; rc config file path (default: ./) --configFileName &lt;path&gt; rc config file name (default: .ncurc.&#123;json,yml,js&#125;) -s, --silent don&#x27;t output anything (--loglevel silent) -t, --greatest find the highest versions available instead of the latest stable versions --timeout &lt;ms&gt; a global timeout in ms -u, --upgrade overwrite package file -x, --reject &lt;matches&gt; exclude packages matching the given string, comma-delimited list, or regex -a, --upgradeAll include even those dependencies whose latest version satisfies the declared semver dependency --semverLevel &lt;level&gt; find the highest version within &quot;major&quot; or &quot;minor&quot; --removeRange remove version ranges from the final package version -v, --version 2.14.2 -V -h, --help output usage information 查看需要更新的1ncu 1234567891011121314151617181920212223242526272829Using D:\\projects\\blog\\NotNoneX\\package.json[..................] - : axios ^0.16.1 → ^0.18.0 connect-mongo ^1.3.2 → ^2.0.1 cookie-parser ~1.3.5 → ~1.4.3 debug ~2.2.0 → ~4.0.1 graphql ^0.10.0 → ^14.0.2 jsonwebtoken ^7.2.1 → ^8.3.0 log4js ^1.1.0 → ^3.0.5 mongoose ^4.7.6 → ^5.2.18 nodemailer ^2.7.0 → ^4.6.8 socket.io ^1.7.2 → ^2.1.1 validator ^6.2.1 → ^10.8.0 opn ^4.0.2 → ^5.4.0The following dependencies are satisfied by their declared version range, but the installed versions are behind. You can install the latest versions without modifying your package file by using npm update. If you want to update the dependencies in your package file anyway, run ncu -a. express-graphql ^0.6.5 → ^0.6.12 markdown-it ^8.3.1 → ^8.4.2 morgan ^1.9.0 → ^1.9.1 qingstor ^1.0.2 → ^1.0.5 qingstor-sdk ^2.2.13 → ^2.2.15 uuid ^3.0.1 → ^3.3.2 babel-polyfill ^6.20.0 → ^6.26.0 nodemon ^1.11.0 → ^1.18.4Run ncu with -u to upgrade package.json 更新全部1ncu -a 1234567891011121314151617181920212223Using D:\\projects\\blog\\NotNoneX\\package.json[..................] \\ : axios ^0.16.1 → ^0.18.0 connect-mongo ^1.3.2 → ^2.0.1 cookie-parser ~1.3.5 → ~1.4.3 debug ~2.2.0 → ~4.0.1 graphql ^0.10.0 → ^14.0.2 jsonwebtoken ^7.2.1 → ^8.3.0 log4js ^1.1.0 → ^3.0.5 mongoose ^4.7.6 → ^5.2.18 nodemailer ^2.7.0 → ^4.6.8 socket.io ^1.7.2 → ^2.1.1 validator ^6.2.1 → ^10.8.0 opn ^4.0.2 → ^5.4.0 express-graphql ^0.6.5 → ^0.6.12 markdown-it ^8.3.1 → ^8.4.2 morgan ^1.9.0 → ^1.9.1 qingstor ^1.0.2 → ^1.0.5 qingstor-sdk ^2.2.13 → ^2.2.15 uuid ^3.0.1 → ^3.3.2 babel-polyfill ^6.20.0 → ^6.26.0 nodemon ^1.11.0 → ^1.18.4Upgraded D:\\projects\\blog\\NotNoneX\\package.json npm-check-updates升级插件，更新后会自动修改package.json里的版本号，简单方便。","tags":["NodeJS","Module"],"categories":["Language"]},{"title":"宝塔搭建Bitwarden","path":"/posts/98008807.html","content":"前言搭建一个开源的密码管理平台Bitwarden，搭建自己的私人密码库，实现账号密码更安全。 bitwarden 介绍BitwardenBitwarden是一款自由且开源的密码管理服务，用户可在加密的保管库中存储敏感信息（例如网站登入凭据（简单说就是账号密码））。他还支持多种设备，从桌面端到移动端再到浏览器端，一个不拉，全都有，甚至连命令行和网页端都有！ 一：购买服务器首先，完成此项任务，我们必须得有一台自己的服务器，就是一台能够24H常开的电脑，当然，你用你自己的电脑不关机也是可以的。如果你没有的话，你可以看我的这一篇文章，可以指导你如何购买服务器。《服务器选购指南》单做密码管理的话要求很低，但如果你希望能多用途利用，那么优先选择内存大和带宽高的机型。也可以选择 Vultr(免费100刀)、Linode、DigitalOcean 等国外几大口碑主机商。 二：设置域名绑定由于Bitwarden需要，你还是绑定一个域名吧，域名可以在阿里云域名购买，腾讯云域名购买购买。也可以在国外服务商godaddy等平台购买。 三：安装宝塔面板国际版此次我们选择aa-panel面板来安装（宝塔面板国际版，好处就是不用登陆绑定手机号）。 (不想等待而且懒得看英语可以选择安装宝塔面板) aaPanel 我们用finalshell连接到服务器最好也是sudo -i 用管理员权限 1234567# centos用这个yum install -y wget &amp;&amp; wget -O install.sh http://www.aapanel.com/script/install_6.0_en.sh &amp;&amp; bash install.sh aapanel# Ubuntu/Deepin用这个wget -O install.sh http://www.aapanel.com/script/install-ubuntu_6.0_en.sh &amp;&amp; sudo bash install.sh aapanel# Debian用这个wget -O install.sh http://www.aapanel.com/script/install-ubuntu_6.0_en.sh &amp;&amp; bash install.sh aapanel bash 一路y&#x2F;yes过去 aapanel 接下来输入你的内外网地址，输入账号密码即可如果提示这个界面，那就左边的，点绿色的，一键安装即可。 bt 四：安装docker既然咱们为了简便操作安装了宝塔面板，那咱们就直接一步解决。点击docker docker 提示没有docker，需要安装。点击即可安装 unnamed-1664059859831 安装完成后，点击website再点击add site unnamed-1664059810241 再然后，按照图片的提示输入域名，选择打开ssl打开强制https（不然等下无法访问）。 unnamed-1664059893337 五：docker 拉取valutwarden&#x2F;server:latest按照步骤，在第三步输入 vaultwarden&#x2F;server:latest再点击提交（submit）。 img 拉取完成后，点击container，再点击add container unnamed-1664059945442 根据我的设置填充，Name写名字，image是你刚下载的镜像，port选择端口，第一个空是docker容器的端口，写80，第二个是服务器的，写88，你也可以随意写一个。(注意：别忘了点&quot;+&quot;号添加)再向下，找到memory写到256MBvolume写&#x2F;www&#x2F;wwwroot&#x2F;vm&#x2F;是你想要把文件放在哪里，后面是容器文件夹，写上&#x2F;data&#x2F; (注意：别忘了点”+”号添加)再向后拉，重启规则选择第一个。 unnamed-1664059964230 unnamed-1664059970932 出现这个界面就说明搭建完成了。 unnamed-1664059976743 六：设置网站目录和反代回到website，点击刚才创建网站的后面conf。 选择site directory，再点击📁文件夹图标，找到刚才docker那里设置的文件目录，再点击后面的save unnamed-1664059994039 再按照顺序设置反代。3处名字设置短了，会报错。应该长一点 七：添加站点SSL按照顺序一个一个点开即可。 unnamed-1664060013731 八：访问站点创建账户，输入用户名密码即可登录 unnamed-1664060022842 九：app登陆bitwarden提供了特别多的客户端，下载地址但是所有的应用一定要先改此处的设置，将服务器地址设置成你自己的。 unnamed-1664059556633 image-20230120020528406 十：取消用户注册参考此段代码。 12345678docker run -d --name bitwardenrs \\ --restart unless-stopped \\ -e SIGNUPS_ALLOWED=false \\ -e WEBSOCKET_ENABLED=true \\ -v /bitwardens:/data/ \\ -p 52013:80 \\ -p 52014:3012 \\ vaultwarden/server:latest","tags":["Docker","Bitwarden","aaPanel"],"categories":["WebSite"]},{"title":"Python备忘录","path":"/posts/84b8716d.html","content":"循环普通循环range 是左闭右开区间 12for i in range(0, 10): print(i) 逆序12for i in range(10, 0, -1): print(i) 循环变量在循环体外面依然可以用 1234for i in range(0, 10): pass# 这里输出的是9，并不等价于类c语言里面的 for(i = 0;i &lt; 10; i++)print(i) 数组切片12345678910# 复制数组b = a[:]# 取前四个数b = a[:4]b = a[0:4]b = a[0:4:1]# 取前四个没隔两个一取b = a[:4:2] 数组比较直接比就可以了 1list1 == list2 字符串按照字典序排序12a = &quot;dcba&quot;b = &quot;&quot;.join(sorted(a)) 转换成 asc 码1a = ord(&#x27;a&#x27;) 切片同数组 字符串是否是数字1str.isdigit() 字符串是否是由数字和字母组成1str.isalnum() 转大小写12str.lower()str.upper() collectionsCounter可以用来统计字符出现的个数 12a = [&quot;A&quot;, &quot;B&quot;, &quot;A&quot;, &quot;C&quot;, &quot;A&quot;]b = collections.Counter(a) 返回的是个字典 1&#123;&#x27;A&#x27;: 3, &#x27;B&#x27;: 1, &#x27;C&#x27;: 1&#125; defaultdict相比于 dict 可以在 key 不存在的时候返回一个默认值，而不是报错 123456a = collections.defaultdict(list)a = collections.defaultdict(int)a = collections.defaultdict(set)a = collections.defaultdict(set)a = collections.defaultdict(lambda: 10) 数学相关开方会返回一个浮点数 12import matha = math.sqrt(16) 乘方12a = pow(3,4)a = 3 ** 4 其他zip将可迭代的对象打包成元组 1234a = [1, 2, 3]b = [2, 3, 4]c = [4, 5, 6]d = list(zip(a, b, c)) 输出 1[(1, 2, 4), (2, 3, 5), (3, 4, 6)] reduce函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。 1234s = reduce(lambda x, y: x+y, [1,2,3,4,5])# 当然在python中 list相加不需要自己写s = sum([1,2,3,4,5])","tags":["Tips","Python"],"categories":["Language"]},{"title":"Python之requirements相关","path":"/posts/b1754e68.html","content":"Python中通过requirements.txt来记录项目所有的依赖包及其版本号，以便在其他的环境中部署。如果在开发的时候升级了依赖包，记得更新此文件！ 两种方式：一是项目依赖的python包，二是所在python环境安装的python包。 方式一安装pipreqs工具 命令： 1pip install pipreqs 项目根目录下, 命令： 1pipreqs ./ 若出现编码错误，则可使用： 1pipreqs ./ --encoding=utf8 若已存在requirements.txt,则可使用–force 强制执行） 1pipreqs ./ --encoding=utf8 --force 这时会生成requirements.txt文件 方式二1pip freeze &gt; requirements.txt 在其他环境部署项目之前先通过如下命令安装依赖包： 1pip install -r requirements.txt pip 指定源安装 阿里源 1pip install -r requirements.txt -i https://mirrors.aliyun.com/pypi/simple/ 豆瓣 1pip install -r requirements.txt -i https://pypi.douban.com/simple/ 清华大学 1pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple/ 参数”–trusted-host”表示信任 1pip install -r requirements.txt -i http://pypi.douban.com/simple --trusted-host pypi.douban.com","tags":["Python"],"categories":["Language"]},{"title":"JavaScript加载之defer与async","path":"/posts/c04e94a5.html","content":"页面的解析过程是单线程的，但是单线程亦可有同步与异步之分，script标签的解释方式分为3种，默认、defer和async三种 1&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt; 默认模式，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之后的所有文档内容之前，也就是说不等待后续载入的文档元素，读取到就加载并执行。 1&lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt; async加载模式，加载和渲染后续文档元素的过程， script.js 异步加载，并且在script.js加载完成之后同步执行script.js(可能在后续文档元素解析完成的过程中) 1&lt;script defer src=&quot;script.js&quot;&gt;&lt;/script&gt; defer加载模式，加载和渲染后续文档元素的过程， script.js 异步加载，并且在script.js加载完成和后续文档元素解析完成之后同步执行script.js script 标签解析时间图 只有以src属性链接的script标签这2个属性才起作用。 1&lt;script defer type=&quot;text/javascript&quot; src=&quot;&quot;&gt;&lt;/script&gt; 不带src属性script标签在文档加载时顺序加载，这两个属性无效。 12345&lt;script type=&quot;text/javascript&quot;&gt; let idEle = document.getElementById(&quot;app&quot;);&lt;/script&gt;","tags":["Tips","JavaScript"],"categories":["Language"]},{"title":"FileCodeBox-文件快递柜-部署教程","path":"/posts/acdace32.html","content":"开源地址GitHub：https://github.com/vastsa/FileCodeBox 文档地址：语雀：https://www.yuque.com/lxyo/work/kw9gxqfk882ez7k5 准备工作新建一个空白目录 12mkdir /opt/FileCodeBoxcd /opt/FileCodeBox 新建一个.env环境变量文件 1vi .env 将下列字段内容替换成你自己的 12345678910111213141516171819202122232425262728293031323334# 端口PORT=12345# Sqlite数据库文件DATABASE_URL=sqlite+aiosqlite:///database.db# 静态文件夹DATA_ROOT=./static# 静态文件夹URLSTATIC_URL=/static# 开启上传ENABLE_UPLOAD=True# 错误次数ERROR_COUNT=5# 错误限制分钟数ERROR_MINUTE=10# 上传次数UPLOAD_COUNT=60# 上传限制分钟数UPLOAD_MINUTE=1# 删除过期文件的间隔（分钟）DELETE_EXPIRE_FILES_INTERVAL=10# 管理地址ADMIN_ADDRESS=admin# 管理密码ADMIN_PASSWORD=admin# 文件大小限制，默认10MBFILE_SIZE_LIMIT=10# 网站标题TITLE=文件快递柜# 网站描述DESCRIPTION=FileCodeBox，文件快递柜，口令传送箱，匿名口令分享文本，文件，图片，视频，音频，压缩包等文件# 网站关键词KEYWORDS=FileCodeBox，文件快递柜，口令传送箱，匿名口令分享文本，文件，图片，视频，音频，压缩包等文件# 存储引擎STORAGE_ENGINE=filesystem 修改完毕后，按esc进入命令模式，输入wq保存退出 注：如果是docker可以采用环境变量，如果没有新建此文件，将会使用系统默认配置 Docker部署（拉取镜像）1docker run -d --restart=always -p 12345:12345 -v /opt/FileCodeBox/:/app/data --name filecodebox lanol/filecodebox:latest Docker部署（自己打包）最好sudo -i后执行 1. 拉取代码如果有wget： 1wget https://github.com/vastsa/FileCodeBox/archive/refs/tags/latest.zip -O /opt/FileCodeBox/code.zip 如果有curl: 1curl https://github.com/vastsa/FileCodeBox/archive/refs/tags/latest.zip -o /opt/FileCodeBox/code.zip 2. 解压代码1unzip code.zip 3. 修改配置参数切换到项目目录1cd /opt/FileCodeBox 如果你是海外服务器，可以编辑一下Dockerfile，删除这个参数，安装依赖速度更快，不删也不影响img 4. Build1docker build --file Dockerfile --tag filecodebox . 5. Run可以修改前面这个的12345，修改端口 1docker run -d -p 12345:12345 --name filecodebox -v /opt/FileCodeBox:/app filecodebox 6. 安装完成img 就可以使用ip:12345访问了，可以使用nginx进行反代一下。 宝塔部署我这里用的是aapanel，大同小异。 1. 应用商店安装Python Managerimg 2. 安装Versionimg 在他安装的时候，可以先进行下一步。 3. 拉取代码新建一个合适的空白目录，使用remote download拉取代码。 1https://github.com/vastsa/FileCodeBox/archive/refs/tags/latest.zip img 解压缩img 编辑main.py注：建议新建目录data 然后新建配置文件.env 配置如下： 12345678910111213141516171819202122232425262728293031323334# 端口PORT=12345# Sqlite数据库文件DATABASE_URL=sqlite+aiosqlite:///database.db# 静态文件夹DATA_ROOT=./static# 静态文件夹URLSTATIC_URL=/static# 开启上传ENABLE_UPLOAD=True# 错误次数ERROR_COUNT=5# 错误限制分钟数ERROR_MINUTE=10# 上传次数UPLOAD_COUNT=60# 上传限制分钟数UPLOAD_MINUTE=1# 删除过期文件的间隔（分钟）DELETE_EXPIRE_FILES_INTERVAL=10# 管理地址ADMIN_ADDRESS=admin# 管理密码ADMIN_PASSWORD=admin# 文件大小限制，默认10MBFILE_SIZE_LIMIT=10# 网站标题TITLE=文件快递柜# 网站描述DESCRIPTION=FileCodeBox，文件快递柜，口令传送箱，匿名口令分享文本，文件，图片，视频，音频，压缩包等文件# 网站关键词KEYWORDS=FileCodeBox，文件快递柜，口令传送箱，匿名口令分享文本，文件，图片，视频，音频，压缩包等文件# 存储引擎STORAGE_ENGINE=filesystem 这是main.py img 修改红框内容后保存。 img 4. Add a project照着我的写 img 5. 启动成功img 6. 宝塔放开端口img 6. 安装完成img 7. 反代（可以不用放端口）项目-&gt;mapping img 输入你的域名 img 项目更新拉取最新代码，覆盖就代码，项目重启，或Docker重启","tags":["FileCodeBox"],"categories":["WebSite"]},{"title":"Vue3-10_事件&按键修饰符","path":"/posts/f998cd4b.html","content":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163&lt;script&gt;// --------------- 事件&amp;按键修饰符 ---------------export default &#123; data() &#123; return &#123; msg: 0, &#125;; &#125;, methods: &#123; // div点击事件 changeCont: function () &#123; console.log(&quot;我是div点击事件&quot;); var inp = document.getElementById(&quot;inp&quot;); &#125;, // 按钮点击事件 changeCt() &#123; console.log(&quot;我是button点击事件&quot;); var inp = document.getElementById(&quot;inp&quot;); &#125;, // 提交按钮点击事件 subm: function () &#123; console.log(&#x27;提交成功&#x27;) &#125;, // .once事件 onc:function()&#123; console.log(&#x27;随便log些啥&#x27;) &#125;, // 按键修饰符 keyUp:function()&#123; console.log(&#x27;按键松开了, 数据提交成功&#x27;) &#125; &#125;,&#125;;&lt;/script&gt; &lt;template&gt; &lt;div&gt; &lt;!-----------壹 事件修饰符 ------------&gt; &lt;!-- 常用事件修饰符 .stop .prevent .capture .self .once .passive --&gt; &lt;!----------- (一) .stop 阻止事件冒泡 -----------&gt; &lt;!-- 1.1 未使用.stop时 div的点击事件会和button的点击事件一起运行 --&gt; &lt;div v-on:click=&quot;changeCont&quot;&gt; &lt;button @click=&quot;changeCt&quot;&gt;未使用.stop 打印console日志&lt;/button&gt; &lt;/div&gt; &lt;!-- 1.2 使用.stop后 只会执行button的点击事件 --&gt; &lt;div v-on:click=&quot;changeCont&quot;&gt; &lt;button @click.stop=&quot;changeCt&quot;&gt;使用.stop 打印console日志&lt;/button&gt; &lt;/div&gt; &lt;p&gt;------------------ 分隔线 ------------------&lt;/p&gt; &lt;!----------- (二) .prevent 阻止默认行为 -----------&gt; &lt;!-- 2.1 未加入.prevent 会跳转网页 --&gt; &lt;form action=&quot;&quot;&gt; &lt;input type=&quot;submit&quot; name=&quot;&quot; id=&quot;&quot; v-on:click=&quot;subm&quot; value=&quot;直接提交&quot;/&gt; &lt;/form&gt; &lt;!-- 2.2 加入.prevent后 不会跳转网页 --&gt; &lt;form action=&quot;&quot;&gt; &lt;input type=&quot;submit&quot; name=&quot;&quot; id=&quot;&quot; v-on:click.prevent=&quot;subm&quot; value=&quot;.prevent提交&quot;/&gt; &lt;/form&gt; &lt;p&gt;------------------ 分隔线 ------------------&lt;/p&gt; &lt;!----------- (三) .once 只触发一次回调 -----------&gt; &lt;button @click=&quot;onc&quot;&gt;未使用.once console&lt;/button&gt; &lt;button @click.once=&quot;onc&quot;&gt;使用.once只触发一次 console&lt;/button&gt; &lt;p&gt;------------------ 分隔线 ------------------&lt;/p&gt; &lt;!----------- 贰 按键修饰符 -----------&gt; &lt;!-- 常用按键 .enter .tab .up .down .left .right .esc .space .esc .delete删除和退格键 --&gt; &lt;!----------- 一 .enter回车 -----------&gt; &lt;!-- 1.1 未使用.enter keyup事件(按钮松开事件) 所有按键松开都会触发--&gt; &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot; @keyup=&quot;keyUp&quot; placeholder=&quot;所有按钮松开都会触发console事件&quot;&gt; &lt;!-- 1.2 使用.enter keyup事件(按钮松开事件) 只有回车键松开才会触发--&gt; &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot; @keyup.enter=&quot;keyUp&quot; placeholder=&quot;只有按下回车键松开才会触发console事件&quot;&gt; &lt;/div&gt;&lt;/template&gt; &lt;style&gt;&lt;/style&gt;","tags":["Vue","Vue3"],"categories":["Language"]},{"title":"Vue3-09_事件处理","path":"/posts/b7eecddd.html","content":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;script&gt;import &#123; h &#125; from &quot;vue&quot;; // --------------- 事件处理 ---------------export default &#123; data() &#123; return &#123; counter: 0, age:18 &#125;; &#125;, methods: &#123; // addCounter: function()&#123;&#125; 和以下等价 addCounter(num, e) &#123; this.counter++; console.log(&quot;数字：&quot;, num, &quot; 事件：&quot;, e); &#125;, addAge:function()&#123; this.age++ &#125; &#125;,&#125;;&lt;/script&gt; &lt;template&gt; &lt;div&gt; &lt;!-- 绑定事件 直接通过JS代码处理 --&gt; &lt;p v-on:click=&quot;counter++&quot;&gt;&#123;&#123; counter &#125;&#125;&lt;/p&gt; &lt;!-- 绑定事件 没有传递参数 --&gt; &lt;p @click=&quot;addCounter&quot;&gt;&#123;&#123; counter &#125;&#125;&lt;/p&gt; &lt;!-- 绑定事件 传递参数 --&gt; &lt;p @click=&quot;addCounter(5)&quot;&gt;&#123;&#123; counter &#125;&#125;&lt;/p&gt; &lt;!-- 绑定事件 既传递参数 也要有事件对象 --&gt; &lt;p @click=&quot;addCounter(6, $event)&quot;&gt;&#123;&#123; counter &#125;&#125;&lt;/p&gt; &lt;!-- 一个事件 绑定多个处理函数 都要有括号--&gt; &lt;p @click=&quot;addCounter(),addAge()&quot;&gt;&#123;&#123; counter &#125;&#125; --- &#123;&#123; age &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; &lt;style&gt;&lt;/style&gt;","tags":["Vue","Vue3"],"categories":["Language"]},{"title":"Vue3-08_数组操作","path":"/posts/724f7c2a.html","content":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&lt;script&gt;// --------------- 数组操作 ---------------export default &#123; data() &#123; return &#123; list: [1, 3, 6, 4, 5], &#125;; &#125;, methods: &#123; changeList: function () &#123; // 通过索引修改数组 vue3可以 this.list[5] = 7 // push(); 末尾添加元素 // this.list.push(7,8,9) // pop(); 删除数组最末尾元素 // this.list.pop() // shift(); 删除数组第一位 // this.list.shift() // unshift(); 在数组首位添加元素 // this.list.unshift(0,9,8) // splice(); 删除元素、插入元素、替换元素 // ----- 删除元素 ----- // 参数一：开始插入或删除的元素位置索引 参数二：表示钥删除的元素数量(不传则删除后面所有) // this.list.splice(1,2) // ----- 插入元素 ----- // 参数一：开始插入或删除的元素位置索引 参数二：传入0并且后面接上要插入的元素 // this.list.splice(1,0,7,8,9) // ----- 替换元素 ----- // 可以理解为先删除了元素后又增加了后几个元素 // this.list.splice(1,3,7,8,9) // sort(); 排序 // this.list.sort() // reverse(); 字符串反转 // this.list.reverse() &#125;, &#125;,&#125;;&lt;/script&gt; &lt;template&gt; &lt;div&gt; &lt;ul&gt; &lt;li v-for=&quot;item in list&quot; :key=&quot;item&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;button @click=&quot;changeList&quot;&gt;改变数组&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; &lt;style&gt;&lt;/style&gt;","tags":["Vue","Vue3"],"categories":["Language"]},{"title":"Vue3-07_v-for使用数组或or对象","path":"/posts/c408efb7.html","content":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127&lt;script&gt;// --------------- v-for使用数组or对象 ---------------export default &#123; data() &#123; return &#123; person: [&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;], personObj: &#123; name: &quot;冰糖&quot;, sex: &quot;男&quot;, age: 18 &#125;, &#125;; &#125;, methods:&#123; // 添加元素函数 addPer: function()&#123; this.person.unshift(&#x27;冰糖&#x27;); &#125; &#125;&#125;;&lt;/script&gt; &lt;template&gt; &lt;div&gt; &lt;!-- v-for 使用数组 --&gt; &lt;!-- 用法 v-for=&quot;item in items&quot; v-bind:key --&gt; &lt;!-- item为元素 index为索引 --&gt; &lt;ul&gt; &lt;li v-for=&quot;name in person&quot; v-bind:key=&quot;name&quot;&gt;&#123;&#123; name &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;!-- 索引做唯一key --&gt; &lt;ul&gt; &lt;li v-for=&quot;(nm, index) in person&quot; v-bind:key=&quot;nm&quot;&gt; &#123;&#123; nm &#125;&#125;--&gt;&#123;&#123; index &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;!-- 可用in 也可用of --&gt; &lt;ul&gt; &lt;li v-for=&quot;(nm, index) of person&quot; v-bind:key=&quot;nm&quot;&gt; &#123;&#123; nm &#125;&#125;--&gt;&#123;&#123; index &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;!--------------- v-for使用对象 ---------------&gt; &lt;ul&gt; &lt;li v-for=&quot;info in personObj&quot; v-bind:key=&quot;info&quot;&gt;&#123;&#123; info &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;!-- info为键值 key为键名 index为索引--&gt; &lt;ul&gt; &lt;li v-for=&quot;(info, key, index) in personObj&quot; v-bind:key=&quot;info&quot;&gt; &#123;&#123; info &#125;&#125; --&gt; &#123;&#123; key &#125;&#125; --&gt; &#123;&#123; index &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;!-- key为唯一标识 ：快速找到节点 减少渲染次数--&gt; &lt;!-- 为了给Vue一个提示,以便他们跟踪每个节点的身份,从而重用和重新排序现有元素 --&gt; &lt;ul&gt; &lt;li v-for=&quot;(name,index) in person&quot; :key=&quot;name&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; &#123;&#123;name&#125;&#125;--&gt;&#123;&#123;index&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;button @click=&quot;addPer&quot;&gt;增加人&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; &lt;style&gt;&lt;/style&gt;","tags":["Vue","Vue3"],"categories":["Language"]},{"title":"Vue-Tips-01_三目运算","path":"/posts/53b3ce54.html","content":"1234567891011121314151617181920212223242526272829303132333435363738394041&lt;script&gt;// --------------- 小知识 三目运算 ---------------// 实现来回切换内容export default &#123; data() &#123; return &#123; msg: &quot;哈哈哈哈&quot;, &#125;; &#125;,&#125;;&lt;/script&gt; &lt;template&gt; &lt;div id=&quot;test&quot;&gt; &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt; &lt;button @click=&quot;msg = msg == &#x27;哈哈哈哈&#x27; ? &#x27;嘿嘿嘿嘿&#x27; : &#x27;哈哈哈哈&#x27;&quot;&gt;改变内容&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; &lt;style&gt;&lt;/style&gt;","tags":["Tips","Vue","Vue3"],"categories":["Language"]},{"title":"Charles激活码计算","path":"/posts/f710c278.html","content":"Charles官网：Charles在此网站可直接运行：Go Play 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156package mainimport (\t&quot;bytes&quot;\t&quot;encoding/binary&quot;\t&quot;fmt&quot;\t&quot;math/rand&quot;\t&quot;time&quot;)const (\trounds = 12\troundKeys = 2 * (rounds + 1))func main() &#123;\trand.Seed(time.Now().UnixNano())\tname := &quot;charles&quot;\tfmt.Println(&quot;name:&quot;, name, &quot; key:&quot;, crack(name))&#125;func crack(text string) string &#123;\tname := []byte(text)\tlength := len(name) + 4\tpadded := ((-length) &amp; (8 - 1)) + length\tbs := make([]byte, 4)\tbinary.BigEndian.PutUint32(bs, uint32(len(name)))\tbuff := bytes.Buffer&#123;&#125;\tbuff.Write(bs)\tbuff.Write(name)\tvar ckName int64 = 0x7a21c951691cd470\tvar ckKey int64 = -5408575981733630035\tck := newCkCipher(ckName)\toutBuff := bytes.Buffer&#123;&#125;\tfor i := 0; i &lt; padded; i += 8 &#123; bf := buff.Bytes()[i : i+8] buf := bytes.NewBuffer(bf) var nowVar int64 if err := binary.Read(buf, binary.BigEndian, &amp;nowVar); err != nil &#123; panic(err) &#125; dd := ck.encrypt(nowVar) outBuff.WriteByte(byte(dd &gt;&gt; 56)) outBuff.WriteByte(byte(dd &gt;&gt; 48)) outBuff.WriteByte(byte(dd &gt;&gt; 40)) outBuff.WriteByte(byte(dd &gt;&gt; 32)) outBuff.WriteByte(byte(dd &gt;&gt; 24)) outBuff.WriteByte(byte(dd &gt;&gt; 16)) outBuff.WriteByte(byte(dd &gt;&gt; 8)) outBuff.WriteByte(byte(dd))\t&#125;\tvar n int32\tfor _, b := range outBuff.Bytes() &#123; n = rotateLeft(n^int32(int8(b)), 0x3)\t&#125;\tprefix:= n ^ 0x54882f8a\tsuffix:=rand.Int31()\tin := int64(prefix) &lt;&lt; 32\ts := int64(suffix)\tswitch suffix &gt;&gt; 16 &#123;\tcase 0x0401:\tcase 0x0402:\tcase 0x0403: in |= s break\tdefault: in |= 0x01000000 | (s &amp; 0xffffff) break\t&#125;\tout := newCkCipher(ckKey).decrypt(in)\tvar n2 int64\tfor i := 56; i &gt;= 0; i -= 8 &#123; n2 ^= int64((uint64(in) &gt;&gt; i) &amp; 0xff)\t&#125;\tvv := int32(n2 &amp; 0xff)\tif vv &lt; 0 &#123; vv = -vv\t&#125;\treturn fmt.Sprintf(&quot;%02x%016x&quot;, vv, uint64(out))&#125;type ckCipher struct &#123;\trk [roundKeys]int32&#125;func newCkCipher(ckKey int64) ckCipher &#123;\tck := ckCipher&#123;&#125;\tvar ld [2]int32\tld[0] = int32(ckKey)\tld[1] = int32(uint64(ckKey) &gt;&gt; 32)\tck.rk[0] = -1209970333\tfor i := 1; i &lt; roundKeys; i++ &#123; ck.rk[i] = ck.rk[i-1] + -1640531527\t&#125;\tvar a, b int32\tvar i, j int\tfor k := 0; k &lt; 3*roundKeys; k++ &#123; ck.rk[i] = rotateLeft(ck.rk[i]+(a+b), 3) a = ck.rk[i] ld[j] = rotateLeft(ld[j]+(a+b), a+b) b = ld[j] i = (i + 1) % roundKeys j = (j + 1) % 2\t&#125;\treturn ck&#125;func (ck ckCipher) encrypt(in int64) int64 &#123;\ta := int32(in) + ck.rk[0]\tb := int32(uint64(in)&gt;&gt;32) + ck.rk[1]\tfor r := 1; r &lt;= rounds; r++ &#123; a = rotateLeft(a^b, b) + ck.rk[2*r] b = rotateLeft(b^a, a) + ck.rk[2*r+1]\t&#125;\treturn pkLong(a, b)&#125;func (ck ckCipher) decrypt(in int64) int64 &#123;\ta := int32(in)\tb := int32(uint64(in) &gt;&gt; 32)\tfor i := rounds; i &gt; 0; i-- &#123; b = rotateRight(b-ck.rk[2*i+1], a) ^ a a = rotateRight(a-ck.rk[2*i], b) ^ b\t&#125;\tb -= ck.rk[1]\ta -= ck.rk[0]\treturn pkLong(a, b)&#125;func rotateLeft(x int32, y int32) int32 &#123;\treturn int32(x&lt;&lt;(y&amp;(32-1))) | int32(uint32(x)&gt;&gt;(32-(y&amp;(32-1))))&#125;func rotateRight(x int32, y int32) int32 &#123;\treturn int32(uint32(x)&gt;&gt;(y&amp;(32-1))) | int32(x&lt;&lt;(32-(y&amp;(32-1))))&#125;func pkLong(a int32, b int32) int64 &#123;\treturn (int64(a) &amp; 0xffffffff) | (int64(b) &lt;&lt; 32)&#125;","tags":["Charles"],"categories":["Source"]},{"title":"代理服务器知识普及代理IP使用","path":"/posts/8b84b7e6.html","content":"扫盲篇什么是代理服务器？ 代理服务器是介于浏览器和Web服务器之间的一台服务器，当你通过代理服务器上网浏览时，浏览器不是直接到Web服务器去取回网页，而是向代理服务器发出请求，由代理服务器来取回浏览器所需要的信息，并传送给你的浏览器。 什么是免费代理服务器 ？ 在使用代理猎手等软件搜索代理服务器地址时，会在验证状态栏中出现类似“要密码”、“Free”等字样。如果你把“Free”的地址设置为代理服务器，那你就会发现访问网页时不会要求你输入密码了。这就是“免费的代理服务器”。为什么会出现free的呢？有以下几种情况： 1.是系统漏洞，一旦被网管发现就会被堵上； 2.是善良的网管和其他有机会接近主机的人，将机器设成了代理服务器； 3.是真正的好心人，就是将自己的机器作为免费代理，造福广大同仁。这真值得钦佩！但被查封关闭得也最快。 4.是ISP商为了提高影响，在一段时间内免费开放，一般很短。 使用代理服务器的好处 ： Proxy Server(代理服务器)是Internet链路级网关所提供的一种重要的安全功能，它的工作主要在开放系统互联(OSI)型的对话层，主要的功能有： 突破自身IP访问限制： 1.访问国外站点。教育网、169网等网络用户可以通过代理访问国外网站。 2.访问一些单位或团体内部资源，如某大学FTP(前提是该代理地址在该资源的允许访问范围之内)，使用教育网内地址段免费代理服务器，就可以用于对教育网开放的各类FTP下载上传，以及各类资料查询共享等服务。 3.突破中国电信的IP封锁：中国电信用户有很多网站是被限制访问的，这种限制是人为的，不同Serve对地址的封锁是不同的。所以不能访问时可以换一个国外的代理服务器试试。 4.提高访问速度：通常代理服务器都设置一个较大的硬盘缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时，则直接由缓冲区中取出信息，传给用户，以提高访问速度。 5.隐藏真实IP：上网者也可以通过这种方法隐藏自己的IP，免受攻击。 6.嘿嘿，免费全文。 上手篇 Internet Explorer中代理的设置方法(适用于直接上internet的用户,否则请看二次或多次代理篇) 1.在IE4.0中的代理设置方法： 在主菜单上选择“查看”→“Internet选项”→“连接”→“通过代理服务器访问Internet”，此时将你找到的代理服务器地址和端口填入，然后点击“确定”，就可以通过代理服务器浏览网页了。 2.IE5.0的代理设置方法： 在主菜单上选择“工具”→“Internet选项”→“连接”→“设置”→“使用代理服务器”，这时将你找到的代理服务器地址和端口填入即可。 提示：对于局域网用户，应点击“连接‘标签下面的’局网域设置”来设置代理。 3.NETSCAPE 4.x的代理设置方法： 选择主菜单上的“Edit”→“Preferences”→“advanced”→“proxies”→“Manual proxy configuration”→“View”，将你找到的代理服务器地址和端口填入，按“OK”完成。 4.Opera的代理设置方法： 选择主菜单上的“设置”→“Proxy选项”，将你找到的代理服务器地址和端口填入即可。 5.网络蚂蚁的代理设置方法： 在主菜单上选择“选项设置”→“参数设置”→“代理”→“添加”，然后将可用的代理服务器地址根据类型填入，如该服务器需要输入用户名和密码，选中代理服务器选项下的“认证”，填入即可。大多数下载软件的代理设置与网络蚂蚁相似，如FlashGet。 进阶篇从哪里能找到代理 ？ 最原始的方法就是用软件搜索某个网段(现在网上还有很多搜索代理的工具软件)，不过这种搜索代理服务器可是很费时的活。通常大家是不会把自己经常使用的代理服务器告诉别人的，因为用的人多了速度自然就会慢。不过网上也有很多网站和BBS都提供免费代理服务器的地址，你可以自己用搜索引擎(如搜狐、新浪)查一下Proxy或者免费代理，就能发现很多类似的网站。 说到搜索代理软件那就首推代理猎手，向导式的在线帮助说明，就算你是第一次使用也应不存在太大的问题。具体步骤如下： 1.从网上收录到尽可能多的代理列表(最好都是可用的)，保存为一个以.txt后缀的文本文件，格式如下： 10.19.193.109:1080@SOCKS4 10.19.193.109:1080@SOCKS5 10.19.193.109:21@ftp 10.19.193.109:80@http 10.19.193.109:8080@http …… (以上地址皆为举例，不一定可用) 2.运用代理猎手到“搜索结果”页面中,点“导入结果”，将.txt格式的代理列表导入。 3.点击“系统”按钮，选择“参数设置”。 4.在“搜索验证设置”页面中对“验证设置”项中的两个超时时间参数进行设置。 5.最后当然是上网的校验。 什么样的代理是好代理? 代理好用的标准：速度快，稳定，当然前提是免费。 在代理猎手3.0以上版本，验证时间栏为“时间特性”，显示情况类似这样：“0.9│1.3│2.6”、“26.3│0.0│26.3”，这三个时间依次代表：连接时间、首次接收数据时间、总验证时间。当然也是越小越好了。决定一个代理的速度的因素有很多，主要有： 1.免费代理服务器所在的网路。大家用proxy主要还是为了出国，因而，四大网络的出口局的带宽就直接决定着其中的proxy的速度。 2.代理服务器的性能。前面的文章提到，proxy不过是一个大cache而已，因此它的硬盘大小、网路的带宽就会影响速度。这和你自己机器是一样的。 3.代理服务器与你的机器之间的距离。proxy主要是为特定对象服务的，其地理分布通常不会太广泛。而广大网友就不会与你所用的proxy之间的距离有多远了。自然，距离越远，速度也就越慢。 4.你所访问的站点的情况。这也是影响proxy速度的原因。你要访问对方的站点，自然要以对方的标准为主，就如同两架速度不同的Modem一样。可惜很多网友常常忽略这点。 高手篇怎样使用代理访问被屏蔽掉的网站？ 由于某些原因，中国电信把一些国外网站屏蔽掉了，所有国内用户不能与之访问，比如以前非常红火的赔钱网站(Speida)，还有一些国外的网站禁止中国的IP访问，解决方法就是使用国外的代理服务器。但是教育网用户不能访问国外网站，所有国外的代理也不能为之使用，是否我们便无能为力了呢？不，我们可以参照下面二次代理的使用方法解决。 1.去Download一个Sockscap32，在设置中填好Socks代理服务器地址。 2.将浏览器的快捷方式拖到SocksCap32的空白框中。 联网后，先启动Sockscap32。再在浏览器中填上国外代理服务器的地址，在SocksCap32中运行浏览器即可。 如何通过代理使用FoxMail收信？ 可以使用sockscap32解决。前提：有一个好用的Socks代理，通过一个可以访问的Socks代理(Socks5或者Sock4代理)，将FoxMail的快捷方式拖到SocksCap32的空白框中，你的Foxmail即可以畅通无阻了。同样的方法也适用于Cterm、Sterm等Telnet软件访问教育网内的各大BBS站点，加快速度，而又能隐藏真实IP地址等等。有时会出现不能解析服务器地址的现象，可以先使用ping pop.mail.yahoo.com命令，然后把解析到的IP地址填入Foxmal的POP3服务器选项。 另一法：假设你有POP3代理服务器，例如:203.95.7.196，你的账号为&#65;&#x6c;&#103;&#97;&#109;&#x40;&#50;&#x31;&#x63;&#x6e;&#x2e;&#99;&#111;&#109;；则在OutlookExpress或FOXMAIL30中应按如下设置：POP3服务器地址中填写:代理服务器地址，203.95.7.196（端口无须设定）；SMTP服务器地址为：原来的SMTP服务器地址，smtp.21cn.com(实际上因为不需要用他发信,所以SMTP服务器地址可以随便填写)；帐号为:原来账号Algam#21cn.com(既用’#’取代原来的‘@’符号)；口令为：原来的账号口令。 QQ可以使用代理吗？ 有一次笔者的同学在QQ上说：“你怎么跑到深圳去了，你不是在厦门吗？”其实笔者知道这家伙爱卖弄，不就是装了个可以看IP的QQ版本吗，现在有几个人用的QQ不是可以看IP的。QQ使用代理可以隐藏真实IP，这样可以避免一些不必要的骚扰。QQ的会员可以能够使用HTTP代理的功能，而非会员就只能使用Socks代理了。有些公司网络只能上网浏览不能使用QQ，主要是封了Socks端口，避免员工上班的时候用QQ聊天。其实这种情况也有办法解决。首先下载一个SocksOnline软件，是将普通HTTP代理转换为“万能”的Socks5代理的工具，SocksOnline代理是利用了CommOnline的在线通讯能力，进行Socks代理转接。SocksOnline代理使用非常简单，只要将客户端应用的Socks5代理设置到SocksOnline的地址，客户端即能正常使用。 使用代理上QQ 假设你有Socks5代理服务器，例如:202.96.58.241；则在oicq系统菜单&#x3D;&#x3D;&gt;系统参数&#x3D;&#x3D;&gt;网络设置下,在使用Proxy Socks5 防火墙前面打勾&#x3D;&#x3D;&gt;在防火墙地址中填入代理的地址&#x3D;&#x3D;&gt; 端口号中填入socks5的端口号(一般是1080),如果不确定代理服务器是否可用,可以按校验用户密码边上的测试按钮进行测试。 使用FTP代理服务器（上传&#x2F;下载文档） 一般FTP软件设置；服务器栏：代理服务器地址，账号为：账号@原FTP服务器地址，密码为：原来的账号口令。以CUTE FTP之中使用FTP代理为例子。菜单栏“FPT”&#x3D;&#x3D;〉“SETTINGS”&#x3D;&#x3D;〉“OPTIONS”&#x3D;&#x3D;〉“FIRE WALL&#x3D;&#x3D;〉HOST：代理服务器地址&#x3D;&#x3D;〉PORT：21&#x3D;&#x3D;〉TYPE：USERuser@site&#x3D;&#x3D;〉选择“Enable firewall…” CUTE FTP中使用socks代理服务器（上传&#x2F;下载文档） 以CUTE FTP4.0为例：Edit&#x3D;&#x3D;&gt;Settings…&#x3D;&#x3D;&gt;Connection&#x3D;&#x3D;&gt;Socks&#x3D;&#x3D;&gt;选择“socks4”或“socks5”&#x3D;&#x3D;&gt;在Host旁边填写上socks4或socks5代理服务器的地址（鉴于socks5十分紧俏，又不稳定，请使用socks4为好）&#x3D;&#x3D;&gt;选择“Firewall”把“Enable fire ac..”旁边的复选框中的钩去掉。&#x3D;&#x3D;&gt;点击确定。现在就可以大大方方的使用socks4代理服务器上传主页了。（虽然多数socks代理都能上传主页，但有部分socks代理由于不允许同一ip重复联接，可能不能上传，出现这种情况时，请换一个socks代理） 在网络蚂蚁中设置代理服务器 点击“网络蚂蚁”的菜单“选项”&#x3D;&#x3D;〉 参数设置&#x3D;&#x3D;〉 “代理”&#x3D;&#x3D;〉点击“添加”&#x3D;&#x3D;〉在“类型”下拉式列表中选择http（get）&#x3D;&#x3D;&gt;在“地址”中填写http代理服务器的地址；端口填写代理服务器的端口（例如80）；在“名称”中随便起个名字&#x3D;&#x3D;〉一路选择“确定”当下载东西时，选择好了文件存放的本地文件夹之后，不要忙于点“确定”。应该点“代理”选择希望使用的代理服务器的名称，然后再点击“确定”，就可以使用这个代理服务器下载了。顺便说一句，本站长用“蚂蚁+自己专用的http代理”下载1M以上东西通常也都是能稳定在6k&#x2F;s左右。 CTERM2000中使用telnet代理访问BBS文件&#x3D;&#x3D;&gt;地址簿&#x3D;&#x3D;&gt;选择自己要去的bbs或者自己增加新的bbs站&#x3D;&#x3D;&gt;将原来放置在“地址”栏中的bbs的地址（例如：网易的bbs.nease.net）剪贴到“自动登陆”栏中，原来的地方填写telnet代理服务器的ip地址（例如：203.93.37.248）&#x3D;&#x3D;&gt;然后最好在“自动登陆”栏中bbs.nease.net后面加上“&#x2F;n”表示回车，如果知道进入时需要键入什么用户名之类的还可以加上其他的转意符和字符。（具体可以看他的Help）&#x3D;&#x3D;&gt;为了方便，建议点击“输出到文档”按钮，将设置存入文档，方便以后使用&#x3D;&#x3D;&gt;然后就可以按“连接站点”了。顺便说一句：我对cterm2000的印象很好，使用也很简单，建议要上bbs的用户使用。 二级代理篇 对于在教育网和科技网内的朋友，直接从国外下载需要支付高额流量费，或机器不能直接连出国，所以要使用国外的代理，还得先学会用二级代理。二级代理的设置方法参见 “Httport”的说明文章。”socks2http + Sockscap” 设置，参见其它代理设置网站。有一点需要注意的是：并不是所有的代理都能用作一级代理，只有支持SSL的HTTP代理才行。 论坛代理专业版中有很多. 一句话：一级代理用支持SSL的免费HTTP代理，二级代理用下载文献的国外代理！ Httport中二级代理设置简介 如果只是想使用二级代理的话，这个软件比socks2http+SocksCap32要方便得多。至于Httport的其它功用，自己慢慢摸索吧，对于这方面的询问，恕不回复！当然有一个前提，就是你所用的一级代理得要支持SSL,其实在socks2http里设的代理也有这个要求。这也就是为什么有些代理不能用在socks2http里的原因. 以202.120.25.36:8080作为一级代理为例，首先在代理页面将202.120.25.36填入主机名或IP地址栏中，别忘了填端口。勾选身份验证，填入用户名和密码（免费代理随便填）。用户代理选IE，用过SSL连接模式，其余不填。二级代理设置在端口映射菜单。”外部HTTP代理”下面的就是你要用的二级代理了，比如2.25.56.58:80。即”远程主机”里填上2.25.56.58,”远程端口”就是80，至于那个”本地端口”，比如用3128,那么你在IE里设代理localhost:3128 。点击左边那个的”开始”就行了. 将HTTP代理转为SOCKS代理 首先向大家推荐两个软件:sockscap和socks2http。sockscap我想就不用多说了吧,如果你有socks代理,用了这个自然就能实现二级代理,不过socks代理倒是不多.而socks2http是用http代理模拟socks5代理. 比如用202.38.64.4:8080做socks代理,在socks2http设置中如是填入后,填入你的帐号和密码.再点击 “完成”即可.使用时,在你所用的软件中的socks5代理栏处 填入localhost,端口1080 .这样你所用的自然就是202.38.64.4的socks代理了. 或者运行sockscap,在socks代理设置中填localhost,注意只能用socks5,不能做socks4代理. 但用http模拟的socks代理限于很少的一些网络软件.http浏览没什么问题(注意IE4不支持sockacap),可telnet,ftp就不一定了,好像只有本身支持socks代理的软件才行.建议在telnet时使用Sterm1.0,在ftp时用Absoluteftp.(注意需要使用二级代理的软件,一定要在sockscap里运行,你所用的第一级代理才能生效)。 哇塞,用了这个法子,好处可多多哟!特别是使用64.4的大侠们.用它telnet,ftp前面已述.当教育网那条路断了时,用64.4还是可以的说.特别是可以不再有什么几条线程的限制了,也没有什么不能下载mp3及rm文件的限制了,不信你试试看!只是有点遗憾不能用这个方法上oicq! 我想有了这个方法后,大家再也不用愁什么二级代理的问题了吧.象你如果用64.4模拟成socks5后,照上述方法,再用一个国内的免费代理,连出国,速度也还不马马虎虎,只是你的钞票会哗啦哗啦往外流得少一点了吧! 对于一些没有出校IP，只有学校proxy的朋友，得要用三级代理。设置三级代理就得要httport +socks2http+ sockscap一起用了。先搜索校内可用的代理，例如：202.120.25.36（假设），在httport中用第一级202.120.25.36；或申请国内浏览服务器（注意要填上你的帐号和密码）。第二级用支持SSL的免费代理，在httport的”端口映射”—&gt;外部http代理”中设定。然后在socks2http里用代理localhost，端口就是你在上述”外部http代理”中你用的本地端口（202.120.25.36）。下面就是用sockscap,在里面启动IE，那个能下载文献的代理就往IE里设代理的地方填吧． 二次代理进阶篇 其实二次代理就是两个代理的级联，有很多Proxy Server本来就支持级联，如 Winproxy、Wingate，不是我们自己开代理，只是使用代理，所以不讨论这个问题，（只讨论如何使用代理，建立代理的问题看看WINGATE等的说明，很容易的。） 先说说要用到的一些软件，Sockscap、Httport、MProxy，这几个软件在网上都能很方便的找到，代理级联一般有http代理和socks代理为基础来进行，常用代理级联大概有以下几种方式： 1、http代理之间的级联。 2、socks代理之间的级联。 3、http代理和其他代理的级联。 4、socks代理和其他代理的级联。 5、tlenet代理之间的级联。 一、http代理之间的级联 http代理级联可以有多种方式来实现，我说说简单的两种吧，最简单的方法就是使用Mproxy，它支持三级http代理级联，支持输入前两级代理的地址和端口即可，然 后就可以使用本地127.0.0.1:888作为代理来访问，不如这个方法的缺陷就是不支持 http代理的认证，不能使用需要认证http代理；另外一种方法使用Httport，其实这个代理功能很强大，现在只是用来http代理间的级联，打开Httport，在proxy页 输入第一级http代理的地址和端口，如果需要认证就选择上认证，输入用户名和密码， 然后到port mapping页，点击Add按钮，在列表中出现New mapping，然后在Remote Host里输入第二级http代理的地址，Remote port里输入第二级http代理的端口， local port里输入本地监听的端口，如3128、8080等端口，在Proxy页点start按钮 后就可以使用本地127.0.0.1:3128作为代理来访问了，需要注意的是第一级http代理 必须支持ssl连接，否则不能级联第二级http代理。 （所谓SSL，是指Secure Sockets Layer，是由Netscape公司开发的一套Internet数据安全协议，当前版本为3.0。它已被广泛地用于Web浏览器与服务器之间的身份认证和加密数据传输。需要说明的是，虽然你浏览的内容是加密的，不过连接站点在代理服务器上边的是可见的。另外，站点的URL和IP在代理服务器上仍然是可见的。找SSL的代理很简单，可以使用AATools之类的软件，也可以直接用FLASHGAT来验证） 需要补充一点的就是，上面的二次代理可以供别人使用，因为是在本地所有ip上进 行监听的，如在你的机器ip是10.9.1.11，本地端口是888，别人能访问10.9.0.11:888 作为二次代理使用，这样你就可以与别人共享你的二次代理了，这里介绍的Mproxy不是 Multiproxy，Multiproxy是做代理验证和调度用的。 二、socks代理之间的级联 socks代理级联也有几种方式，常用的方法是使用sockscap来实现，在sockscap的 Setting对话框中输入socks代理地址、端口，如是socks5还有用户和密码，然后加入 可使用socks代理的软件（FREE的SOCKS更好了！！），如IE，在Internet选项里socks里设置二级socks代理的地址 和端口，在sockscap里运行IE就可以使用上二次socks代理了，像其他的Flashfxp、 Sterm和Leapftp里也一样，在这些软件上设置二级socks代理，然后在sockscap里运行 就可以使用二次socks代理了；另外也可以使用SkSockServer来实现，这个软件支持256 级socks代理的级联，本身也可以作为socks proxy server来使用，跟mproxy差不多， 只要加入各级socks代理地址和端口即可，另外sockschain也是做socks级联的工具。 （SOCKS代理本身的安全性就高。但仍然有可能通过技术手段来监控到实际ＩＰ！） 三、http代理和其他代理的级联 http代理跟别的代理级联，这里用的是上面提到的httport，注意第一级http代理 一定要求ssl连接（一定是SSL的代理呀，否则不行的！！），在proxy页输入http代理的地址和端口，然后在 port mapping页加入其他要级联的代理，如telnet代理，在remote host和remote port里输入分别telnet代理的地址和端口，在local port输入本地监听端口，如23， 在proxy页点击start，这样telnet 127.0.0.1 23就是连接到二次代理上，接着输入 要远程登录地址和端口即可，级联socks代理也一样，在port mapping页输入二次代理 的地址、端口和本地监听端口(如1080)，这样你就可以在其他软件上使用127.0.0.1:1080 作为二次代理使用了，其他的如ftp、pop3代理也一样这样作为二级代理与http代理级联。 四、socks代理和其他代理的级联 socks代理与其他代理级联，这里介绍的是sockscap，跟上面介绍的一样，在setting 对话框里输入socks代理的地址和端口，然后add其他需要用二次代理的软件，如IE，OE 和flashfxp等软件，只要在internet选项里输入第二级http和ftp代理的地址和端口， 在sockscap里运行IE就能使用二级的http和ftp代理，其他的软件也一样，设置上二级 代理在sockscap里运行即可使用二级代理。 五、tlenet代理之间的级联 其实telnet代理之间的级联很简单，以常用的wingate代理为例，当我们telnet到 代理时出现 Wingate&gt; 的提示，直接输入另外一个telnet代理的地址和端口即可，一般是”ip port”，有些代 理是”iport”(如CSM Proxy Server)，输入即可连到二次代理上，在二次代理输入 要telnet登录的地址就可以了。 上面介绍了几种常用代理的级联方法，其实就是灵活使用上面的httport、sockscap等几个软件，只要熟练掌握软件的使用，能够玩出很多的花样来，比如跟 其它的软件配合使用，至于国外的二次代理，http代理可以到multiproxy的主页上 去找，其他代理可以在google上输入free proxy http socks来搜索，最新软件 可以到软件的主页获得，最后说一句，学好httport软件的使用大有前途， 对那些 只开了http代理，其他端口被封的人大有用处，对了大家别用这些方法干坏事哦 三级代理 用httport + s2h + sockscap即：在httport中用第一级代理（注意要填上你的帐号和密码）第二级用支持SSL的免费代理，在httport的”端口映射”—&gt;外部http代理”中设。 然后在socks2http里用代理localhost　端口就是你在上述”外部http代理”中你用的本地端口了下面步骤的就是用sockscap,在里面启动IE，那个能下载文献的代理就往IE里设代理的地方填吧． 对于大部分计算机用户来说，管理计算机基本上是借助某些第三方工具，甚至是自己手工修改注册表来实现。其实Windows XP组策略已经把这些功能集于一体，通过组策略及相关工具完全可以实现我们所需要的功能。 一、组策略基础 1.什么是组策略 注册表是Windows系统中保存系统软件和应用软件配置的数据库，而随着Windows功能越来越丰富，注册表里的配置项目也越来越多，很多配置都可以自定义设置，但这些配置分布在注册表的各个角落，如果是手工配置，可以想像是多么困难和烦杂。而组策略则将系统重要的配置功能汇集成各种配置模块，供用户直接使用，从而达到方便管理计算机的目的。 其实简单地说，组策略设置就是在修改注册表中的配置。当然，组策略使用了更完善的管理组织方法，可以对各种对象中的设置进行管理和配置，远比手工修改注册表方便、灵活，功能也更加强大。 2.组策略的版本 对于Windows 9X&#x2F;NT用户来说，都知道“系统策略”的概念，其实组策略就是系统策略的高级扩展，它是自Windows 9X&#x2F;NT的“系统策略”发展而来的，具有更多的管理模板、更灵活的设置对象及更多的功能，目前主要应用于Windows 2000&#x2F;XP&#x2F;2003操作系统中。 早期系统策略的运行机制是通过策略管理模板，定义特定的POL(通常是Config.pol)文件。当用户登录时，它会重写注册表中的设置值。当然，系统策略编辑器也支持对当前注册表的修改，另外也支持连接网络计算机并对其注册表进行设置。 而组策略及其工具，则是对当前注册表进行直接修改。显然，Windows 2000&#x2F;XP&#x2F;2003系统的网络功能是其最大的特色之处，所以其网络功能自然是不可少的，因此组策略工具还可以打开网络上的计算机进行配置，甚至可以打开某个Active Directory(活动目录)对象(即站点、域或组织单位)并对其进行设置。这是以前“系统策略编辑器”工具无法做到的。 当然，无论是“系统策略”还是“组策略”，它们的基本原理都是修改注册表中相应的配置项目，从而达到配置计算机的目的，只是它们的一些运行机制发生了变化和扩展而已。 3.在Windows XP中运行组策略 在Windows 2000&#x2F;XP&#x2F;2003系统中，系统默认已经安装了组策略程序，在“开始”菜单中，单击“运行”选项，在打开的对话框中输入“gpedit.msc”并确定，即可运行组策略。如图1所示。 使用上面的方法，打开的组策略对象是当前的计算机，而如果需要配置其他的计算机组策略对象，则需要将组策略作为独立的MMC管理单元打开： (1)打开Microsoft管理控制台(可在“开始”菜单的“运行”对话框中直接输入“MMC”并确定)。 (2)单击“文件→添加&#x2F;删除管理单元”菜单命令，在打开的对话框中单击“添加”按钮。 (3)在“可用的独立管理单元”对话框中，单击“组策略”选项，然后单击“添加”按钮。 (4)在“选择组策略对象”对话框中，单击“本地计算机”选项编辑本地计算机对象，或通过单击“浏览”查找所需的组策略对象。 (5)单击“完成”按钮，组策略管理单元即打开要编辑的组策略对象。 (6)在左窗格中定位需要更改的选项的位置，在右窗格中右键单击需要更改的具体选项，单击“属性”命令，即可打开其属性对话框，从中选择“已启用”、“未配置”、“已禁用”选项即可对计算机策略进行管理。 4.组策略中的管理模板 在Windows 2000&#x2F;XP&#x2F;2003中包含几个ADM文件。这些文件是文本文件，被称为“管理模板”，它们为组策略管理单元的控制树中“管理模板”文件夹下的项目提供策略信息。 在Windows 2000&#x2F;XP&#x2F;2003中，默认的Admin.adm管理模板位于系统文件夹的INF文件夹中，包含了默认安装下的4个模板文件，分别为： (1)System.adm：默认安装在“组策略”中，用于系统设置。 (2)Inetres.adm：默认安装在“组策略”中，用于Internet Explorer(IE)策略设置。 (3)Wmplayer.adm：用于Windows Media Player设置。 (4)Conf.adm：用于NetMeeting设置。 在策略管理控制台中，可以多次添加“策略模板”，下面让我们来看看具体操作： 首先运行“组策略”程序，然后选择“计算机配置”或者“用户配置”下的“管理模板”，单击鼠标右键，选择“添加&#x2F;删除模板”命令，然后在打开的对话框中单击“添加”按钮，在打开的对话框中选择相应的ADM文件。单击“打开”按钮，则在系统策略编辑器中打开选定的脚本文件，并等待用户执行。 返回到“组策略”编辑器主界面后，依次打开目录“本地计算机策略→用户配置→管理模板”选项，再单击相应的目录树，就会看到我们新添加的管理模板所产生的配置项目了。 注意：下面的操作均在Windows XP中进行。 二、个性化我的电脑 1.删除“开始”菜单中的“文档”菜单项 在多人使用的计算机中，有的用户不希望其他用户看到自己曾经编辑过的文档或其他信息。因此，为了删除用于记录历史文档的“文档”菜单项，我们可以通过修改组策略来实现。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;任务栏和“开始”菜单&#x2F; 启用此设置，则系统保存“文档”快捷方式，但不在“文档”菜单中显示它们。如果以后禁用此设置或把它设置为未配置，则启用设置之前及其生效之时保存的“文档”快捷方式会出现在“文档”菜单项中。如图2所示。 注意：此设置不会阻止Windows程序在最近打开的文档中显示快捷方式。 另外，你也可以设置在退出系统时自动清除最近打开的文档的历史记录。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;任务栏和“开始”菜单&#x2F; 如果禁用该策略设置，系统就会在用户退出时删除快捷方式。因此，用户登录时，“开始”菜单上的文档菜单总是空的。如果禁用或不配置此设置，系统将保留文档快捷方式，并且用户登录时的文档菜单看起来与用户退出系统时完全相同。 注意：系统在&#x2F;Documents and Settings&#x2F;&lt;用户名&gt;&#x2F;Recent文件夹中的用户配置文件中保存文档快捷方式。 2.删除“开始”菜单中的“运行”菜单项 在“开始”菜单中有“运行”菜单项，可以输入程序名称来启动程序。我们可以将“运行”菜单项从“开始”菜单中删除。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;任务栏和“开始”菜单&#x2F; 如果启用该设置，发生如下更改： (1)“运行”命令从“开始”菜单中删除。 (2)新建任务(运行)命令从任务管理器删除。 (3)阻止用户在IE地址栏中输入下列项： UNC路径：&#x2F;&#x2F;＜server＞&#x2F;＜share＞。 访问本地驱动器：例如，C:。 访问本地文件夹：例如，&#x2F;temp＞。 同时，使用WIN+R组合键将无法显示“运行”对话框。如果禁用或不配置此设置，用户可以访问“开始”菜单和任务管理器的“运行”命令，以及使用IE地址栏。 注意：这个策略只影响指定的界面。不会防止用户使用其他方法运行程序。 3.给“开始”菜单减肥 如果觉得Windows的“开始”菜单太臃肿，你完全可以通过组策略设置将不需要的菜单项从“开始”菜单中删除。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;任务栏和“开始”菜单&#x2F; 在组策略右侧窗格中，提供“从‘开始’菜单删除用户文件夹”、“删除到‘Windows Update’的访问和链接”、从‘开始’菜单删除公用程序组、从‘开始’菜单中删除“我的文档”图标等配置项目。你只要将不需要的菜单项所对应的策略启用即可。 4.隐藏和禁用桌面上的所有项目 该策略可以从桌面上删除图标、快捷方式和其他默认的和用户定义的项目。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;桌面&#x2F; 该策略删除图标和快捷方式不防止用户用另一种方法启动程序或打开图标和快捷方式所代表的项目。 5.退出时不保存用户设置 该策略用于防止用户保存对桌面的某些更改。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;桌面&#x2F; 如果你启用这个设置，用户可以对桌面做某些更改，但有些更改，比如图标和打开窗口的位置、任务栏的位置及大小在用户注销后都无法保存。 6.启用&#x2F;禁用“活动桌面”(Active Desktop) 活动桌面是Windows 98(及以后版本)或安装了IE 4.0的系统中自带的高级功能，它最大的特点是可以设置各种图片格式的墙纸，甚至可以将网页作为墙纸显示。但出于对安全和性能的考虑，有时候我们需要禁用这一功能(并且防止用户启用它)。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;桌面&#x2F;Active Desktop 提示：如果同时启用“启用Active Desktop”设置和“禁用Active Desktop”设置，“禁用Active Desktop”设置会被忽略。如果“禁用Active Desktop和Web视图”设置(在“用户配置&#x2F;管理模板&#x2F;Windows组件&#x2F;Windows资源管理器”)被启用，Active Desktop就会被禁用，并且这两个策略都会被忽略。 7.从“我的电脑”中删除共享文档 当Windows用户在一个工作组中，一个“共享文档”图标会以Windows资源管理器的Web视图出现在“其他位置”和“在这台计算机上存储的其他文件”中。使用此设置，你可选择不显示这些项目。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;Windows组件&#x2F;Windows资源管理器&#x2F; 如果启用此设置，“共享文档”文件夹将不会以Web视图方式显示或在“我的电脑”中出现。如果禁用或不配置此设置，当用户是“工作组”的一部分时，“共享文档”文件夹将会以Web视图方式显示或在“我的电脑”中出现。 8.不要将已删除的文件移到“回收站” 当Windows资源管理器中的一个文件或文件夹被删除时，该文件或文件夹的副本会被放在“回收站”里。使用此策略，你能改变此行为。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;Windows组件&#x2F;Windows资源管理器&#x2F; 如果启用此设置，使用Windows资源管理器删除的文件或文件夹不会被放在“回收站”里，因此被永久删除。如果禁用或不配置此设置，使用Windows资源管理器删除的文件或文件夹会被放在“回收站”里。 三、利用组策略进行系统设置 1.登录时不显示欢迎屏幕 为了加快计算机启动的速度，我们完全可以通过组策略设置在每次用户登录时将Windows XP欢迎屏幕隐藏。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;系统&#x2F; 要显示欢迎屏幕，请依次单击“开始→程序→附件→系统工具”选项，然后单击“开始”选项。要在不指定设置的情况下不显示欢迎屏幕，请在欢迎屏幕上的复选框中清除“在开始显示这个屏幕”选项。 注意：这项设置出现在“计算机配置”和“用户配置”文件夹中。如果配置这项设置，“计算机配置”中的设置比“用户配置”中的设置优先。 2.配置驱动程序查找位置 默认情况下，Windows将从本地安装、软盘驱动器、光盘驱动器、Windows Update等位置搜索驱动程序。此设置配置查找到新硬件时Windows将要搜索驱动程序的位置。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;系统&#x2F; 如果启用此设置，你可以通过检查位置名称的相关复选框，删除这三个位置中的任何位置。如果禁用或不配置此设置，Windows将从本地安装、软盘驱动器、光盘驱动器和Windows Update等位置中搜索驱动程序。 3.关闭自动播放 一旦你将媒体插入驱动器，自动运行就开始从驱动器中读取。这会造成程序的设置文件和在音频媒体上的音乐立即开始。该策略将关闭自动运行功能。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;系统&#x2F; 如果你启动这项设置，你还可以在CD-ROM驱动器禁用自动运行或在所有驱动器上禁用自动运行。 注意：这个设置出现在“计算机配置”和“用户配置”两个文件夹中。如果两个设置都配置，“计算机配置”中的设置比“用户配置”中的设置优先。 另外，此设置不阻止自动播放音乐 CD。 4.只运行许可的Windows应用程序 该策略可以限制用户可以运行的Windows程序。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;系统&#x2F; 如果你启用这个设置，用户只能运行你加入“允许运行的应用程序列表”中的程序。 这个设置只能防止用户从Windows资源管理器启动程序。无法防止用户用其他方式启动程序，例如任务管理器。如果用户可以访问命令提示符窗口，这个设置无法防止用户从命令窗口启动不允许在Windows资源管理器中运行的程序。 注意：要创建允许的文件列表，请单击“显示”按钮，在打开的对话框中单击“添加”按钮，然后输入应用程序的执行文件名称(例如，Winword.exe、Poledit.exe、Powerpnt.exe)。如图3所示。 5.删除任务管理器 当我们同时按下Ctrl+Alt+Del组合键将显示“Windows任务管理器”对话框。任务管理器可以让用户启动或终止程序、监视计算机性能、查看及监视计算机上所有运行中的程序(包含系统服务)、搜索程序的执行文件名、更改程序运行的优先顺序。在这里，我们可以通过组策略删除任务管理器。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;系统&#x2F;Ctrl+Alt+Del选项&#x2F; 如果该设置被启用，并且用户试图启动任务管理器，系统会显示消息，解释是一个策略禁止了这个操作。 6.删除改变“密码”选项 该策略可以防止用户通过任务管理器更改系统密码。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;系统&#x2F;Ctrl+Alt+Del选项&#x2F; 这个设置停用Windows安全设置对话框上的“更改密码”按钮。但是，用户在得到系统提示时依旧可以更改密码。管理员要求新密码和密码作废时，系统会提示用户输入新密码。 7.不允许运行Windows Messenger Windows XP自带有聊天工具Windows Messenger，但是，我们也有可能在系统中安装MSN Messenger。该策略允许你禁用Windows Messenger。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;Windows组件&#x2F;Windows Messenger 如果启用该策略，Windows Messenger将不会运行。如果禁止或不配置该策略，Windows Messenger可以被使用。 注意：如果启用这个策略，远程协助无法使用Windows Messenger。另外，这个策略也会出现在“计算机配置”中。如果两个设置都配置，“计算机配置”中的设置比“用户配置”中的设置优先。 8.关闭系统还原功能 系统还原是Windows XP&#x2F;2003中集成的强大功能，它在系统运行的同时，备份被更改的文件和数据，如果出现问题，系统还原使用户能够在不丢失个人数据文件的情况下，将计算机还原到以前的状态。默认情况下，系统还原处于打开状态。 但这一功能付出的代价也是相当大的，系统性能会明显下降，磁盘空间也会被占用很多。对于配置不高的计算机来说，强烈建议关闭此功能。 位置：&#x2F;计算机配置&#x2F;管理模板&#x2F;系统&#x2F;系统还原&#x2F;关闭系统还原 启用此设置后即可关闭系统还原功能，并且不能访问“系统还原向导”和“配置界面”。 四、利用组策略调整上网设置 1.禁用导入和导出收藏夹 禁止用户使用“导入&#x2F;导出向导”菜单项导入或导出收藏夹链接。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;Windows组件&#x2F;Internet Explorer 如果启用该策略，“导入&#x2F;导出向导”菜单项将无法导入&#x2F;导出收藏夹链接和Cookie。如果禁用该功能或不对其进行配置，则用户可以通过单击“文件”菜单上的“导入和导出”菜单项，然后运行“导入&#x2F;导出向导”，导入&#x2F;导出IE中的收藏夹。 注意：如果启用该策略，用户仍然可以查看“导入&#x2F;导出向导”，但当用户单击“完成”按钮时，将出现说明该功能已被禁用的提示信息。 2.禁用更改“高级”选项卡的设置 禁止用户更改“Internet 选项”对话框中“高级”选项卡上的设置。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;Windows组件&#x2F;Internet Explorer 如果启用该策略，则用户无法更改高级Internet设置，如安全、多媒体和打印。用户无法选中“高级”选项卡上的复选框，也不能清除这些复选框的复选标记。如果禁用该策略或不对其进行配置，则用户可以选择或清除“高级”选项卡上的设置。 如果设置了位于&#x2F;用户配置&#x2F;管理模板&#x2F;Windows组件&#x2F;Internet Explorer&#x2F;Internet控制面板中的“禁用高级页”策略，则无需设置该策略，因为“禁用高级页”策略将删除界面上的“高级”选项卡。 3.对拨号连接使用“自动检测”属性 自动检测在浏览器第一次启动时使用 DHCP(动态主机配置协议)或DNS服务器来自定义浏览器。该策略指定自动检测用于用户的拨号设置的配置。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;Windows组件&#x2F;Internet Explorer 如果启用该设置，自动检测将配置用户的拨号设置。如果禁用该配置或不配置，自动检测不会配置用户的拨号设置，除非用户指定。 4.禁用Internet连接向导 禁止用户运行Internet连接向导。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;Windows组件&#x2F;Internet Explorer 如果启用该策略，“Internet选项”对话框中“连接”选项卡上的“建立连接”按钮将变灰。用户也无法通过单击桌面上的“连接到Internet”图标或单击“开始→程序→附件→通讯”，然后单击“Internet连接向导”运行Internet连接向导。如果禁用该策略或不对其进行配置，则用户可以通过运行Internet连接向导，更改连接设置。 注意：该策略与位于＼用户配置＼管理模板＼Windows 组件＼Internet Explorer＼Internet控制面板中的“禁用连接页”策略有相似之处，后者将删除界面上的“连接”选项卡。从界面上删除“连接”选项卡并不会妨碍用户从桌面或“开始”菜单中运行Internet连接向导。 5.禁用表单的自动完成功能 禁止IE自动完成表单，如填写用户以前在网页中输入过的姓名或密码。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;Windows组件&#x2F;Internet Explorer 如果启用该策略，“表单”复选框将变灰。单击“Internet选项”对话框中“内容”选项卡上的“自动完成”按钮，即可出现“表单”复选框。如果禁用该策略或不对其进行配置，则用户可以启用表单的自动完成功能。 位于&#x2F;用户配置&#x2F;管理模板&#x2F;Windows组件&#x2F;Internet Explorer&#x2F;Internet控制面板中的“禁用内容页”策略的优先级高于该策略。如果启用了“禁用内容页”策略，该策略将被忽略，因为“禁用内容页”策略将删除“控制面板”中“Internet Explorer属性”对话框中的“内容”选项卡。 注意：如果用户已开始使用启用了表单自动完成功能的浏览器后，再启用该策略，则不会清除用户已经使用表单自动完成功能在表单中所填写的内容。 6.配置媒体浏览栏属性 媒体浏览器栏播放来自Internet的音乐和视频内容，该策略允许管理员启用和禁用媒体浏览器栏和设置默认自动播放。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;Windows组件&#x2F;Internet Explorer 如果禁用媒体浏览器栏，用户无法显示媒体浏览器栏。自动播放功能也被禁用。当用户在IE中单击一个链接，系统中的默认媒体客户端将播放内容。如果启用媒体浏览器栏或不配置，用户可以显示和隐藏媒体浏览器栏。 管理员也可以打开和关闭自动播放功能。该设置只在媒体浏览器栏启用时应用。如果选择，媒体浏览器栏将在用户单击媒体链接时自动显示和播放媒体内容。如果不选择，系统上的默认媒体客户端将播放内容。 7.禁用右键快捷菜单 禁止在用户使用IE过程中单击鼠标右键时出现快捷菜单。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;Windows组件&#x2F;Internet Explorer&#x2F;浏览器菜单 如果启用该策略，在用户指向网页，然后单击鼠标右键时将不出现快捷菜单。如果禁用该策略或不对其进行配置，则用户可以使用快捷菜单。 8.自定义IE标题栏 我们可以利用组策略自定义出现在IE和OE标题栏中的文本。无论软件包中是否有OE或者用户计算机上已经安装了OE，都将更新OE标题栏。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;Windows设置&#x2F;Internet Explorer维护&#x2F;浏览器用户界面&#x2F;浏览器标题 请在打开的对话框中选中“自定义标题栏”选项，然后在“标题栏文本”框中键入希望的文本。 注意：在选择某个位图时，要确保颜色与文本的对比度。这为用户确保了更高程度的可读性。 9.自定义IE工具按钮 我们可以利用该策略个性化出现在IE中的工具栏，给你一定的灵活性和设计机会。可以使用的元素包括用于标准工具栏按钮(例如“搜索”和“历史”)的工具栏背景和图标外观。 位置：＼用户配置＼管理模板＼Windows设置＼Internet Explorer维护＼浏览器用户界面＼浏览器工具栏自定义 在打开的对话框中单击“添加”按钮，然后在打开的对话框中在“工具栏标题(必需)”框中，键入用户鼠标悬停在工具栏按钮上时出现的文本。必须指定该按钮的标题或标签。建议的最大长度是10个字符。 在“工具栏操作(作为脚本文件或可执行文件，必需)”框中，键入脚本文件或可执行文件的名称，或者单击“浏览”按钮查找文件。必须指定用户单击工具栏按钮时运行的脚本文件或可执行文件。 在“工具栏颜色图标(必需)”框中，键入表示按钮为活动状态的文件的名称，或者单击“浏览”按钮查找该文件。必须指定出现在工具栏上的按钮的彩色图标。图标由活动和非活动状态的20×20像素的图像组成。 在“工具栏灰度图标(必需)”框中，键入出现在黑白监视器上的工具栏的灰度图标文件名和位置，或者单击“浏览”按钮查找文件。必须指定显示在工具栏上按钮的灰度图标。 选中“默认情况下，该按钮应显示在工具栏上”复选框来显示默认情况下用户浏览器中的工具栏按钮。 五、利用组策略设置优化网络环境 1.禁止访问网络连接组件的属性 “本地连接属性”对话框包括连接时使用的网络组件列表。要查看或更改组件属性，请单击组件名称，然后单击组件列表下面的“属性”按钮，如图4所示。该策略确定用户是否可以更改由网络连接使用的组件属性，它确定是否启用用于网络连接组件的“属性”按钮。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;网络&#x2F;网络连接&#x2F; 如果启用此设置(并启用“为管理员启用网络连接设置”设置)，就会为管理员禁用“属性”按钮。无论“为管理员启用网络连接设置”设置启用与否，用户都不可以访问连接组件。如果禁用或不配置“为管理员启用网络连接设置”。 如果禁用或不配置此设置，将为用户启用“属性”按钮。 2.禁用TCP&#x2F;IP高级配置 确定用户是否可以配置TCP&#x2F;IP 设置。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;网络&#x2F;网络连接&#x2F; 如果启用此设置(并启用“为管理员启用网络连接设置”设置)，就对所有用户(包括管理员)禁用“Internet协议(TCP&#x2F;IP) 属性”对话框上的“高级”按钮。因此，用户不能打开“高级TCP&#x2F;IP设置”对话框并修改IP设置(例如，DNS和WINS服务器信息)。如果禁用此设置，则启用“高级”按钮，并且所有用户均可打开“高级TCP&#x2F;IP设置”对话框。 注意：此设置会由禁止访问连接属性或连接组件属性的设置取代。如果将这些策略设置为拒绝访问连接属性对话框或用于连接组件的“属性”按钮，用户就无法访问用于TCP&#x2F;IP配置的“高级”按钮。不管此设置如何，非管理员用户均不具有访问用于网络连接的TCP&#x2F;IP高级配置的权限。在用户退出系统之前，将此设置从“启用”更改为“未配置”不会启用“高级”按钮。 3.禁止添加或删除用于网络连接或远程访问连接的组件 “安装”按钮可打开用来添加网络组件的对话框。单击“卸载”按钮可删除组件列表中的选定组件。“安装”和“卸载”按钮出现在用于连接的“属性”对话框之中。这些按钮位于“常规”选项卡和“网络”选项卡上。该策略确定管理员是否可以添加和删除用于网络连接或远程访问连接的网络组件。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;网络&#x2F;网络连接&#x2F; 如果启用此设置(并启用“为管理员启用网络连接设置”设置)，就会禁用用于连接组件的“安装”和“卸载”按钮，并且不允许用户访问“Windows组件向导”中的网络组件。如果禁用或不配置此设置，就会启用用于“网络连接”文件夹中连接组件的“安装”和“卸载”按钮。同样地，用户可以访问“Windows组件向导”中的网络组件。 4.禁止访问网络连接的属性 右键单击“网上邻居”图标，在打开的快捷菜单中可以看到“属性”菜单项，用于打开网络连接属性对话框，该策略确定用户是否可以更改网络连接的属性。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;网络&#x2F;网络连接&#x2F; 如果启用此设置(并启用“为管理员启用网络连接设置”设置)，就对所有用户禁用“属性”菜单项，而且用户不能打开“连接属性”对话框。如果禁用或不配置此设置，右键单击“网上邻居”的图标时，就会出现“属性”菜单项。同样地，当用户选择此连接时，就会启用“文件”菜单上的“属性”菜单项。 注意：此设置优先于操作“局域连接属性”对话框内的功能的可用性设置。如果启用此设置，用户将不可使用网络连接的属性对话框内的任何功能。 5.更改所有用户远程访问连接的属性 该策略用于确定用户是否可以查看和更改对计算机所有用户可用的远程访问连接的属性。此设置确定是否启用“属性”菜单项，以及远程访问连接属性对话框是否对用户可用。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;网络&#x2F;网络连接&#x2F; 如果启用此设置，任何用户右键单击用来进行远程访问连接的图标时，就会出现“属性”菜单项。同样地，当任何用户选择连接时，“文件”菜单上就出现“属性”。如果禁用此设置(并启用“为管理员启用网络连接设置”设置)，就会禁用“属性”菜单项，并且用户(包括管理员)无法打开远程访问连接对话框。如果不配置此设置，则只有管理员才可以更改所有用户远程访问连接的属性。 注意：此设置优先于操作远程访问连接属性对话框内的功能的可用性设置。如果禁用此设置，则用户不可使用用于远程访问连接的属性对话框内的任何功能。 6.为管理员启用Windows XP网络连接设置 该策略确定Windows XP中的已有设置是否适用于管理员。默认情况下，Windows XP中的“网络连接”组设置不具有禁止管理员使用功能的能力。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;网络&#x2F;网络连接&#x2F; 如果启用此设置，已存在于Windows XP中的设置会具有阻止管理员使用某些功能的能力。这些设置为包括：“重命名所有用户可以使用的网络连接或远程访问连接的能力”、“禁止访问网络连接组件的属性”、“禁止访问远程访问连接组件的属性”、“访问TCP&#x2F;IP高级配置的能力”、“禁止访问高级菜单上的高级设置项”、“禁止添加和删除用来进行网络连接或远程访问连接的组件”、“禁止访问网络连接的属性”、“禁止启用&#x2F;禁用网络连接组件”、“更改所有用户远程访问连接的属性的能力”、“禁止更改专用远程访问连接的属性”、“禁止删除远程访问连接”、“删除所有用户远程访问连接的能力”、“禁止连接和断开连接远程访问连接”、“启用&#x2F;禁用网络连接的能力”、“禁止访问新建连接向导”、“禁止重命名专用远程访问连接”、“禁止访问高级菜单上的拨号参数选择项”、“禁止查看活动连接的状态”。启用此设置时，上述设置对管理员的行为有效。如果禁用或不配置此设置，上述设置将不适用于管理员。 注意：此设置是专用于正在应用这些设置的组策略对象同时包含Windows 2000和Windows XP计算机的情形中，并且在所有Windows 2000和Windows XP计算机之间必需相同的网络连接策略行为。 六、精心维护系统安全 1.防止从“我的电脑”中访问磁盘驱动器 该策略可以防止用户使用“我的电脑”访问所选驱动器的内容。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;Windows组件&#x2F;Windows资源管理器&#x2F; 如果启用了这项设置，用户无法查看在“我的电脑”或Windows资源管理器中所选驱动器的内容。同时它也无法使用运行对话框、镜像网络驱动器对话框、或使用Dir命令查看在这些驱动器上的目录。要利用这些设置，请选择一个驱动器或几个驱动器。要允许访问所有驱动器目录，请禁用这项设置或选择“不要限制驱动器”选项。 注意：驱动器的图标仍会出现在我的电脑中，但是如果用户双击图标，会出现一个消息解释设置防止这一操作。同时这以设置不会防止用户使用程序访问本地和网络驱动器。 2.禁止“注销”和“关机” 当计算机启动以后，如果你不希望该用户进行关机和注销操作，可以通过组策略来完成设置。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;任务栏和“开始”菜单&#x2F; 这个设置会从“开始”菜单删除“关机”选项，并禁用“Windows任务管理器”对话框中的“关机”选项(按Ctrl+Alt+Del会出现该对话框)。另外需要注意的是，此设置虽然可防止用户用Windows界面来关机，但无法防止用户用其他第三方工具程序来将Windows关闭。 提示：如果启用“删除‘开始’菜单上的‘注销’”策略，则还从“‘开始’菜单选项”删除“显示注销”项目。结果是用户无法将“注销&lt;用户名&gt;”项目还原到“开始”菜单(只能通过手动修改注册表的方法)。这个设置只影响“开始”菜单。它不影响“Windows 安全性”对话框中的“注销”选项(因此需要同时启用“删除和阻止访问‘关机’命令”)；而且不防止用户用其他方法注销。 3.阻止访问命令提示符 防止用户运行命令提示符窗口(Cmd.exe)。这个设置还决定批文件(.cmd和.bat)是否可以在计算机上运行。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;系统&#x2F; 如果启用这个设置，用户试图打开命令窗口，系统会显示一个消息，解释设置阻止这种操作。 注意：如果计算机使用登录、注销、启动或关闭批文件脚本，不防止计算机运行批文件；也不防止使用终端服务的用户运行批文件。 4.阻止访问注册表编辑工具 该策略将禁用Regedit.exe，以禁用Windows注册表编辑器。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;系统&#x2F; 如果这个设置被启用，并且用户试图启动注册表编辑器，解释设置禁止这类操作的消息会出现。要防止用户使用其他系统管理工具，请使用“只运行许可的Windows应用程序”策略设置。 5.禁止访问控制面板 控制面板允许用户配置其计算机、添加或删除程序和更改设置。该策略用于防止“控制面板”的程序文件Control.exe的启动，用户无法启动“控制面板”或运行任何“控制面板”项目。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;控制面板&#x2F; 该策略还从“开始”菜单中删除“控制面板”菜单项，也将“控制面板”文件夹从Windows资源管理器中删除。如果用户想从右键快捷菜单的“属性”选项中选择一个“控制面板”项目，会出现一个消息，说明该设置防止这个操作。 6.隐藏指定的控制面板程序 该策略将控制板面的项目(如显示)和文件夹从控制版面和“开始”菜单中删除。它可以删除Windows XP中包含的控制板面的项目，也可以删除你在系统里添加的控制面板项目。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;控制面板&#x2F; 若想隐藏一个控制面板项目，请在打开的对话框中，单击“已启用”选项，然后单击“显示”按钮，在打开的对话框中，单击“添加”按钮，输入该项目的文件名即可，如Ncpa.cpl(用于网络)。若想隐藏一个文件夹，输入该文件夹名即可，如“字体”。 此设置只影响“开始”菜单和控制面板窗口。它不会阻止用户使用“运行”对话框来运行控制面板项目。 注意：要寻找控制面板项目的文件名称，请在&#x2F;System32目录中寻找.cpl文件名称的扩展。 7.密码保护屏幕保护程序 该策略确定计算机上使用的屏幕保护程序是否受密码保护。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;控制面板&#x2F;显示&#x2F; 如果你启用了这项设置，所有屏幕保护程序都是有密码保护。如果你禁用了这项设置，密码保护就不能在任何屏幕保护程序上设置。这项设置也禁用了“控制面板”中“显示”项中的“屏幕保护程序”的“密码保护”复选框，防止用户更改密码保护策略。如果你不配置该策略，用户选择使用在每个屏幕保护程序上设置密码保护。 注意：只有当在计算机上指定屏幕保护程序时才可使用这项设置。 七、用组策略完善Windows娱乐功能 1.防止CD和DVD媒体信息检索 该策略防止Windows Media Player 9.0运行时从Internet检索有关CD及DVD的媒体信息。另外，首次使用对话框的“隐私选项”选项卡和播放机“隐私”选项卡中的“从Internet检索CD和DVD媒体信息”复选框都未选中，并且不可用。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;Windows组件&#x2F;Windows Media Player 如果未配置或禁用了该策略，则用户可以对“从Internet检索CD和DVD媒体信息”复选框的设置进行更改。 2.防止音乐文件媒体信息检索 该策略防止Windows Media Player 9.0自动从Internet获取有关音乐文件(例如Windows Media Audio (WMA)和MP3)的媒体信息。另外，在首次使用对话框和播放机的“隐私”及“媒体库”选项卡中的“通过从 Internet 检索缺少的媒体信息来更新音乐文件(WMA 和 MP3 文件)”都未选中，并且不可用。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;Windows组件&#x2F;Windows Media Player 如果未配置或禁用了该策略，则用户可以对“通过从Internet检索缺少的媒体信息来更新音乐文件(WMA和 MP3文件)”复选框的设置进行更改。 3.指定流媒体协议 该策略指定了可以使用在“设置”选项卡中选中的协议从Windows Media服务器接收流媒体。该策略还指定了在“设置”选项卡中选中“多播”复选框时可以接收多播流。 如果在“设置”选项卡中选中了“UDP”复选框，并且“UDP 端口”框为空，则Windows Media Player将使用默认端口播放来自Windows Media服务器的内容。如果未选中“UDP”复选框，“UDP 端口”框中的信息将被忽略。 如果未选择任何协议并启用了该策略，将无法播放来自Windows Media服务器的内容。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;Windows组件&#x2F;Windows Media Player&#x2F;网络 如果启用或禁用了该策略，播放机“网络”选项卡中的“流协议”部分将不可用。如果启用了“隐藏‘网络’选项卡”策略，则整个“网络”选项卡将隐藏起来。如果禁用该策略，播放机将无法从Windows Media服务器接收流媒体。如果有必要控制所接收的流媒体的类型，建议使用其他方法，如防火墙。如果未配置该策略，并且未启用“隐藏‘网络’选项卡”策略，则用户可以对“网络”选项卡中“流协议”部分的设置进行更改。 4.配置HTTP代理 该策略指定了HTTP协议的代理服务器设置。如果启用该策略，必须选择一种代理类型(自动检测、自定义或使用浏览器代理服务器设置)。自动检测即系统自动检查代理服务器设置。自定义即使用惟一的代理服务器设置。使用浏览器代理服务器设置则意味着使用浏览器的代理服务器设置。 如果选择自定义代理服务器类型，则必须指定“设置”选项卡中的其余选项，这是因为代理服务器没有默认设置。如果选择“自动检测”或“浏览器”，则可以忽略这些选项。 播放器“网络”选项卡中的“配置”按钮对HTTP协议无效，因此无法配置代理服务器。如果还启用了“隐藏网络选项卡”策略，则整个“网络”选项卡都不可见。 如果启用了“流媒体协议”策略，且未选择HTTP协议，该策略将被忽略。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;Windows组件&#x2F;Windows Media Player&#x2F;网络 如果禁用该策略，HTTP代理服务器将无法使用，用户也将无法配置HTTP代理服务器。如果未配置该策略，用户便可以配置HTTP代理服务器设置。 5.配置MMS代理服务器 该策略指定了MMS协议的代理服务器设置。如果启用该策略，必须选择一种代理类型(自动检测或自定义)。“自动检测”表示系统自动检测代理服务器设置。“自定义”表示使用惟一的代理服务器设置。 如果选择“自定义”代理类型，则必须指定“设置”选项卡中的其余选项。否则，将使用默认设置。如果选择“自动检测”，这些选项将被忽略。 播放器“网络”选项卡中的“配置”按钮不可用，并且无法配置协议。如果还启用了“隐藏‘网络’选项卡”策略，则整个“网络”选项卡将隐藏起来。 如果启用了“流媒体协议”策略，并且未选择“多播”，该策略将被忽略。 位置：&#x2F;用户配置&#x2F;管理模板&#x2F;Windows组件&#x2F;Windows Media Player&#x2F;网络 如果禁用该策略，MMS代理服务器将无法使用，用户将无法配置MMS代理服务器设置。如果未配置该策略，则用户可以配置MMS代理服务器设置。","tags":["Proxy"],"categories":["lnternet"]},{"title":"Vue3-06_条件渲染v-if和v-show","path":"/posts/866c339b.html","content":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;script&gt;// --------------- 条件渲染 v-if 和 v-show ---------------export default &#123; data() &#123; return &#123; age: 17, isTrue: true, sex:&#x27;man&#x27; &#125;; &#125;,&#125;;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;!---------------- v-if ----------------&gt; &lt;p&gt;请输入你的年龄：&lt;input type=&quot;number&quot; name=&quot;&quot; id=&quot;&quot; v-model=&quot;age&quot;&gt;&lt;/p&gt; &lt;!-- 用法：true显示 为false不显示 --&gt; &lt;p v-if=&quot;true&quot;&gt;这是一个文本内容&lt;/p&gt; &lt;p v-if=&quot;false&quot;&gt;我不会显示&lt;/p&gt; &lt;!-- 根据age判断显示 --&gt; &lt;p v-if=&quot;age &lt; 18&quot;&gt;我还是个小朋友&lt;/p&gt; &lt;p v-if=&quot;age &gt;= 18&quot;&gt;我已经成年了&lt;/p&gt; &lt;!-- 没必要用两个v-if 所以可以v-else --&gt; &lt;p v-if=&quot;isTrue&quot;&gt;内容v-if&lt;/p&gt; &lt;P v-else&gt;内容v-else&lt;/P&gt; &lt;button v-on:click=&quot;isTrue = !isTrue&quot;&gt;改变v-if的真假,现在是：&#123;&#123;isTrue&#125;&#125;&lt;/button&gt; &lt;!-- 再优化加入刚好18 v-else-if--&gt; &lt;p v-if=&quot;age&gt;18&quot;&gt;我已经成年了&lt;/p&gt; &lt;p v-else-if=&quot;age==18&quot;&gt;我刚到18岁&lt;/p&gt; &lt;p v-else&gt;我还是个小朋友&lt;/p&gt; &lt;!-- 在&lt;template&gt;元素上使用 v-if 条件渲染分组--&gt; &lt;template v-if=&quot;age&gt;=18&quot;&gt; &lt;p&gt;----------------成年人内容------------&lt;/p&gt; &lt;p&gt;这可是成年人才能看的内容&lt;/p&gt; &lt;p&gt;这可是成年人才能看的内容&lt;/p&gt; &lt;p&gt;这可是成年人才能看的内容&lt;/p&gt; &lt;/template&gt; &lt;!---------------- v-show --------------&gt; &lt;p v-show=&quot;sex==&#x27;man&#x27;&quot;&gt;男生&lt;/p&gt; &lt;p v-show=&quot;sex==&#x27;women&#x27;&quot;&gt;女生&lt;/p&gt; &lt;!-- v-if和v-show区别 --&gt; &lt;!-- v-show：元素始终会被渲染并保留DOM中 --&gt; &lt;!-- v-show：只是简单的切换元素的display css属性 --&gt; &lt;!-- v-whow：频繁切换状态用 --&gt; &lt;!-- v-if：只要后面为false, 对应的元素及子元素都不会被渲染 --&gt; &lt;!-- v-if：用于控制dom元素的创建和销毁 --&gt; &lt;!-- v-if：运行条件改变少或一次性用 --&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt;","tags":["Vue","Vue3"],"categories":["Language"]},{"title":"Vue3-05_style样式的多种操作方式","path":"/posts/92e94d5.html","content":"12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;script&gt;// --------------- style样式的多种操作方式 ---------------export default &#123; data() &#123; return &#123; msg: &quot;hello world&quot;, activeColor: &quot;blue&quot;, fSize: &quot;25px&quot;, bgColor: &quot;pink&quot;, // style对象 styleObj: &#123; color: &#x27;red&#x27;, // fontSize是font-size fontSize: &#x27;25px&#x27;, // &quot;background-color&quot;可写为backgroundColor不带引号 &quot;background-color&quot;: &#x27;pink&#x27;, &#125;, &#125;; &#125;,&#125;;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;!-- 第一种：放置字符串 --&gt; &lt;p style=&quot;color: red&quot;&gt;放置字符串：&#123;&#123; msg &#125;&#125;&lt;/p&gt; &lt;!-- 第二种：放置对象 (属性名可以用驼峰命名式 或短横线分隔(得用引号括起来)来命名)--&gt; &lt;!-- 写法：&lt;p v-bind:style=&quot;&#123;key:value&#125;&quot;&gt;xxx&lt;/p&gt; 其中key是属性值,value可来自data --&gt; &lt;p v-bind:style=&quot;&#123; color: activeColor &#125;&quot;&gt;放置对象：666&lt;/p&gt; &lt;!-- 注意：fontSize是小驼峰写法 原写法为(font-size) 这里直接写font-size会出错 --&gt; &lt;!-- 例如background-color写法 加上引号后不报错 --&gt; &lt;p :style=&quot;&#123;color: activeColor,fontSize: fSize,&#x27;background-color&#x27;: bgColor&#125;&quot;&gt;放置对象：888&lt;/p&gt; &lt;!-- 上面style里内容太多 定义style对象使用--&gt; &lt;p :style=&quot;styleObj&quot;&gt;放置对象：999&lt;/p&gt; &lt;!-- 第三种：数组语法 --&gt; &lt;p v-bind:style=&quot;[styleObj,&#123;border: &#x27;5px solid blue&#x27;&#125;]&quot;&gt;数组语法：666&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt;","tags":["Vue","Vue3"],"categories":["Language"]},{"title":"GitHubAction详解","path":"/posts/f6758ec2.html","content":"一. GitHubAction简介🧅什么是Github Action ? GitHubActions是一个持续集成和持续交付的平台，它可以帮助你通过自动化的构建（包括编译、发布、自动化测试）来验证你的代码，从而尽快地发现集成错误。github于2019年11月后对该功能全面开放，现在所有的github用户可以直接使用该功能。GitHub 提供 Linux、Windows 和 macOS 虚拟机来运行您的工作流程，或者您可以在自己的数据中心或云基础架构中托管自己的自托管运行器。在使用Github Action之前首先需要了解以下前置知识: 持续集成&#x2F;持续交付的概念。 Git相关知识。 Linux或Windows或macOS脚本相关知识。 Yaml基础语法。 🍤什么是Yaml ? 编写GithubAction的流程时，需要创建一个workflow工作流，workflow必须存储在你的项目库根路径下的.github&#x2F;workflows目录中，每一个 workflow对应一个具体的.yml 文件（或者 .yaml）。yml是YAML（YAML Ain’t Markup Language）语言的文件，以数据为中心，比properties、xml等更适合做配置文件，主要有以下几个特点: 大小写敏感。 使用缩进表示层级关系。 缩进只能使用空格，不能用 TAB 字符。 缩进的空格数量不重要，只要层级相同的元素左对齐即可。 ‘#’ 表示注释。 🍝Github Action基本概念 workflow: 一个 workflow 就是一个完整的工作流过程，每个workflow 包含一组 jobs任务。 job : jobs任务包含一个或多个job ，每个 job包含一系列的 steps 步骤。 step : 每个 step 步骤可以执行指令或者使用一个 action 动作。 action : 每个 action 动作就是一个通用的基本单元。 🍓Github Action 的使用限制在使用免费版本的Github Action是有如下限制的: 作业执行时间 - 工作流中的每个作业最多可以运行 6 小时的执行时间。如果作业达到此限制，该作业将终止且无法完成。 工作流运行时间 - 每个工作流运行限制为 35 天。如果工作流运行达到此限制，则工作流运行将被取消。此时间段包括执行持续时间以及等待和批准所花费的时间。 API 请求 - 您可以在一小时内跨存储库中的所有操作执行多达 1000 个 API 请求。如果超出此限制，其他 API 调用将失败，这可能会导致作业失败。 并发作业 - 可以在帐户中运行的并发作业数取决于 GitHub 计划，如下表所示。如果超出，则任何其他作业都将排队。 GitHub 计划 并发作业总数 最大并发 macOS 作业数 自由 20 5 专业版 40 5 团队 60 5 企业 180 50 作业矩阵 - 作业矩阵每次工作流运行最多可以生成 256 个作业。此限制适用于 GitHub 托管和自托管的运行程序。 工作流运行队列 - 每个存储库的排队时间间隔不超过 500 个工作流运行，间隔为 10 秒。如果工作流运行达到此限制，则工作流运行将终止且无法完成。 具体以最新版官方文档为主:usage-limits-billing-and-administration 二. GitHubAction的使用😀workflow 在项目库根路径下的.github&#x2F;workflows目录中创建一个.yml 文件（或者 .yaml）: 123456789101112131415161718192021222324252627282930313233343536373839404142name: hello-github-actions# 触发 workflow 的事件on: push: # 分支随意 branches: - master# 一个workflow由执行的一项或多项jobjobs: # 一个job任务，任务名为build build: #运行在最新版ubuntu系统中 runs-on: ubuntu-latest #步骤合集 steps: #新建一个名为checkout_actions的步骤 - name: checkout_actions #使用checkout@v2这个action获取源码 uses: actions/checkout@v2 #使用建一个名为setup-node的步骤 - name: setup-node #使用setup-node@v1这个action uses: actions/setup-node@v1 #指定某个action 可能需要输入的参数 with: node-version: &#x27;14&#x27; - name: npm install and build #执行执行某个shell命令或脚本 run: | npm install npm run build - name: commit push #执行执行某个shell命令或脚本 run: | git config --global user.email xxx@163.com git config --global user.name xxxx git add . git commit -m &quot;update&quot; -a git push # 环境变量 env: email: xxx@163.com 😂name Workflow的名字，随便可以设置，就是工作流的名字。如果省略该字段，默认为当前 workflow 的文件名。 1name: hello-github-actions 🤣on 触发的事件，可以是一个事件数组。 在代码仓库Push时触发: 12#push时触发on: push 可以用数组指定多个条件触发: 12#push和merge时触发on: [push, merge] 还可以对条件进行限制触发: 12345#当master分支push时触发，可以限定分支或标签。on: push: branches: - master 完整的事件列表，请查看官方文档。除了代码库事件，GitHub Actions 也支持外部事件触发，或者定时运行。 😉jobs1.job jobs表示要执行的一项或多项任务。jobs可以包含一个或多个job，一个job就是一个任务，这个任务可以包含多个步骤(steps): 12345jobs: job1: ... job2: ... ​ 需要注意的是每一个Job都是并发执行的并不是按照申明的先后顺序执行的， 如果多个job 之间存在依赖关系，那么你可能需要使用 needs : 12345678jobs: job1: job2: needs: job1 job3: needs: [job1, job2] 这里的needs声明了job2 必须等待 job1 成功完成，job3必须等待 job1 和 job2依次成功完成。因此，这个 workflow 的运行顺序依次为：job1、job2、job3。needs字段指定当前任务的依赖关系，即运行顺序。 2.job-&gt;runs-on runs-on字段指定运行所需要的虚拟机环境。它是必填字段，目前可用的虚拟机如下: ubuntu-latest，ubuntu-18.04或ubuntu-16.04。 windows-latest，windows-2019或windows-2016。 macOS-latest或macOS-10.14。 指定job的运行环境: 1234567jobs: job1: runs-on: ubuntu-18.04 job2: runs-on: macos-10.15 job3: runs-on: windows-2019 github 会提供一个配置很不错的服务器做为 runner，Windows 和 Linux 虚拟机的硬件规格： 2 核处理器。 7 GB 内存。 14 GB 固态硬盘空间。 macOS 虚拟机的硬件规格： 3 核处理器。 14 GB 内存。 14 GB 固态硬盘空间。 如果你有网络时延的需求，（比如推送及拉取镜像时产生的网络时延），你也可以自建runner 。 3.job-&gt;env 使用env可以给该任务或者是步骤配置环境变量: 1234env: name: &quot;zhangsan&quot;run: | echo $name 环境变量可以配置在以下地方: jobs-&gt;job-&gt;env jobs-&gt;job-&gt;steps.env 4.job-&gt;steps steps字段指定每个 Job 的运行步骤，每个job由多个step构成，它会从上至下依次执行。steps可以包含一个或多个步骤，每个 step 步骤可以有: name：步骤名称，步骤的名称。 env：该步骤所需的环境变量。 id : 每个步骤的唯一标识符 uses : 使用哪个action，这个表示使用别人预先设置好的Actions，比如因为我代码中要用到python，所以就用了actions&#x2F;setup-python@v1来设置python环境，不用我自己设置了。 with: 指定某个action 可能需要输入的参数。 run: 执行哪些指令，具体运行什么命令行代码。 continue-on-error : 设置为 true 允许此步骤失败job 仍然通过。 timeout-minutes : step 的超时时间。 例如: 12345678910111213141516171819202122232425...name: Sync To Giteeon: [ push ]jobs: sync: runs-on: ubuntu-latest steps: #创建一个打印环境变量的步骤 - name: PrintName env: name: &quot;zhangsan&quot; run: | echo $name #创建一个安装Python环境的步骤 - name: SetUpPython uses: actions/setup-python@v1 with: python-version: 3.7 #创建一个安装Python包的步骤 - name: Install dependencies run: | python -m pip install --upgrade pip pip install requests pip install bs4 pip install lxml 使用uses指的是这一步骤需要先调用哪个 Action。 Action 是组成工作流最核心最基础的元素。 每个 Action 可以看作封装的独立脚本，有自己的操作逻辑，我们只需要 uses 并通过 with 传入参数即可。 比如 actions&#x2F;checkout@v2 就是官方社区贡献的用来拉取仓库分支的 Action， 你不需要考虑安装 git 命令工具，只需要把分支参数传入即可。 5.Action Github Actions 是GitHub的持续集成服务。持续集成由很多操作组成，比如登录远程服务器，发布内容到第三方服务等等，这些相同的操作完全可以提取出来制作成脚本供所有人使用。GitHub允许开发者把每个操作写成独立的脚本文件，存放到代码仓库，使得其他开发者可以引用该脚本，这个脚本就是一个Action。如果你需要某种功能的Action可以从GitHub社区共享的action官方市场查找，也可以自己编程Action开源出来供大家使用。既然 actions 是代码仓库，当然就有版本的概念，用户可以引用某个具体版本的 action。 下面都是合法的 action 引用: 123actions/setup-node@74bc508 # 指向一个 commitactions/setup-node@v1.0 # 指向一个标签actions/setup-node@master # 指向一个分支 😊GitHub Actions 中使用密文 在持续集成的过程中，我们可能会使用到自己的敏感数据，这些数据不应该被开源并泄露。那么如何才能安全的使用这些敏感数据呢?GithubActions提供了Secrets变量来实现这一效果。我们可以在 github repo 上依次点击 Settings -&gt; Secrets-&gt; Actions-&gt;New repository secret创建一个敏感数据例如:OSS_KEY_ID，OSS_KEY_SECRET， 然后我们就可以在GithubAction脚本中使用这一变量了: 123456- name: setup aliyun oss uses: manyuanrong/setup-ossutil@master with: endpoint: oss-cn-beijing.aliyuncs.com access-key-id: $&#123;&#123; secrets.OSS_KEY_ID &#125;&#125; access-key-secret: $&#123;&#123; secrets.OSS_KEY_SECRET &#125;&#125; 这里的secret就是一种context，描述 CI&#x2F;CD 一个workflow 中的上下文信息，使用$语法表示。更多context信息可以参考官方文档 😎GitHubAction执行结果对于GitHubAction的执行流程我们可以通过repo 上依次点击Actions就可以看到Action的状态和执行结果等信息: img 三. 示例 使用GitHubAction实现Push代码发送邮件通知功能。 主要通过 GitHub Action 监听代码 push 事件，并发送邮件（前提是邮箱需要开通 SMTP 服务）。在项目中 .&#x2F;github&#x2F;workflows&#x2F; 路径下添加 .yml 或者 .yaml文件，名字可以随便取。在这里我取名为 github-action-email.yml: 123456789101112131415161718192021222324252627name: github-action-emailon: [push]jobs: build: runs-on: ubuntu-latest steps: # 检出代码 - name: CheckoutRepo uses: actions/checkout@v2 # 获取master分支上最新一条提交的git log - name: GetLastLog id: git_log uses: Edisonboy/latest-git-log-action@main with: tag: origin/master # 发送邮件 - name: Send email uses: dawidd6/action-send-mail@v3 with: server_address: smtp.qq.com server_port: 465 username: $&#123;&#123;secrets.MAIL_USERNAME&#125;&#125; password: $&#123;&#123;secrets.MAIL_PASSWORD&#125;&#125; subject: Github Actions job result to: $&#123;&#123;secrets.MAIL_TOUSERNAME&#125;&#125; from: $&#123;&#123;secrets.MAIL_USERNAME&#125;&#125; body: $&#123;&#123;github.repository&#125;&#125; push log : $&#123;&#123;steps.git_log.outputs.log&#125;&#125; secrets.XXX ： GitHub 允许仓库所有者创建和管理需要保密性的参数。例如邮件的账号和密码都是属于敏感参数。 可以通过项目Settings -&gt; Secrets -&gt; Actions配置密码，在这里我们添加 MAIL_USERNAME、MAIL_PASSWORD、MAIL_TOUSERNAME 三个配置参数（注意：这里的密码是指 SMTP 服务的授权密码）。 上下文：可以访问工作流程运行、运行器环境、作业及步骤相关信息的方式$：当前仓库的的所有者和仓库名称。$ ：获取step id 为 git_log 的输出集。 因为我们定义 push 为触发条件，所以当我们只有push 代码后，我们定义的 GitHub Action 才会被执行。然后在 GitHub 上的 Action 能够实时看到当前的执行状态。","tags":["GitHubAction"],"categories":["GitHub"]},{"title":"Windows批处理(cmdbat)常用命令教程","path":"/posts/4761816f.html","content":"常见问题： 1.如果你自己编写的.bat文件，双击打开，出现闪退 2.批处理.bat 文件中输出中文乱码 解决方法在文章末尾！ 前言 批处理文件（batch file）包含一系列 DOS命令，通常用于自动执行重复性任务。用户只需双击批处理文件便可执行任务，而无需重复输入相同指令。编写批处理文件非常简单，但难点在于确保一切按顺序执行。编写严谨的批处理文件可以极大程度地节省时间，在应对重复性工作时尤其有效 在Windows中善用批处理可以简化很多重复工作 什么是批处理？ 批处理(Batch)，也称为批处理脚本。顾名思义，批处理就是对某对象进行批量的处理。批处理文件的扩展名为bat 目前比较常见 的批处理包含两类： DOS批处理和PS批处理。 PS批处理是基于强大的图片编辑软件 Photoshop的，用来批量处理图片的脚本； 而DOS批处理则是基于DOS命令的，用来自动地批量地执行 DOS命令以实现特定操作的脚本。这里要讲的就是DOS批处理 批处理是一种简化的脚本语言，它应用于DOS和Windows系统中，它是由DOS或者Windows系统内嵌的命令解释器（通常是COMMAND.COM或者CMD.EXE）解释运行 批处理类似于Unix中的Shell脚本。批处理文件具有.bat或者.cmd的扩展名，其最简单的例子，是逐行书写在命令行中会用到的各种命令。更复杂的情况，需要使用if，for，goto等命令控制程序的运行过程，如同C，Basic等中高级语言一样。如果需要实现更复杂的应用，利用外部程序是必要的，这包括系统本身提供的外部命令和第三方提供的工具或者软件 怎么创建批处理文件？ 批处理文件，或称为批处理程序，是由一条条的DOS命令组成的普通文本文件，可以用记事本直接编辑或用DOS命令创建，也可以用DOS下的文本编辑器Edit.exe来编辑。在“命令提示”下键入批处理文件的名称，或者双击该批处理文件，系统就会调用Cmd.exe运行该批处理程序 一般情况下，每条命令占据一行 当然也可以将多条命令用特定符号（如：&amp;、&amp;&amp;、|、||等）分隔后写入同一行中 还有的情况就是像if、for等较高级的命令则要占据几行甚至几十几百行的空间。系统在解释运行批处理程序时，首先扫描整个批处理程序，然后从第一行代码开始向下逐句执行所有的命令，直至程序结尾或遇见exit命令或出错意外退出 批处理命令简介 echo rem pause call start goto set 批处理常用命令总结批处理符号简介 回显屏蔽 @ 重定向1 &gt;与&gt;&gt; 重定向2 &lt; 管道符号 | 转义符 ^ 逻辑命令符包括：&amp;、&amp;&amp;、|| 常用DOS命令 文件夹管理： cd 显示当前目录名或改变当前目录。 md 创建目录。 rd 删除一个目录。 dir 显示目录中的文件和子目录列表。 tree 以图形显示驱动器或路径的文件夹结构。 path 为可执行文件显示或设置一个搜索路径。 xcopy 复制文件和目录树。 文件管理： type 显示文本文件的内容。 copy 将一份或多份文件复制到另一个位置。 del 删除一个或数个文件。 move 移动文件并重命名文件和目录。(Windows XP Home Edition中没有) ren 重命名文件。 replace 替换文件。 attrib 显示或更改文件属性。 find 搜索字符串。 fc 比较两个文件或两个文件集并显示它们之间的不同 网络命令： ping 进行网络连接测试、名称解析 ftp 文件传输 net 网络命令集及用户管理 telnet 远程登陆 ipconfig显示、修改TCP&#x2F;IP设置 msg 给用户发送消息 arp 显示、修改局域网的IP地址-物理地址映射列表 系统管理： at 安排在特定日期和时间运行命令和程序 shutdown立即或定时关机或重启 tskill 结束进程 taskkill结束进程(比tskill高级，但WinXPHome版中无该命令) tasklist显示进程列表(Windows XP Home Edition中没有) sc 系统服务设置与控制 reg 注册表控制台工具 powercfg控制系统上的电源设置 对于以上列出的所有命令，在cmd中输入命令+&#x2F;?即可查看该命令的帮助信息。如find &#x2F;? Windows Batch 常用命令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913921 echo 和 @回显命令@ #关闭单行回显echo off #从下一行开始关闭回显@echo off #从本行开始关闭回显。一般批处理第一行都是这个echo on #从下一行开始打开回显echo #显示当前是 echo off 状态还是 echo on 状态echo. #输出一个”回车换行”，空白行#(同echo, echo; echo+ echo[ echo] echo/ echo)2 errorlevelecho %errorlevel%每个命令运行结束，可以用这个命令行格式查看返回码默认值为0，一般命令执行出错会设 errorlevel 为13 dir显示文件夹内容dir #显示当前目录中的文件和子目录dir /a #显示当前目录中的文件和子目录，包括隐藏文件和系统文件dir c: /a:d #显示 C 盘当前目录中的目录dir c: /a:-d #显示 C 盘根目录中的文件dir c: /b/p #/b只显示文件名，/p分页显示dir *.exe /s #显示当前目录和子目录里所有的.exe文件4 cd切换目录cd #进入根目录cd #显示当前目录cd /d d:sdk #可以同时更改盘符和目录5 md创建目录md d:abc #如果 d:a 不存在，将会自动创建中级目录#如果命令扩展名被停用，则需要键入 mkdir abc6 rd删除目录rd abc #删除当前目录里的 abc 子目录，要求为空目录rd /s/q d:temp #删除 d:temp 文件夹及其子文件夹和文件，/q安静模式7 del删除文件del d:test.txt #删除指定文件，不能是隐藏、系统、只读文件del /q/a/f d:temp*.*删除 d:temp 文件夹里面的所有文件，包括隐藏、只读、系统文件，不包括子目录del /q/a/f/s d:temp*.*删除 d:temp 及子文件夹里面的所有文件，包括隐藏、只读、系统文件，不包括子目录8 ren重命名命令ren d:temp tmp #支持对文件夹的重命名9 cls清屏10 type显示文件内容type c:boot.ini #显示指定文件的内容，程序文件一般会显示乱码type *.txt #显示当前目录里所有.txt文件的内容11 copy拷贝文件copy c:test.txt d:test.bak复制 c:test.txt 文件到 d: ，并重命名为 test.bakcopy con test.txt从屏幕上等待输入，按 Ctrl+Z 结束输入，输入内容存为test.txt文件con代表屏幕，prn代表打印机，nul代表空设备copy 1.txt + 2.txt 3.txt合并 1.txt 和 2.txt 的内容，保存为 3.txt 文件如果不指定 3.txt ，则保存到 1.txtcopy test.txt +复制文件到自己，实际上是修改了文件日期12 title设置cmd窗口的标题title 新标题 #可以看到cmd窗口的标题栏变了13 ver显示系统版本14 label 和 vol设置卷标vol #显示卷标label #显示卷标，同时提示输入新卷标label c:system #设置C盘的卷标为 system15 pause暂停命令16 rem 和 ::注释命令注释行不执行操作17 date 和 time日期和时间date #显示当前日期，并提示输入新日期，按&quot;回车&quot;略过输入date/t #只显示当前日期，不提示输入新日期time #显示当前时间，并提示输入新时间，按&quot;回车&quot;略过输入time/t #只显示当前时间，不提示输入新时间18 goto 和 :跳转命令:label #行首为:表示该行是标签行，标签行不执行操作goto label #跳转到指定的标签那一行19 find (外部命令)查找命令find &quot;abc&quot; c:test.txt在 c:test.txt 文件里查找含 abc 字符串的行如果找不到，将设 errorlevel 返回码为1find /i “abc” c:test.txt查找含 abc 的行，忽略大小写find /c &quot;abc&quot; c:test.txt显示含 abc 的行的行数20 more (外部命令)逐屏显示more c:test.txt #逐屏显示 c:test.txt 的文件内容21 tree显示目录结构tree d: #显示D盘的文件目录结构22 &amp;顺序执行多条命令，而不管命令是否执行成功23 &amp;&amp;顺序执行多条命令，当碰到执行出错的命令后将不执行后面的命令find &quot;ok&quot; c:test.txt &amp;&amp; echo 成功如果找到了&quot;ok&quot;字样，就显示&quot;成功&quot;，找不到就不显示24 ||顺序执行多条命令，当碰到执行正确的命令后将不执行后面的命令find &quot;ok&quot; c:test.txt || echo 不成功如果找不到&quot;ok&quot;字样，就显示&quot;不成功&quot;，找到了就不显示25 |管道命令dir *.* /s/a | find /c &quot;.exe&quot;管道命令表示先执行 dir 命令，对其输出的结果执行后面的 find 命令该命令行结果：输出当前文件夹及所有子文件夹里的.exe文件的个数type c:test.txt|more这个和 more c:test.txt 的效果是一样的26 &gt; 和 &gt;&gt;输出重定向命令&gt; 清除文件中原有的内容后再写入&gt;&gt; 追加内容到文件末尾，而不会清除原有的内容主要将本来显示在屏幕上的内容输出到指定文件中指定文件如果不存在，则自动生成该文件type c:test.txt &gt;prn屏幕上不显示文件内容，转向输出到打印机echo hello world&gt;con在屏幕上显示hello world，实际上所有输出都是默认 &gt;con 的copy c:test.txt f: &gt;nul拷贝文件，并且不显示&quot;文件复制成功&quot;的提示信息，但如果f盘不存在，还是会显示出错信息copy c:test.txt f: &gt;nul 2&gt;nul不显示”文件复制成功”的提示信息，并且f盘不存在的话，也不显示错误提示信息echo ^^W ^&gt; ^W&gt;c:test.txt生成的文件内容为 ^W &gt; W^ 和 &gt; 是控制命令，要把它们输出到文件，必须在前面加个 ^ 符号27 &lt;从文件中获得输入信息，而不是从屏幕上一般用于 date time label 等需要等待输入的命令@echo offecho 2005-05-01&gt;temp.txtdate &lt;temp.txtdel temp.txt这样就可以不等待输入直接修改当前日期28 %0 %1 %2 %3 %4 %5 %6 %7 %8 %9 %*命令行传递给批处理的参数%0 批处理文件本身%1 第一个参数%9 第九个参数%* 从第一个参数开始的所有参数批参数(%n)的替代已被增强。您可以使用以下语法:%~1 - 删除引号(&quot; )， 扩充 %1%~f1 - 将 %1 扩充到一个完全合格的路径名%~d1 - 仅将 %1 扩充到一个驱动器号%~p1 - 仅将 %1 扩充到一个路径%~n1 - 仅将 %1 扩充到一个文件名%~x1 - 仅将 %1 扩充到一个文件扩展名%~s1 - 扩充的路径指含有短名%~a1 - 将 %1 扩充到文件属性%~t1 - 将 %1 扩充到文件的日期/时间%~z1 - 将 %1 扩充到文件的大小%~$PATH : 1 - 查找列在 PATH 环境变量的目录，并将 %1扩充到找到的第一个完全合格的名称。如果环境变量名未被定义，或者没有找到文件，此组合键会扩充到空字符串可以组合修定符来取得多重结果:%~dp1 - 只将 %1 扩展到驱动器号和路径%~nx1 - 只将 %1 扩展到文件名和扩展名%~dp$PATH:1 - 在列在 PATH 环境变量中的目录里查找 %1，并扩展到找到的第一个文件的驱动器号和路径。%~ftza1 - 将 %1 扩展到类似 DIR 的输出行。可以参照 call/? 或 for/? 看出每个参数的含意echo load &quot;%%1&quot; &quot;%%2&quot;&gt;c:test.txt生成的文件内容为 load &quot;%1&quot; &quot;%2&quot;批处理文件里，用这个格式把命令行参数输出到文件29 if判断命令if &quot;%1&quot;==&quot;/a&quot; echo 第一个参数是/aif /i &quot;%1&quot; equ &quot;/a&quot; echo 第一个参数是/a/i 表示不区分大小写，equ 和 == 是一样的，其它运算符参见 if/?if exist c:test.bat echo 存在c:test.bat文件if not exist c:windows (echo 不存在c:windows文件夹)if exist c:test.bat (echo 存在c:test.bat) else (echo 不存在c:test.bat)30 setlocal 和 endlocal设置”命令扩展名”和”延缓环境变量扩充”SETLOCAL ENABLEEXTENSIONS #启用&quot;命令扩展名&quot;SETLOCAL DISABLEEXTENSIONS #停用&quot;命令扩展名&quot;SETLOCAL ENABLEDELAYEDEXPANSION #启用&quot;延缓环境变量扩充&quot;SETLOCAL DISABLEDELAYEDEXPANSION #停用&quot;延缓环境变量扩充&quot;ENDLOCAL #恢复到使用SETLOCAL语句以前的状态“命令扩展名”默认为启用“延缓环境变量扩充”默认为停用批处理结束系统会自动恢复默认值可以修改注册表以禁用&quot;命令扩展名&quot;，详见 cmd /? 。所以用到&quot;命令扩展名&quot;的程序，建议在开头和结尾加上 SETLOCAL ENABLEEXTENSIONS 和 ENDLOCAL 语句，以确保程序能在其它系统上正确运行&quot;延缓环境变量扩充&quot;主要用于 if 和 for 的符合语句，在 set 的说明里有其实用例程31 set设置变量引用变量可在变量名前后加 % ，即 %变量名%set #显示目前所有可用的变量，包括系统变量和自定义的变量echo %SystemDrive% #显示系统盘盘符。系统变量可以直接引用set p #显示所有以p开头的变量，要是一个也没有就设errorlevel=1set p=aa1bb1aa2bb2 #设置变量p，并赋值为 = 后面的字符串，即aa1bb1aa2bb2echo %p% #显示变量p代表的字符串，即aa1bb1aa2bb2echo %p:~6% #显示变量p中第6个字符以后的所有字符，即aa2bb2echo %p:~6,3% #显示第6个字符以后的3个字符，即aa2echo %p:~0,3% #显示前3个字符，即aa1echo %p:~-2% #显示最后面的2个字符，即b2echo %p:~0,-2% #显示除了最后2个字符以外的其它字符，即aa1bb1aa2becho %p:aa=c% #用c替换变量p中所有的aa，即显示c1bb1c2bb2echo %p:aa=% #将变量p中的所有aa字符串置换为空，即显示1bb12bb2echo %p:*bb=c% #第一个bb及其之前的所有字符被替换为c，即显示c1aa2bb2set p=%p:*bb=c% #设置变量p，赋值为 %p:*bb=c% ，即c1aa2bb2set /a p=39 #设置p为数值型变量，值为39set /a p=39/10 #支持运算符，有小数时用去尾法，39/10=3.9，去尾得3，p=3set /a p=p/10 #用 /a 参数时，在 = 后面的变量可以不加%直接引用set /a p=”1&amp;0″ #”与”运算，要加引号。其它支持的运算符参见set/?set p= #取消p变量set /p p=请输入屏幕上显示”请输入”，并会将输入的字符串赋值给变量p注意这条可以用来取代 choice 命令注意变量在 if 和 for 的复合语句里是一次性全部替换的，如@echo offset p=aaaif %p%==aaa (echo %p%set p=bbbecho %p%)结果将显示aaaaaa因为在读取 if 语句时已经将所有 %p% 替换为aaa这里的&quot;替换&quot;，在 /? 帮助里就是指&quot;扩充&quot;、&quot;环境变量扩充&quot;可以启用”延缓环境变量扩充”，用 ! 来引用变量，即 !变量名!@echo offSETLOCAL ENABLEDELAYEDEXPANSIONset p=aaaif %p%==aaa (echo %p%set p=bbbecho !p!)ENDLOCAL结果将显示aaabbb还有几个动态变量，运行 set 看不到%CD% #代表当前目录的字符串%DATE% #当前日期%TIME% #当前时间%RANDOM% #随机整数，介于0~32767%ERRORLEVEL% #当前 ERRORLEVEL 值%CMDEXTVERSION% #当前命令处理器扩展名版本号%CMDCMDLINE% #调用命令处理器的原始命令行可以用echo命令查看每个变量值，如 echo %time%注意 %time% 精确到毫秒，在批处理需要延时处理时可以用到32 start批处理中调用外部程序的命令，否则等外部程序完成后才继续执行剩下的指令33 call批处理中调用另外一个批处理的命令，否则剩下的批处理指令将不会被执行有时有的应用程序用start调用出错的，也可以call调用34 choice (外部命令)选择命令让用户输入一个字符，从而选择运行不同的命令，返回码errorlevel为1234……win98里是choice.comwin2000pro里没有，可以从win98里拷过来win2003里是choice.exechoice /N /C y /T 5 /D y&gt;nul延时5秒35 assoc 和 ftype文件关联assoc 设置&#x27;文件扩展名&#x27;关联，关联到&#x27;文件类型&#x27;ftype 设置&#x27;文件类型&#x27;关联，关联到&#x27;执行程序和参数&#x27;当你双击一个.txt文件时，windows并不是根据.txt直接判断用 notepad.exe 打开而是先判断.txt属于 txtfile &#x27;文件类型&#x27;再调用 txtfile 关联的命令行 txtfile=%SystemRoot%system32NOTEPAD.EXE %1可以在&quot;文件夹选项&quot;→&quot;文件类型&quot;里修改这2种关联assoc #显示所有&#x27;文件扩展名&#x27;关联assoc .txt #显示.txt代表的&#x27;文件类型&#x27;，结果显示 .txt=txtfileassoc .doc #显示.doc代表的&#x27;文件类型&#x27;，结果显示 .doc=Word.Document.8assoc .exe #显示.exe代表的&#x27;文件类型&#x27;，结果显示 .exe=exefileftype #显示所有&#x27;文件类型&#x27;关联ftype exefile #显示exefile类型关联的命令行，结果显示 exefile=&quot;%1&quot; %*assoc .txt=Word.Document.8设置.txt为word类型的文档，可以看到.txt文件的图标都变了assoc .txt=txtfile恢复.txt的正确关联ftype exefile=&quot;%1&quot; %*恢复 exefile 的正确关联如果该关联已经被破坏，可以运行 command.com ，再输入这条命令36 pushd 和 popd切换当前目录@echo offc: &amp; cd &amp; md mp3 #在 C: 建立 mp3 文件夹md d:mp4 #在 D: 建立 mp4 文件夹cd /d d:mp4 #更改当前目录为 d:mp4pushd c:mp3 #保存当前目录，并切换当前目录为 c:mp3popd #恢复当前目录为刚才保存的 d:mp437 for循环命令这个比较复杂，请对照 for/? 来看for %%i in (c: d: e: f:) do echo %%i依次调用小括号里的每个字符串，执行 do 后面的命令注意%%i，在批处理中 for 语句调用参数用2个%默认的字符串分隔符是&quot;空格键&quot;，&quot;Tab键&quot;，&quot;回车键&quot;for %%i in (*.txt) do find &quot;abc&quot; %%i对当前目录里所有的txt文件执行 find 命令for /r . %%i in (*.txt) do find &quot;abc&quot; %%i在当前目录和子目录里所有的.txt文件中搜索包含 abc 字符串的行for /r . %%i in (.) do echo %%~pni显示当前目录名和所有子目录名，包括路径，不包括盘符for /r d:mp3 %%i in (*.mp3) do echo %%i&gt;&gt;d:mp3.txt把 d:mp3 及其子目录里的mp3文件的文件名都存到 d:mp3.txt 里去for /l %%i in (2,1,8) do echo %%i生成2345678的一串数字，2是数字序列的开头，8是结尾，1表示每次加1for /f %%i in (&#x27;set&#x27;) do echo %%i对 set 命令的输出结果循环调用，每行一个for /f &quot;eol=P&quot; %%i in (&#x27;set&#x27;) do echo %%i取 set 命令的输出结果，忽略以 P 开头的那几行for /f %%i in (d:mp3.txt) do echo %%i显示 d:mp3.txt 里的每个文件名，每行一个，不支持带空格的名称for /f &quot;delims=&quot; %%i in (d:mp3.txt) do echo %%i显示 d:mp3.txt 里的每个文件名，每行一个，支持带空格的名称for /f &quot;skip=5 tokens=4&quot; %%a in (&#x27;dir&#x27;) do echo %%a对 dir 命令的结果，跳过前面5行，余下的每行取第4列每列之间的分隔符为默认的&quot;空格&quot;可以注意到 dir 命令输出的前5行是没有文件名的for /f &quot;tokens=1,2,3 delims=- &quot; %%a in (&#x27;date /t&#x27;) do (echo %%aecho %%becho %%c)对 date /t 的输出结果，每行取1、2、3列第一列对应指定的 %%a ，后面的 %%b 和 %%c 是派生出来的，对应其它列分隔符指定为 - 和&quot;空格&quot;，注意 delims=- 后面有个&quot;空格&quot;其中 tokens=1,2,3 若用 tokens=1-3 替换，效果是一样的for /f &quot;tokens=2* delims=- &quot; %%a in (&#x27;date /t&#x27;) do echo %%b取第2列给 %%a ，其后的列都给 %%b38 subst (外部命令)映射磁盘。subst z: serverd #这样输入z:就可以访问serverd了subst z: /d #取消该映射subst #显示目前所有的映时39 xcopy (外部命令)文件拷贝xcopy d:mp3 e:mp3 /s/e/i/y复制 d:mp3 文件夹、所有子文件夹和文件到 e: ，覆盖已有文件加 /i 表示如果 e: 没有 mp3 文件夹就自动新建一个，否则会有询问 常见问题： 1.如果你自己编写的.bat文件，双击打开，出现闪退 原因：执行速度很快，执行完之后，自行关闭 解决办法：在最后面一行加上 pause 例如： @echo offset p&#x3D;aaaif %p%&#x3D;&#x3D;aaa (echo %p%set p&#x3D;bbbecho %p%)pause 截图： 2.批处理.bat 文件中输出中文乱码 原因：记事本新建的文件，编码不是 utf-8 解决方法：用【记事本】打开&gt;【另存为】&gt;【修改编码为：utf-8】 操作截图： 效果截图：","tags":["Dos","Bat","cmd"],"categories":["Language"]},{"title":"Vue3-04_class类名的多种使用方式","path":"/posts/4294f534.html","content":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;script&gt;// --------------- class类名的多种使用方式 ---------------export default &#123; data() &#123; return &#123; msg: &quot;Hello World&quot;, // hello5的class对象 clsObj: &#123; hl5: true, hello5: false, &#125;, hl7Msg: &quot;hello7-报错会变红&quot;, // isTru是否为真 err报错信息 isTru: true, err: null, hl8: &quot;hl7&quot; &#125;; &#125;, computed: &#123; cls7Obj:function()&#123; return &#123; // isTru为真 err取反为真才为真 hl7: this.isTru &amp;&amp; !this.err, // err为为真(有错) 则为真 hello7: this.err &#125; &#125; &#125;,&#125;;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;!-- 第一种：放置字符串 --&gt; &lt;p class=&quot;hl1&quot;&gt;hello1&lt;/p&gt; &lt;!-- 第二种：放置对象(常用) --&gt; &lt;!-- 用法 &lt;p :class=&quot;&#123;类名：boolean&#125;&quot;&gt;&lt;/p&gt; --&gt; &lt;p v-bind:class=&quot;&#123; hl2: true &#125;&quot;&gt;hello2&lt;/p&gt; &lt;p :class=&quot;&#123; hl3: true, hello3: true &#125;&quot;&gt;hello3&lt;/p&gt; &lt;!-- 可与普通class同时存在 不会冲突 --&gt; &lt;p :class=&quot;&#123; hl4: true &#125;&quot; class=&quot;hello4&quot;&gt;hello4&lt;/p&gt; &lt;!-- 变量方式控制 --&gt; &lt;p :class=&quot;clsObj&quot;&gt;hello5&lt;/p&gt; &lt;p v-bind:class=&quot;&#123; hl6: isTru &#125;&quot;&gt;hello6&lt;/p&gt; &lt;button v-on:click=&quot;isTru = !isTru&quot;&gt;改变hello6的对象布尔值&lt;/button&gt; &lt;!-- 第三种：使用computed计算属性 --&gt; &lt;p v-bind:class=&quot;cls7Obj&quot;&gt;computed：&#123;&#123;hl7Msg&#125;&#125;&lt;/p&gt; &lt;button @click=&quot;err=&#x27;出错了哦&#x27;&quot;&gt;让hello7报错&lt;/button&gt; &lt;!-- 第四种：数组语法(不常用) --&gt; &lt;p v-bind:class=&quot;[hl8]&quot;&gt;数组语法：hello8&lt;/p&gt; &lt;!-- 第五种：数字+对象 --&gt; &lt;p v-bind:class=[hl8,&#123;hello3:true&#125;]&gt;hello9&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;.hl1 &#123; color: rgb(255, 0, 0);&#125;.hl2 &#123; color: blue;&#125;.hl3 &#123; color: green;&#125;.hello3 &#123; background: rgba(88, 44, 130, 0.512);&#125;.hl4 &#123; color: rgb(226, 142, 63);&#125;.hello4 &#123; background: pink;&#125;.hl5 &#123; color: rgb(246, 72, 171);&#125;.hello5 &#123; background: rgb(79, 225, 176);&#125;.hl6 &#123; color: pink;&#125;.hl7&#123; color: rgb(0, 255, 81);&#125;.hello7&#123; color: red;&#125;&lt;/style&gt;","tags":["Vue","Vue3"],"categories":["Language"]},{"title":"使用Gulp压缩博客静态资源","path":"/posts/7f089827.html","content":"写在最前gulp能够帮助用户自动压缩静态资源，配合各类下属插件，能够压缩包括css、js、html乃至各类格式的图片文件。（图片文件的压缩往往只能节省几十KB，效果远远不如imagine、tinypng等压缩方式，所以此处不再写使用gulp压缩图片的内容）。 配置教程安装Gulp插件在博客根目录[Blogroot]打开终端，输入： 12npm install --global gulp-cli #全局安装gulp指令集npm install gulp --save #安装gulp插件 安装下属插件安装各个下属插件以实现对各类静态资源的压缩 压缩HTML： 123npm install gulp-htmlclean --save-devnpm install gulp-html-minifier-terser --save-dev# 用gulp-html-minifier-terser可以压缩HTML中的ES6语法 压缩CSS： 1npm install gulp-clean-css --save-dev 压缩JS Butterfly主题文档提供了两种压缩JS的插件方案。两者的差别在于terser是ES6+的JavaScript解析器，而gulp-babel是一个JavaScript转换编译器，可以把ES6转换成ES5，两种方案都有效。但使用上各有利弊。考虑到目前的浏览器市场占有率，更加建议各位使用terser来压缩js。 方案一：为了适配绝大多数浏览器（IE：就是老子），可以将ES6语法降为ES5语法。则使用gulp-babel，这一方案在压缩部分使用了ES6的js以后，由于强制降级导致变量生命周期的变动，会引发一系列迷之bug，需要手动再去添加屏蔽项以选择不压缩对应的js。 12npm install gulp-uglify --save-devnpm install gulp-babel @babel/core @babel/preset-env --save-dev 方案二（更加推荐）：gulp-terser只会直接压缩js代码，所以不存在因为语法变动导致的错误 。事实上，当我们使用jsdelivr的CDN服务时，只需要在css或者js的后缀前添加.min,例如example.js-&gt;example.min.js,JsDelivr就会自动使用terser帮我们压缩好代码。 1npm install gulp-terser --save-dev 压缩字体包 字体文件作为最让人又爱又恨的静态资源，为了保证站点文字匹配，全字库字体包往往超过15MB，这对博客的加载速度造成了巨大压力。fontmin可以遍历博客内用到的字符，并将字体包内这些字符的字体样式提取出来输出为新的字体包。 font-min仅支持压缩ttf格式的字体包 1npm install gulp-fontmin --save-dev 创建gulpfile.js文件为Gulp创建gulpfile.js任务脚本。在博客根目录[Blogroot]下新建gulpfile.js,打开[Blogroot]\\gulpfile.js,输入以下内容： 方案一 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//用到的各个插件var gulp = require(&#x27;gulp&#x27;);var cleanCSS = require(&#x27;gulp-clean-css&#x27;);var htmlmin = require(&#x27;gulp-html-minifier-terser&#x27;);var htmlclean = require(&#x27;gulp-htmlclean&#x27;);var fontmin = require(&#x27;gulp-fontmin&#x27;);var uglify = require(&#x27;gulp-uglify&#x27;)var babel = require(&#x27;gulp-babel&#x27;)//压缩jsgulp.task(&#x27;compress&#x27;, async() =&gt;&#123; gulp.src([&#x27;./public/**/*.js&#x27;, &#x27;!./public/**/*.min.js&#x27;]) .pipe(babel(&#123; presets: [&#x27;@babel/preset-env&#x27;] &#125;)) .pipe(uglify().on(&#x27;error&#x27;, function (e) &#123; console.log(e) &#125;)) .pipe(gulp.dest(&#x27;./public&#x27;))&#125;);//压缩cssgulp.task(&#x27;minify-css&#x27;, () =&gt; &#123; return gulp.src([&#x27;./public/**/*.css&#x27;]) .pipe(cleanCSS(&#123; compatibility: &#x27;ie11&#x27; &#125;)) .pipe(gulp.dest(&#x27;./public&#x27;));&#125;);//压缩htmlgulp.task(&#x27;minify-html&#x27;, () =&gt; &#123; return gulp.src(&#x27;./public/**/*.html&#x27;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, //清除html注释 collapseWhitespace: true, //压缩html collapseBooleanAttributes: true, //省略布尔属性的值，例如：&lt;input checked=&quot;true&quot;/&gt; ==&gt; &lt;input /&gt; removeEmptyAttributes: true, //删除所有空格作属性值，例如：&lt;input id=&quot;&quot; /&gt; ==&gt; &lt;input /&gt; removeScriptTypeAttributes: true, //删除&lt;script&gt;的type=&quot;text/javascript&quot; removeStyleLinkTypeAttributes: true, //删除&lt;style&gt;和&lt;link&gt;的 type=&quot;text/css&quot; minifyJS: true, //压缩页面 JS minifyCSS: true, //压缩页面 CSS minifyURLs: true //压缩页面URL &#125;)) .pipe(gulp.dest(&#x27;./public&#x27;))&#125;);//压缩字体function minifyFont(text, cb) &#123; gulp .src(&#x27;./public/fonts/*.ttf&#x27;) //原字体所在目录 .pipe(fontmin(&#123; text: text &#125;)) .pipe(gulp.dest(&#x27;./public/fontsdest/&#x27;)) //压缩后的输出目录 .on(&#x27;end&#x27;, cb);&#125;gulp.task(&#x27;mini-font&#x27;, (cb) =&gt; &#123; var buffers = []; gulp .src([&#x27;./public/**/*.html&#x27;]) //HTML文件所在目录请根据自身情况修改 .on(&#x27;data&#x27;, function(file) &#123; buffers.push(file.contents); &#125;) .on(&#x27;end&#x27;, function() &#123; var text = Buffer.concat(buffers).toString(&#x27;utf-8&#x27;); minifyFont(text, cb); &#125;);&#125;);// 运行gulp命令时依次执行以下任务gulp.task(&#x27;default&#x27;, gulp.parallel( &#x27;compress&#x27;, &#x27;minify-css&#x27;, &#x27;minify-html&#x27;,&#x27;mini-font&#x27;)) 方案二 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//用到的各个插件var gulp = require(&#x27;gulp&#x27;);var cleanCSS = require(&#x27;gulp-clean-css&#x27;);var htmlmin = require(&#x27;gulp-html-minifier-terser&#x27;);var htmlclean = require(&#x27;gulp-htmlclean&#x27;);var fontmin = require(&#x27;gulp-fontmin&#x27;);// gulp-testervar terser = require(&#x27;gulp-terser&#x27;);// 压缩jsgulp.task(&#x27;compress&#x27;, async() =&gt;&#123; gulp.src([&#x27;./public/**/*.js&#x27;, &#x27;!./public/**/*.min.js&#x27;]) .pipe(terser()) .pipe(gulp.dest(&#x27;./public&#x27;))&#125;);//压缩cssgulp.task(&#x27;minify-css&#x27;, () =&gt; &#123; return gulp.src([&#x27;./public/**/*.css&#x27;]) .pipe(cleanCSS(&#123; compatibility: &#x27;ie11&#x27; &#125;)) .pipe(gulp.dest(&#x27;./public&#x27;));&#125;);//压缩htmlgulp.task(&#x27;minify-html&#x27;, () =&gt; &#123; return gulp.src(&#x27;./public/**/*.html&#x27;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, //清除html注释 collapseWhitespace: true, //压缩html collapseBooleanAttributes: true, //省略布尔属性的值，例如：&lt;input checked=&quot;true&quot;/&gt; ==&gt; &lt;input /&gt; removeEmptyAttributes: true, //删除所有空格作属性值，例如：&lt;input id=&quot;&quot; /&gt; ==&gt; &lt;input /&gt; removeScriptTypeAttributes: true, //删除&lt;script&gt;的type=&quot;text/javascript&quot; removeStyleLinkTypeAttributes: true, //删除&lt;style&gt;和&lt;link&gt;的 type=&quot;text/css&quot; minifyJS: true, //压缩页面 JS minifyCSS: true, //压缩页面 CSS minifyURLs: true //压缩页面URL &#125;)) .pipe(gulp.dest(&#x27;./public&#x27;))&#125;);//压缩字体function minifyFont(text, cb) &#123; gulp .src(&#x27;./public/fonts/*.ttf&#x27;) //原字体所在目录 .pipe(fontmin(&#123; text: text &#125;)) .pipe(gulp.dest(&#x27;./public/fontsdest/&#x27;)) //压缩后的输出目录 .on(&#x27;end&#x27;, cb);&#125;gulp.task(&#x27;mini-font&#x27;, (cb) =&gt; &#123; var buffers = []; gulp .src([&#x27;./public/**/*.html&#x27;]) //HTML文件所在目录请根据自身情况修改 .on(&#x27;data&#x27;, function(file) &#123; buffers.push(file.contents); &#125;) .on(&#x27;end&#x27;, function() &#123; var text = Buffer.concat(buffers).toString(&#x27;utf-8&#x27;); minifyFont(text, cb); &#125;);&#125;);// 运行gulp命令时依次执行以下任务gulp.task(&#x27;default&#x27;, gulp.parallel( &#x27;compress&#x27;, &#x27;minify-css&#x27;, &#x27;minify-html&#x27;,&#x27;mini-font&#x27;)) 可能出现的BUG 毕竟是bug御三家，没点bug都不好意思出来混 部分js经过gulp-babel的压缩加密后，因为一些变量的生命周期变化，可能无法正常使用，报错一般为提示该js中的某个变量未被声明。最快的解决方案就是干脆不要压缩它，对它设置压缩屏蔽。(terser就不会有这问题) 此处举例，假设使用gulp压缩后，位于/source/js/example.js无法正常使用。则在[Blogroot]\\gulpfile.js中修改js压缩任务的相关配置 123456789101112 //压缩js gulp.task(&#x27;compress&#x27;, async() =&gt;&#123;- gulp.src([&#x27;./public/**/*.js&#x27;, &#x27;!./public/**/*.min.js&#x27;])+ gulp.src([&#x27;./public/**/*.js&#x27;, &#x27;!./public/**/*.min.js&#x27;,&#x27;!./public/js/example.js&#x27;]) .pipe(babel(&#123; presets: [&#x27;@babel/preset-env&#x27;] &#125;)) .pipe(uglify().on(&#x27;error&#x27;, function (e) &#123; console.log(e) &#125;)) .pipe(gulp.dest(&#x27;./public&#x27;)) &#125;); Gulp执行压缩在每次运行完hexo generate生成静态页面后，运行gulp对其进行压缩。指令流程如下： 1234hexo cleanhexo generategulphexo server 或 hexo deploy 关于font-min的补充说明，在本文中，是通过读取所有编译好的html文件（./public/**/*.html）中的字符，然后匹配原有字体包内./public/fonts/*.ttf字体样式，输出压缩后的字体包到./public/fontsdest/目录。所以最终引用字体的相对路径应该是/fontsdest/*.ttf。而本地测试时，如果没有运行gulp，自然也就不会输出压缩字体包到public目录，也就看不到字体样式。","tags":["Hexo","Butterfly","Gulp"],"categories":["Hexo"]},{"title":"Vue3-03_watch监听","path":"/posts/4bfb358d.html","content":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;script&gt;// --------------- 监听器 ---------------// 声明式渲染 提高开发效率export default &#123; data() &#123; return &#123; msg: &quot;阿巴阿巴啊巴巴巴&quot;, num: 0, users: &#123; name1: &quot;张三&quot;, name2: &quot;王五&quot; &#125;, &#125;; &#125;, // 计算属性computed computed: &#123;&#125;, methods: &#123; changeMsg: function () &#123; this.msg = &quot;阿巴个锤子&quot;; &#125;, //给vue实例定义方法 &#125;, // watch监听数据变化 每当被监听对象变化时会被执行 watch: &#123; // 写法1 msg: function (newVal, oldVal) &#123; console.log(&quot;写法1 新的值为：&quot; ,newVal); console.log(&quot;写法1 旧的值为：&quot; , oldVal); // 监听事件 if (newVal != oldVal) &#123; this.num += 1; &#125; &#125;, // 写法2 只监听某个属性 &quot;users.name2&quot;或&quot;users[&#x27;name2&#x27;]&quot; &quot;users.name1&quot;:&#123; handler:function(newValue)&#123; console.log(&#x27;写法2 name1的新值为：&#x27;,newValue) &#125; &#125;, // 写法3 深度监听 会监听users里面所有信息 users: &#123; //初始化的时候就调用函数 // immediate: true, handler: function (newValue) &#123; // 字符串评价对象 需要使用JSON.stringify()才能显示 // console.log(&quot;写法3 users下的所有新的值分别为：&quot; + JSON.stringify(newValue)); console.log(&quot;写法3 users下的所有新的值分别为：&quot; ,newValue) &#125;, // 是否深度监听 deep: true, &#125;, &#125;,&#125;;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;!--------------- watch监听 ---------------&gt; &lt;h1&gt;(六) watch监听&lt;/h1&gt; &lt;p&gt;我是msg：&#123;&#123; msg &#125;&#125;&lt;/p&gt; &lt;p&gt;我是name1：&#123;&#123; users.name1 &#125;&#125;&lt;/p&gt; &lt;p&gt;我是name2：&#123;&#123;users.name2&#125;&#125;&lt;/p&gt; &lt;p&gt;msg变化一次我就会加1：&#123;&#123; num &#125;&#125;&lt;/p&gt; &lt;!-- v-model 数据双向绑定 --&gt; &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot; v-model=&quot;msg&quot; /&gt; &lt;p&gt; &lt;button id=&quot;btn&quot; @click=&quot;changeMsg&quot;&gt;改变msg&lt;/button&gt; &lt;button v-on:click=&quot;users.name1 = &#x27;李四&#x27;&quot;&gt;改变name1&lt;/button&gt; &lt;button v-on:click=&quot;users.name2=&#x27;吴六&#x27;&quot;&gt;改变name2&lt;/button&gt; &lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt;","tags":["Vue","Vue3"],"categories":["Language"]},{"title":"Vue3-02_computed计算属性","path":"/posts/4f5d6972.html","content":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;script&gt;// --------------- 计算属性 ---------------// 声明式渲染 提高开发效率export default &#123; data() &#123; return &#123; name: &quot;冰糖&quot;, &#125;; &#125;, // 计算属性computed computed: &#123; // 1-计算属性简写: 用于计算的属性 这里不叫方法 叫属性可直接&#123;&#123;&#125;&#125;调用 // 只要依赖值不变就不会重新计算 rvName: function () &#123; console.log(&quot;计算属性：我显示几次代表我被执行了几次&quot;); return this.name.split(&quot;&quot;).reverse().join(&quot;&quot;); &#125;, // 2-计算属性完整写法 // 每个计算属性都有一个geter和seter reNmae1: &#123; // seter: 在设置或更改计算属性的时候调用 注：newValue任意 // 计算属性是只读属性一般不会更改 所以一般默认没有set方法 写简写即可 set: function (newValue) &#123; console.log(newValue); &#125;, // geter：默认被调用 get: function () &#123; return this.name.split(&quot;&quot;).reverse().join(&quot;&quot;); &#125;, &#125;, &#125;, methods: &#123; //给vue实例定义方法 reverseName: function () &#123; console.log(&quot;methods：我显示几次代表我被执行了几次&quot;); return this.name.split(&quot;&quot;).reverse().join(&quot;&quot;); &#125;, &#125;,&#125;;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;!--------------- 计算属性及其他方式区分 反转名字执行3次 ---------------&gt; &lt;!-- 结论：看执行次数后发现 只要值不变 computed计算属性只会执行一次 效率更高 因为会从缓存读取数据 而methods会执行三次 --&gt; &lt;h1&gt;(五) 计算属性 computed&lt;/h1&gt; &lt;!-- 1 JavaScript表达式 计算3次--&gt; &lt;p&gt;js01 &#123;&#123; name.split(&quot;&quot;).reverse().join(&quot;&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;js02 &#123;&#123; name.split(&quot;&quot;).reverse().join(&quot;&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;js03 &#123;&#123; name.split(&quot;&quot;).reverse().join(&quot;&quot;) &#125;&#125;&lt;/p&gt; &lt;!-- 2 使用methods中的方法 --&gt; &lt;p&gt;methods01 &#123;&#123; reverseName() &#125;&#125;&lt;/p&gt; &lt;p&gt;methods02 &#123;&#123; reverseName() &#125;&#125;&lt;/p&gt; &lt;p&gt;methods03 &#123;&#123; reverseName() &#125;&#125;&lt;/p&gt; &lt;!-- 3 computed计算属性 一次且不需要括号--&gt; &lt;p&gt;计算属性01 &#123;&#123; rvName &#125;&#125;&lt;/p&gt; &lt;p&gt;计算属性02 &#123;&#123; rvName &#125;&#125;&lt;/p&gt; &lt;p&gt;计算属性03 &#123;&#123; rvName &#125;&#125;&lt;/p&gt; &lt;button v-on:click=&quot;name = &#x27;12345&#x27;&quot;&gt; conputed计算属性 改变内容: 看控制台触发次数 &lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt;","tags":["Vue","Vue3"],"categories":["Language"]},{"title":"Vue3-01_模板语法","path":"/posts/6fbf3b10.html","content":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;script&gt;// --------------- 模板语法 ---------------// 声明式渲染 提高开发效率export default &#123; data() &#123; return &#123; age: 23, name: &quot;冰糖&quot;, vo: &quot;v-once测试: 我不会改变&quot;, vh: &quot;&lt;h4&gt;v-html四级标题渲染测试&lt;/h4&gt;&quot;, id: &quot;d1&quot;, url: &quot;https://s2.loli.net/2022/12/01/tY3VBLpkceU9lEC.jpg&quot;, &#125;; &#125;, methods: &#123; //给vue实例定义方法 changeVO: function () &#123; alert(&quot;弹窗测试：点击按钮后我会出现&quot;); this.name = &quot;我变了&quot;; this.vo = &quot;我会变吗?&quot;; &#125;, changeD1: function () &#123; this.id = &quot;d1&quot;; &#125;, changeD2: function () &#123; this.id = &quot;d2&quot;; &#125;, changeSrc: function () &#123; this.url = &quot;https://cn.vitejs.dev/logo-with-shadow.png&quot;; &#125;, &#125;,&#125;;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;p&gt;我叫：&#123;&#123; name &#125;&#125;&lt;/p&gt; &lt;p&gt;我今年&#123;&#123; age &#125;&#125;岁&lt;/p&gt; &lt;!--------------- v-one/v-html/v-bind ---------------&gt; &lt;h1&gt;(一) v-one/v-html/v-bind&lt;/h1&gt; &lt;!-- v-once 数据改变,内容不更新 --&gt; &lt;p v-once&gt;&#123;&#123; vo &#125;&#125;&lt;/p&gt; &lt;button @click=&quot;changeVO&quot;&gt;v-once改变测试按钮&lt;/button&gt; &lt;!-- v-html渲染测试 --&gt; &lt;p&gt;下面是v-html的标题标签测试：&lt;span v-html=&quot;vh&quot;&gt;&lt;/span&gt;&lt;/p&gt; &lt;!-- v-bind：动态绑定属性内容 --&gt; &lt;p v-bind:id=&quot;id&quot;&gt;v-bind动态绑定id：id为d1是红色,d2是蓝色&lt;/p&gt; &lt;p&gt; &lt;button @click=&quot;changeD1&quot;&gt;ID切换为d1&lt;/button&gt; &lt;button @click=&quot;changeD2&quot;&gt;ID切换为d2&lt;/button&gt; &lt;/p&gt; &lt;p&gt;v-bind动态绑定src：&lt;img v-bind:src=&quot;url&quot; alt=&quot;&quot; width=&quot;200&quot; /&gt;&lt;/p&gt; &lt;p&gt;&lt;button @click=&quot;changeSrc&quot;&gt;点我改变图片链接&lt;/button&gt;&lt;/p&gt; &lt;!--------------- JavaScript表达式 ---------------&gt; &lt;h1&gt;(二) JavaScript表达式&lt;/h1&gt; &lt;p&gt;年龄+1等于：&#123;&#123; age + 1 &#125;&#125;&lt;/p&gt; &lt;p&gt;名字反转：&#123;&#123; name.split(&quot;&quot;).reverse().join(&quot;&quot;) &#125;&#125;&lt;/p&gt; &lt;p v-bind:id=&quot;id + 1&quot;&gt;v-bind绑定&lt;/p&gt; &lt;!--------------- 语法糖 ---------------&gt; &lt;h1&gt;(三) 语法糖&lt;/h1&gt; &lt;!-- @是v-on的语法糖 --&gt; &lt;button v-on:click=&quot;changeD1&quot;&gt;v-on按钮&lt;/button&gt; &lt;!-- :冒号是v-bind的语法糖 --&gt; &lt;p :id=&quot;id&quot;&gt;&lt;/p&gt; &lt;!--------------- 动态参数 中括号[] ---------------&gt; &lt;h1&gt;(四) 动态属性[]&lt;/h1&gt; &lt;!-- 动态属性 和 动态事件 --&gt; &lt;a v-bind:[attributeName]=&quot;url&quot;&gt; 动态属性 &lt;/a&gt; &lt;a v-on:[eventName]=&quot;doSomething&quot;&gt; 动态事件 &lt;/a&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;.logo &#123; height: 6em; padding: 1.5em; will-change: filter;&#125;.logo:hover &#123; filter: drop-shadow(0 0 2em #646cffaa);&#125;.logo.vue:hover &#123; filter: drop-shadow(0 0 2em #42b883aa);&#125;#d1 &#123; color: rgb(255, 0, 0);&#125;#d2 &#123; color: blue;&#125;&lt;/style&gt;","tags":["Vue","Vue3"],"categories":["Language"]},{"title":"Vue3-00_Vue开始入门","path":"/posts/70029b18.html","content":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;!--------------- 使用JS的方式引入vue3 -----------------&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 引入vue 你的vue文件路径 --&gt; &lt;script src=&quot;./vue.global.js&quot;&gt;&lt;/script&gt;&lt;/head&gt; &lt;body&gt; &lt;div id=&quot;counter&quot;&gt; &lt;!-- vue语法 变量设置 --&gt; &lt;p&gt;num是：&#123;&#123;num&#125;&#125;&lt;/p&gt; &lt;p&gt;我是：&#123;&#123;uname&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; const Counter = &#123; data: function () &#123; return &#123; num: 0, uname: &#x27;冰糖&#x27; &#125; &#125; &#125; // Vue.createApp(Counter).mount(&#x27;#counter&#x27;) // 创建应用,传入配置,mount挂载 关联以上元素 let app = Vue.createApp(Counter).mount(&#x27;#counter&#x27;) console.log(app); &lt;/script&gt;&lt;/body&gt; &lt;/html&gt;","tags":["Vue","Vue3"],"categories":["Language"]},{"title":"Nginx入门","path":"/posts/33a007fa.html","content":"介绍Nginx是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP&#x2F;POP3&#x2F;SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的[http://Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。 其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。2011年6月1日，nginx 1.0.4发布。 Nginx是一款轻量级的Web 服务器&#x2F;反向代理服务器及电子邮件（IMAP&#x2F;POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强。 以下的所有server块都是在nginx.conf文件内的http块内添加的，nginx.conf文件位于/usr/local/nginx/nginx.conf 案例一：直接部署静态资源需求：将服务器下/www/hexo路径下的博客文件部署到公网上，并且用域名cvki.cn和www.cvki.cn可以访问。 123456789server &#123; listen 80; # 指定80端口访问 server_name cvki.cn www.cvki.cn; # 如果使用cvki.cn和www.cvki.cn则执行以下操作 location / &#123; root /www/hexo; # 指定该网站的根目录 index index.html index.htm; # 访问时默认打开index.html或index.htm文件 &#125;&#125; 案例二：反向代理部署静态资源需求：我的服务器上有一个Java项目，但Java项目需要使用tomcat，tomcat默认的端口是8080，我的Java项目放在/www/tomcat9/webapps/ROOT下，并且使用域名java.cvki.cn域名访问该项目。 1234567server&#123; listen 80 server_name java.cvki.cn; location / &#123; proxy_pass http://127.0.0.1:8080; &#125;&#125; 案例三：加网站HTTPS需求：给我的博客 http://cvki.cn 加SSL，使网站更加安全，在案例一的基础上修改，首先需要申请SSL证书，如果你是在阿里云或者腾讯云购买的域名可以免费申请一年的SSL证书，如果你也没有申请到证书，那你也可以申请免费的SSL证书 123456789101112131415161718192021222324server &#123; listen 80; server_name www.cvki.cn; return 301 https://$server_name$request_uri; #访问http时自动跳转到https&#125;# 对SSL证书解析server &#123; listen 443 ssl default; listen [::]:443 ssl; server_name www.cvki.cn; ssl_certificate cert/cvki.cn/cert-hikki-site.pem; #证书存放相对路径 ssl_certificate_key cert/cvki.cn/cert-hikki-site.key; #证书存放相对路径 ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3; ssl_prefer_server_ciphers on; location / &#123; root /www/hexo; #Web网站程序存放目录。 index index.html index.htm; &#125;&#125; 常见的Nginx状态码、响应码状态码分类 分类 分类描述 分类详细说明 1** 信息 服务器收到请求，需要请求者继续执行操作 2** 成功 操作被成功接收并处理 3** 重定向 需要进一步的操作以完成请求 4** 客户端错误 请求包含语法错误或无法完成请求 5** 服务器错误 服务器在处理请求的过程中发生了错误 1开头状态码 状态码 状态码英文名称 描述 100 Continue 继续，客户端应继续请求 101 Switching Protocols 切换协议，服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 2开头状态码 状态码 状态码英文名称 描述 200 OK 请求成功，一般用于GET与POST请求 201 Created 已创建，成功请求创建了新的资源 202 Accepted 已接受，已经接受请求，但未处理完成 203 Non-Authoritative Information 非授权信息，请求成功，但返回的meta信息不在原始的服务器，而是一个副本 204 No Content 无内容，服务器成功处理，但未返回内容。在未更新的网页情况下，可确保浏览器继续显示当前文档 205 Reset Content 重置内容，服务器处理成功，用户终端（浏览器）应重置文档视图，可通过此返回码清除浏览器的表单域 206 Partial Content 部分内容，服务器成功处理了部分GET请求 3开头状态码 状态码 状态码英文名称 描述 300 Multiple Choices 多种选择，请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端选择 301 Moved Permanently 永久跳转。请求的资源已被永久移动到新的URL，返回信息会包括新的URL，浏览器会自动定向到新URL，今后任何新的请求都应使用新的URL代替 302 Found 临时移动，与301类似，但资源只是临时被移动，客户端应继续使用原有的URL 303 See Other 查看其它地址,与301类似，使用GET和POST请求查看 304 Not Modified 未修改，所请求的资源未修改，服务器返回此状态码时，不会返回任何资源，客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 305 Use Proxy 使用代理，所请求的资源必须通过代理访问 306 Unused 已经被废弃的HTTP状态码 307 Unused 临时重定向，与302类似，使用GET请求重定向 4开头状态码 状态码 状态码英文名称 描述 400 Bad Request 客户端请求的语法错误，服务器无法理解 401 Unauthorized 请求要求用户的身份认证 402 Payment Required 保留，将来使用 403 Forbidden 服务器拒绝执行此请求 404 Not Found 服务器无法根据客户端的请求找到资源（网页），通过此代码，网站设计人员可设置“你所请求的资源无法找到”的个性页面 405 Method Not Allowed 客户端请求中的访求被禁止 406 Not Acceptable 服务器无法根据客户端请求的内容性完成请求 407 Proxy Authentication Required 请求要求代理的身份证，与401类似，但请求者应当使用代理进行授权 408 Request Time-out 超时，服务器等待客户端发送的请求时间过长 409 Conflict 服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突 410 Gone 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息 412 Precondition Failed 客户端请求信息的先决条件错误 413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 414 Request-URI Too Large 请求的URI过长（URI通常为网址），服务器无法处理 414 Request-URI Too Large 请求的URI过长（URI通常为网址），服务器无法处理 415 Unsupported Media Type 服务器无法处理请求附带的媒体格式 416 Requested range not satisfiable 客户端请求的范围无效 417 Expectation Failed 服务器无法满足Expect的请求头信息 5开头状态码 状态码 状态码英文名称 描述 500 Internal Server Error 服务器内部错误，无法完成请求 501 Not Implemented 服务器不支持请求的功能，无法完成请求 502 Bad Gateway 充当网关或代理的服务器，从远端服务器接收到了一个无效的请求 503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求 505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理","tags":["Nginx"],"categories":["Nginx"]},{"title":"NodeJS总结","path":"/posts/7c217faf.html","content":"项目树123456789101112131415161718192021TestDemo ├─ db // 连接数据库 │ └─ index.js ├─ router // 路由规则 │ ├─ artcata.js │ ├─ article.js │ ├─ user.js │ └─ userinfo.js ├─ router_handler // 路由函数体│ ├─ artcata_handler.js │ ├─ article_handler.js │ ├─ userinfo_handler.js │ └─ user_handler.js ├─ schema //数据校验规则│ ├─ article.js │ └─ user.js ├─ uploads // 文件上传存储位置├─ app.js // 程序启动入口├─ config.js // 全局变量配置├─ package-lock.json └─ package.json 程序入口app.js跨域问题在写项目是一般要都会遇到跨域的问题，要如何解决呢？ 在客户端对服务端请求的数据的程序入口添加cors中间件来解决跨域问题 1234app.js// 解决跨域问题，导入 cors 中间件const cors = require(&#x27;cors&#x27;)// 将 cors 注册为全局中间件app.use(cors()) 表单数据解析只需要添加urlencoded中间件就可以解析表单数据了 123app.jsconst express = require(&#x27;express&#x27;)// 解析表单的数据中间件，只能解析application/x-www-form-urlencodedapp.use(express.urlencoded(&#123; extended: false &#125;)) 错误中间件服务端在处理数据时难免会有错误，这时需要一个中间件来处理这些错误。 先封装一个中间件用来处理发生错误时给客户端返回的响应数据，可以减少代码冗余。 在给客户端返回数据时应该有规定的格式，应该有响应码和响应描述&#123; status:0 , msg: &#39;响应内容&#39; &#125; 123456789101112131415161718192021222324app.js// 封装res.cc的捕捉错误中间件app.use(function (req, res, next) &#123; // status = 0 为成功； status = 1 为失败； 默认将 status 的值设置为 1，方便处理失败的情况 res.cc = function (err, status = 1) &#123; res.send(&#123; // 状态 status, // 状态描述，判断 err 是 错误对象 还是 字符串 msg: err instanceof Error ? err.message : err, &#125;) &#125; next()&#125;)// 错误中间件app.use(function (err, req, res, next) &#123; // 数据验证失败 if (err instanceof joi.ValidationError) return res.cc(err) if (err.name === &#x27;UnauthorizedError&#x27;) return res.cc(&#x27;身份认证失败！&#x27;) // 未知错误 res.cc(err)&#125;) 登录 &amp; 注册解析数据利用urlencoded中间件解析表单传过来的数据。 导入登录注册的路由并定义入口地址前缀/api 123456app.js// 解析表单的数据中间件，只能解析application/x-www-form-urlencodedapp.use(express.urlencoded(&#123; extended: false &#125;))//导入路由const userRouter = require(&#x27;./router/user&#x27;)app.use(&#x27;/api&#x27;,userRouter) 登录请求地址:127.0.0.1:3000/api/login 参数格式： 12username`:`valuepassword`:`value image-20220731124011773 注册请求地址：127.0.0.1:3000/api/reguser 参数格式： 12username`:`valuepassword`:`value image-20220731132033648 在注册和登录要进行数据的校验： 先验证数据是否为空或者数据是否合乎规则 查询用户名是否被占用 登录成功&#x2F;添加成功 在验证用户名和密码一般需要使用joi模块来校验规则。 以下是schema/user.js的文件，主要功能是对客户端对个人用户信息修改进行规则验证。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768schema/user.jsconst joi = require(&#x27;joi&#x27;)/** * string() 值必须是字符串 * alphanum() 值只能是包含 a-zA-Z0-9 的字符串 * min(length) 最小长度 * max(length) 最大长度 * required() 值是必填项，不能为 undefined * pattern(正则表达式) 值必须符合正则表达式的规则 */// 用户名的验证规则const username = joi.string().alphanum().min(1).max(15).required()// 密码的验证规则const password = joi .string() .pattern(/^[\\S]&#123;6,12&#125;$/) .required()// id 的验证规则const id = joi.number().required().integer().min(1)// 昵称的验证规则const nickname = joi.string().required()// email的验证规则const email = joi.string().email().required()// 头像验证规则const avatar = joi.string().dataUri().required()// 注册和登录表单的验证规则对象exports.reg_login_schema = &#123; // 表示需要对 req.body 中的数据进行验证 body: &#123; username, password, &#125;,&#125;exports.update_userinfo_schema = &#123; // 需要对req.body 里面的数据进行验证。 // 如果body里面的变量名和客户端传过来的变量名一致的，就可以不用写冒号，原本是: // id:id,nickname:nickname,email:email body:&#123; id, nickname, email, &#125;,&#125;// 验证规则对象 - 重置密码exports.update_password_schema = &#123; body: &#123; // 使用 password 这个规则，验证 req.body.oldPwd 的值 oldPwd: password, // 使用 joi.not(joi.ref(&#x27;oldPwd&#x27;)).concat(password) 规则，验证 req.body.newPwd 的值 // 解读： // 1. joi.ref(&#x27;oldPwd&#x27;) 表示 newPwd 的值必须和 oldPwd 的值保持一致 // 2. joi.not(joi.ref(&#x27;oldPwd&#x27;)) 表示 newPwd 的值不能等于 oldPwd 的值 // 3. .concat() 用于合并 joi.not(joi.ref(&#x27;oldPwd&#x27;)) 和 password 这两条验证规则 newPwd: joi.not(joi.ref(&#x27;oldPwd&#x27;)).concat(password), &#125;,&#125;// 头像验证对象exports.reg_avatar_schema = &#123; body:&#123; avatar, &#125;,&#125; 然后在请求时校验规则，在导入规则对象时记得要加&#123;&#125;，以下是router/user.js文件，主要功能是对个人信息相关的路由进行控制。 123456789101112131415161718192021router/user.jsconst express = require(&#x27;express&#x27;)，// 创建路由对象const router = express.Router()// 导入用户路由模块处理函数对应的模块const user_handler = require(&#x27;../router_handler/user_handler&#x27;)// 1. 导入验证表单数据的中间件const expressJoi = require(&#x27;@escook/express-joi&#x27;)// 2. 导入需要的验证规则对象const &#123; reg_login_schema &#125; = require(&#x27;../schema/user&#x27;)// 注册新用户router.post(&#x27;/reguser&#x27;,expressJoi(reg_login_schema),user_handler.reguser )// 登录router.post(&#x27;/login&#x27;,expressJoi(reg_login_schema), user_handler.login)// 将路由对象共享出去module.exports = router 请求地址处理在设计项目初期，应该给不同类型的内容设计不同的请求地址，防止项目路由混乱。 比如在注册登录使用路由前缀/api 在用户发布文章使用前缀/my/article 在用户查阅个人信息时使用前缀/my 路由处理项目有非常多的请求地址，应该有条理的把路由整齐划分，将路由请求方式和路由函数体分开，以便能够查阅清洗条例的路由请求方式。 在路由请求方式中，记得在末尾导出路由对象module.exports = router。 在路由函数体也要导出函数对象exports.login = (req, res) =&gt; &#123;&#125; 比如以下: 1234567891011TestDemo├─ router // 路由规则 │ ├─ artcata.js │ ├─ article.js │ ├─ user.js │ └─ userinfo.js ├─ router_handler // 路由函数体│ ├─ artcata_handler.js │ ├─ article_handler.js │ ├─ userinfo_handler.js │ └─ user_handler.js 数据校验在客户端给服务通过url传参数的时候， 在joi模块校验应该把规则变量挂载到params而不是body下，使用id的时候是通过req.params.id 123456// 这里不是body，是paramsexports.delete_cate_schema = &#123; params:&#123; id, &#125;&#125; 此项目所使用到的模块以及某些案例数据校验案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960const express = require(&#x27;express&#x27;)const app = express()// 导入 Joi 来定义验证规则const Joi = require(&#x27;joi&#x27;)// 1. 导入 @escook/express-joiconst expressJoi = require(&#x27;@escook/express-joi&#x27;)// 解析 x-www-form-urlencoded 格式的表单数据app.use(express.urlencoded(&#123; extended: false &#125;))// 2. 定义验证规则// 注意：如果客户端提交的某些参数项未在 schema 中定义，// 此时，这些多余的参数项默认会被忽略掉const userSchema = &#123; // 2.1 校验 req.body 中的数据 body: &#123; username: Joi.string().alphanum().min(3).max(12).required(), password: Joi.string() .pattern(/^[\\S]&#123;6,15&#125;$/) .required(), repassword: Joi.ref(&#x27;password&#x27;) &#125;, // 2.2 校验 req.query 中的数据 query: &#123; name: Joi.string().alphanum().min(3).required(), age: Joi.number().integer().min(1).max(100).required() &#125;, // 2.3 校验 req.params 中的数据 params: &#123; id: Joi.number().integer().min(0).required() &#125;&#125;// 3. 在路由中通过 expressJoi(userSchema) 的方式// 调用中间件进行参数验证app.post(&#x27;/add&#x27;, expressJoi(userSchema), function (req, res) &#123; const body = req.body res.send(body)&#125;)// 4.1 错误级别中间件app.use(function (err, req, res, next) &#123; // 4.1 Joi 参数校验失败 if (err instanceof Joi.ValidationError) &#123; return res.send(&#123; status: 1, message: err.message &#125;) &#125; // 4.2 未知错误 res.send(&#123; status: 1, message: err.message &#125;)&#125;)// 调用 app.listen 方法，指定端口号并启动web服务器app.listen(3001, function () &#123; console.log(&#x27;Express server running at http://127.0.0.1:3001&#x27;)&#125;) 所用到的包1234567891011121314151617181920212223&#123; &quot;name&quot;: &quot;TestDemo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;@escook/express-joi&quot;: &quot;^1.1.1&quot;, &quot;bcryptjs&quot;: &quot;^2.4.3&quot;, &quot;cors&quot;: &quot;^2.8.5&quot;, &quot;express&quot;: &quot;^4.17.1&quot;, &quot;express-jwt&quot;: &quot;^5.3.3&quot;, &quot;joi&quot;: &quot;^17.6.0&quot;, &quot;jsonwebtoken&quot;: &quot;^8.5.1&quot;, &quot;multer&quot;: &quot;^1.4.2&quot;, &quot;mysql&quot;: &quot;^2.18.1&quot; &#125;&#125; 删除文章案例1234567891011121314// 删除文章exports.deleteCateById = (req,res)=&gt;&#123; //0表示未删除，1表示已删除 const sql = `select * from ev_article_cate where id =?` db.query(sql,req.params.id,(err,results)=&gt;&#123; if (err) return res.cc(err) const delSql = `update ev_article_cate set is_delete = 1 where id = ?` db.query(delSql,req.params.id,(err,results)=&gt;&#123; if (err) return res.cc(err) if (results.affectedRows !== 1) return res.cc(&#x27;删除文章失败&#x27;) res.cc(&#x27;删除文章成功&#x27;,0) &#125;) &#125;)&#125;","tags":["NodeJS"],"categories":["Language"]},{"title":"批处理 清理 WINDOWS 图标缓存","path":"/posts/acebed7c.html","content":"如下批处理程序（保存为“清理图标缓存.cmd”或“清理图标缓存.bat”） 可用于刷新 WINDOWS 的图标缓存，用于解决 WINDOWS 图标的显示异常。 123456789101112131415161718rem 关闭 Windows 外壳程序 Explorertaskkill /f /im explorer.exerem 清理系统图标缓存数据库attrib -h -s -r &quot;%userprofile%\\AppData\\Local\\IconCache.db&quot;del /f &quot;%userprofile%\\AppData\\Local\\IconCache.db&quot;attrib /s /d -h -s -r &quot;%userprofile%\\AppData\\Local\\Microsoft\\Windows\\Explorer\\*&quot;del /f &quot;%userprofile%\\AppData\\Local\\Microsoft\\Windows\\Explorer\\thumbcache_32.db&quot;del /f &quot;%userprofile%\\AppData\\Local\\Microsoft\\Windows\\Explorer\\thumbcache_96.db&quot;del /f &quot;%userprofile%\\AppData\\Local\\Microsoft\\Windows\\Explorer\\thumbcache_102.db&quot;del /f &quot;%userprofile%\\AppData\\Local\\Microsoft\\Windows\\Explorer\\thumbcache_256.db&quot;del /f &quot;%userprofile%\\AppData\\Local\\Microsoft\\Windows\\Explorer\\thumbcache_1024.db&quot;del /f &quot;%userprofile%\\AppData\\Local\\Microsoft\\Windows\\Explorer\\thumbcache_idx.db&quot;del /f &quot;%userprofile%\\AppData\\Local\\Microsoft\\Windows\\Explorer\\thumbcache_sr.db&quot;rem 清理系统托盘记忆的图标echo y　reg delete &quot;HKEY_CLASSES_ROOT\\Local Settings\\Software\\Microsoft\\Windows\\CurrentVersion\\TrayNotify&quot; /v IconStreamsecho y　reg delete &quot;HKEY_CLASSES_ROOT\\Local Settings\\Software\\Microsoft\\Windows\\CurrentVersion\\TrayNotify&quot; /v PastIconsStreamrem 重启 Windows 外壳程序 Explorerstart explorer","tags":["Dos","Windows"],"categories":["Source"]},{"title":"BAT 批处理 特殊符号 总结","path":"/posts/1cbe4b4.html","content":"批处理特殊符号 参考1 参考2 % 变量引导符 算数运算：SET /A a=5%%2里面%%为取余数(结果为1) 引用变量：%var%就是变量var的引用，如果直接var，系统会把var当字符处理了 命令行参数：单个%紧跟0-9的一个数字表示引用命令行参数 引用循环变量：用于for中表示引用循环变量 用于for中连续的两个%表示执行时脱为一个% 用作行内注释：%行内注释% %n 调用程序外部参数 %n(n为自然数)表示在调用批处理文件时传递的参数 %0 批处理文件本身，包括完整的路径和扩展名。参数%0具有特殊的功能，可以调用批处理自身，以达到批处理本身循环的目的，也可以复制文件自身等等。 %1 第一个参数 %9 第九个参数 %* 从第一个参数开始的所有参数 12copy %0 d: ew_file.bat:: 最简单的复制文件自身的方法 %行内注释% 可以用作行内注释，不能出现重定向符号和管道符号。 此时“注释内容”其实被当作变量，其值是空的，故只起注释作用，不过这种用法容易出现语法错误，一般不用。 %%k for语句特有的变量 %%i是for语句里面特有的变量，只有在批处理里面才写两个%%号表示变量(用1个会报错)，在cmd中则只用一个%号(用2个会报错)。 批处理中之所以用两个%%是因为编译器编译的时候要屏蔽一个%。 ! 变量延迟时变量引用符 变量引用符：在变量延迟问题中，用来表示变量，即%var%应该表示为!var!(不要问我为什么，因为这就是最基础的语法)。 逻辑运算符：在 set &#x2F;a 中表示逻辑非 () 多行命令整合符小括号在批处理编程中有特殊的作用，左右括号必须成对使用，括号中可以包括多行命令，这些命令将被看成一个整体，视为一条命令行。 括号在for语句和if语句中常见，用来嵌套使用循环或条件语句，其实括号也可以单独使用。 1234567echo 1 &amp; echo 2 &amp; echo 3( echo 1 echo 2 echo 3):: 上面两种写法效果一样，这两种写法都被视为是一条命令行 注意：这种多条命令被视为一条命令行时，如果其中有变量，就涉及到变量延迟的问题。 &amp; 命令连接符 命令连接符：可以把多个命令组合起来当一个命令来执行，这在批处理脚本里用的非常广泛，因为批处理认行不认命令数目。 位运算：在set&#x2F;a中是按位与 12@echo off &amp; setlocal enabledelayedexpansionset /A b=1 &amp; echo b的值为：%b%，!b!(必须使用延迟扩展) &amp;&amp; 和 || 组合命令符符号&amp;&amp;、||为组合命令： 符号&amp;&amp;：前面的命令失败时，后边的命令将不会执行(前面的命令成功时，后边的命令会执行) 符号||：前面的命令失败时，后边的命令才会执行(前面的命令成功时，后边的命令不会执行) 符号&amp;：前面的命令不影响后边的命令执行，目的一般为了将多行命令放在一行 123456copy %0 new_file.txt &amp;&amp; echo 【拷贝当前批处理文件成功】copy 不存在的文件.txt new_file.txt &amp;&amp; echo 【拷贝成功1(不会执行)】copy 不存在的文件.txt new_file.txt || echo 【拷贝失败1】copy %0 new_file.txt &amp;&amp; echo 【拷贝成功2】 || echo 【拷贝失败2(不会执行)】copy 不存在的文件.txt new_file.txt &amp;&amp; echo 【拷贝成功3(不会执行)】 || echo 【拷贝失败3】 ; 相同命令分割符当命令相同时，分号;可以将不同目标用隔离，但执行效果不变。 12345dir c:\\;d:\\;e:\\:: 如果其中e盘不存在，运行显示：系统找不到指定的路径。然后终止命令的执行。不会打印任何内容dir c:\\;d:\\ &gt;&gt;a.txt:: 把C盘和D盘的信息都重定向到文件a.txt中 ^ 取消转义符 取消转义符：将所有转义字符的转义作用关闭 位运算：在set&#x2F;a中是按位异 不匹配：在findstr&#x2F;r的[]中表示不匹配指定的字符集 续行符：因为每行末尾还有一个看不见的回车符，转义字符位于行尾时就让回车符失效了，从而起到了续行的作用 1234echo test ^&gt;1.txtecho 我^是^包青天^ : 标签定位符标签定位符，可以接受goto命令所指向的标签。 “” 字符串界定符 字符串界定符：在表示带有空格的路径时常要用&quot;&quot;来将路径括起来；在一些命令里面也需要&quot;&quot;符号 在for&#x2F;f中将表示它们包含的内容当作字符串分析 在for&#x2F;f “usebackq”表示它们包含的内容当作文件路径并分析其文件的内容 在其它情况下表示其中的内容是一个完整的字符串，其中的&gt;、&gt;&gt;、&lt;、&amp;、|、空格等不再转义 1234cd &quot;program files&quot;cd progra~1cd pro*:: 以上三种方法都可以进入program files这个目录 &#x2F; 功能开关符 能开关符：表示其后的字符（串）是命令的功能开关（选项），比如dir /s/b/a-d 算数运算：在set&#x2F;a中表示除法 , 特殊空格符在某些情况下，逗号,可以用来当做空格使 1dir,c:\\ ~ 变量扩展符 在for中表示使用增强的变量扩展 在set中表示使用扩展环境变量指定位置的字符串 在set&#x2F;a中表示按位取反 @ 命令行回显屏蔽符这个字符在批处理中的意思是：关闭当前行的回显。 我们知道，ECHO OFF可以关闭掉整个批处理命令的回显，但不能关掉ECHO OFF这个命令的回显，现在我们在ECHO OFF这个命令前加个@，就可以达到所有命令均不回显的要求 * 通配符 匹配符：代表任意个任意字符，就是我们通常所说的通配符 算数运算：在set&#x2F;a中是乘法 多次匹配：在findstr&#x2F;r中表示将前一个字符多次匹配 - 范围表示符 范围表示符：比如日期的查找，for命令里的tokens操作中就可以用到这个字符 匹配范围：在findstr&#x2F;r中连接两个字符表示匹配范围 取反：跟在某些命令后表示取反向的开关 + 文件合并符 文件合并符：主要是在copy命令里面会用到它，表示将很多个文件合并为一个文件 算数运算：在set&#x2F;a中是加法 &#x3D; 赋值符赋值符号，用于变量的赋值 \\ 根目录符 根目录：这个\\符号在有的情况下，代表的是当前路径的根目录。比如当前目录在c盘下,那么你dir \\的话，就相当与dir c:\\ 转义符：在findstr&#x2F;r中表示正则转义字符 ‘’ 命令或字符串 在for&#x2F;f中表示将它们包含的内容当作命令行执行并分析其输出 在for/f &quot;usebackq&quot;中表示将它们包含的字符串当作字符串分析 . 当前目录 在路径的\\后紧跟或者单独出现时：一个.表示当前目录，两个..表示上一级目录 在路径中的文件名中出现时：最后的一个.表示主文件名与扩展文件名的分隔 $ 一行的结束在findstr命令里面表示一行的结束 &#96; 命令符指的是TAB上面的那个按键。 在for&#x2F;f中，表示它们所包含的内容当作命令行执行并分析它的输出。 [] 字符集 在帮助文档表示其中的开关、选项或参数是可选的 在findstr&#x2F;r中表示按其中指定的字符集匹配 ? 匹配一个字符 在findstr&#x2F;r中表示在此位置匹配一个任意字符 在路径中表示在此位置通配任意一个字符 紧跟在/后表示获取命令的帮助文档","tags":["Dos","Bat","cmd"],"categories":["Language"]},{"title":"实用网站收集","path":"/posts/1e5417a7.html","content":"日常通用壁纸头像 我要个性网专注分享图片、文字等素材（头像,图片,网名,个性签名等） 彼岸图网4K壁纸_4K电脑壁纸_4K高清壁纸下载_4K,5K,6K,7K,8K壁纸图片素材 极简壁纸海量电脑桌面壁纸美图_4K超高清_最潮壁纸网站 wallhavenThe best wallpapers on the Net! 电脑壁纸电脑桌面壁纸,高清电脑桌面壁纸,电脑桌面壁纸下载,电脑高清桌面壁纸 Alpha CodersYour Source For Wallpapers, Art, Photography, Gifs and More! GGACCG艺术创作分享平台-专业权威CG创作大赛-全球游戏动漫美术概念大赛 导航网站 Edui123 - 教学工具导航Edui123.com | 让教学简单一点点。 实用工具 改图鸭在线图片压缩、图片编辑、图片格式转换工具 z-library数字图书馆。搜索书籍。免费下载书籍 WantWords 反向词典唯一支持中文及中英跨语言查询的反向词典系统，可以通过描述意思来查找词语。WantWords基于最先进的人工智能和自然语言处理算法实现，由清华大学自然语言处理实验室出品。 Bigjpg使用人工智能深度卷积神经网络（CNN）智能无损免费放大图片，可放大4K级超高清分辨率（4000x4000）图片，最大32倍放大,效果秒杀PhotoZoom放大。 Web Apps by 123apps - 编辑、转换、创建一个 音频，视频，PDF 在线工具 TinyJPGCompress WebP, PNG and JPEG images intelligently SquooshSquoosh is the ultimate image optimizer that allows you to compress and compare images with different codecs in your browser. 在线转换文档，图像，视频，音频文件在线转换PDF，在线转换文档，在线转换电子书，在线转换图像，在线转换视频，在线转换音频。 极简简历极简简历，polebrief简历，极简polebrief，简历模板，在线简历制作，个人简历模板，免费简历模板，简历模板下载word格式 学习提升办公效率 PDF24 Tools: 免费且易于使用的在线PDF工具合并、压缩、创建、编辑和转换PDF文件的免费在线PDF工具。 快捷方便。没有安装。没有注册。 PDF转WordPDF转Word 免费PDF转化 免费在线格式转换工具 免费在线转换工具 免费视频在线转换 免费音频在线转换 免费在线转换 PPT超级市场官网免费下载PPT模板与PPT作品，提供免费的PPT代做服务，提供一站式PPT(模板、定制、工具、教程)服务，有了它，一切制作PPT的烦恼都将成为过去！ OfficePLUSOfficePLUS,微软Office官方在线模板网站，为您提供各类精品PPT模板、PPT实用模块、Word求职简历、Excel图表、图片素材等资源，成为您职场和生活的加油站！ 优品PPT优品PPT模板网是一家专注于分享高质量的免费PPT模板下载网站，包括图表、背景图片、素材、教程等各类PPT模板相关资源。致力于打造国内最大最权威的PPT下载一站式服务平台。 编程开发编程文档 jQuery API 中文文档jQuery API 1.x - 3.x 中文在线版，jQuery API 中文最新版，jQuery 是一个兼容多浏览器的 JavasSript 框架，核心理念是 - write less, do more。jQuery API 中文文档(适用jQuery 1.0 - jQuery 3.x). 正则表达式速查表上面网站带的，单独拿出来放在这方便进行查看。 HTML5速查表同上 在线Java 8 中文版 API手册在线Java 8 中文版 api,Java 8 中文版在线中文参考手册,Java 8 中文版在线chm文档,Java 8 中文版开发文档 API接口 AbeimAPI 韩小韩API接口站 Hitokoto - 一言 在线美图美女图片API接口-夏沫博客 自适应随机图片API","tags":["WebSite"],"categories":["lnternet"]},{"title":"12种JS常用获取时间的方式","path":"/posts/69186ae5.html","content":"1、获取当前的日期和时间方法：new Date() 1console.log(new Date())//Wed Nov 04 2020 18:20:49 GMT+0800 (中国标准时间) 2、获取当前日期可运行代码： 1console.log(new Date().toLocaleDateString())//2020/11/4 不一样的格式： 123456789function fn()&#123;\tlet t = new Date() let fn1 = (d) =&gt;(‘0‘+d).substr(-2) console.log(t.getFullYear()+‘-‘+ fn1(t.getMonth()+1)+‘-‘+ fn1(t.getDate())) )&#125;fn() 说明：b.substr(-2)的含义是将字符串b字符串从后面数起，返回倒数两位的字符 3、返回当前时间获取的是12小时制： 1console.log(new Date().toLocaleTimeString())//下午6:23:09 获取的是24小时制： 1console.log(new Date().toLocaleTimeString(‘chinese‘, &#123; hour12: false &#125;))//18:45:50 4、从Date()对象返回当前 年份1console.log(new Date().getFullYear())//2020 5、从Date()对象返回当前 月份注意：月份的返回值范围是 0~11，所以要获得当前月份，要+1 1console.log(new Date().getMonth())//当前月份-1 1console.log(new Date().getMonth()+1)//当前月份 6、从Date()对象返回月份的当前 日1console.log(new Date().getDate())//返回当前 日 7、从Date()对象返回一个星期的某一天，当前是星期几注意：获取的返回值范围是 0~6 , 0表示星期天 1console.log(new Date().getDay()) 8、从Date()对象的 当前 小时注意：获取返回值的范围是 0~23 1console.log(new Date().getHours())//小时 9、返回Date()对象的 当前 分钟注意：获取返回值的范围是 0~59 1console.log(new Date().getMinutes())//分 10、返回Date()对象的 当前 秒数注意：获取返回值的范围是 0~59 1console.log(new Date().getSeconds())//秒 11、返回Date()对象的 当前 毫秒数注意：范围是 0~999 1console.log(new Date().getMilliseconds())//毫秒 12、返回 日期 1970.01.01 距现在的毫秒数1console.log(new Date().getTime())","tags":["Tips","JavaScript"],"categories":["Language"]},{"title":"Hexo魔改教程(三)","path":"/posts/98733b80.html","content":"文章置顶滚动栏详见：Swiper Bar 安装插件，在博客根目录 [Blogroot] 下打开终端，运行以下指令： 1npm install hexo-butterfly-swiper --save 添加配置信息，以下为写法示例在站点配置文件_config.yml 或者主题配置文件_config.butterfly.yml 中添加 12345678910111213141516# hexo-butterfly-swiper# see https://akilar.top/posts/8e1264d1/swiper: enable: true # 开关 priority: 5 #过滤器优先权 enable_page: all # 应用页面 timemode: date #date/updated layout: # 挂载容器类型 type: id name: recent-posts index: 0 default_descr: 再怎么看我也不知道怎么描述它的啦！ swiper_css: https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css #swiper css依赖 swiper_js: https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js #swiper js依赖 custom_css: https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css # 适配主题样式补丁 custom_js: https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js # swiper初始化方法 参数释义 参数 备选值 &#x2F; 类型 释义 priority number 【可选】过滤器优先级，数值越小，执行越早，默认为 10，选填 enable true&#x2F;false 【必选】控制开关 enable_page path&#x2F;all 【可选】填写想要应用的页面的相对路径（即路由地址）, 如根目录就填’&#x2F;‘, 分类页面就填’&#x2F;categories&#x2F;‘。若要应用于所有页面，就填’all’，默认为 all timemode date&#x2F;updated 【可选】时间显示，date 为显示创建日期，updated 为显示更新日期，默认为 date layout.type id&#x2F;class 【可选】挂载容器类型，填写 id 或 class，不填则默认为 id layout.name text 【必选】挂载容器名称 layout.index 0 和正整数 【可选】前提是 layout.type 为 class，因为同一页面可能有多个 class，此项用来确认究竟排在第几个顺位 default_descr text 默认文章描述 swiper_css url 【可选】自定义的 swiper 依赖项 css 链接 swiper_js url 【可选】自定义的 swiper 依赖项加 js 链接 custom_css url 【可选】适配主题样式补丁 custom_js url 【可选】swiper 初始化方法 使用方法：在文章的 front_matter 中添加 swiper_index 配置项即可。 12345678---title: 文章标题date: 创建日期updated: 更新日期cover: 文章封面description: 文章描述swiper_index: 1 #置顶轮播图顺序，非负整数，数字越大越靠前--- 哔哩哔哩番剧页面 安装依赖 1npm install hexo-bilibili-bangumi --save 更新依赖库 1npm install hexo-bilibili-bangumi --update --save 注入哔哩哔哩番剧修改站点配置文件_config.yml，添加如下代码： 1234567bangumi: enable: true vmid: 321638084 title: &#x27;生命不息，追番不止。&#x27; quote: &#x27;Where there is life, there is life.&#x27; show: 1 loading: &#x27;/img/bangumi-loading.gif&#x27; 配置说明： enable: 是否启用 vmid: 哔哩哔哩番剧页面的 vmid(uid), 如何获取？ title: 该页面的标题 quote: 写在页面开头的一段话，支持 html 语法 show: 初始显示页面：0: 想看 , 1: 在看 , 2: 看过，默认为 1 loading: 图片加载完成前的 loading 图片 执行Docs命令前往博客根目录，打开cmd命令窗口执行hexo new page bangumis。 1hexo new page bangumis 找到 BlogRoot&#x2F;source&#x2F;bangumis&#x2F;index.md 这个文件，修改这个文件，添加 type: “bangumis”。 12345---title: bangumisdate: 2020-12-14 14:43:39type: &quot;bangumis&quot;--- 防止请求次数过多插件不再自动获取番剧数据，所以请根据自己的需要在hexo generate或hexo deploy之前使用hexo bangumi -u命令更新番剧数据。删除数据命令: hexo bangumi -d 获取 uid登录哔哩哔哩后前往 https://space.bilibili.com/xxx，网址最后的一串数字就是 uid。 侧边栏微博热搜前言 原文https://blog.eurkon.com/post/38b005e1.html 准备工作新建侧边栏 官方文档：https://butterfly.js.org/posts/ea33ab97/，想要了解更多可以查看这篇文章。 打开_data文件夹，创建一个widget.yml文件，在里面粘贴如下代码: 12345678# 这里填top表示所有地方都显示，bottom表示只在非文章页面显示，如主页等等bottom: - class_name: id_name: weibo name: 微博热搜 icon: fa-brands fa-weibo order: 1 html: &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/weibo.css&quot;&gt;&lt;div id=&quot;weiboContent&quot;&gt;&lt;img src=&quot;https://www.leonus.cn/img/loading.gif&quot;&gt;&lt;/div&gt;&lt;script src=&quot;/js/weibo.js&quot;&gt;&lt;/script&gt; # 注意这里，我放了一个加载图片，在加载之前会显示，你可以选择删除或者放一个加载图片。 创建weibo.css文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091.weibo-new &#123; background: #ff3852&#125;.weibo-hot &#123; background: #ff9406&#125;.weibo-jyzy &#123; background: #ffc000&#125;.weibo-recommend &#123; background: #00b7ee&#125;.weibo-adrecommend &#123; background: #febd22&#125;.weibo-friend &#123; background: #8fc21e&#125;.weibo-boom &#123; background: #bd0000&#125;.weibo-topic &#123; background: #ff6f49&#125;.weibo-topic-ad &#123; background: #4dadff&#125;.weibo-boil &#123; background: #f86400&#125;#weibo .item-content &#123; text-align: center;&#125;#weibo-container &#123; width: 100%; height: 140px; font-size: 95%; overflow-y: auto; -ms-overflow-style: none; scrollbar-width: none&#125;.weibo-list-item &#123; display: flex; flex-direction: row; justify-content: space-between; flex-wrap: nowrap&#125;.weibo-title &#123; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-right: auto&#125;.weibo-num &#123; float: right&#125;.weibo-hotness &#123; display: inline-block; padding: 0 6px; transform: scale(.8) translateX(-3px); color: #fff; border-radius: 8px&#125;#weibo-container a &#123; color: #555;&#125;[data-theme=&#x27;dark&#x27;] #weibo-container a &#123; color: rgba(255, 255, 255, 0.7);&#125;/* 隐藏滚动条 */#weibo-container::-webkit-scrollbar&#123; display: none;&#125; 创建weibo.js文件js方面有两种方式选择，各有利弊，根据自身情况选择 一、使用现成现成的vercel api，创建js文件就能用： 优点：直接用 缺点：速度慢，要加载两秒左右 创建weibo.js12345678910111213141516171819202122232425262728293031323334353637383940// 如果你开启了在手机端显示侧边栏，可以将下面这行代码注释，开启下面的weibo();try &#123; if (document.getElementById(&#x27;weibo&#x27;).clientWidth) weibo(); &#125; catch (error) &#123;&#125;// weibo();function weibo() &#123; let hotness = &#123; &#x27;爆&#x27;: &#x27;weibo-boom&#x27;, &#x27;热&#x27;: &#x27;weibo-hot&#x27;, &#x27;沸&#x27;: &#x27;weibo-boil&#x27;, &#x27;新&#x27;: &#x27;weibo-new&#x27;, &#x27;荐&#x27;: &#x27;weibo-recommend&#x27;, &#x27;影&#x27;: &#x27;weibo-jyzy&#x27;, &#x27;剧&#x27;: &#x27;weibo-jyzy&#x27;, &#x27;综&#x27;: &#x27;weibo-jyzy&#x27; &#125; let html = &#x27;&lt;div id=&quot;weibo-container&quot;&gt;&#x27; let data = JSON.parse(localStorage.getItem(&#x27;weibo&#x27;)); let nowTime = Date.now(); let ls; if (data == null || nowTime - data.time &gt; 600000) &#123; // 600000为缓存时间，即10分钟，避免频繁请求，加快本地访问速度。 getData(); return &#125; else &#123; ls = JSON.parse(data.ls) &#125;; for (let item of ls) &#123; html += &#x27;&lt;div class=&quot;weibo-list-item&quot;&gt;&lt;div class=&quot;weibo-hotness &#x27; + hotness[(item.hot || &#x27;荐&#x27;)] + &#x27;&quot;&gt;&#x27; + (item.hot || &#x27;荐&#x27;) + &#x27;&lt;/div&gt;&#x27; + &#x27;&lt;span class=&quot;weibo-title&quot;&gt;&lt;a title=&quot;&#x27; + item.title + &#x27;&quot;href=&quot;&#x27; + item.url + &#x27;&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer&quot;&gt;&#x27; + item.title + &#x27;&lt;/a&gt;&lt;/span&gt;&#x27; + &#x27;&lt;div class=&quot;weibo-num&quot;&gt;&lt;span&gt;&#x27; + item.num + &#x27;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&#x27; &#125; html += &#x27;&lt;/div&gt;&#x27;; document.getElementById(&#x27;weiboContent&#x27;).innerHTML = html;&#125;function getData() &#123; fetch(&#x27;https://weibo-top-api.vercel.app/api&#x27;).then(data =&gt; data.json()).then(data =&gt; &#123; data = &#123; time: Date.now(), ls: JSON.stringify(data) &#125; localStorage.setItem(&#x27;weibo&#x27;, JSON.stringify(data)) &#125;).then(weibo);&#125; 二、自建api 优点：速度快，只需要两百毫秒左右。 缺点：麻烦原作者是使用的python弄的，项目地址：https://github.com/Eurkon/weibo-top-api下面是node的，代码如下： 因为某某某访台的原因，微博炸了，api获取不到内容报错停了。于是增加了一个try catch让代码更的健壮，已在index代码内更新。如果你是使用的自建api，可以在前端weibo.js添加一个错误处理，如下： 12345678910function getData() &#123; fetch(&#x27;https://api.leonus.cn/weibo&#x27;).then(data =&gt; data.json()).then(data =&gt; &#123;+ if (data == &#x27;0&#x27;) &#123;+ document.getElementById(&#x27;weiboContent&#x27;).innerHTML = &#x27;获取微博热搜失败&#x27;+ return+ &#125; data = &#123; time: Date.now(), ls: JSON.stringify(data) &#125; localStorage.setItem(&#x27;weibo&#x27;, JSON.stringify(data)) &#125;).then(weibo);&#125; package.json12345678910111213&#123; &quot;name&quot;: &quot;api&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;node index.js&quot; &#125;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;@vercel/node&quot;: &quot;^2.4.4&quot;, &quot;axios&quot;: &quot;^0.27.2&quot;, &quot;express&quot;: &quot;^4.18.1&quot; &#125;&#125; index.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970const express = require(&#x27;express&#x27;);const axios = require(&#x27;axios&#x27;)const app = express()app.all(&#x27;*&#x27;, function(req, res, next) &#123; res.header(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); res.header(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;Content-Type&#x27;); res.header(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;*&#x27;); res.header(&#x27;Content-Type&#x27;, &#x27;application/json;charset=utf-8&#x27;); next();&#125;);app.get(&#x27;/weibo&#x27;, async(req, res) =&gt; &#123; try &#123; let data = await get_data(); res.send(data); &#125; catch (e) &#123; res.send(&#x27;0&#x27;); &#125;&#125;)async function get_data() &#123; let dataList = [] let &#123; data &#125; = await axios.get(&#x27;https://weibo.com/ajax/side/hotSearch&#x27;); let data_json = data.data.realtime let jyzy = &#123; &#x27;电影&#x27;: &#x27;影&#x27;, &#x27;剧集&#x27;: &#x27;剧&#x27;, &#x27;综艺&#x27;: &#x27;综&#x27;, &#x27;音乐&#x27;: &#x27;音&#x27; &#125;; for (let i = 0; i &lt; data_json.length; i++) &#123; let hot = &#x27;&#x27; if (&#x27;is_ad&#x27; in data_json[i] == true) &#123; continue; &#125; if (&#x27;flag_desc&#x27; in data_json[i] == true) &#123; hot = jyzy[data_json[i][&#x27;flag_desc&#x27;]] &#125; if (&#x27;is_boom&#x27; in data_json[i] == true) &#123; hot = &#x27;爆&#x27; &#125; if (&#x27;is_hot&#x27; in data_json[i] == true) &#123; hot = &#x27;热&#x27; &#125; if (&#x27;is_fei&#x27; in data_json[i] == true) &#123; hot = &#x27;沸&#x27; &#125; if (&#x27;is_new&#x27; in data_json[i] == true) &#123; hot = &#x27;新&#x27; &#125; let dic = &#123; &#x27;title&#x27;: data_json[i][&#x27;note&#x27;], &#x27;url&#x27;: &#x27;https://s.weibo.com/weibo?q=%23&#x27; + data_json[i][&#x27;word&#x27;] + &#x27;%23&#x27;, &#x27;num&#x27;: data_json[i][&#x27;num&#x27;], &#x27;hot&#x27;: hot &#125; dataList.push(dic) &#125; return dataList&#125;app.listen(3000) 部署到腾讯云打开宝塔面板，在wwwroot下新建一个目录，然后新建 index.js 和 package.json 并填写以上代码。 新建文件 建好之后切到网站页面，依次点击 node项目 &gt; 新建node项目，然后填写配置，没有node的先安装node。 项目目录：刚才创建的目录 项目端口：随意先一个不常用端口，别忘了放行。 绑定域名：随便绑一个你的域名，别忘了解析。建议申请并配置一下ssl，有的网站不能使用http。 其他：默认即可 配置node 提交之后等待包安装完成就行，新建完成之后你可以通过设置来配置管理项目。 创建weibo.js内容和上面直接使用vercel api的完全一样。只不过需要修改api地址，即：https://weibo-top-api.vercel.app/api改成https://你的域名/weibo 返回顶部阅读进度修改源码我们需要给按钮添加一个元素来存放内容，可以选择使用js插入，不过我还是觉得改源码简单方便。修改文件themes\\butterfly\\layout\\includes\\rightside.pug，在最下面插入如下两行代码（注意去掉前面的+号，别傻呼呼的直接复制粘贴） 1234button#go-up(type=&quot;button&quot; title=_p(&quot;rightside.back_to_top&quot;)) i.fas.fa-arrow-up+ span#percent 0+ span % 添加js在自定义js文件中加入如下代码： 1234567891011121314151617window.addEventListener(&#x27;scroll&#x27;,percent);// 执行函数// 页面百分比function percent() &#123; let a = document.documentElement.scrollTop || window.pageYOffset, // 卷去高度 b = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight) - document.documentElement.clientHeight, // 整个网页高度 result = Math.round(a / b * 100), // 计算百分比 up = document.querySelector(&quot;#go-up&quot;) // 获取按钮 if (result &lt;= 95) &#123; up.childNodes[0].style.display = &#x27;none&#x27; up.childNodes[1].style.display = &#x27;block&#x27; up.childNodes[1].innerHTML = result; &#125; else &#123; up.childNodes[1].style.display = &#x27;none&#x27; up.childNodes[0].style.display = &#x27;block&#x27; &#125;&#125; 添加css在自定义css文件中添加如下代码：(可以根据需求进行调整) 123456789101112131415161718192021/* 返回顶部 */button#go-up #percent &#123; display: none; font-weight: bold; font-size: 15px !important;&#125;button#go-up span &#123; font-size: 12px!important; margin-right: -1px;&#125;/* 鼠标滑动到按钮上时显示返回顶部图标 */button#go-up:hover i &#123; display: block !important;&#125;button#go-up:hover #percent &#123; display: none !important;&#125; 原理讲解实现原理其实很简单，我们只需要使用 被顶部卷去的高度 / (页面总高度 - 可视高度) ，既可算出百分比。之所以减去可视高度，是因为当我们在滑到最底部的时候，可以看出 页面高度 &#x3D; 被卷去的高度 + 可视高度 Butterfly右下角悬浮菜单栏魔改指南魔改文件路径：themes\\butterfly\\layout\\includes\\rightside.pug如果你有更实用的功能或者其他建议欢迎留言告知。 注意：部分代码中最前面的加号代表增加，减号代表删除，是为了高亮代码的，粘贴代码之后记得删除。删除之后不需要再补上一个空格，这样会出bug。 增加按钮首先我们需要添加按钮，在文件的一众when下面添加一个when。 1234567when &#x27;comment&#x27; if commentsJsLoad a#to_comment(href=&quot;#post-comment&quot; title=_p(&quot;rightside.scroll_to_comment&quot;)) i.fas.fa-comments+ when &#x27;xxxx&#x27;+ button(type=&quot;button&quot; title=&quot;测试按钮&quot;)+ i.fas.fa-xxx 然后在下面的数组里添加此项。在 hideArray 里面添加会在点击齿轮按钮之后显示，在 showArray 里面添加会直接显示，自己根据需要添加。 12345#rightside - const &#123; enable, hide, show &#125; = theme.rightside_item_order- - const hideArray = enable ? hide &amp;&amp; hide.split(&#x27;,&#x27;) : [&#x27;readmode&#x27;,&#x27;translate&#x27;,&#x27;darkmode&#x27;,&#x27;hideAside&#x27;]+ - const hideArray = enable ? hide &amp;&amp; hide.split(&#x27;,&#x27;) : [&#x27;readmode&#x27;,&#x27;translate&#x27;,&#x27;darkmode&#x27;,&#x27;hideAside&#x27;,&#x27;xxxx&#x27;] - const showArray = enable ? show &amp;&amp; show.split(&#x27;,&#x27;) : [&#x27;toc&#x27;,&#x27;chat&#x27;,&#x27;comment&#x27;] 进行排序主题提供了自定义排序，在主题配置文件搜索 rightside_item_order 即可。但我觉得既然都魔改了就没必要再两头麻烦了，直接在源码里面改就可以。排序方法很简单，直接更改数组即可（即 hideArray 和 showArray），渲染之后前面的在上，后面的在下。如：[‘toc’,’chat’,’comment’] 从上到下显示为：目录（手机），聊天室，评论 一些小问题当你的翻译、夜间模式或阅读模式没开启的时候，齿轮按钮可能会无法显示。如果想显示的话可以选择使用主题配置的排序或者像这样改一下源码： 1234567891011121314#rightside-config-show if enable if hide button#rightside_config(type=&quot;button&quot; title=_p(&quot;rightside.setting&quot;)) i.fas.fa-cog.fa-spin else if is_post() if (readmode || translate.enable || (darkmode.enable &amp;&amp; darkmode.button)) button#rightside_config(type=&quot;button&quot; title=_p(&quot;rightside.setting&quot;)) i.fas.fa-cog.fa-spin- else if translate.enable || (darkmode.enable &amp;&amp; darkmode.button)+ else if hideArray button#rightside_config(type=&quot;button&quot; title=_p(&quot;rightside.setting&quot;)) i.fas.fa-cog.fa-spin 功能下面列出一些适合添加在此处的功能按钮。 一、分享本页引入ClipboardJS:在主题配置文件inject下的bottom添加如下代码，注意要放在自定义js文件的上面： 12345678inject: head: bottom: # clipboard+ - &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js&quot;&gt;&lt;/script&gt; # 自定义js - &lt;script src=&quot;/js/xxx.js&quot;&gt;&lt;/script&gt; 添加按钮： 123456789+ when &#x27;share&#x27;+ button.share(type=&quot;button&quot; title=&#x27;分享链接&#x27; onclick=&quot;share()&quot;)+ i.fas.fa-share-nodes#rightside - const &#123; enable, hide, show &#125; = theme.rightside_item_order - const hideArray = enable ? hide &amp;&amp; hide.split(&#x27;,&#x27;) : [&#x27;readmode&#x27;,&#x27;translate&#x27;,&#x27;darkmode&#x27;]- - const showArray = enable ? show &amp;&amp; show.split(&#x27;,&#x27;) : [&#x27;chat&#x27;,&#x27;comment&#x27;,&#x27;hideAside&#x27;,&#x27;toc&#x27;]+ - const showArray = enable ? show &amp;&amp; show.split(&#x27;,&#x27;) : [&#x27;chat&#x27;,&#x27;share&#x27;,&#x27;comment&#x27;,&#x27;hideAside&#x27;,&#x27;toc&#x27;] 在自定义js文件中添加如下代码 123456// 分享本页function share() &#123; let url = window.location.origin + window.location.pathname new ClipboardJS(&quot;.share&quot;, &#123; text: function() &#123; return &#x27;标题：&#x27; + document.title + &#x27; 链接：&#x27; + url &#125; &#125;); btf.snackbarShow(&quot;本页链接已复制到剪切板，快去分享吧~&quot;)&#125; 二、直达底部添加如下代码即可： 12345button#go-up(type=&quot;button&quot; title=_p(&quot;rightside.back_to_top&quot;)) i.fas.fa-arrow-up+button#go-down(type=&quot;button&quot; title=&quot;直达底部&quot; onclick=&quot;btf.scrollToDest(document.body.scrollHeight, 500)&quot;)+ i.fas.fa-arrow-down 自定义右键菜单PUG部分 新建 [blogRoot]\\themes\\butterfly\\layout\\includes\\rightmenu.pug，编写以下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#rightMenu .rightMenu-group.rightMenu-small a.rightMenu-item(href=&quot;javascript:window.history.back();&quot;) i.fa.fa-arrow-left a.rightMenu-item(href=&quot;javascript:window.history.forward();&quot;) i.fa.fa-arrow-right a.rightMenu-item(href=&quot;javascript:window.location.reload();&quot;) i.fa.fa-refresh a.rightMenu-item(href=&quot;javascript:rmf.scrollToTop();&quot;) i.fa.fa-arrow-up .rightMenu-group.rightMenu-line.hide#menu-text a.rightMenu-item(href=&quot;javascript:rmf.copySelect();&quot;) i.fa.fa-copy span=&#x27;复制&#x27; a.rightMenu-item(href=&quot;javascript:window.open(\\&quot;https://www.baidu.com/s?wd=\\&quot;+window.getSelection().toString());window.location.reload();&quot;) i.iconfont.icon-baidu span=&#x27;百度搜索&#x27; .rightMenu-group.rightMenu-line.hide#menu-too a.rightMenu-item(href=&quot;javascript:window.open(window.getSelection().toString());window.location.reload();&quot;) i.fa.fa-link span=&#x27;转到链接&#x27; .rightMenu-group.rightMenu-line.hide#menu-paste a.rightMenu-item(href=&#x27;javascript:rmf.paste()&#x27;) i.fa.fa-copy span=&#x27;粘贴&#x27; .rightMenu-group.rightMenu-line.hide#menu-post a.rightMenu-item(href=&quot;#post-comment&quot;) i.fas.fa-comment span=&#x27;空降评论&#x27; a.rightMenu-item(href=&quot;javascript:rmf.copyWordsLink()&quot;) i.fa.fa-link span=&#x27;复制本文地址&#x27; .rightMenu-group.rightMenu-line.hide#menu-to a.rightMenu-item(href=&quot;javascript:rmf.openWithNewTab()&quot;) i.fa.fa-window-restore span=&#x27;新窗口打开&#x27; a.rightMenu-item#menu-too(href=&quot;javascript:rmf.open()&quot;) i.fa.fa-link span=&#x27;转到链接&#x27; a.rightMenu-item(href=&quot;javascript:rmf.copyLink()&quot;) i.fa.fa-copy span=&#x27;复制链接&#x27; .rightMenu-group.rightMenu-line.hide#menu-img a.rightMenu-item(href=&quot;./#post-comment&quot;) i.fa.fa-download span=&#x27;保存图片&#x27; a.rightMenu-item(href=&quot;javascript:rmf.openWithNewTab()&quot;) i.fa.fa-window-restore span=&#x27;在新窗口打开&#x27; a.rightMenu-item(href=&quot;javascript:rmf.click()&quot;) i.fa.fa-arrows-alt span=&#x27;全屏显示&#x27; a.rightMenu-item(href=&quot;javascript:rmf.copyLink()&quot;) i.fa.fa-copy span=&#x27;复制图片链接&#x27; .rightMenu-group.rightMenu-line a.rightMenu-item(href=&quot;javascript:toRandomPost()&quot;) i.fa.fa-paper-plane span=&#x27;随便逛逛&#x27; a.rightMenu-item(href=&quot;javascript:rmf.switchDarkMode();&quot;) i.fa.fa-moon span=&#x27;昼夜切换&#x27; a.rightMenu-item(href=&quot;javascript:rmf.translate();&quot;) i.iconfont.icon-fanti span=&#x27;繁简转换&#x27; if is_home()==false a.rightMenu-item(href=&quot;javascript:rmf.switchReadMode();&quot;) i.fa.fa-book span=&#x27;阅读模式&#x27; a.rightMenu-item(href=&quot;javascript:window.location.href=\\&quot;/about/\\&quot;;&quot;) i.fa.fa-info-circle span=&#x27;版权声明&#x27; 如果你加了评论弹幕的话，改为：（删掉+号，仅用作标记） 1234567891011121314151617 #rightMenu .rightMenu-group.rightMenu-small ... .rightMenu-group.rightMenu-line.hide#menu-paste a.rightMenu-item(href=&#x27;javascript:rmf.paste()&#x27;) i.fa.fa-copy span=&#x27;粘贴&#x27; .rightMenu-group.rightMenu-line.hide#menu-post ...+ a.rightMenu-item(href=&quot;javascript:switchCommentBarrage()&quot;)+ i.fa.fa-bell-slash+ span=&#x27;开/关评论弹幕&#x27; a.rightMenu-item(href=&quot;javascript:rmf.copyWordsLink()&quot;) i.fa.fa-link span=&#x27;复制本文地址&#x27; .rightMenu-group.rightMenu-line.hide#menu-to ... 然后在 [blogRoot]&#x2F;themes&#x2F;butterfly&#x2F;layout&#x2F;includes&#x2F;layout.pug中引入（注意缩进，去掉+） 1234567891011121314doctype htmlhtml(lang=config.language data-theme=theme.display_mode class=htmlClassHideAside) head include ./head.pug body ... else include ./404.pug include ./rightside.pug !=partial(&#x27;includes/third-party/search/index&#x27;, &#123;&#125;, &#123;cache: true&#125;)+ !=partial(&#x27;includes/rightmenu&#x27;,&#123;&#125;, &#123;cache:true&#125;) include ./additional-js.pug CSS部分 新建 [blogRoot]&#x2F;themes&#x2F;butterfly&#x2F;source&#x2F;css&#x2F;rightmenu.css 编辑以下内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* rightMenu */#rightMenu&#123; display: none; position: fixed; width: 160px; height: fit-content; top: 10%; left: 10%; background-color: var(--card-bg); border: 1px solid var(--font-color); border-radius: 8px; z-index: 100;&#125;#rightMenu .rightMenu-group&#123; padding: 7px 6px;&#125;#rightMenu .rightMenu-group:not(:nth-last-child(1))&#123; border-bottom: 1px solid var(--font-color);&#125;#rightMenu .rightMenu-group.rightMenu-small&#123; display: flex; justify-content: space-between;&#125;#rightMenu .rightMenu-group .rightMenu-item&#123; height: 30px; line-height: 30px; border-radius: 8px; transition: 0.3s; color: var(--font-color);&#125;#rightMenu .rightMenu-group.rightMenu-line .rightMenu-item&#123; display: flex; height: 40px; line-height: 40px; padding: 0 4px;&#125;#rightMenu .rightMenu-group .rightMenu-item:hover&#123; background-color: var(--text-bg-hover);&#125;#rightMenu .rightMenu-group .rightMenu-item i&#123; display: inline-block; text-align: center; line-height: 30px; width: 30px; height: 30px; padding: 0 5px;&#125;#rightMenu .rightMenu-group .rightMenu-item span&#123; line-height: 30px;&#125;#rightMenu .rightMenu-group.rightMenu-line .rightMenu-item *&#123; height: 40px; line-height: 40px;&#125;.rightMenu-group.hide&#123; display: none;&#125; 以下是dorakika的原版css，你也可以试试我的版本，不保证完全可用： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/* rightMenu */[data-theme=&#x27;light&#x27;] #rightMenu&#123; display: none; position: fixed; width: 160px; height: fit-content; top: 10%; left: 10%; background-color: var(--card-bg); border: 1px solid rgb(210,210,210);; border-radius: 8px; z-index: 100; box-shadow: 3px 3px 5px #88888894; background-color: var(--lyx-white-acrylic1); backdrop-filter: blur(30px);&#125;[data-theme=&#x27;dark&#x27;] #rightMenu&#123; display: none; position: fixed; width: 160px; height: fit-content; top: 10%; left: 10%; background-color: var(--card-bg); border: 1px solid rgb(210,210,210);; border-radius: 8px; z-index: 100; box-shadow: 3px 3px 5px #88888894; background-color: var(--lyx-black-acrylic1); backdrop-filter: blur(30px);&#125;#rightMenu .rightMenu-group&#123; padding: 7px 6px;&#125;#rightMenu .rightMenu-group:not(:nth-last-child(1))&#123; border-bottom: 1px solid rgb(180,180,180);&#125;#rightMenu .rightMenu-group.rightMenu-small&#123; display: flex; justify-content: space-between;&#125;#rightMenu .rightMenu-group .rightMenu-item&#123; height: 30px; line-height: 30px; border-radius: 8px; transition: 0.3s; color: var(--font-color);&#125;#rightMenu .rightMenu-group.rightMenu-line .rightMenu-item&#123; display: flex; height: 40px; line-height: 40px; padding: 0 4px;&#125;#rightMenu .rightMenu-group .rightMenu-item:hover&#123; background-color: var(--text-bg-hover); box-shadow: 0px 0px 5px var(--lyx-border);&#125;#rightMenu .rightMenu-group .rightMenu-item i&#123; display: inline-block; text-align: center; line-height: 30px; width: 30px; height: 30px; padding: 0 5px;&#125;#rightMenu .rightMenu-group .rightMenu-item span&#123; line-height: 30px;&#125;#rightMenu:hover&#123; border: 1px solid var(--lyx-blue); /* box-shadow:0 0 3px var(--lyx-blue)!important; */&#125;#rightMenu .rightMenu-group.rightMenu-line .rightMenu-item *&#123; height: 40px; line-height: 40px;&#125;.rightMenu-group.hide&#123; display: none;&#125;.rightMenu-item:hover&#123; color:white!important; background-color:var(--lyx-blue)!important;&#125;:root&#123; --lyx-border:#c9c9c9; --lyx-blue:#6cf; --lyx-gray:#e2e2e2; --lyx-theme:#6cf; --lyx-green:#39c5bb; --lyx-black-acrylic1: #0008; --lyx-black-acrylic2: #000a; --lyx-black-acrylic3:#00000099; --lyx-black:black; --lyx-white:white; --lyx-white-acrylic1:#fffd; --lyx-white-acrylic2:#fffa; --lyx-blackgray:#797979; --lyx-0:#0000; --lyx-scrollbar: #acacacDD;&#125; 然后在主题配置文件中引入： 123456inject: head: - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/rightmenu.css&quot;&gt; - ... bottom: - ... iconfont图标 因为少部分图标使用iconfont，你需要自己添加，下载iconfont图标包，然后解压把里面的东西扔到 [blogRoot]/themes/butterfly/source/css里面即可 https://xydc.lanzouv.com/iRlu409ouaba然后在主题配置文件中引入： 123456inject: head: - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/iconfont.css&quot;&gt; - ... bottom: - ... JS部分 创建 [blogRoot]/themes/butterfly/source/js/rightmenu.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242console.log( &quot;Codes uses GPL Licence&quot;)function insertAtCursor(myField, myValue) &#123; //IE 浏览器 if (document.selection) &#123; myField.focus(); sel = document.selection.createRange(); sel.text = myValue; sel.select(); &#125; //FireFox、Chrome等 else if (myField.selectionStart || myField.selectionStart == &#x27;0&#x27;) &#123; var startPos = myField.selectionStart; var endPos = myField.selectionEnd; // 保存滚动条 var restoreTop = myField.scrollTop; myField.value = myField.value.substring(0, startPos) + myValue + myField.value.substring(endPos, myField.value.length); if (restoreTop &gt; 0) &#123; myField.scrollTop = restoreTop; &#125; myField.focus(); myField.selectionStart = startPos + myValue.length; myField.selectionEnd = startPos + myValue.length; &#125; else &#123; myField.value += myValue; myField.focus(); &#125;&#125;let rmf = &#123;&#125;;rmf.showRightMenu = function (isTrue, x = 0, y = 0) &#123; let $rightMenu = $(&#x27;#rightMenu&#x27;); $rightMenu.css(&#x27;top&#x27;, x + &#x27;px&#x27;).css(&#x27;left&#x27;, y + &#x27;px&#x27;); if (isTrue) &#123; $rightMenu.show(); &#125; else &#123; $rightMenu.hide(); &#125;&#125;rmf.switchDarkMode = function () &#123; const nowMode = document.documentElement.getAttribute(&#x27;data-theme&#x27;) === &#x27;dark&#x27; ? &#x27;dark&#x27; : &#x27;light&#x27; if (nowMode === &#x27;light&#x27;) &#123; activateDarkMode() saveToLocal.set(&#x27;theme&#x27;, &#x27;dark&#x27;, 2) GLOBAL_CONFIG.Snackbar !== undefined &amp;&amp; btf.snackbarShow(GLOBAL_CONFIG.Snackbar.day_to_night) &#125; else &#123; activateLightMode() saveToLocal.set(&#x27;theme&#x27;, &#x27;light&#x27;, 2) GLOBAL_CONFIG.Snackbar !== undefined &amp;&amp; btf.snackbarShow(GLOBAL_CONFIG.Snackbar.night_to_day) &#125; // handle some cases typeof utterancesTheme === &#x27;function&#x27; &amp;&amp; utterancesTheme() typeof FB === &#x27;object&#x27; &amp;&amp; window.loadFBComment() window.DISQUS &amp;&amp; document.getElementById(&#x27;disqus_thread&#x27;).children.length &amp;&amp; setTimeout(() =&gt; window.disqusReset(), 200)&#125;;rmf.copyWordsLink = function () &#123; let url = window.location.href let txa = document.createElement(&quot;textarea&quot;); txa.value = url; document.body.appendChild(txa) txa.select(); document.execCommand(&quot;Copy&quot;); document.body.removeChild(txa); Swal.fire(&quot;复制成功！&quot;);&#125;rmf.switchReadMode = function () &#123; const $body = document.body $body.classList.add(&#x27;read-mode&#x27;) const newEle = document.createElement(&#x27;button&#x27;) newEle.type = &#x27;button&#x27; newEle.className = &#x27;fas fa-sign-out-alt exit-readmode&#x27; $body.appendChild(newEle) function clickFn() &#123; $body.classList.remove(&#x27;read-mode&#x27;) newEle.remove() newEle.removeEventListener(&#x27;click&#x27;, clickFn) &#125; newEle.addEventListener(&#x27;click&#x27;, clickFn)&#125;//复制选中文字rmf.copySelect = function () &#123; document.execCommand(&#x27;Copy&#x27;, false, null); //这里可以写点东西提示一下 已复制&#125;//回到顶部rmf.scrollToTop = function () &#123; btf.scrollToDest(0, 500);&#125;rmf.translate = function () &#123; document.getElementById(&quot;translateLink&quot;).click();&#125;// 右键菜单事件document.onkeydown = function (event) &#123; event = (event || window.event); if (event.keyCode == 17) &#123; console.log(&quot;你知道的太多了&quot;); return; &#125;&#125;function popupMenu() &#123; //window.oncontextmenu=function()&#123;return false;&#125; window.oncontextmenu = function (event) &#123; if(event.ctrlKey)return true; console.log(event.keyCode) $(&#x27;.rightMenu-group.hide&#x27;).hide(); //如果有文字选中，则显示 文字选中相关的菜单项 if (document.getSelection().toString()) &#123; $(&#x27;#menu-text&#x27;).show(); &#125; if (document.getElementById(&#x27;post&#x27;)) &#123; $(&#x27;#menu-post&#x27;).show(); &#125; else &#123; if (document.getElementById(&#x27;page&#x27;)) &#123; $(&#x27;#menu-post&#x27;).show(); &#125; &#125; var el = window.document.body; el = event.target; var a=/^(?:http(s)?:\\/\\/)?[\\w.-]+(?:\\.[\\w\\.-]+)+[\\w\\-\\._~:/?#[\\]@!\\$&amp;&#x27;\\*\\+,;=.]+$/ if (a.test(window.getSelection().toString()))&#123; $(&#x27;#menu-too&#x27;).show() &#125; if (el.tagName == &#x27;A&#x27;) &#123; $(&#x27;#menu-to&#x27;).show() rmf.open = function () &#123; location.href = el.href &#125; rmf.openWithNewTab = function () &#123; window.open(el.href); &#125; rmf.copyLink = function () &#123; let url = el.href let txa = document.createElement(&quot;textarea&quot;); txa.value = url; document.body.appendChild(txa) txa.select(); document.execCommand(&quot;Copy&quot;); document.body.removeChild(txa); &#125; &#125; if (el.tagName == &#x27;IMG&#x27;) &#123; $(&#x27;#menu-img&#x27;).show() rmf.openWithNewTab = function () &#123; window.open(el.src); &#125; rmf.click = function () &#123; el.click() &#125; rmf.copyLink = function () &#123; let url = el.src let txa = document.createElement(&quot;textarea&quot;); txa.value = url; document.body.appendChild(txa) txa.select(); document.execCommand(&quot;Copy&quot;); document.body.removeChild(txa); &#125; &#125; else if (el.tagName == &quot;TEXTAREA&quot; || el.tagName == &quot;INPUT&quot;) &#123; $(&#x27;#menu-paste&#x27;).show(); rmf.paste = function () &#123; navigator.permissions .query(&#123; name: &#x27;clipboard-read&#x27; &#125;) .then(result =&gt; &#123; if (result.state == &#x27;granted&#x27; || result.state == &#x27;prompt&#x27;) &#123; //读取剪贴板 navigator.clipboard.readText().then(text =&gt; &#123; console.log(text) insertAtCursor(el, text) &#125;) &#125; else &#123; alert(&#x27;请允许读取剪贴板！&#x27;) &#125; &#125;) &#125; &#125; let pageX = event.clientX + 10; let pageY = event.clientY; let rmWidth = $(&#x27;#rightMenu&#x27;).width(); let rmHeight = $(&#x27;#rightMenu&#x27;).height(); if (pageX + rmWidth &gt; window.innerWidth) &#123; pageX -= rmWidth + 10; &#125; if (pageY + rmHeight &gt; window.innerHeight) &#123; pageY -= pageY + rmHeight - window.innerHeight; &#125; rmf.showRightMenu(true, pageY, pageX); return false; &#125;; window.addEventListener(&#x27;click&#x27;, function () &#123; rmf.showRightMenu(false); &#125;);&#125;if (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) &#123; popupMenu()&#125;const box = document.documentElementfunction addLongtabListener(target, callback) &#123; let timer = 0 // 初始化timer target.ontouchstart = () =&gt; &#123; timer = 0 // 重置timer timer = setTimeout(() =&gt; &#123; callback(); timer = 0 &#125;, 380) // 超时器能成功执行，说明是长按 &#125; target.ontouchmove = () =&gt; &#123; clearTimeout(timer) // 如果来到这里，说明是滑动 timer = 0 &#125; target.ontouchend = () =&gt; &#123; // 到这里如果timer有值，说明此触摸时间不足380ms，是点击 if (timer) &#123; clearTimeout(timer) &#125; &#125;&#125;addLongtabListener(box, popupMenu) 因为这个js依赖于jquery，所以还需要引入jquery，在主题配置文件中引入： 12345678inject: head: - ... bottom: - ... - &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn1.tianli0.top/npm/jquery@latest/dist/jquery.min.js&quot;&gt;&lt;/script&gt; - &lt;script type=&quot;text/javascript&quot; src=&quot;/js/rightmenu.js&quot;&gt;&lt;/script&gt; - ... 然后你就拥有了一个好看且功能丰富的右键菜单了！ 添加访客信息欢迎卡片注册腾讯位置服务注册腾讯位置服务 创建应用 到应用管理 - 我的应用界面点击 +创建应用，然后名称类型随便填 这里的白名单填不填都行，省事就不填, 冰糖建议填一下 防止别人调用。 获取 key 值完事之后就可以获取自己的 key 了，这个保存好，一会要用！ 创建 js 在目录 Blogroot (博客所在根目录)\\source\\js 下创建 txmap.js, 插入以下代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225//get请求$.ajax(&#123; type: &#x27;get&#x27;, url: &#x27;https://apis.map.qq.com/ws/location/v1/ip&#x27;, data: &#123; // 你的腾讯位置key key: &#x27;你的腾讯位置key&#x27;, output: &#x27;jsonp&#x27;, &#125;, dataType: &#x27;jsonp&#x27;, success: function (res) &#123; ipLoacation = res; &#125;&#125;)function getDistance(e1, n1, e2, n2) &#123; const R = 6371 const &#123; sin, cos, asin, PI, hypot &#125; = Math let getPoint = (e, n) =&gt; &#123; e *= PI / 180 n *= PI / 180 return &#123; x: cos(n) * cos(e), y: cos(n) * sin(e), z: sin(n) &#125; &#125; let a = getPoint(e1, n1) let b = getPoint(e2, n2) let c = hypot(a.x - b.x, a.y - b.y, a.z - b.z) let r = asin(c / 2) * 2 * R return Math.round(r);&#125;function showWelcome() &#123; // //这里换成自己的经纬度 let dist = getDistance(103.926842,30.596172, ipLoacation.result.location.lng, ipLoacation.result.location.lat); let pos = ipLoacation.result.ad_info.nation; let ip; let posdesc; //根据国家、省份、城市信息自定义欢迎语 switch (ipLoacation.result.ad_info.nation) &#123; case &quot;日本&quot;: posdesc = &quot;よろしく，一起去看樱花吗&quot;; break; case &quot;美国&quot;: posdesc = &quot;Let us live in peace!&quot;; break; case &quot;英国&quot;: posdesc = &quot;想同你一起夜乘伦敦眼&quot;; break; case &quot;俄罗斯&quot;: posdesc = &quot;干了这瓶伏特加！&quot;; break; case &quot;法国&quot;: posdesc = &quot;C&#x27;est La Vie&quot;; break; case &quot;德国&quot;: posdesc = &quot;Die Zeit verging im Fluge.&quot;; break; case &quot;澳大利亚&quot;: posdesc = &quot;一起去大堡礁吧！&quot;; break; case &quot;加拿大&quot;: posdesc = &quot;拾起一片枫叶赠予你&quot;; break; case &quot;中国&quot;: pos = ipLoacation.result.ad_info.province + &quot; &quot; + ipLoacation.result.ad_info.city + &quot; &quot; +ipLoacation.result.ad_info.district; ip = ipLoacation.result.ip; switch (ipLoacation.result.ad_info.province) &#123; case &quot;北京市&quot;: posdesc = &quot;北——京——欢迎你~~~&quot;; break; case &quot;天津市&quot;: posdesc = &quot;讲段相声吧。&quot;; break; case &quot;河北省&quot;: posdesc = &quot;山势巍巍成壁垒，天下雄关。铁马金戈由此向，无限江山。&quot;; break; case &quot;山西省&quot;: posdesc = &quot;展开坐具长三尺，已占山河五百余。&quot;; break; case &quot;内蒙古自治区&quot;: posdesc = &quot;天苍苍，野茫茫，风吹草低见牛羊。&quot;; break; case &quot;辽宁省&quot;: posdesc = &quot;我想吃烤鸡架！&quot;; break; case &quot;吉林省&quot;: posdesc = &quot;状元阁就是东北烧烤之王。&quot;; break; case &quot;黑龙江省&quot;: posdesc = &quot;很喜欢哈尔滨大剧院。&quot;; break; case &quot;上海市&quot;: posdesc = &quot;众所周知，中国只有两个城市。&quot;; break; case &quot;江苏省&quot;: switch (ipLoacation.result.ad_info.city) &#123; case &quot;南京市&quot;: posdesc = &quot;这是我挺想去的城市啦。&quot;; break; case &quot;苏州市&quot;: posdesc = &quot;上有天堂，下有苏杭。&quot;; break; default: posdesc = &quot;散装是必须要散装的。&quot;; break; &#125; break; case &quot;浙江省&quot;: posdesc = &quot;东风渐绿西湖柳，雁已还人未南归。&quot;; break; case &quot;河南省&quot;: switch (ipLoacation.result.ad_info.city) &#123; case &quot;郑州市&quot;: posdesc = &quot;豫州之域，天地之中。&quot;; break; case &quot;南阳市&quot;: posdesc = &quot;臣本布衣，躬耕于南阳。此南阳非彼南阳！&quot;; break; case &quot;驻马店市&quot;: posdesc = &quot;峰峰有奇石，石石挟仙气。嵖岈山的花很美哦！&quot;; break; case &quot;开封市&quot;: posdesc = &quot;刚正不阿包青天。&quot;; break; case &quot;洛阳市&quot;: posdesc = &quot;洛阳牡丹甲天下。&quot;; break; default: posdesc = &quot;可否带我品尝河南烩面啦？&quot;; break; &#125; break; case &quot;安徽省&quot;: posdesc = &quot;蚌埠住了，芜湖起飞。&quot;; break; case &quot;福建省&quot;: posdesc = &quot;井邑白云间，岩城远带山。&quot;; break; case &quot;江西省&quot;: posdesc = &quot;落霞与孤鹜齐飞，秋水共长天一色。&quot;; break; case &quot;山东省&quot;: posdesc = &quot;遥望齐州九点烟，一泓海水杯中泻。&quot;; break; case &quot;湖北省&quot;: posdesc = &quot;来碗热干面！&quot;; break; case &quot;湖南省&quot;: posdesc = &quot;74751，长沙斯塔克。&quot;; break; case &quot;广东省&quot;: posdesc = &quot;老板来两斤福建人。&quot;; break; case &quot;广西壮族自治区&quot;: posdesc = &quot;桂林山水甲天下。&quot;; break; case &quot;海南省&quot;: posdesc = &quot;朝观日出逐白浪，夕看云起收霞光。&quot;; break; case &quot;四川省&quot;: posdesc = &quot;康康川妹子。&quot;; break; case &quot;贵州省&quot;: posdesc = &quot;茅台，学生，再塞200。&quot;; break; case &quot;云南省&quot;: posdesc = &quot;玉龙飞舞云缠绕，万仞冰川直耸天。&quot;; break; case &quot;西藏自治区&quot;: posdesc = &quot;躺在茫茫草原上，仰望蓝天。&quot;; break; case &quot;陕西省&quot;: posdesc = &quot;来份臊子面加馍。&quot;; break; case &quot;甘肃省&quot;: posdesc = &quot;羌笛何须怨杨柳，春风不度玉门关。&quot;; break; case &quot;青海省&quot;: posdesc = &quot;牛肉干和老酸奶都好好吃。&quot;; break; case &quot;宁夏回族自治区&quot;: posdesc = &quot;大漠孤烟直，长河落日圆。&quot;; break; case &quot;新疆维吾尔自治区&quot;: posdesc = &quot;驼铃古道丝绸路，胡马犹闻唐汉风。&quot;; break; case &quot;台湾省&quot;: posdesc = &quot;我在这头，大陆在那头。&quot;; break; case &quot;香港特别行政区&quot;: posdesc = &quot;永定贼有残留地鬼嚎，迎击光非岁玉。&quot;; break; case &quot;澳门特别行政区&quot;: posdesc = &quot;性感荷官，在线发牌。&quot;; break; default: posdesc = &quot;带我去你的城市逛逛吧！&quot;; break; &#125; break; default: posdesc = &quot;带我去你的国家逛逛吧。&quot;; break; &#125; //根据本地时间切换欢迎语 let timeChange; let date = new Date(); if (date.getHours()&gt;= 5 &amp;&amp; date.getHours() &lt; 11) timeChange = &quot;&lt;span&gt;上午好&lt;/span&gt;，一日之计在于晨！&quot;; else if (date.getHours()&gt;= 11 &amp;&amp; date.getHours() &lt; 13) timeChange = &quot;&lt;span&gt;中午好&lt;/span&gt;，该摸鱼吃午饭了。&quot;; else if (date.getHours() &gt;= 13 &amp;&amp; date.getHours() &lt; 15) timeChange = &quot;&lt;span&gt;下午好&lt;/span&gt;，懒懒地睡个午觉吧！&quot;; else if (date.getHours() &gt;= 15 &amp;&amp; date.getHours() &lt; 16) timeChange = &quot;&lt;span&gt;三点几啦&lt;/span&gt;，一起饮茶呀！&quot;; else if (date.getHours() &gt;= 16 &amp;&amp; date.getHours() &lt; 19) timeChange = &quot;&lt;span&gt;夕阳无限好！&lt;/span&gt;&quot;; else if (date.getHours() &gt;= 19 &amp;&amp; date.getHours() &lt; 24) timeChange = &quot;&lt;span&gt;晚上好&lt;/span&gt;，夜生活嗨起来！&quot;; else timeChange = &quot;夜深了，早点休息，少熬夜。&quot;; //自定义文本和需要放的位置 document.getElementById(&quot;welcome-info&quot;).innerHTML = `&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 欢迎来自&lt;span&gt;$&#123;pos&#125;&lt;/span&gt;的小伙伴，$&#123;timeChange&#125;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 您距离&lt;span&gt;冰糖&lt;/span&gt;约有&lt;span&gt;$&#123;dist&#125;&lt;/span&gt;公里，您的IP为：$&#123;ip&#125;,$&#123;posdesc&#125;`;&#125;window.onload = showWelcome;// 如果使用了pjax在加上下面这行代码document.addEventListener(&#x27;pjax:complete&#x27;, showWelcome);console.log(&#x27;加载成功&#x27;); 创建 css这里我是放在了公告栏里，如果不放公告栏可以不加这个 css👻在目录 Blogroot (博客所在根目录)\\source\\css 下创建txmap.css,插入以下代码。当然也阔以自己写啦！&#96; 12345678910/* 公告栏突出颜色 */:root &#123; --NotNoneX-color: #666999;&#125;.card-announcement span&#123; font-weight:bold; font-size:15px!important; color:var(--NotNoneX-color);&#125; 引入 js、css 和 jq js 和 jq 在 inject 的 bottom 下引入 123#访客信息- &lt;script src=&quot;/js/jquery-3.6.1.min.js&quot;&gt;&lt;/script&gt;- &lt;script src=&quot;/js/nkt_txmap.js&quot;&gt;&lt;/script&gt; css 在 inject 的 head 下引入 1- &lt;link href=&quot;/css/nkt_txmap.css&quot;&gt; 下载 jq 文件 随便搜索一下就有了 将语句放在要展示的位置以公告栏为例 pug文件具有严格缩进，直接删除 + 就好…&#x2F;themes&#x2F;butterfly&#x2F;layout&#x2F;includes&#x2F;widget&#x2F;card_announcement.pug 1234567if theme.aside.card_announcement.enable .card-widget.card-announcement .item-headline i.fas.fa-bullhorn.fa-shake span= _p(&#x27;aside.card_announcement&#x27;) .announcement_content!= theme.aside.card_announcement.content+ #welcome-info 更推荐直接主题配置文件在公告部分写一个&lt;div id=&quot;welcome-info&quot;&gt;Welcome&lt;/div&gt; 这样就可以不用修改主题 摸鱼中…","tags":["Hexo","Butterfly"],"categories":["Hexo"]},{"title":"Hexo魔改教程(二)","path":"/posts/e6801bab.html","content":"外挂标签引入详见：Tag Plugins Plus 安装插件，在博客根目录 [Blogroot] 下打开终端，运行以下指令： 12BASHnpm install hexo-butterfly-tag-plugins-plus --save 考虑到 hexo 自带的 markdown 渲染插件 hexo-renderer-marked 与外挂标签语法的兼容性较差，建议您将其替换成 hexo-renderer-kramed 123BASHnpm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save 添加配置信息，以下为写法示例在站点配置文件_config.yml 或者主题配置文件_config.butterfly.yml 中添加 123456789101112131415# tag-plugins-plus# see https://akilar.top/posts/615e2dec/tag_plugins: enable: true # 开关 priority: 5 #过滤器优先权 issues: false #issues标签依赖注入开关 link: placeholder: /img/link.png #link_card标签默认的图标图片 CDN: anima: https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css #动画标签anima的依赖 jquery: https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js #issues标签依赖 issues: https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/issues.js #issues标签依赖 iconfont: //at.alicdn.com/t/font_2032782_8d5kxvn09md.js #参看https://akilar.top/posts/d2ebecef/ carousel: https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js tag_plugins_css: https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css 参数释义 参数 备选值 &#x2F; 类型 释义 enable true&#x2F;false 【必选】控制开关 priority number 【可选】过滤器优先级，数值越小，执行越早，默认为 10，选填 issues true&#x2F;false 【可选】issues 标签控制开关，默认为 false link.placeholder 【必选】link 卡片外挂标签的默认图标 CDN.anima URL 【可选】动画标签 anima 的依赖 CDN.jquery URL 【可选】issues 标签依赖 CDN.issues URL 【可选】issues 标签依赖 CDN.iconfont URL 【可选】iconfont 标签 symbol 样式引入，如果不想引入，则设为 false CDN.carousel URL 【可选】carousel 旋转相册标签鼠标拖动依赖，如果不想引入则设为 false CDN.tag_plugins_css URL 【可选】外挂标签样式的 CSS 依赖，为避免 CDN 缓存延迟，建议将 @latest 改为具体版本号 具体样式和写法可见：Markdown 语法与外挂标签写法汇总 鼠标效果 新建文件 [BlogRoot]\\source\\js\\cursor.js，在里面写上如下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283var CURSOR;Math.lerp = (a, b, n) =&gt; (1 - n) * a + n * b;const getStyle = (el, attr) =&gt; &#123; try &#123; return window.getComputedStyle ? window.getComputedStyle(el)[attr] : el.currentStyle[attr]; &#125; catch (e) &#123;&#125; return &quot;&quot;;&#125;;class Cursor &#123; constructor() &#123; this.pos = &#123;curr: null, prev: null&#125;; this.pt = []; this.create(); this.init(); this.render(); &#125; move(left, top) &#123; this.cursor.style[&quot;left&quot;] = `$&#123;left&#125;px`; this.cursor.style[&quot;top&quot;] = `$&#123;top&#125;px`; &#125; create() &#123; if (!this.cursor) &#123; this.cursor = document.createElement(&quot;div&quot;); this.cursor.id = &quot;cursor&quot;; this.cursor.classList.add(&quot;hidden&quot;); document.body.append(this.cursor); &#125; var el = document.getElementsByTagName(&#x27;*&#x27;); for (let i = 0; i &lt; el.length; i++) if (getStyle(el[i], &quot;cursor&quot;) == &quot;pointer&quot;) this.pt.push(el[i].outerHTML); document.body.appendChild((this.scr = document.createElement(&quot;style&quot;))); // 这里改变鼠标指针的颜色 由svg生成 this.scr.innerHTML = `* &#123;cursor: url(&quot;data:image/svg+xml,&lt;svg xmlns=&#x27;http://www.w3.org/2000/svg&#x27; viewBox=&#x27;0 0 8 8&#x27; width=&#x27;8px&#x27; height=&#x27;8px&#x27;&gt;&lt;circle cx=&#x27;4&#x27; cy=&#x27;4&#x27; r=&#x27;4&#x27; opacity=&#x27;.5&#x27;/&gt;&lt;/svg&gt;&quot;) 4 4, auto&#125;`; &#125; refresh() &#123; this.scr.remove(); this.cursor.classList.remove(&quot;hover&quot;); this.cursor.classList.remove(&quot;active&quot;); this.pos = &#123;curr: null, prev: null&#125;; this.pt = []; this.create(); this.init(); this.render(); &#125; init() &#123; document.onmouseover = e =&gt; this.pt.includes(e.target.outerHTML) &amp;&amp; this.cursor.classList.add(&quot;hover&quot;); document.onmouseout = e =&gt; this.pt.includes(e.target.outerHTML) &amp;&amp; this.cursor.classList.remove(&quot;hover&quot;); document.onmousemove = e =&gt; &#123;(this.pos.curr == null) &amp;&amp; this.move(e.clientX - 8, e.clientY - 8); this.pos.curr = &#123;x: e.clientX - 8, y: e.clientY - 8&#125;; this.cursor.classList.remove(&quot;hidden&quot;);&#125;; document.onmouseenter = e =&gt; this.cursor.classList.remove(&quot;hidden&quot;); document.onmouseleave = e =&gt; this.cursor.classList.add(&quot;hidden&quot;); document.onmousedown = e =&gt; this.cursor.classList.add(&quot;active&quot;); document.onmouseup = e =&gt; this.cursor.classList.remove(&quot;active&quot;); &#125; render() &#123; if (this.pos.prev) &#123; this.pos.prev.x = Math.lerp(this.pos.prev.x, this.pos.curr.x, 0.15); this.pos.prev.y = Math.lerp(this.pos.prev.y, this.pos.curr.y, 0.15); this.move(this.pos.prev.x, this.pos.prev.y); &#125; else &#123; this.pos.prev = this.pos.curr; &#125; requestAnimationFrame(() =&gt; this.render()); &#125;&#125;(() =&gt; &#123; CURSOR = new Cursor(); // 需要重新获取列表时，使用 CURSOR.refresh()&#125;)(); 其中比较重要的参数就是鼠标的尺寸和颜色，已经在上图中标出，目前发现颜色只支持 RGB 写法和固有名称写法（例如 red 这种），其他参数也可以自行摸索： 1* &#123;cursor: url(&quot;data:image/svg+xml,&lt;svg xmlns=&#x27;http://www.w3.org/2000/svg&#x27; viewBox=&#x27;0 0 8 8&#x27; width=&#x27;8px&#x27; height=&#x27;8px&#x27;&gt;&lt;circle cx=&#x27;4&#x27; cy=&#x27;4&#x27; r=&#x27;4&#x27; opacity=&#x27;1.0&#x27; fill=&#x27;rgb(57, 197, 187)&#x27;/&gt;&lt;/svg&gt;&quot;) 4 4, auto&#125;` 在 [BlogRoot]\\source\\css\\custom.css 添加如下代码： 123456789101112131415161718192021222324252627282930313233343536/* 鼠标样式 */#cursor &#123; position: fixed; width: 16px; height: 16px; /* 这里改变跟随的底色 */ background: var(--theme-color); border-radius: 8px; opacity: 0.25; z-index: 10086; pointer-events: none; transition: 0.2s ease-in-out; transition-property: background, opacity, transform;&#125;#cursor.hidden &#123; opacity: 0;&#125;#cursor.hover &#123; opacity: 0.1; transform: scale(2.5); -webkit-transform: scale(2.5); -moz-transform: scale(2.5); -ms-transform: scale(2.5); -o-transform: scale(2.5);&#125;#cursor.active &#123; opacity: 0.5; transform: scale(0.5); -webkit-transform: scale(0.5); -moz-transform: scale(0.5); -ms-transform: scale(0.5); -o-transform: scale(0.5);&#125; 这里比较重要的参数就是鼠标跟随的圆形颜色，可以根据自己的喜好进行更改： 1234#cursor &#123; /* 这里改变跟随的底色 */ background: rgb(57, 197, 187);&#125; 在主题配置文件_config.butterfly.yml 文件的 inject 配置项引入刚刚创建的 css 文件和 js 文件： 12345inject: head: + - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/custom.css&quot;&gt; bottom:+ - &lt;script defer src=&quot;/js/cursor.js&quot;&gt;&lt;/script&gt; 页面样式通过 css 样式调节各个页面透明度、模糊度（亚克力效果）、圆角、边框样式等，看起来会更加舒适。 复制以下代码进去自定义的 custom.css 文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778:root &#123; --trans-light: rgba(255, 255, 255, 0.88); --trans-dark: rgba(25, 25, 25, 0.88); --border-style: 1px solid rgb(169, 169, 169); --backdrop-filter: blur(5px) saturate(150%);&#125;/* 首页文章卡片 */#recent-posts &gt; .recent-post-item &#123; background: var(--trans-light); backdrop-filter: var(--backdrop-filter); border-radius: 25px; border: var(--border-style);&#125;/* 首页侧栏卡片 */#aside-content .card-widget &#123; background: var(--trans-light); backdrop-filter: var(--backdrop-filter); border-radius: 18px; border: var(--border-style);&#125;/* 文章页、归档页、普通页面 */div#post,div#page,div#archive &#123; background: var(--trans-light); backdrop-filter: var(--backdrop-filter); border: var(--border-style); border-radius: 20px;&#125;/* 导航栏 */#page-header.nav-fixed #nav &#123; background: rgba(255, 255, 255, 0.75); backdrop-filter: var(--backdrop-filter);&#125;[data-theme=&quot;dark&quot;] #page-header.nav-fixed #nav &#123; background: rgba(0, 0, 0, 0.7) !important;&#125;/* 夜间模式遮罩 */[data-theme=&quot;dark&quot;] #recent-posts &gt; .recent-post-item,[data-theme=&quot;dark&quot;] #aside-content .card-widget,[data-theme=&quot;dark&quot;] div#post,[data-theme=&quot;dark&quot;] div#archive,[data-theme=&quot;dark&quot;] div#page &#123; background: var(--trans-dark);&#125;/* 夜间模式页脚页头遮罩透明 */[data-theme=&quot;dark&quot;] #footer::before &#123; background: transparent !important;&#125;[data-theme=&quot;dark&quot;] #page-header::before &#123; background: transparent !important;&#125;/* 阅读模式 */.read-mode #aside-content .card-widget &#123; background: rgba(158, 204, 171, 0.5) !important;&#125;.read-mode div#post &#123; background: rgba(158, 204, 171, 0.5) !important;&#125;/* 夜间模式下的阅读模式 */[data-theme=&quot;dark&quot;] .read-mode #aside-content .card-widget &#123; background: rgba(25, 25, 25, 0.9) !important; color: #ffffff;&#125;[data-theme=&quot;dark&quot;] .read-mode div#post &#123; background: rgba(25, 25, 25, 0.9) !important; color: #ffffff;&#125; 参数说明： --trans-light：白天模式带透明度的背景色，如 rgba(255, 255, 255, 0.88) 底色是纯白色，其中 0.88 就透明度，在 0-1 之间调节，值越大越不透明； --trans-dark: 夜间模式带透明度的背景色，如 rgba(25, 25, 25, 0.88) 底色是柔和黑色，其中 0.88 就透明度，在 0-1 之间调节，值越大越不透明； --border-style: 边框样式，1px solid rgb(169, 169, 169) 指宽度为 1px 的灰色实体边框； --backdrop-filter: 背景过滤器，如 blur(5px) saturate(150%) 表示饱和度为 150% 的、高斯模糊半径为 5px 的过滤器，这是亚克力效果的一种实现方法； 大家可以根据自己喜好进行调节，不用拘泥于我的样式！ 记住在主题配置文件_config.butterfly.yml 的 inject 配置项中引入该 css 文件： 123inject: head: + - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/custom.css&quot;&gt; Aplayer播放器详见：Butterfly 添加全局吸底 Aplayer 教程 注意：我这里只在某个页面引入音乐播放器，如果要引入全局吸底的播放器，请见上面的链接。 在博客根目录 [Blogroot] 下打开终端，运行以下指令： 1npm install hexo-tag-aplayer --save 在网站配置文件_config.yml 中修改 aplayer 配置项为： 1234# 音乐插件aplayer: meting: true asset_inject: false 在主题配置文件_config.butterfly.yml 中修改 aplayerInject 配置项为： 1234# Inject the css and script (aplayer/meting)aplayerInject: enable: true per_page: false 在你想要加入音乐播放器的页面加入以下语句： 1&lt;div id=&quot;aplayer-oSEOhviA&quot; class=&quot;aplayer aplayer-tag-marker meting-tag-marker&quot; data-id=&quot;4895239160&quot; data-server=&quot;netease&quot; data-type=&quot;playlist&quot; data-mode=&quot;random&quot; data-autoplay=&quot;false&quot; data-listmaxheight=&quot;340px&quot; data-preload=&quot;auto&quot; data-theme=&quot;#e3f2f5&quot; data-volume=&quot;0.4&quot; mutex=&quot;true&quot;&gt;&lt;/div&gt; 其中 data-id 为歌单 ID 可以换为你喜欢的歌曲，其他参数见详情页这里不再赘述！ 顶部渐变色加载条详见：给 Butterfly 加上顶部加载条 新建 [BlogRoot]\\source\\css\\progress_bar.css 文件，写入以下内容（或者你在 [BlogRoot]\\source\\css\\custom.css 直接加也行，最后在配置文件记得引入即可） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455.pace &#123; -webkit-pointer-events: none; pointer-events: none; -webkit-user-select: none; -moz-user-select: none; user-select: none; z-index: 2000; position: fixed; margin: auto; top: 4px; left: 0; right: 0; height: 8px; border-radius: 8px; width: 7rem; background: #eaecf2; border: 1px #e3e8f7; overflow: hidden&#125;.pace-inactive .pace-progress &#123; opacity: 0; transition: .3s ease-in&#125;.pace .pace-progress &#123; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; -ms-box-sizing: border-box; -o-box-sizing: border-box; box-sizing: border-box; -webkit-transform: translate3d(0, 0, 0); -moz-transform: translate3d(0, 0, 0); -ms-transform: translate3d(0, 0, 0); -o-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0); max-width: 200px; position: absolute; z-index: 2000; display: block; top: 0; right: 100%; height: 100%; width: 100%; /* linear-gradient(to right, #3494e6, #ec6ead) */ background: linear-gradient(to right, #43cea2, #3866ca); animation: gradient 2s ease infinite; background-size: 200%&#125;.pace.pace-inactive &#123; opacity: 0; transition: .3s; top: -8px&#125; 在主题配置文件_config.butterfly.yml 的 inject 配置项加入刚刚的 css 样式和必须的 js 依赖： 1234567inject: head: - xxx - &lt;link rel=&quot;stylesheet&quot; href=&quot;/static/css/progress_bar.css&quot; media=&quot;defer&quot; onload=&quot;this.media=&#x27;all&#x27;&quot;&gt; bottom: - xxx - &lt;script async src=&quot;//npm.elemecdn.com/pace-js@1.2.4/pace.min.js&quot;&gt;&lt;/script&gt; 哔哩哔哩视频适配 在 [BlogRoot]\\source\\css\\custom.css 自定义样式的文件中引入如下代码（这是我的，你可以自行微调）： 12345678910111213141516/*哔哩哔哩视频适配*/.aspect-ratio &#123; position: relative; width: 90%; height: auto; padding-bottom: 75%; margin: 3% auto; text-align: center;&#125;.aspect-ratio iframe &#123; position: absolute; width: 100%; height: 86%; left: 0; top: 0;&#125; 直接复制插入你的 md 文章就行，修改里面的 aid 为你视频的 AV 号： 1234567891011&lt;div align=center class=&quot;aspect-ratio&quot;&gt; &lt;iframe src=&quot;https://player.bilibili.com/player.html?aid=474023258&amp;&amp;page=1&amp;as_wide=1&amp;high_quality=1&amp;danmaku=0&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; high_quality=1 danmaku=1 allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt;&lt;/div&gt; 文章局部不渲染在你的 md 文章页中，部分内容不想经过 Hexo 渲染，则包一层 raw 标签： 1234&#123;% raw %&#125;&lt;div class=&quot;&quot;&gt;你的一些代码...&lt;/div&gt;&lt;script&gt;你的一些代码...&lt;/script&gt;&#123;% endraw %&#125; 那么标签内的代码就不会被框架渲染了～ 文章H1-H6标题小风车 修改主题配置文件_config.butterfly.yml 文件的 beautify 配置项： 123456beautify: enable: true field: post # site/post # title-prefix-icon: &#x27;\\f0c1&#x27; 原内容 title-prefix-icon: &#x27;\\f863&#x27; title-prefix-icon-color: &quot;#F47466&quot; 在 [BlogRoot]\\source\\css\\custom.css 中加入以下代码，可以自己调节一下转速: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/* 文章页H1-H6图标样式效果 *//* 控制风车转动速度 4s那里可以自己调节快慢 */h1::before,h2::before,h3::before,h4::before,h5::before,h6::before &#123; -webkit-animation: ccc 4s linear infinite; animation: ccc 4s linear infinite;&#125;/* 控制风车转动方向 -1turn 为逆时针转动，1turn 为顺时针转动，相同数字部分记得统一修改 */@-webkit-keyframes ccc &#123; 0% &#123; -webkit-transform: rotate(0deg); transform: rotate(0deg); &#125; to &#123; -webkit-transform: rotate(-1turn); transform: rotate(-1turn); &#125;&#125;@keyframes ccc &#123; 0% &#123; -webkit-transform: rotate(0deg); transform: rotate(0deg); &#125; to &#123; -webkit-transform: rotate(-1turn); transform: rotate(-1turn); &#125;&#125;/* 设置风车颜色 */#content-inner.layout h1::before &#123; color: #ef50a8; margin-left: -1.55rem; font-size: 1.3rem; margin-top: -0.23rem;&#125;#content-inner.layout h2::before &#123; color: #fb7061; margin-left: -1.35rem; font-size: 1.1rem; margin-top: -0.12rem;&#125;#content-inner.layout h3::before &#123; color: #ffbf00; margin-left: -1.22rem; font-size: 0.95rem; margin-top: -0.09rem;&#125;#content-inner.layout h4::before &#123; color: #a9e000; margin-left: -1.05rem; font-size: 0.8rem; margin-top: -0.09rem;&#125;#content-inner.layout h5::before &#123; color: #57c850; margin-left: -0.9rem; font-size: 0.7rem; margin-top: 0rem;&#125;#content-inner.layout h6::before &#123; color: #5ec1e0; margin-left: -0.9rem; font-size: 0.66rem; margin-top: 0rem;&#125;/* s设置风车hover动效 6s那里可以自己调节快慢*/#content-inner.layout h1:hover,#content-inner.layout h2:hover,#content-inner.layout h3:hover,#content-inner.layout h4:hover,#content-inner.layout h5:hover,#content-inner.layout h6:hover &#123; color: var(--theme-color);&#125;#content-inner.layout h1:hover::before,#content-inner.layout h2:hover::before,#content-inner.layout h3:hover::before,#content-inner.layout h4:hover::before,#content-inner.layout h5:hover::before,#content-inner.layout h6:hover::before &#123; color: var(--theme-color); -webkit-animation: ccc 6s linear infinite; animation: ccc 6s linear infinite;&#125; 在主题配置文件_config.butterfly.yml 的 inject 配置项进行引入 Algolia在线搜索插件选择12npm install hexo-algolia --savenpm install hexo-algoliasearch --save 分别是 hexo-algolia 和 hexo-algoliasearch，他们的介绍分别为 Index your hexo website content to Algolia Search. 🔎 A plugin to index posts of your Hexo blog on Algolia 本教程选用hexo-algoliasearch 安装1npm install hexo-algoliasearch --save 去主题配置文件打开 Algolia 搜索，记得关闭本地搜索，二者只能取其一。 编辑_config.butterfly.yml : 123456789# Algolia searchalgolia_search: enable: true hits: per_page: 3# Local searchlocal_search: enable: false 配置前往 Algolia 官网注册一个账号，新建 应用和index 获取appId，apiKey，adminApiKey，记住三个变量。 在_config.yml中添加 12345678910algolia: appId: &quot;你的Application ID&quot; apiKey: &quot;你的Search-Only API Key&quot; adminApiKey: &quot;你的Admin API Key&quot; indexName: &quot;你的引用(index)的名字如：Hexo&quot; chunkSize: 5000 fields: - path - title - content:strip 使用下面介绍两种上传搜索资料的方法 本地123456# 在这之前需要hexo g生成文件hexo algolia# 所以具体使用命令就是hexo cl &amp;&amp; hexo g &amp;&amp; hexo algolia# 或者在未安装 HEXO CLI 的情况下使用以下命令npm run clean &amp;&amp; npm run build &amp;&amp; hexo algolia -n Github Action前提是你已经配置好博客源文件的Github Action 在BlogRoot下.github之下的yml中生成静态文件命令中最后一行添加 1hexo algolia --no-clear 到这里恭喜你完成Algolia的配置。","tags":["Hexo","Butterfly"],"categories":["Hexo"]},{"title":"Hexo魔改教程(一)","path":"/posts/49b180c9.html","content":"一图流教程(遮罩透明) 在 [BlogRoot]\\source 文件夹下新建一个文件夹 css，该文件夹用于存放自定义的 css样式，再新建一个名为 custom.css，在里面写入以下代码： 1234567891011121314151617181920212223/* 页脚与头图透明 */#footer &#123; background: transparent !important;&#125;#page-header &#123; background: transparent !important;&#125;/* 白天模式遮罩透明 */#footer::before &#123; background: transparent !important;&#125;#page-header::before &#123; background: transparent !important;&#125;/* 夜间模式遮罩透明 */[data-theme=&quot;dark&quot;] #footer::before &#123; background: transparent !important;&#125;[data-theme=&quot;dark&quot;] #page-header::before &#123; background: transparent !important;&#125; 自定义徽标详见：Add Github Badge 安装插件，在博客根目录 [Blogroot] 下打开终端，运行以下指令： 12BASHnpm install hexo-butterfly-footer-beautify --save 添加配置信息，以下为写法示例在站点配置文件_config.yml 或者主题配置文件_config.butterfly.yml 中添加（这是我的配置） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# footer_beautify# 页脚计时器：[Native JS Timer](https://akilar.top/posts/b941af/)# 页脚徽标：[Add Github Badge](https://akilar.top/posts/e87ad7f8/)footer_beautify: enable: timer: true # 计时器开关 bdage: true # 徽标开关 priority: 5 #过滤器优先权 enable_page: all # 应用页面 exclude: #屏蔽页面 # - /posts/ # - /about/ layout: # 挂载容器类型 type: id name: footer-wrap index: 0 # 计时器部分配置项（看你喜欢哪个，最好下载下来放到自己的项目中不然会增加我网站的负载） # 这是我的 # runtime_js: /custom/js/runtime.js # runtime_css: /custom/css/runtime.min.css # 这是店长的 runtime_js: https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.js runtime_css: https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css # 徽标部分配置项 swiperpara: 0 #若非0，则开启轮播功能，每行徽标个数 bdageitem: - link: https://hexo.io/ #徽标指向网站链接 shields: https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo #徽标API message: 博客框架为Hexo_v6.2.0 #徽标提示语 - link: https://butterfly.js.org/ shields: https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender message: 主题版本Butterfly_v4.3.1 - link: https://vercel.com/ shields: https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel message: 本站采用多线部署，主线路托管于Vercel - link: https://dashboard.4everland.org/ # https://img.shields.io/badge/Hosted-4EVERLAND-3FE2C1?style=flat&amp;logo=IPFS shields: https://img.shields.io/badge/Hosted-4EVERLAND-22DDDD?style=flat&amp;logo=IPFS message: 本站采用多线部署，备用线路托管于4EVERLAND - link: https://github.com/ shields: https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub message: 本站项目由Github托管 - link: http://creativecommons.org/licenses/by-nc-sa/4.0/ shields: https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris message: 本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可 swiper_css: https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css swiper_js: https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js swiperbdage_init_js: https://npm.elemecdn.com/hexo-butterfly-footer-beautify/lib/swiperbdage_init.min.js 参数释义 参数 备选值 &#x2F; 类型 释义 priority number 【可选】过滤器优先级，数值越小，执行越早，默认为 10，选填 enable.timer true&#x2F;false 【必选】计时器控制开关 enable.bdage true&#x2F;false 【必选】徽标控制开关 enable_page path 【可选】填写想要应用的页面，如根目录就填’&#x2F;‘, 分类页面就填’&#x2F;categories&#x2F;‘。若要应用于所有页面，就填 all，默认为 all exclude path 【可选】填写想要屏蔽的页面，可以多个。仅当 enable_page 为’all’时生效。写法见示例。原理是将屏蔽项的内容逐个放到当前路径去匹配，若当前路径包含任一屏蔽项，则不会挂载。 layout.type id&#x2F;class 【可选】挂载容器类型，填写 id 或 class，不填则默认为 id layout.name text 【必选】挂载容器名称 layout.index 0 和正整数 【可选】前提是 layout.type 为 class，因为同一页面可能有多个 class，此项用来确认究竟排在第几个顺位 runtime_js url 【必选】页脚计时器脚本，可以下载上文填写示例的链接，参照注释和教程：Native JS Timer 自行修改。 runtime_css url 【可选】自定义样式，预留开发者接口，可自行下载。 swiperpara number 【可选】若非零，则开启轮播功能，此项表示每行最多容纳徽标个数，用来应对徽标过多显得页脚拥挤的问题 bdageitem.link url 【可选】页脚徽标指向的网站链接 bdageitem.shields url 【必选】页脚徽标对应的 API，API 具体写法示例参照教程 Add Github Badge bdageitem.message text 【可选】页脚徽标悬停时显示的信息 swiper_css url 【可选】swiper 的依赖 swiper_js url 【可选】swiper 的依赖 swiperbdage_init_js url 【可选】swiper 初始化方法 文章双侧边栏(小冰)详见：教程：butterfly 主题文章双栏布局插件 在博客根目录 [Blogroot] 下打开终端，运行以下指令： 12BASHnpm i hexo-butterfly-article-double-row --save 在网站配置文件_config.yml 新增以下项 (注意不是主题配置文件)： 123YMLbutterfly_article_double_row: enable: true 最后一页文章数目为奇数的时候 插件有个 bug，只需要在 custom.css居中即可 12345/* 翻页按钮居中 */#pagination &#123; width: 100%; margin: auto;&#125; wowjs动画详见：Add Blog Animation – Wowjs 安装插件，在博客根目录 [Blogroot] 下打开终端，运行以下指令： 1npm install hexo-butterfly-wowjs --save 添加配置信息，以下为写法示例在站点配置文件_config.yml 或者主题配置文件_config.butterfly.yml 中添加 12345678910111213141516wowjs: enable: true #控制动画开关。true是打开，false是关闭 priority: 10 #过滤器优先级 mobile: false #移动端是否启用，默认移动端禁用 animateitem: - class: recent-post-item #必填项，需要添加动画的元素的class style: animate__zoomIn #必填项，需要添加的动画 duration: 2s #选填项，动画持续时间，单位可以是ms也可以是s。例如3s，700ms。 delay: 1s #选填项，动画开始的延迟时间，单位可以是ms也可以是s。例如3s，700ms。 offset: 100 #选填项，开始动画的距离（相对浏览器底部） iteration: 2 #选填项，动画重复的次数 - class: card-widget style: animate__zoomIn animate_css: https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css wow_js: https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js wow_init_js: https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js 参数释义 参数 备选值 &#x2F; 类型 释义 enable true&#x2F;false 【必选】控制开关 priority number 【可选】过滤器优先级，数值越小，执行越早，默认为 10，选填 mobile true&#x2F;false 控制移动端是否启用，默认移动端禁用 animateitem.class class 【可选】添加动画类名，只支持给 class 添加 animateitem.style text 【可选】动画样式，具体类型参考 animate.css animateitem.duration time, 单位为 s 或 ms 【可选】动画持续时间，单位可以是 ms 也可以是 s。例如 3s，700ms。 animateitem.delay time, 单位为 s 或 ms 【可选】动画开始的延迟时间，单位可以是 ms 也可以是 s。例如 3s，700ms。 animateitem.offset number, 单位为 px 【可选】开始动画的距离（相对浏览器底部）。 animateitem.iteration number, 单位为 s 或 ms 【可选】动画重复的次数 animate_css URL 【可选】animate.css 的 CDN 链接，默认为 https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css wow_js URL 【可选】wow.min.js 的 CDN 链接，默认为 https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js wow_init_js URL 【可选】wow_init.js 的 CDN 链接，默认为 https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js wowjs 详细用法见原帖。 Gitcalendar店长详见：Gitcalendar 安装 安装插件，在博客根目录 [Blogroot] 下打开终端，运行以下指令： 12BASHnpm install hexo-filter-gitcalendar --save 添加配置信息，以下为写法示例在站点配置文件_config.yml 或者主题配置文件如_config.butterfly.yml 中添加 12345678910111213141516171819202122232425YML# hexo-filter-gitcalendargitcalendar: enable: true # 开关 priority: 5 #过滤器优先权 enable_page: / # 应用页面 # butterfly挂载容器 layout: # 挂载容器类型 type: id name: recent-posts index: 0 user: Fomalhaut-Blog #git用户名 apiurl: &#x27;https://gitcalendar.fomal.cc&#x27;\t# 这是我的API，最好自己弄一个 minheight: pc: 280px #桌面端最小高度 mibile: 0px #移动端最小高度 color: &quot;[&#x27;#d9e0df&#x27;, &#x27;#c6e0dc&#x27;, &#x27;#a8dcd4&#x27;, &#x27;#9adcd2&#x27;, &#x27;#89ded1&#x27;, &#x27;#77e0d0&#x27;, &#x27;#5fdecb&#x27;, &#x27;#47dcc6&#x27;, &#x27;#39dcc3&#x27;, &#x27;#1fdabe&#x27;, &#x27;#00dab9&#x27;]&quot; # 目前我在用的 # &quot;[&#x27;#e4dfd7&#x27;, &#x27;#f9f4dc&#x27;, &#x27;#f7e8aa&#x27;, &#x27;#f7e8aa&#x27;, &#x27;#f8df72&#x27;, &#x27;#fcd217&#x27;, &#x27;#fcc515&#x27;, &#x27;#f28e16&#x27;, &#x27;#fb8b05&#x27;, &#x27;#d85916&#x27;, &#x27;#f43e06&#x27;]&quot; #橘黄色调 # color: &quot;[&#x27;#ebedf0&#x27;, &#x27;#fdcdec&#x27;, &#x27;#fc9bd9&#x27;, &#x27;#fa6ac5&#x27;, &#x27;#f838b2&#x27;, &#x27;#f5089f&#x27;, &#x27;#c4067e&#x27;, &#x27;#92055e&#x27;, &#x27;#540336&#x27;, &#x27;#48022f&#x27;, &#x27;#30021f&#x27;]&quot; #浅紫色调 # color: &quot;[&#x27;#ebedf0&#x27;, &#x27;#f0fff4&#x27;, &#x27;#dcffe4&#x27;, &#x27;#bef5cb&#x27;, &#x27;#85e89d&#x27;, &#x27;#34d058&#x27;, &#x27;#28a745&#x27;, &#x27;#22863a&#x27;, &#x27;#176f2c&#x27;, &#x27;#165c26&#x27;, &#x27;#144620&#x27;]&quot; #翠绿色调 # color: &quot;[&#x27;#ebedf0&#x27;, &#x27;#f1f8ff&#x27;, &#x27;#dbedff&#x27;, &#x27;#c8e1ff&#x27;, &#x27;#79b8ff&#x27;, &#x27;#2188ff&#x27;, &#x27;#0366d6&#x27;, &#x27;#005cc5&#x27;, &#x27;#044289&#x27;, &#x27;#032f62&#x27;, &#x27;#05264c&#x27;]&quot; #天青色调 container: .recent-post-item(style=&#x27;width:100%;height:auto;padding:10px;&#x27;) #父元素容器，需要使用pug语法 gitcalendar_css: https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css gitcalendar_js: https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js 参数释义 参数 备选值 &#x2F; 类型 释义 priority number 【可选】过滤器优先级，数值越小，执行越早，默认为 10，选填 enable true&#x2F;false 【必选】控制开关 enable_page path&#x2F;all 【可选】填写想要应用的页面的相对路径（即路由地址）, 如根目录就填’&#x2F;‘, 分类页面就填’&#x2F;categories&#x2F;‘。若要应用于所有页面，就填’all’，默认为’&#x2F;‘ layout.type id&#x2F;class 【可选】挂载容器类型，填写 id 或 class，不填则默认为 id layout.name text 【必选】挂载容器名称 layout.index 0 和正整数 【可选】前提是 layout.type 为 class，因为同一页面可能有多个 class，此项用来确认究竟排在第几个顺位 user text 【必选】git 用户名 apiurl url 【可选】默认使用提供文档提供的 api，但还是建议自建 api，参考教程：自建 API 部署 minheight.pc 280px 【可选】桌面端最小高度，默认为 280px minheight.mobile 0px 【可选】移动端最小高度，默认为 0px color list 【可选】一个包含 11 个色值的数组，文档给出了四款预设值 container pug 【可选】预留的父元素容器，用以适配多主题，需要用 pug 语法填写，目前已适配 butterfly，volantis，matery，mengd 主题，这四个主题，插件会自自动识别_config.yml 内填写的 theme 配置项。其余主题需要自己填写父元素容器。 gitcalendar_css URL 【可选】自定义 CSS 样式链接 gitcalendar_js URL 【可选】自定义 js 链接 自定义挂载容器很多人反映不想挂在首页，想挂在关于或者统计等页面，只需要做 2 步: 在对应页面创建一个 DOM 让插件有地方挂载，例如演示的就是在关于页面 (/about/) 的文件中直接写入一个 div 块 123MARKDOWN&lt;!-- GitCalendar容器 --&gt;&lt;div id=&quot;gitZone&quot;&gt;&lt;/div&gt; 在对应配置项改为与你容器 id 以创建页面路径相关的（是改不是加！！！） 1234567YMLenable_page: /about/ # 应用页面(记住最后带/)layout: # 挂载容器类型 type: id name: gitZone index: 0 重启项目就会看见 12BASHhexo cl; hexo s 自建 API 部署虽然 Vercel 的访问应当没有次数限制，但是不排除存在因访问次数过多而限流等限制。所以还是建议各位自建 API。使用 Vercel 部署，完全免费，且无需服务器。 将此项目 fork 到你的 Github 仓库 img](https://github.com/Zfour/python_github_calendar_api) 访问 Vercel 官网，点击右上角的 sign up 进行注册，注册并登录后点击右上角创建一个项目，并选择以 Github 继续。 此时应该会看到你刚刚 fork 过来的你仓库的项目，看不到就输入关键字进行搜索。 点击该仓库右边的 Import 进行导入，Vercel 的 PROJECT NAME 可以自定义，不用太过在意，但是之后不支持修改，若要改名，只能删除 PROJECT 以后重建一个了，下方三个选项保持默认就好，点击 Deploy 进行部署。 到此时，Vercel 的部署已经完成，可以使用 Vercel 提供的默认域名来访问 api 链接。例如我获取到的默认域名为 github-calendar-api.vercel.app, 则用它来替换冰老师教程中的自建 API，填写到 [Blogroot]\\_config.butterfly.yml 中关于 gitcalendar 的 apiurl 中。注意源码修改版不要带协议，不要带后缀。就填写给你的默认域名就好。而插件版需要带协议 123456gitcalendar: enable: true simplemode: true user: Akilarlxh apiurl: github-calendar-api.vercel.app color: &quot;[&#x27;#e4dfd7&#x27;, &#x27;#f9f4dc&#x27;, &#x27;#f7e8aa&#x27;, &#x27;#f7e8aa&#x27;, &#x27;#f8df72&#x27;, &#x27;#fcd217&#x27;, &#x27;#fcc515&#x27;, &#x27;#f28e16&#x27;, &#x27;#fb8b05&#x27;, &#x27;#d85916&#x27;, &#x27;#f43e06&#x27;]&quot; 导航栏魔改 在 [BlogRoot]\\source\\css\\custom.css 中引入如下 css 代码，然后在主题配置文件_config.butterfly.yml 中引入该文件： 12345678910111213141516/* 一级菜单居中 */#nav .menus_items &#123; position: absolute !important; width: fit-content !important; left: 50% !important; transform: translateX(-50%) !important;&#125;/* 子菜单横向展示 */#nav .menus_items .menus_item:hover .menus_item_child &#123; display: flex !important;&#125;/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */.menus_items .menus_item:nth-child(2) .menus_item_child &#123; left: -125px;&#125; 此处的 css 实现了两个作用：菜单栏居中、子菜单横向显示。其中子菜单横向显示要根据自己的实际情况来改，例如你的以及菜单的第 2 个选项中有子菜单，那就要加一项调节第 2 个选项中的子菜单，这个具体调节多少要根据你的具体情况为准，可以自己慢慢调到中间。 此时我们的手机端子菜单默认是展开显示的，如下图所示： 此时我们只需要在主题配置文件_config.butterfly.yml 中列表对应的地方加一个 hide 即可，如下图的列表选项： 123456789101112menu: 首页: / || fas fa-home 归档: /archives/ || fas fa-archive 标签: /tags/ || fas fa-tags 分类: /categories/ || fas fa-folder-open 列表||fas fa-list || hide: 音乐: /music/ || fas fa-music 电影: /movies/ || fas fa-video 留言板: /comments/ || fas fa-envelope-open 友链: /link/ || fas fa-link 关于: /about/ || fas fa-heart 此时有人觉得右边搜索按钮露出搜索两个字很丑，我们也可以把它隐藏了，在 [BlogRoot]\\themes\\Butterfly\\layout\\includes\\header av.pug（npm 安装的在 [BlogRoot] ode_moudules\\hexo-theme-butterfly\\layout\\includes\\header av.pug）中把以下语句删除或注释掉即可，搜索两个字就不会显示出来 (这种语句统一写法是直接删除 + 就可以，不用补空格)。 123456789101112131415nav#nav span#blog_name a#site-name(href=url_for(&#x27;/&#x27;)) #[=config.title] #menus if (theme.algolia_search.enable || theme.local_search.enable) #search-button a.site-page.social-icon.search i.fas.fa-search.fa-fw- span=&#x27; &#x27;+_p(&#x27;search.title&#x27;) !=partial(&#x27;includes/header/menu_item&#x27;, &#123;&#125;, &#123;cache: true&#125;) #toggle-menu a.site-page i.fas.fa-bars.fa-fw 黑夜霓虹灯此教程会有两处地方有霓虹灯效果：一个是大标题和个人信息的动态霓虹灯，默认周期为 1200ms；另外的是菜单栏的小字有夜光效果，为你的博客增添几分赛博朋克风～ 首先在自定义的样式文件 [BlogRoot]\\source\\css\\custom.css 中引入以下代码，这部分代码是菜单栏文字有夜光效果的，变量部分 var(--theme-color) 可以换为自己喜欢的颜色，例如紫色 rgb(179, 71, 241)： 12345678910/* 夜间模式菜单栏发光字 */[data-theme=&quot;dark&quot;] #nav .site-page,[data-theme=&quot;dark&quot;] #nav .menus_items .menus_item .menus_item_child li a &#123; text-shadow: 0 0 2px var(--theme-color) !important;&#125;/* 手机端适配 */[data-theme=&quot;dark&quot;] #sidebar #sidebar-menus .menus_items .site-page &#123; text-shadow: 0 0 2px var(--theme-color) !important;&#125; 新建文件 [BlogRoot]\\source\\js\\light.js 并写入以下代码，本质就是计时器，大家可以根据自己的喜好调节闪烁周期，默认为 1200ms： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 霓虹灯效果// 颜色数组var arr = [&quot;#39c5bb&quot;, &quot;#f14747&quot;, &quot;#f1a247&quot;, &quot;#f1ee47&quot;, &quot;#b347f1&quot;, &quot;#1edbff&quot;, &quot;#ed709b&quot;, &quot;#5636ed&quot;];// 颜色索引var idx = 0;// 切换颜色function changeColor() &#123; // 仅夜间模式才启用 if (document.getElementsByTagName(&#x27;html&#x27;)[0].getAttribute(&#x27;data-theme&#x27;) == &#x27;dark&#x27;) &#123; if (document.getElementById(&quot;site-name&quot;)) document.getElementById(&quot;site-name&quot;).style.textShadow = arr[idx] + &quot; 0 0 15px&quot;; if (document.getElementById(&quot;site-title&quot;)) document.getElementById(&quot;site-title&quot;).style.textShadow = arr[idx] + &quot; 0 0 15px&quot;; if (document.getElementById(&quot;site-subtitle&quot;)) document.getElementById(&quot;site-subtitle&quot;).style.textShadow = arr[idx] + &quot; 0 0 10px&quot;; if (document.getElementById(&quot;post-info&quot;)) document.getElementById(&quot;post-info&quot;).style.textShadow = arr[idx] + &quot; 0 0 5px&quot;; try &#123; document.getElementsByClassName(&quot;author-info__name&quot;)[0].style.textShadow = arr[idx] + &quot; 0 0 12px&quot;; document.getElementsByClassName(&quot;author-info__description&quot;)[0].style.textShadow = arr[idx] + &quot; 0 0 12px&quot;; &#125; catch &#123; &#125; idx++; if (idx == 8) &#123; idx = 0; &#125; &#125; else &#123; // 白天模式恢复默认 if (document.getElementById(&quot;site-name&quot;)) document.getElementById(&quot;site-name&quot;).style.textShadow = &quot;#1e1e1ee0 1px 1px 1px&quot;; if (document.getElementById(&quot;site-title&quot;)) document.getElementById(&quot;site-title&quot;).style.textShadow = &quot;#1e1e1ee0 1px 1px 1px&quot;; if (document.getElementById(&quot;site-subtitle&quot;)) document.getElementById(&quot;site-subtitle&quot;).style.textShadow = &quot;#1e1e1ee0 1px 1px 1px&quot;; if (document.getElementById(&quot;post-info&quot;)) document.getElementById(&quot;post-info&quot;).style.textShadow = &quot;#1e1e1ee0 1px 1px 1px&quot;; try &#123; document.getElementsByClassName(&quot;author-info__name&quot;)[0].style.textShadow = &quot;&quot;; document.getElementsByClassName(&quot;author-info__description&quot;)[0].style.textShadow = &quot;&quot;; &#125; catch &#123; &#125; &#125;&#125;// 开启计时器window.onload = setInterval(changeColor, 1200); 在主题配置文件_config.butterfly.yml 引入以上两个文件，要注意的是，js 文件这里必须为 defer，不能为 async，保证脚本会延迟到整个页面都解析完后再执行，此时才有对应的元素进行操作： 12345inject: head: - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/custom.css&quot; media=&quot;defer&quot; onload=&quot;this.media=&#x27;all&#x27;&quot;&gt; bottom: - &lt;script defer src=&quot;/js/light.js&quot;&gt;&lt;/script&gt; # 霓虹灯(必须defer否则有时候会不生效) 侧边栏电子时钟详见：给 butterfly 添加侧边栏电子钟 安装 如果有安装店长的插件版侧边栏电子钟（与店长的电子钟冲突），在博客根目录 [Blogroot] 下打开终端，运行以下指令 123BASH# 卸载原版电子钟npm uninstall hexo-butterfly-clock 安装插件，在博客根目录 [Blogroot] 下打开终端，运行以下指令： 12BASHnpm install hexo-butterfly-clock-anzhiyu --save 添加配置信息，以下为写法示例在主题配置文件_config.butterfly.yml（注意一定要主题配置文件）中添加： 12345678910111213141516171819202122# electric_clock (安知鱼电子钟)# see https://anzhiy.cn/posts/fc18.htmlelectric_clock: enable: true # 开关 priority: 5 #过滤器优先权 enable_page: / # 应用页面 exclude: # - /posts/ # - /about/ layout: # 挂载容器类型 type: class name: sticky_layout index: 0 loading: https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif #加载动画自定义 clock_css: https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css clock_js: https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js ip_api: https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0 qweather_key: # 和风天气key gaud_map_key: # 高得地图web服务key default_rectangle: false # 开启后将一直显示rectangle位置的天气，否则将获取访问者的地理位置与天气 rectangle: 113.34532,23.15624 # 获取访问者位置失败时会显示该位置的天气，同时该位置为开启default_rectangle后的位置 其中 qweather_key 和 gaud_map_key 最好自己去申请对应的 api key，默认使用鱼的，可能会被限制，不保证可靠性。 参数释义 参数 备选值 &#x2F; 类型 释义 priority number 【可选】过滤器优先级，数值越小，执行越早，默认为 10，选填 enable true&#x2F;false 【必选】控制开关 enable_page path&#x2F;all 【可选】填写想要应用的页面的相对路径（即路由地址）, 如根目录就填’&#x2F;‘, 分类页面就填’&#x2F;categories&#x2F;‘。若要应用于所有页面，就填’all’，默认为 all exclude path 【可选】填写想要屏蔽的页面，可以多个。写法见示例。原理是将屏蔽项的内容逐个放到当前路径去匹配，若当前路径包含任一屏蔽项，则不会挂载。 layout.type id&#x2F;class 【可选】挂载容器类型，填写 id 或 class，不填则默认为 id layout.name text 【必选】挂载容器名称 layout.index 0 和正整数 【可选】前提是 layout.type 为 class，因为同一页面可能有多个 class，此项用来确认究竟排在第几个顺位 loading URL 【可选】电子钟加载动画的图片 clock_css URL 【可选】电子钟样式 CDN 资源 clock_js URL 【可选】电子钟执行脚本 CDN 资源 ip_api URL 【可选】获取时钟 IP 的 API qweather_key text 【可选】和风天气 key gaud_map_key text 【可选】高得地图 web 服务 key default_rectangle text 【可选】开启后将一直显示 rectangle 位置的天气，否则将获取访问者的地理位置与天气 rectangle text 【可选】获取访问者位置失败时会显示该位置的天气，同时该位置为开启 default_rectangle 后的位置 API 申请教程一、qweather_key 申请地址: https://id.qweather.com/#/login 登录后进入控制台 创建应用 填写应用名称和 key 名称随意 选择 W-ebApi 复制 key ] 二、gaud_map_key 申请地址: https://lbs.amap.com/ 登录后进入控制台 创建应用，名称随意，类型选其他 ] 点击添加，key 名称随意，服务平台选择 Web服务 , 点击提交 复制 key ] 个人卡片渐变色 在 [BlogRoot]\\source\\css\\custom.css 自定义样式的文件中引入如下代码（最后记得在 inject 配置项引入！！！）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/* 侧边栏个人信息卡片动态渐变色 */#aside-content &gt; .card-widget.card-info &#123; background: linear-gradient( -45deg, #e8d8b9, #eccec5, #a3e9eb, #bdbdf0, #eec1ea ); box-shadow: 0 0 5px rgb(66, 68, 68); position: relative; background-size: 400% 400%; -webkit-animation: Gradient 10s ease infinite; -moz-animation: Gradient 10s ease infinite; animation: Gradient 10s ease infinite !important;&#125;@-webkit-keyframes Gradient &#123; 0% &#123; background-position: 0% 50%; &#125; 50% &#123; background-position: 100% 50%; &#125; 100% &#123; background-position: 0% 50%; &#125;&#125;@-moz-keyframes Gradient &#123; 0% &#123; background-position: 0% 50%; &#125; 50% &#123; background-position: 100% 50%; &#125; 100% &#123; background-position: 0% 50%; &#125;&#125;@keyframes Gradient &#123; 0% &#123; background-position: 0% 50%; &#125; 50% &#123; background-position: 100% 50%; &#125; 100% &#123; background-position: 0% 50%; &#125;&#125;/* 黑夜模式适配 */[data-theme=&quot;dark&quot;] #aside-content &gt; .card-widget.card-info &#123; background: #191919ee;&#125;/* 个人信息Follow me按钮 */#aside-content &gt; .card-widget.card-info &gt; #card-info-btn &#123; background-color: #3eb8be; border-radius: 8px;&#125; 自定义字体 准备好字体文件后，在 [BlogRoot]\\source\\css\\custom.css（没有就自己创建）中添加以下代码： 123456789101112@font-face &#123; /* 为载入的字体取名字(随意) */ font-family: &#x27;YSHST&#x27;; /* 字体文件地址(相对或者绝对路径都可以) */ src: url(/font/优设好身体.woff2); /* 定义加粗样式(加粗多少) */ font-weight: normal; /* 定义字体样式(斜体/非斜体) */ font-style: normal; /* 定义显示样式 */ font-display: block;&#125; 各个属性的定义： font-family 属性值中使用 webfont 来声明使用的是服务器端字体，即设置文本的字体名称。 src 属性值中首先指定了字体文件所在的路径。 format 声明字体文件的格式，可以省略文件格式的声明，单独使用 src 属性值。 font-style：设置文本样式。取值：normal: 不使用斜体；italic: 使用斜体；oblique: 使用倾斜体；inherit：从父元素继承。 支持格式：*.eot (老版本 IE)，*.otf，*.ttf，*.woff，*.woff2 (推荐) 在主题配置文件_config.butterfly.yml 中的 font 配置项以及 blog_title_font 配置项写上你刚刚引入的字体名称，系统会根据先后次序从前到后依次加载这些字体： 123456789101112# Global font settings# Don&#x27;t modify the following settings unless you know how they work (非必要不要修改)font: global-font-size: &#x27;15px&#x27; code-font-size: &#x27;14px&#x27; font-family: YSHST, -apple-system, &#x27;Quicksand&#x27;, &#x27;Nimbus Roman No9 L&#x27;, &#x27;PingFang SC&#x27;, &#x27;Hiragino Sans GB&#x27;, &#x27;Noto Serif SC&#x27;, &#x27;Microsoft Yahei&#x27;, &#x27;WenQuanYi Micro Hei&#x27;, &#x27;ST Heiti&#x27;, sans-serif; code-font-family: Consolas, YSHST, &quot;Microsoft YaHei&quot;, Menlo, &quot;PingFang SC&quot;, &quot;Microsoft JhengHei&quot;, sans-serif# 左上角網站名字 主頁居中網站名字blog_title_font: font_link: font-family: YSHST, -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot; , &quot;Helvetica Neue&quot; , Lato, Roboto, &quot;PingFang SC&quot; , &quot;Microsoft JhengHei&quot; , &quot;Microsoft YaHei&quot; , sans-serif","tags":["Hexo","Butterfly"],"categories":["Hexo"]},{"title":"Python上下文管理器with","path":"/posts/ce05e2d4.html","content":"正常open步骤123instance = open(&quot;mydata.txt&quot;, &quot;w&quot;)instance.write(&quot;Hello this is a test file&quot;)instance.close() with使用1234# 使用with后不再需要close 原理如[进阶使用(原理)]with open(&quot;mydata.txt&quot;, &quot;w&quot;) as instance: instance.write(&quot;Hello this is a test file&quot;)\tprint(&quot;The end&quot;) 进阶使用(原理)1234567891011121314151617181920212223242526272829# 例：程序执行时间计算import time# 定义一个类class Timer: def __init__(self): self.elapsed = 0 # with会先进入enter方法 def __enter__(self): # 开始时间 self.start = time.perf_counter() return self\t# 执行完成后进入exit方法 def __exit__(self, exc_type, exc_val, exc_tb): # 结束时间 self.stop = time.perf_counter() # 运行时间 self.elapsed = self.stop - self.start # return Falsewith Timer() as timer: nums = [] for n in range(10000): nums.append(n ** 2)print(timer.elapsed) with使用场景 开 - 关 锁 - 释放 启动 - 停止 改变 - 重置","tags":["Python"],"categories":["Language"]},{"title":"宝塔海外版aaPanel","path":"/posts/4fc40c59.html","content":"aaPanel installation script Centos 1yum install -y wget &amp;&amp; wget -O install.sh http://www.aapanel.com/script/install_6.0_en.sh &amp;&amp; bash install.sh aapanelCopy Ubuntu&#x2F;Deepin 1wget -O install.sh http://www.aapanel.com/script/install-ubuntu_6.0_en.sh &amp;&amp; sudo bash install.sh aapanel Debian 1wget -O install.sh http://www.aapanel.com/script/install-ubuntu_6.0_en.sh &amp;&amp; bash install.sh aapanel ManagementStop 1service bt stop Start 1service bt start Restart 1service bt restart Uninstall 1service bt stop &amp;&amp; chkconfig --del bt &amp;&amp; rm -f /etc/init.d/bt &amp;&amp; rm -rf /www/server/panel View current port of control panel 1cat /www/server/panel/data/port.pl Change port of control panel，e.g. 8881（centos 6 Operation System） 1echo &#x27;8881&#x27; &gt; /www/server/panel/data/port.pl &amp;&amp; service bt restart iptables -I INPUT -p tcp -m state --state NEW -m tcp --dport 8881 -j ACCEPT service iptables save service iptables restart Change port of control panel，e.g. 8881（centos 7 Operation System） 1echo &#x27;8881&#x27; &gt; /www/server/panel/data/port.pl &amp;&amp; service bt restart firewall-cmd --permanent --zone=public --add-port=8881/tcp firewall-cmd --reload Force to change MySQL manager (root) Password，e.g. 123456 1cd /www/server/panel &amp;&amp; python tools.py root 123456 Change control Panel login password，e.g. 123456 1cd /www/server/panel &amp;&amp; python tools.py panel 123456 Site Configuration location 1/www/server/panel/vhost Delete banding domain of control panel 1rm -f /www/server/panel/data/domain.conf Clean login restriction 1rm -f /www/server/panel/data/*.login View control panel authorization IP 1cat /www/server/panel/data/limitip.conf Stop access restriction 1rm -f /www/server/panel/data/limitip.conf View permission domain 1cat /www/server/panel/data/domain.conf Turn off control panel SSL 1rm -f /www/server/panel/data/ssl.pl &amp;&amp; /etc/init.d/bt restart View control panel error logs 1cat /tmp/panelBoot View database error log 1cat /www/server/data/*.err Site Configuration directory(nginx) 1/www/server/panel/vhost/nginx Site Configuration directory(apache) 1/www/server/panel/vhost/apache Site default directory 1/www/wwwroot Database backup directory 1/www/backup/database Site backup directory 1/www/backup/site Site logs 1/www/wwwlogs Nginxnginx installation directory 1/www/server/nginx Start 1service nginx start Stop 1service nginx stop Restart 1service nginx restart Reload 1service nginx reload nginx Configuration 1/www/server/nginx/conf/nginx.conf Apacheapache installation directory 1/www/server/httpd Start 1service httpd start Stop 1service httpd stop Restart 1service httpd restart Reload 1service httpd reload apache Configuration 1/www/server/apache/conf/httpd.conf MySQLmysql installation directory 1/www/server/mysql phpmyadmin installation directory 1/www/server/phpmyadmin Data storage directory 1/www/server/data mysql Start 1service mysqld start Stop 1service mysqld stop Restart 1service mysqld restart Reload 1service mysqld reload mysql Configuration 1/etc/my.cnf FTPftp installation directory 1/www/server/pure-ftpd Start 1service pure-ftpd start Stop 1service pure-ftpd stop Restart 1service pure-ftpd restart ftp Configuration 1/www/server/pure-ftpd/etc/pure-ftpd PHPphp installation directory 1/www/server/php Start(Please modify by PHP version, e.g. service php-fpm-54 start) 1service php-fpm-&#123;52|53|54|55|56|70|71|72|73|74|80|81&#125; start Stop(Please modify by PHP version, e.g. service php-fpm-54 stop) 1service php-fpm-&#123;52|53|54|55|56|70|71|72|73|74|80|81&#125; stop Restart(Please modify by PHP version, e.g. service php-fpm-54 restart) 1service php-fpm-&#123;52|53|54|55|56|70|71|72|73|74|80|81&#125; restart Reload(Please modify by PHP version, e.g. service php-fpm-54 reload) 1service php-fpm-&#123;52|53|54|55|56|70|71|72|73|74|80|81&#125; reload Configuration(Please modify by PHP version, e.g. &#x2F;www&#x2F;server&#x2F;php&#x2F;52&#x2F;etc&#x2F;php.ini) 1/www/server/php/&#123;52|53|54|55|56|70|71|72|73|74|80|81&#125;/etc/php.ini Redisredis installation directory 1/www/server/redis Start 1service redis start Stop 1service redis stop redis Configuration 1/www/server/redis/redis.conf Memcachedmemcached installation directory 1/usr/local/memcached Start 1service memcached start Stop 1service memcached stop Restart 1service memcached restart Reload 1service memcached reload","tags":["aaPanel"],"categories":["WebSite"]},{"title":"Typecho搭建一个简易情侣网站","path":"/posts/29ee7192.html","content":"最近需要搭建一个情侣网站，因为之前的网站是在WordPress建站平台上搭建的，就想着能不能找到一个WordPress情侣主题网站，但很遗憾没找到，即使找到一个还是十几年前的网站风格，不忍直视。 因为考虑到另一半对网站管理后台的操作及编辑能力有限，所以要找一个简单的网站，不需要像自己创建博客网站那样整得花里胡哨。经过在度娘上的搜索，还真的找到了一个，主题名为Brave勇敢爱[1]，主题作者[2]@秦枫鸢梦。 image.png 可以看出这个网站极简，主页面从上到下只有一言、情侣展示区、恋爱时间计时器、祝福板（用于网站访客发送祝福）、点点滴滴（情侣写的文章会被收录其中）、Love List（恋爱清单，用于记录两人想一起做的事）、网站底部同样可以加入一言。 祝福板image.png 点点滴滴image.png Love Listimage.png 建站准备该主题基于Typecho平台建站，在使用typecho搭建完网站后发现网站后台很轻量，网站访问也很流畅，真的适合搭建轻主题。 下面简单介绍一下搭建Brave主题情侣网站的流程，前面基本与WordPress建站相同。 你需要： 一个服务器 一个备案域名并将域名解析到服务器 宝塔面板安装与配置 考虑到我之前已经将一级域名搭建过网站了，这里我们可以使用二级域名，例如使用love.xxxx.com，将二级域名解析到服务器后，在宝塔面板中点击【添加站点】，填入自己的二级域名，创建FTP和数据库，记住自己的数据库账号和密码，安装typecho时需要用。 注：宝塔面板可以创建多个网站部署到服务器中，一个一级域名可以分发无数个二级域名，也就意味着一个域名加一个服务器可以创建许多个网站，当然前提服务器能承受住。 创建好网站后可以给网站安装SSL证书 Typecho安装下载Typecho安装包[3] 在宝塔面板【文件】找到/www/wwwroot/自己的域名文件夹将Typecho安装包上传到此目录下并解压。 解压后生成一个名为build的文件夹，将build的文件夹下的所有文件剪切到/www/wwwroot/自己的域名文件夹下，并删除build文件夹。 在同级目录下找到usr进入到子级文件夹uploads把权限从755改为777以防止网站建成后上传附件时出问题。 640 在浏览器地址栏中输入自己的域名/install.php进行typecho的安装 image.png 在初始化配置中输入自己的数据库名、数据库用户名、数据库密码（在宝塔面板的数据库找到）和创建typecho用户名，密码、邮箱（用于typecho后台登录），一切都设置好后就可以安装了。 image.png 初始网站的界面为typecho的默认样式 image.png Brave主题安装在宝塔面板的【文件】找到/www/wwwroot/自己的域名/usr/themes，将Brave主题[4]压缩包上传至themes文件夹下并解压。 登录Typecho后台，方法是在浏览器地址栏输入自己的域名/admin并填写自己的用户名密码即可登录到Typecho后台。找到【控制台】【外观】启用Brave主题，在【设置外观】中进行网站的一些设置 640 Brave主题配置教程请查看：https://blog.zwying.com/archives/59.html 关于头像和页面图标可以将图片上传到图床上获得图片的链接填入到相应的表单中 Typecho支持emoji设置Typecho默认是不支持添加emoji的，这就会导致我们不能在主题中加入emoji，如果加入也会无法保存。 这主要是由于Typecho数据库编码是utf8，这种编码不支持emoji表情。 如果想Typecho支持emoji只需要将数据库的编码改为utf8mb4即可。 在宝塔面板的【数据库】中找到自己网站对应的数据库，在右侧点击管理，页面会跳转到数据库的登录页面，输入自己的数据库用户名和密码，点击执行 image.png 注：如果数据库登录界面无法打开，可能是因为服务器的888端口未开，请在阿里云轻量应用服务器工作台【防火墙】中添加一个888端口 登录后在左侧点击自己的数据库，可以看到右侧的排序规则是utf8，我们要改成utf8mb4 image.png 点击SQL，在代码框中输入编码转换代码，点击执行 image.png Text1234567alter table typecho_comments convert to character set utf8mb4 collate utf8mb4_general_ci;alter table typecho_contents convert to character set utf8mb4 collate utf8mb4_general_ci;alter table typecho_fields convert to character set utf8mb4 collate utf8mb4_general_ci;alter table typecho_metas convert to character set utf8mb4 collate utf8mb4_general_ci;alter table typecho_options convert to character set utf8mb4 collate utf8mb4_general_ci;alter table typecho_relationships convert to character set utf8mb4 collate utf8mb4_general_ci;alter table typecho_users convert to character set utf8mb4 collate utf8mb4_general_ci; 出现绿色对勾表示替换成功 640 在宝塔面板找到网站根目录数据库配置文件config.inc.php，将&#39;charset&#39; =&gt; &#39;utf8&#39;改为&#39;charset&#39; =&gt; &#39;utf8mb4&#39;，该代码大约在config.inc.php的第60行，替换后将文件保存即可 Text123456789/** 定义数据库参数 */$db = new Typecho_Db(&#x27;Pdo_Mysql&#x27;, &#x27;typecho_&#x27;);$db-&gt;addServer(array ( &#x27;host&#x27; =&gt; &#x27;localhost&#x27;, &#x27;user&#x27; =&gt; &#x27;xxxxxxxxxxxx&#x27;, &#x27;password&#x27; =&gt; &#x27;xxxxxxxxx&#x27;, &#x27;charset&#x27; =&gt; &#x27;utf8mb4&#x27;, /*将原来的utf8修改为utf8mb4*/ &#x27;port&#x27; =&gt; &#x27;xxxx&#x27;, &#x27;database&#x27; =&gt; &#x27;xxxxxxxx&#x27;, 在完成上述配置后即可为网站全局添加emoji表情，推荐一个emoji网址：https://www.emojiall.com/ Brave主题修改为了增加网站的个性化，我们可以简单地DIY这个主题，下面介绍我的一些定制方法 image.png &gt; 网站底部添加一言在宝塔面板【文件】的网站根目录找到/usr/themes/Brave/base/footer.php，双击进行编辑，第2行&lt;div class=&quot;p-5 text-center &quot;&gt;下即可更改网站底部的文字 Text123456&lt;div class=&quot;p-5 text-center &quot;&gt; &lt;h6&gt;&lt;?php $this-&gt;options-&gt;title() ?&gt;&lt;/h6&gt; /*引入网站名*/ &lt;h6&gt;你惊艳了我的时光，也温柔了我的岁月&lt;/h6&gt; /*加入你想加入的文字，可自改*/ &lt;a class=&quot;lover-card-title&quot; href=&quot;http://beian.miit.gov.cn/&quot; target=&quot;_blank&quot;&gt; 皖ICP备2021016244号-1&lt;/a&gt; /*添加备案号*/ &lt;!--&lt;p class=&quot;h6&quot;&gt; Powered by &lt;a href=&quot;http://typecho.org&quot; target=&quot;_blank&quot;&gt;Typecho&lt;/a&gt; ※ Theme is &lt;a href=&quot;https://blog.zwying.com&quot; target=&quot;_blank&quot;&gt;Brave&lt;/a&gt;&lt;/p&gt;--&gt; /*主题放版权的地方，如果觉得放在自己的情侣网站不和谐可以删除或注释起来*/&lt;/div&gt; 如果你想给自己的文字加入颜色渐变效果可以这样写&lt;h6 class=&quot;lover-card-title&quot;&gt;你惊艳了我的时光，也温柔了我的岁月&lt;/h6&gt;，颜色渐变效果可以参考我的备案号 image.png &gt; 添加下雪特效同样是在footer.php修改，在&lt;/body&gt;前添加 Text12345&lt;script src=&quot;https://pt.pyrroleach.com/js/snowy.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .snow-container&#123;position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:100001;&#125; &lt;/style&gt; &lt;div class=&quot;snow-container&quot;&gt;&lt;/div&gt; 还有一种下雪特效挺有意思，在鼠标接近雪花时会将雪花吹跑 使用Typecho搭建一个简易情侣网站.gif 方法同样是在在&lt;/body&gt;前添加一段JavaScript代码，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132&lt;canvas id=&quot;Snow&quot;&gt;&lt;/canvas&gt;&lt;script&gt; if(true)&#123; (function() &#123; var requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) &#123; window.setTimeout(callback, 1000 / 60); &#125;; window.requestAnimationFrame = requestAnimationFrame; &#125;)(); (function() &#123; var flakes = [], canvas = document.getElementById(&quot;Snow&quot;), ctx = canvas.getContext(&quot;2d&quot;), flakeCount = 200, mX = -100, mY = -100; canvas.width = window.innerWidth; canvas.height = window.innerHeight; function snow() &#123; ctx.clearRect(0, 0, canvas.width, canvas.height); for (var i = 0; i &lt; flakeCount; i++) &#123; var flake = flakes[i], x = mX, y = mY, minDist = 150, x2 = flake.x, y2 = flake.y; var dist = Math.sqrt((x2 - x) * (x2 - x) + (y2 - y) * (y2 - y)), dx = x2 - x, dy = y2 - y; if (dist &lt; minDist) &#123; var force = minDist / (dist * dist), xcomp = (x - x2) / dist, ycomp = (y - y2) / dist, deltaV = force / 2; flake.velX -= deltaV * xcomp; flake.velY -= deltaV * ycomp; &#125; else &#123; flake.velX *= .98; if (flake.velY &lt;= flake.speed) &#123; flake.velY = flake.speed &#125; flake.velX += Math.cos(flake.step += .05) * flake.stepSize; &#125; ctx.fillStyle = &quot;rgba(255,255,255,&quot; + flake.opacity + &quot;)&quot;; flake.y += flake.velY; flake.x += flake.velX; if (flake.y &gt;= canvas.height || flake.y &lt;= 0) &#123; reset(flake); &#125; if (flake.x &gt;= canvas.width || flake.x &lt;= 0) &#123; reset(flake); &#125; ctx.beginPath(); ctx.arc(flake.x, flake.y, flake.size, 0, Math.PI * 2); ctx.fill(); &#125; requestAnimationFrame(snow); &#125;; function reset(flake) &#123; flake.x = Math.floor(Math.random() * canvas.width); flake.y = 0; flake.size = (Math.random() * 3) + 2; flake.speed = (Math.random() * 1) + 0.5; flake.velY = flake.speed; flake.velX = 0; flake.opacity = (Math.random() * 0.5) + 0.3; &#125; function init() &#123; for (var i = 0; i &lt; flakeCount; i++) &#123; var x = Math.floor(Math.random() * canvas.width), y = Math.floor(Math.random() * canvas.height), size = (Math.random() * 3) + 2, speed = (Math.random() * 1) + 0.5, opacity = (Math.random() * 0.5) + 0.3; flakes.push(&#123; speed: speed, velY: speed, velX: 0, x: x, y: y, size: size, stepSize: (Math.random()) / 30 * 1, step: 0, angle: 180, opacity: opacity &#125;); &#125; snow(); &#125;; document.addEventListener(&quot;mousemove&quot;, function(e) &#123; mX = e.clientX, mY = e.clientY &#125;); window.addEventListener(&quot;resize&quot;, function() &#123; canvas.width = window.innerWidth; canvas.height = window.innerHeight; &#125;); init(); &#125;)(); &#125;&lt;/script&gt;&lt;style&gt; #Snow&#123; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 99999; background: rgba(125,137,95,0.1); pointer-events: none; &#125;&lt;/style&gt; &gt; 增加相识时间计时器主题默认只有一套计时器，即设定相恋时间。如果想增加一套相识时间可以按照如下设置 加入计时器功能打开footer.php，找到 12345678&lt;script&gt; window.showSiteRuntime = function() &#123; site_runtime = $(&quot;#site_runtime&quot;); .... &lt;?php if ($this-&gt;options-&gt;pjaxContent) : $this-&gt;options-&gt;pjax回调(); ?&gt;&lt;?php endif; ?&gt;NProgress.done();&#125;);&lt;/script&gt; 在代码&lt;/script&gt;之后加入 12345678910111213141516171819202122232425262728293031323334&lt;script&gt; window.showMeetRuntime = function() &#123; meet_runtime = $(&quot;#meet_runtime&quot;); if (!meet_runtime) &#123; return; &#125; window.setTimeout(&quot;showMeetRuntime()&quot;, 1000); start = new Date(&quot;&lt;?php $this-&gt;options-&gt;meetingtime(); ?&gt;&quot;); now = new Date(); T = (now.getTime() - start.getTime()); i = 24 * 60 * 60 * 1000; d = T / i; D = Math.floor(d); h = (d - D) * 24; H = Math.floor(h); m = (h - H) * 60; M = Math.floor(m); s = (m - M) * 60 S = Math.floor(s); meet_runtime.html(&quot;第 &lt;span class=\\&quot;bigfontNum\\&quot;&gt;&quot; + D + &quot;&lt;/span&gt; 天 &lt;span class=\\&quot;bigfontNum\\&quot;&gt;&quot; + H + &quot;&lt;/span&gt; 小时 &lt;span class=\\&quot;bigfontNum\\&quot;&gt;&quot; + M + &quot;&lt;/span&gt; 分钟 &lt;span class=\\&quot;bigfontNum\\&quot;&gt;&quot; + S + &quot;&lt;/span&gt; 秒&quot;); &#125;; showMeetRuntime(); $(document).pjax(&#x27;a&#x27;, &#x27;#Pjax&#x27;, &#123; fragment: &#x27;#Pjax&#x27;, timeout: 6000 &#125;); $(document).on(&#x27;pjax:send&#x27;, function() &#123; NProgress.start(); &#125;); $(document).on(&#x27;pjax:complete&#x27;, function() &#123; &lt;?php if ($this-&gt;options-&gt;pjaxContent) : $this-&gt;options-&gt;pjax回调(); ?&gt;&lt;?php endif; ?&gt; NProgress.done(); &#125;);&lt;/script&gt; 将计时器引入网站首页在网站根目录找到/usr/themes/Brave/indexPage.php双击打开编辑，在代码的13行到18行进行改动 123456 &lt;blockquote class=&quot;blockquote text-center my-5 py-2&quot;&gt; &lt;h5 class=&quot;lover-card-title&quot;&gt;今天是我们相识的&lt;/h5&gt;/*相识的文字*/ &lt;h5 id=&quot;meet_runtime&quot;&gt;&lt;/h5&gt;/*引入相识计时器*/ &lt;h5 class=&quot;lover-card-title&quot;&gt;也是我们在一起的&lt;/h5&gt;/*相恋文字。原句是：我们风雨同舟已经一起走过，我这里做了修改*/ &lt;h5 id=&quot;site_runtime&quot;&gt;&lt;/h5&gt;/*引入相恋计时器*/ &lt;/blockquote&gt; 网站后台加入相识时间输入框这里是为了方便与用户的交互，只要在后台的【设置外观】按格式填入相识时间即可 在网站根目录找到/usr/themes/Brave/function.php双击打开编辑，找到 Text1 $lovetime = new Typecho_Widget_Helper_Form_Element_Text(&#x27;lovetime&#x27;, NULL, NULL, _t(&#x27;恋爱起始日期设定&#x27;), _t(&#x27;格式“MM/DD/YYYY HH:MM:SS”，例“01/28/2022 23:02:00”&#x27;)); 在前面加入 Text12$meetingtime = new Typecho_Widget_Helper_Form_Element_Text(&#x27;meetingtime&#x27;, NULL, NULL, _t(&#x27;初遇起始日期设定&#x27;), _t(&#x27;格式“MM/DD/YYYY HH:MM:SS”，例“08/20/2013 14:00:00”&#x27;));$form-&gt;addInput($meetingtime); 回到后台的【设置外观】即可看到新增了初遇起始时间设定，时间格式参考下图 image.png 考虑到首页的计时器数字过大，可以在/usr/themes/Brave/base/style.css中找到第一个.bigfontNum&#123;&#125;将字体大小改为2rem Text123.bigfontNum&#123; font-size: 2rem;&#125; 如果看不到效果的变化请清除浏览器的cookie后刷新网站页面 image.png &gt; 插入音乐有两种方式：一种是直接在网页下面添加背景音乐（只插入一首音乐），一种是在网站里加入一个音乐播放器（可以播放一个列表的音乐） 网页插入背景音乐以网易云为例，网易云现在已经支持以外链的方式将网易云音乐插入网页中 浏览器登录网易云音乐 找到自己想插入的音乐，点击生成外链播放器 image.png 复制HTML代码到想插入的页面中 image.png 以插入到lovelist页面为例，找到并打开loveListPage.php，将以下的代码加入到&lt;?php $this-&gt;need(&#39;base/footer.php&#39;); ?&gt;之前，保存 123&lt;div class=&quot;container text-center&quot;&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=26376060&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;/*此处插入前面复制的HTML代码*/&lt;/div&gt; 效果： image.png 文章插入背景音乐这个需要安装一个meting插件，将插件上传至网站根目录/usr/plugins，在后台【控制台】【插件】中启用该插件，启用成功后可以进行相关设置。进入文章撰写页点击右上角的耳机图标，插入音乐链接即可在文章中插入音乐 下载地址：https://distance1998.lanzouw.com/iKHPIzr806b 官网及使用手册：https://github.com/MoePlayer/APlayer-Typecho 插入音乐播放器我目前使用的是这一种方式在网站插入音乐，打开foot.php，在&lt;/body&gt;前插入如下代码 1234567891011&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css&quot;&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js&quot;&gt;&lt;/script&gt;&lt;meting-js server=&quot;netease&quot;/*插入网易云*/ type=&quot;playlist&quot;/*c插入歌单*/ id=&quot;&quot;/*插入歌单id*/ fixed=&quot;true&quot;/*启用吸底模式*/ autoplay=&quot;true&quot;/*自动播放，仅适用于手机浏览器，经测试PC端和微信打开自动播放均会被禁止*/ loop=&quot;all&quot;/*循环播放*/ &gt; 找到网易云歌单id的方法很简单，就是进入歌单主页在地址栏中找到id后面的数字，将数字填入到id=&quot;&quot;，恰好网易云有一个共享歌单的功能，邀请另一半一起管理歌单，歌单会实时同步到网站的音乐列表下 image.png 如果想插入其他音乐，或设置其他参数可参考官方手册：https://github.com/metowolf/MetingJS 注：如果使用插入音乐播放器的方法就不要安装Meting插件了，两者会有冲突 &gt; 加入鼠标点击特效鼠标每点击网站页面一次，就会弹出一行文字，效果如下： 使用Typecho搭建一个简易情侣网站.gif 打开footer.php，在&lt;/body&gt;前插入如下代码 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!--鼠标点击特效--&gt;&lt;script type=&quot;text/javascript&quot;&gt;jQuery(function () &#123; $(&quot;html&quot;).click(function(e) &#123; var a_idx = Math.floor((Math.random() * 30));/*鼠标点击随机出现一句话，代码数字请与添加的短句数量相一致*/ var a = new Array( &quot;希望全世界停电 我可以偷偷跑去亲你&quot;, &quot;我会爱你很久很久&quot;,&quot;我在贩卖日落 你像神明一样将阳光撒向我&quot;,&quot;陪伴本身就是这个世界上最了不起的安慰方式&quot;, &quot;嘿，我是一朵云ლ(⁰⊖⁰ლ)&quot;, &quot;❤&quot; ,&quot;陪你把岁月熬成清酒 陪你把孤夜熬成温柔&quot;,&quot;❤&quot;,&quot;月光下邂逅的是爱情和你&quot;,&quot;祝眉目舒展 顺问冬按&quot;,&quot;只想拥你入怀&quot;,&quot;这个世界乱糟糟的 而你干干净净&quot;,&quot;日月星辰之外 你是第四种难得&quot;,&quot;我会在每个有意义的时刻 远隔山海与你共存&quot;,&quot;山脚下遇见的你 我们山顶见&quot;,&quot;想试试在你迎面跑来一把抱住你的感觉&quot;,&quot;在生命里的旅程里 遇见你真好&quot;,&quot;如果不曾遇见 岂知生命如何&quot;,&quot;❤&quot; ,&quot;想和你一起走过下雪后的天&quot;,&quot;在我贫瘠的土地上你是最后的玫瑰&quot;,&quot;今晚月色很美呢&quot;,&quot;r=a(1-sinθ)&quot;,&quot;天青色等烟雨 而我在等你&quot;,&quot;你是我这一生等了半世未拆的礼物&quot;,&quot;你养我 我养你 两人爱情甜蜜蜜&quot;,&quot;人的一生会遇见两个人 一个惊艳了时光 一个温柔了岁月&quot;,&quot;你不用多好，我喜欢就好&quot;,&quot;愿有岁月可回首 且以深情共白头&quot; );/*请在此添加句子*/ var color1 = Math.floor((Math.random() * 255)) var color2 = Math.floor((Math.random() * 255)); var color3 = Math.floor((Math.random() * 255)); var $i = $(&quot;&lt;span /&gt;&quot;).text(a[a_idx]); var x = e.pageX, y = e.pageY; $i.css(&#123; &quot;z-index&quot;: 9999999999999 , &quot;top&quot;: y - 20, &quot;left&quot;: x, &quot;position&quot;: &quot;absolute&quot;, &quot;font-family&quot;:&quot;mmm&quot;, &quot;fontSize&quot;:Math.floor((Math.random() * 5)+10),/*文字大小在10px到15px之间*/ &quot;font-weight&quot;: &quot;bold&quot;, &quot;color&quot;: &quot;rgb(&quot;+color1+&quot;,&quot;+color2+&quot;,&quot;+color3+&quot;)&quot;,/*随机颜色*/ &quot;-webkit-user-select&quot;:&quot;none&quot;, &quot;-moz-user-select&quot;:&quot;none&quot;, &quot;-ms-user-select&quot;:&quot;none&quot;, &quot;user-select&quot;:&quot;none&quot;, &#125;); $(&quot;body&quot;).append($i); $i.animate(&#123; &quot;top&quot;: y - 200, &quot;opacity&quot;: 0 &#125;, 3000,/*句子悬浮时间*/ function() &#123; $i.remove(); &#125;); &#125;); &#125;);&lt;/script&gt; &gt; 为网站添加灯笼过年的时候为了增加喜庆可以为网站顶部添加灯笼，效果如下： 使用Typecho搭建一个简易情侣网站.gif 打开footer.php，在&lt;/body&gt;前插入如下代码[5] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224&lt;!--灯笼--&gt;&lt;div class=&quot;deng-box2&quot;&gt; &lt;div class=&quot;deng&quot;&gt; &lt;div class=&quot;xian&quot;&gt;&lt;/div&gt; &lt;div class=&quot;deng-a&quot;&gt; &lt;div class=&quot;deng-b&quot;&gt; &lt;div class=&quot;deng-t&quot;&gt;年&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;shui shui-a&quot;&gt; &lt;div class=&quot;shui-c&quot;&gt;&lt;/div&gt; &lt;div class=&quot;shui-b&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;deng-box3&quot;&gt; &lt;div class=&quot;deng&quot;&gt; &lt;div class=&quot;xian&quot;&gt;&lt;/div&gt; &lt;div class=&quot;deng-a&quot;&gt; &lt;div class=&quot;deng-b&quot;&gt; &lt;div class=&quot;deng-t&quot;&gt;新&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;shui shui-a&quot;&gt; &lt;div class=&quot;shui-c&quot;&gt;&lt;/div&gt; &lt;div class=&quot;shui-b&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;deng-box1&quot;&gt; &lt;div class=&quot;deng&quot;&gt; &lt;div class=&quot;xian&quot;&gt;&lt;/div&gt; &lt;div class=&quot;deng-a&quot;&gt; &lt;div class=&quot;deng-b&quot;&gt; &lt;div class=&quot;deng-t&quot;&gt;乐&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;shui shui-a&quot;&gt; &lt;div class=&quot;shui-c&quot;&gt;&lt;/div&gt; &lt;div class=&quot;shui-b&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;deng-box&quot;&gt; &lt;div class=&quot;deng&quot;&gt; &lt;div class=&quot;xian&quot;&gt;&lt;/div&gt; &lt;div class=&quot;deng-a&quot;&gt; &lt;div class=&quot;deng-b&quot;&gt; &lt;div class=&quot;deng-t&quot;&gt;快&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;shui shui-a&quot;&gt; &lt;div class=&quot;shui-c&quot;&gt;&lt;/div&gt; &lt;div class=&quot;shui-b&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;style type=&quot;text/css&quot;&gt;.deng-box &#123; position: fixed; top: -40px; right: -20px; z-index: 9999; pointer-events: none&#125;.deng-box1 &#123; position: fixed; top: -30px; right: 10px; z-index: 9999; pointer-events: none&#125;.deng-box2 &#123; position: fixed; top: -40px; left: -20px; z-index: 9999; pointer-events: none&#125;.deng-box3 &#123; position: fixed; top: -30px; left: 10px; z-index: 9999; pointer-events: none&#125;.deng-box1 .deng, .deng-box3 .deng &#123; position: relative; width: 120px; height: 90px; margin: 50px; background: #d8000f; background: rgba(216, 0, 15, .8); border-radius: 50% 50%; -webkit-transform-origin: 50% -100px; -webkit-animation: swing 5s infinite ease-in-out; box-shadow: -5px 5px 30px 4px #fc903d&#125;.deng &#123; position: relative; width: 120px; height: 90px; margin: 50px; background: #d8000f; background: rgba(216, 0, 15, .8); border-radius: 50% 50%; -webkit-transform-origin: 50% -100px; -webkit-animation: swing 3s infinite ease-in-out; box-shadow: -5px 5px 50px 4px #fa6c00&#125;.deng-a &#123; width: 100px; height: 90px; background: #d8000f; background: rgba(216, 0, 15, .1); margin: 12px 8px 8px 8px; border-radius: 50% 50%; border: 2px solid #dc8f03&#125;.deng-b &#123; width: 45px; height: 90px; background: #d8000f; background: rgba(216, 0, 15, .1); margin: -4px 8px 8px 26px; border-radius: 50% 50%; border: 2px solid #dc8f03&#125;.xian &#123; position: absolute; top: -20px; left: 60px; width: 2px; height: 20px; background: #dc8f03&#125;.shui-a &#123; position: relative; width: 5px; height: 20px; margin: -5px 0 0 59px; -webkit-animation: swing 4s infinite ease-in-out; -webkit-transform-origin: 50% -45px; background: orange; border-radius: 0 0 5px 5px&#125;.shui-b &#123; position: absolute; top: 14px; left: -2px; width: 10px; height: 10px; background: #dc8f03; border-radius: 50%&#125;.shui-c &#123; position: absolute; top: 18px; left: -2px; width: 10px; height: 35px; background: orange; border-radius: 0 0 0 5px&#125;.deng:before &#123; position: absolute; top: -7px; left: 29px; height: 12px; width: 60px; content: &quot; &quot;; display: block; z-index: 999; border-radius: 5px 5px 0 0; border: solid 1px #dc8f03; background: orange; background: linear-gradient(to right, #dc8f03, orange, #dc8f03, orange, #dc8f03)&#125;.deng:after &#123; position: absolute; bottom: -7px; left: 10px; height: 12px; width: 60px; content: &quot; &quot;; display: block; margin-left: 20px; border-radius: 0 0 5px 5px; border: solid 1px #dc8f03; background: orange; background: linear-gradient(to right, #dc8f03, orange, #dc8f03, orange, #dc8f03)&#125;.deng-t &#123; font-family: 华文行楷, Arial, Lucida Grande, Tahoma, sans-serif; font-size: 3.2rem; color: #dc8f03; font-weight: 700; line-height: 85px; text-align: center&#125;.night .deng-box, .night .deng-box1, .night .deng-t &#123; background: 0 0 !important&#125;@-moz-keyframes swing &#123; 0% &#123; -moz-transform: rotate(-10deg) &#125; 50% &#123; -moz-transform: rotate(10deg) &#125; 100% &#123; -moz-transform: rotate(-10deg) &#125;&#125;@-webkit-keyframes swing &#123; 0% &#123; -webkit-transform: rotate(-10deg) &#125; 50% &#123; -webkit-transform: rotate(10deg) &#125; 100% &#123; -webkit-transform: rotate(-10deg) &#125;&#125;&lt;/style&gt; &gt; 为点点滴滴页面文章添加作者Brave主题发布的文章可以在点点滴滴页面中查看，作者还贴心的加入了文章写作时间以及在时间前加一个深情地写于，觉得很浪漫 image.png 如果在深情地写于前加入谁谁写的那就更完美了，本来这个主题网站就应该两人一起来记录。加入作者的方法如下： 登录网站后台，选择【管理】【用户】进入到管理用户界面，选择新增，添加新的用户，填入基本信息（记住自己账号和密码），用户组选择管理员，最后点击增加用户，为另一半创建新账户。 登录宝塔面板，在【文件】的网站根目录找到并打开/usr/themes/Brave/index.php，大约在代码第23行，找到深情地写于，在前面加入&lt;?php $this-&gt;author();后保存 Text1&lt;time datetime=&quot;&lt;?php $this-&gt;date(&#x27;c&#x27;); ?&gt;&quot; itemprop=&quot;datePublished&quot; &gt; &lt;?php $this-&gt;author(); ?&gt; 深情地写于 &lt;?php $this-&gt;date(); ?&gt;&lt;/time&gt; 登录不同的账户撰写文章，在文章发布后就会显示是谁写的 640 &gt; 添加botui聊天机器人 BotUI框架作为一款自动回复文字、图片、视频的JS聊天机器人，可以自由设置多种选项、触发关键词、输入框等内容，聊天内容或范围也可以自由设置，回复内容可以是文字、图片（GIF亦可）、视频。 botui可以帮助我们与网站访客进行简单地交互，比如用来自我介绍。 接下来演示一下怎么在Brave主题中加入这个聊天机器人。 首先在botui官网：https://github.com/botui/botui 下载必要组件的压缩包并完成解压，下载vue.min.js : https://distance1998.lanzouw.com/iAWaazth3uj并解压。登录宝塔面板，在/usr/themes/Brave目录下新建一个botui文件夹，将botui官网下载的build文件夹下的botui-theme-default.css、botui.min.css、botui.min.js及下载的vue.min.js一并上传至刚刚在宝塔面板新建的botui文件夹。 引入CSS样式文件在head部分引入botui-theme-default.css、botui.min.css。打开网站后台，进入设置外观界面，找到头部自定义内容将下面代码填入到头部自定义内容输入框中 &#96;&#96;html 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#### 创建聊天机器人在body部分添加机器人，引入`botui.min.js`、`vue.min.js`及交互内容`js`文件。其中交互内容`js`文件可以自己命名也可以直接命名为`botui.js`以下均以`botui.js`为例，在添加好交互内容后将`botui.js`上传到`/usr/themes/Brave/botui`文件夹下。交互内容如何写请查看官方文档：`https://docs.botui.org/`。给个小例子，你可以直接将以下代码粘贴到`botui.js`空文件中```JavaScriptvar botui = new BotUI(&quot;botui&quot;); botui.message.bot(&#123; delay: 200, content: &quot;hi，欢迎来到这里😄&quot; &#125;).then(function() &#123; return botui.message.bot(&#123; delay: 1000, content: &quot;我是聊天机器人&quot; &#125;) &#125;).then(function() &#123; return botui.message.bot(&#123; delay: 1000, content: &quot;你想知道什么吗？&quot; &#125;) &#125;).then(function() &#123; return botui.action.button(&#123; delay: 1500, action: [&#123; text: &quot;你来自哪里&quot;, value: &quot;lz&quot; &#125;, &#123; text: &quot;不感兴趣&quot;, value: &quot;bgxq&quot; &#125;] &#125;) &#125;).then(function(res) &#123; if (res.value == &quot;lz&quot;) &#123; lz() &#125; if (res.value == &quot;bgxq&quot;) &#123; bgxq() &#125; &#125;); var lz = function() &#123; botui.message.bot(&#123; delay: 1500, content: &quot;我来自虚拟的网络&quot; &#125;).then(function() &#123; return botui.message.bot(&#123; delay: 1500, content: &quot;是个可爱的机器人😃&quot; &#125;) &#125;) &#125; var bgxq = function() &#123; botui.message.bot(&#123; delay: 1500, content: &quot;再见&quot; &#125;) &#125; 文章页面引入聊天机器人这个比较简单，假设以上均设置好后，新建一篇文章，将以下代码粘贴到文章中（框架未美化），发布后就可以看到聊天机器人与访客的交互效果了。 12345&lt;div class=&quot;botui-app-container&quot; id=&quot;botui&quot;&gt;&lt;!-- id要与交互内容第一行的var botui = new BotUI(&quot;此处填一个id值&quot;)相同; --&gt;&lt;bot-ui&gt;&lt;/bot-ui&gt;&lt;script src=&quot;/usr/themes/Brave/botui/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/usr/themes/Brave/botui/botui.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/usr/themes/Brave/botui/botui.js&quot;&gt;&lt;/script&gt; 最终效果如下： 640 网站首页添加聊天机器人在Brave主题网站里，文章发布后要进入点点滴滴页面才能查看。而我想做一个在网站首页就可以查看的聊天机器人，通过聊天机器人来交互式地介绍这个网站。 方法是创建一个关于我们的模板文件，再创建一个新的页面选择这个模板页，最后将页面显示在网站首页。 1. 创建模板创建一个about-us.php的空文件，将下面代码粘贴到这个文件中。将about-us.php通过宝塔面板上传到根目录下的/usr/themes/Brave文件夹下 1234567891011121314151617181920212223242526272829303132&lt;?php/** * 关于我们 * @package custom * Author: ace * CreateTime: 2022/02/10 * about-us page */ $this-&gt;need(&#x27;base/head.php&#x27;);$this-&gt;need(&#x27;base/nav.php&#x27;);?&gt; &lt;div class=&quot;list-content mx-auto mt-5&quot;&gt; &lt;div class=&quot;list-top&quot;&gt;&lt;h5 class=&quot;list-text&quot;&gt;💕关于我们💕&lt;/h5&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;botui-app-container&quot; id=&quot;botui&quot; style=&quot;min-height:300px; padding:14px 6px 4px 6px; background-image:url(https://s2.loli.net/2022/02/10/htvkG9LmSJWK4CF.jpg); border-radius: 10px;&quot;&gt; &lt;h6 class=&quot;list-text&quot; style=&quot;color:#F2F2F2;&quot;&gt;&lt;strong&gt;与&lt;?php $this-&gt;options-&gt;title() ?&gt;对话中...&lt;/strong&gt;&lt;/h6&gt; &lt;bot-ui style=&quot;background:transparent;&quot;&gt; &lt;center&gt; &lt;h4 style=&quot;color:#F2F2F2;&quot;&gt;Loading...&lt;/h4&gt; &lt;h5 style=&quot;color:#F2F2F2;padding-top:30px;&quot;&gt;请刷新一次页面以使聊天机器人能正常显示&lt;/h5&gt; &lt;/center&gt; &lt;bot-ui&gt;&lt;/div&gt; &lt;script src=&quot;/usr/themes/Brave/botui/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/usr/themes/Brave/botui/botui.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/usr/themes/Brave/botui/botui.js&quot;&gt;&lt;/script&gt;&lt;?php $this-&gt;need(&#x27;base/footer.php&#x27;); ?&gt; 2. 创建新的独立页登录网站后台，选择创建页面，在自定义模板中选择关于我们模板，标题任意填写，链接可以填写about-us。最后点击发布页面 3. 设置关于我们页面显示在网站首页找到并打开/usr/themes/Brave/functions.php，将以下代码填入到functions.php中保存，最好靠近lovelist和祝福板表单。 1234 $aboutPageIcon = new Typecho_Widget_Helper_Form_Element_Text(&#x27;aboutPageIcon&#x27;, NULL, NULL, _t(&#x27;首页关于页面图标&#x27;), _t(&#x27;在此输入图标直链，将显示在首页关于小版块中&#x27;)); $form-&gt;addInput($aboutPageIcon); $aboutPageLink = new Typecho_Widget_Helper_Form_Element_Text(&#x27;aboutPageLink&#x27;, NULL, NULL, _t(&#x27;关于页面链接&#x27;), _t(&#x27;在此输入关于页面链接&#x27;)); $form-&gt;addInput($aboutPageLink); 在网站后台的设置外观填入图标链接和前面创建页面的链接，链接前要加http(s):// 640 找到并打开/usr/themes/Brave/indexPage.php，将以下代码填入&lt;div class=&quot;row indexPlate&quot;&gt;下方并保存，代码中的文字可任意修改 Text1234567891011121314151617 &lt;div class=&quot;col-md-4&quot;&gt; &lt;a href=&quot;&lt;?php $this-&gt;options-&gt;aboutPageLink() ?&gt;&quot; class=&quot;card &quot;&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;div class=&quot;row align-items-center&quot;&gt; &lt;div class=&quot;col-auto&quot;&gt; &lt;div class=&quot;avatar avatar-md&quot;&gt; &lt;img src=&quot;&lt;?php $this-&gt;options-&gt;aboutPageIcon() ?&gt;&quot; alt=&quot;...&quot; class=&quot;avatar-img rounded-circle&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col&quot;&gt; &lt;p class=&quot;h5&quot;&gt;关于我们&lt;/p&gt; &lt;p class=&quot;small text-muted mb-1&quot;&gt;💑我们的经历&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/a&gt; &lt;/div&gt; 回到网站就可以发现关于我们页面已经出现在网站首页 640 点击关于我们进入交互聊天机器人页面，效果如下： 640 如果你的效果与我的不一样或者想让手机端有个更好的显示效果，请打开/usr/themes/Brave/botui/botui.min.css将以下代码替换11行的.botui-app-container选择器 1.botui-app-container&#123;width:90%;height:100%;line-height:1;margin:0 auto&#125;@media (min-width:600px)&#123;.botui-app-container&#123;width:600px;height:500px;margin:0 auto&#125;&#125; 注：目前基于页面的聊天机器人可能会出现加载不出的情况，这是由于该主题具有pjax无刷新加载网页的功能，关于页面中的js文件无法被网页加载，解决办法就是刷新一次关于页面。基于文章的聊天机器人则不会出现这种情况。 &gt; 为网站添加相册如果一个网站没有相册功能那也太不完美了，Brave主题本着简洁不自带相册功能。那么如何给Brave主题添加相册呢？ 通过搜索找到了一个基于typecho的相册单页面模板，该模板来自：https://github.com/zzd/photo-page-for-typecho，感谢作者的开源。作者提供了两种相册模板：Multiverse和lens。Multiverse demo：https://html5up.net/uploads/demos/multiverse/ Lens demo：https://html5up.net/uploads/demos/lens/ 在GitHub上下载模板文件后，将其中的Multiverse.php、Lens.php、Multiverse文件夹及Lens文件夹上传到/usr/themes/Brave文件夹下。以Multiverse相册风格为例进行创建相册演示 创建相册页面登录网站后台，选择创建页面，在自定义模板中选择Multiverse风格照片集模板，标题填写相册，链接可以填写album。最后点击发布页面 设置相册页面显示在网站首页与创建关于我们页面相同，将以下代码填入到functions.php中保存 1234$albumPageIcon = new Typecho_Widget_Helper_Form_Element_Text(&#x27;albumPageIcon&#x27;, NULL, NULL, _t(&#x27;首页相册页面图标&#x27;), _t(&#x27;在此输入图标直链，将显示在首页相册小版块中&#x27;)); $form-&gt;addInput($albumPageIcon); $albumPageLink = new Typecho_Widget_Helper_Form_Element_Text(&#x27;albumPageLink&#x27;, NULL, NULL, _t(&#x27;相册页面链接&#x27;), _t(&#x27;在此输入相册页面链接&#x27;)); $form-&gt;addInput($albumPageLink); 在网站后台的设置外观填入图标链接和前面创建相册页面的链接，链接前要加http(s):// 640 将以下代码填入indexPage.php合适的位置并保存，代码中的文字可任意修改 1234567891011121314151617&lt;div class=&quot;col-md-4&quot;&gt; &lt;a href=&quot;&lt;?php $this-&gt;options-&gt;albumPageLink() ?&gt;&quot; class=&quot;card &quot;&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;div class=&quot;row align-items-center&quot;&gt; &lt;div class=&quot;col-auto&quot;&gt; &lt;div class=&quot;avatar avatar-md&quot;&gt; &lt;img src=&quot;&lt;?php $this-&gt;options-&gt;albumPageIcon() ?&gt;&quot; alt=&quot;...&quot; class=&quot;avatar-img rounded-circle&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col&quot;&gt; &lt;p class=&quot;h5&quot;&gt;相册&lt;/p&gt; &lt;p class=&quot;small text-muted mb-1&quot;&gt;🖼️留住你我回忆&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/a&gt; &lt;/div&gt; 回到网站可以发现相册页面已经出现在网站首页 640 发布照片到相册方法是打开前面创建的相册页面，在页面中填入照片标题,拍摄时间,照片的链接分隔的逗号为英文逗号。也可以不填标题时间，但照片的链接前一定要有,,。更多使用说明请查看作者的readme文件。相册效果如下： 640 640 &gt; 为lovelist页面清单增加完成时间原主题的恋爱清单只能显示清单有无完成和插入一张图片，如下： 640 但我想让每个清单里都能显示一个完成清单的时间，经过摸索解决了我的需求。 在宝塔面板找到并打开/usr/themes/Brave/core/App.php，在$out .= &#39;&lt;div class=&quot;card-body p-0&quot;&gt;&#39;（大约第58行）下方插入如下代码 1$out .= &#x27;&lt;div class=&quot;lover-card-title&quot; style=&quot;padding:10px 8px 10px 8px;&quot;&gt;清单完成时间：&#x27;.$value[&#x27;listct&#x27;].&#x27;&lt;/div&gt;&#x27;; 重新编辑恋爱清单页面，清单完成时间的关键字是listct 示例： 123456[loveList][item status=&quot;1&quot; img=&quot;图片url&quot; listct=&quot;2022-02-03&quot;]两个人共用一个博客记录生活点滴🖊️[/item][/loveList] 效果如下： 640 文字默认居中对齐，如果想文字左对齐就在style=&quot;&quot;加入text-align:left; 当然除了写清单完成时间，也可以写一些对清单的描述。 &gt; 为主题添加文章样式本来是不打算改主题文章样式的，因为这个网站只是用来记录我们俩个人的生活和想法，能记录文字就行。但经过测试发现这不是样式简不简陋的问题了，这特喵的根本没有样式好不好 原主题文章样式长这样： 640 唉，还是自己重新写一个样式吧 修改后的文章样式： 640 如果想使用我的主题样式，请将下面的代码复制到/usr/themes/Brave/base/style.css中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248/*文章样式部分*//*开始*//* 全局声明 */#article&#123; line-height: 1.6rem; letter-spacing: .3px;&#125;/* 标题 */#article h1,h2,h3&#123; color:#666; font-weight:700 !important;&#125; #article h1:before &#123; display:block; content:&quot;&quot;; margin-top:30px&#125; #article h1:nth-of-type(1)::before &#123; display:block;margin-top:10px;&#125; #article h1&#123; font-size:28px !important; color:#666; line-height:1.4; margin: 2rem auto 1.4rem !important; background:linear-gradient(to bottom,transparent 65%,rgba(152,176,141,.2) 0) no-repeat; width:auto; display:inline;&#125; #article h1:after &#123; display:block; content:&quot;&quot;; margin-bottom:10px;&#125; #article h2&#123; font-size: 24px !important; margin: 1.6rem auto 1.2rem !important; border-left: 5px solid #98B08D; padding: .1rem .3rem ;&#125; #article h3 &#123; margin: 1.4rem auto 1.2rem !important; font-size:21px !important; font-weight:bold; padding-bottom:3px; border-bottom:1px solid rgba(233,238,231);&#125;#article h4&#123; margin: 1rem auto 1rem !important; font-size:19px !important;&#125;#article h5&#123; margin: 1rem auto 1rem !important; font-size:17px; color:#98B08D;&#125; #article h6&#123; margin: 1rem auto 1rem !important; font-size:17px;&#125;/* 段落 */#article p&#123; font-size:15px; &#125; /* 引用 */#article blockquote&#123; font-family: &quot;Helvetica&quot;, Arial, &quot;kaiti&quot;,&quot;pingfangSC light&quot;, &quot;microsoft yahei&quot; !important; margin: 1.6rem auto 1.2rem !important; padding: 15px 10px 1px 15px; line-height: 27px; background-color:#F7F7F7; border-left:3px solid #98B08D; color:#808080; display:block;&#125; /* 行内代码 */#article li code,p code&#123; color: #789769 !important; background-color: rgba(233,238,231,0.5); font-family: &quot;LM Mono 10&quot;,&quot;microsoft yahei&quot;,&quot;Times New Roman&quot;,Arial, simsun, &quot;pingfangSC light&quot;, sans-serif; font-size: 0.875rem; box-sizing: border-box; margin: 0 4px; padding: 1px 2px ; border-radius: 2px; box-shadow: 0 0 .8px .8px rgba(129,181,103,.5);&#125; /*列表*/ #article ol,#article ul &#123; padding-left: 25px; margin: .5rem 0;&#125; #article ol&gt;li,#article ul&gt;li &#123; color: #333;&#125; #article li::marker&#123; color: #617a55;&#125; #article ol &#123; margin: 1.2rem auto 1rem !important; padding-left: 25px !important; list-style-type: decimal !important;&#125; #article ul &#123; list-style-type: circle;&#125; #article ul ul,#article ol ul&#123; list-style-type: disc; &#125; #article ul ul ul,#article ol ul ul,#article ol ol ul,#article ul ol ul&#123; list-style-type: square; &#125; /*表格*/#article table &#123; margin: 1.6rem auto !important; width: 100%; overflow: auto; display: table; font-size: 14px; border-spacing: 0; border-collapse: collapse; word-break: normal; word-wrap: normal; border-radius: 3px; box-shadow: 2px 2px 5px 1px #8c8c8c61;&#125; #article table td, table th &#123; border-radius: 3px; padding: 6px 13px; word-break: keep-all;&#125; #article table th &#123; font-weight: 700; color:#789769; background-color: #f8f8f8;&#125; #article table tr:nth-child(2n) &#123; background-color: #f8f8f8;&#125;/* 分割线 */#article hr &#123; margin: 2rem 0 !important; border-top: 2px dotted #F2F2F2 !important;&#125; #article pre&#123; margin: 1.2rem auto 1.6rem!important; padding:10px 15px; background-color:#F2F2F2 !important; border-radius:5px;&#125;/* 图片 */#article img &#123; margin:1rem auto; border: 10px solid #ffffff!important; outline: 1px solid #F2F2F2;&#125;/* 文字加粗 */#article strong&#123; color: #6FB147; font-weight: bold;&#125; #article strong::before &#123; content: &#x27;「&#x27;;&#125; #article strong::after &#123; content: &#x27;」&#x27;;&#125;/* 动态彩虹字 考虑到斜体用的比较少，将斜体语法改为显示动态彩虹字 */#article em &#123; font-style:normal; background-image: linear-gradient(to left, orangered, orange, gold, lightgreen, cyan, dodgerblue, mediumpurple, hotpink, orangered); background-size: 110vw; -webkit-background-clip: text; background-clip: text; color: transparent; -webkit-animation:rainbow 60s linear infinite; animation: rainbow 60s linear infinite;&#125; @keyframes rainbow &#123; 100% &#123; background-position: -2000vw;&#125;&#125;button, input, optgroup, select, textarea &#123; margin: 1rem 0 1rem -15px !important;&#125;/* 删除线 */del &#123; padding: 1px 2px; text-decoration: line-through #F87466; color:#808080;&#125;/* 文章最后加上THE STORY CONTINUES... */#article:after&#123; content:&#x27;THE STORY CONTINUES...&#x27;; font-size:16px; display:block; text-align:center; margin-top:50px; color:#999; border-bottom:1px solid #eee;&#125;/*结束*/ 考虑到不经常使用斜体，所以我把斜体的样式改成了动态彩虹字效果，语法是在想要的文字效果前各加一个* 640 想要实现文字高亮的效果请在style.css文件中加入以下代码 123456/*文字高亮*/.highlight&#123; background-color: #9BE9B3; padding: 2px 4px; margin: 0 2px;&#125; 在书写文章时写入以下语法就可给文字加上高亮： &lt;span class=&quot;highlight&quot;&gt;这里的文字都会有高亮效果&lt;/span&gt; 如果想自己二次修改样式可以在上面的代码进行修改，每段代码所对应的样式我已经给了注释，你只需要会一些简单的css语法即可自己定制。 最后参考资料[1]Brave主题: https://blog.zwying.com/archives/59.html [2]秦枫鸢梦: https://blog.zwying.com/ [3]Typecho安装包: http://typecho.org/download [4]Brave主题官方下载地址: https://github.com/zwying0814/Brave [5]网站顶部挂上灯笼: https://www.vfaner.com/2080.html","tags":["Typecho"],"categories":["WebSite"]},{"title":"Cloudreve搭建教学","path":"/posts/d00c523a.html","content":"1、官方支持的网站和文档 官网：https://cloudreve.org/ github：https://github.com/cloudreve/Cloudreve 下载：https://github.com/cloudreve/Cloudreve/releases 安装文档：https://docs.cloudreve.org/getting-started/install 演示：https://demo.cloudreve.org 2、宝塔命令行输入代码查询内核参数arch 输出结果x86_64代表amd64；aarch64代表arm64 www692c7ced81debe908a42d55366feb62f.png 3、下载链接处找到对应的版本,复制链接地址www37f1aacada56537f68aca90dff50dd00.png 4、宝塔安全添加5212端口www49e2c140a15ae2ffc89b81ebff737582.png 5、宝塔命令行逐行执行以下命令，对应链接处改为自己复制的：（当然你也可以把下边的改成自己的然后全部复制黏贴就完事了）1234567891011mkdir /www/wwwroot/cloudreve # 新建一个文件夹存放程序cd /www/wwwroot/cloudreve # 进入该文件夹wget https://github.com/cloudreve/Cloudreve/releases/download/3.0.0/cloudreve_3.0.0_linux_amd64.tar.gz # 下载你复制的链接tar -zxvf cloudreve_3.0.0_linux_amd64.tar.gz # 解压获取到的主程序chmod +x ./cloudreve # 赋予执行权限./cloudreve # 启动 Cloudreve 6、安装完成，保存账户和登录密码，务必保存该密码，测试登录登录地址为服务器ip:5212，比如http://192.168.0.125:5212/ wwwbef2b5a7f660a59a328fe606498d2d65.png 7、想要无忧使用，最好是加个进程守护，这样就不需要每次都到后台启动进程命令行端口ctrl+c，停止进程后关闭即可 感谢宝塔能够安装Supervisor管理器 www97e152583d4696d13dfb036d5f0ce107.png 配置这样填：wwwd57cbdea3cf04253f454cc38c53e265b.png 添加成功后，看下进程状态是否为开启的绿三角，假如不是就重启服务器，再回来看下，还不是就检查配置是否正确。8、搞到这里基本就能正常使用网盘了，下边的配置不是必选，可根据自己需要选择可选配置1、绑定域名访问添加一个网站，设置反向代理 www7d7e61dfe2a13318dd64d77eafab7313.png 可选配置2、默认数据库是自带的SQLite，可改为mysql新建一个mysql数据库，将相关信息添加在目录下的conf.ini文件里，命令行重启进程，获得新账号密码 12345678910111213141516171819202122232425[Database]; 数据库类型，目前支持 sqlite | mysqlType = mysql; 用户名User = cloudreve; 密码Password = cloudreve; 数据库地址Host = 127.0.0.1; 数据库名称Name = cloudreve; 数据表前缀TablePrefix = cd @大海资源网","tags":["Cloudreve"],"categories":["WebSite"]},{"title":"NPM换源","path":"/posts/41cdd4e5.html","content":"查看源先看看源指向哪里： 1npm config get registry 默认是指向 https://registry.npmjs.org/，也就是官方源。 更换源国内源有很多，我这里用淘宝源吧。毕竟是大公司，会比较稳定。 1npm config set registry https://registry.npmmirror.com/ 一些文章还是写着旧的淘宝 NPM 镜像 registry.npm.taobao.org，但它已于 2022 年 05 月 31 日 废弃，读者需要更换为新的 registry.npmmirror.com 源。 这个配置会持久化保存到 ~/.npmrc 文件中，你也可以通过手动改该文件来修改配置。 nrm包因为换源要记域名很麻烦，还要手打较长的命令，所以我们可以考虑安装 nrm 包 1npm i -g nrm nrm 其实就是 NPM registry manager，管理 NPM 源泉的简单命令行工具。 令人悲伤的是，如果用国外源安装 nrm，有可能会因为超时而安装失败。 通过 nrm ls 会列出一些可选择的公有源： 12345678$ nrm ls npm ---------- https://registry.npmjs.org/ yarn --------- https://registry.yarnpkg.com/ tencent ------ https://mirrors.cloud.tencent.com/npm/ cnpm --------- https://r.cnpmjs.org/ taobao ------- https://registry.npmmirror.com/ npmMirror ---- https://skimdb.npmjs.com/registry/ 通过 nrm use &lt;源的名称&gt;，则会配置为对应的 registry url。 1234$ nrm use taobao Registry has been set to: https://registry.npmmirror.com/ nrm 工具的子命令不只是这些，比如可以在列表中新增自己的私有源。不过基本来说，也就前面提到的这两个最常用。具体可以阅读它的文档。 话说它好像有点小 bug。作者其实并没有好好维护，曾经有一段时间 npm 升级，nrm 没有跟进，导致不可使用，后来是修好了。","tags":["NodeJS","Module"],"categories":["Language"]},{"title":"Aria2 一键安装管理脚本 增强版","path":"/posts/bda8ab0.html","content":"Aria2 是目前最强大的全能型下载工具，它支持 BT、磁力、HTTP、FTP 等下载协议，常用做离线下载的服务端。Aria2 一键安装管理脚本是 Toyo (逗比) 大佬最为知名的脚本作品之一，2018年11月14日逗比大佬因未知原因突然失联。由于博主非常喜欢 Aria2 所以自2018年12月7日起开始接手这个项目并进行了大量的功能与细节优化，一直持续维护至今。增强版脚本整合了 Aria2 完美配置，在安装 Aria2 的过程中会下载这套配置方案，这套方案包含了配置文件、附加功能脚本等文件，用于实现 Aria2 功能的增强和扩展，提升 Aria2 的下载速度与使用体验，解决 Aria2 在使用中遇到的 BT 下载无速度、文件残留占用磁盘空间、任务丢失、重复下载等问题。 功能特性 使用 Aria2 完美配置方案 BT 下载率高、速度快 重启后不丢失任务进度、不重复下载 删除正在下载的任务自动删除未完成的文件 下载错误自动删除未完成的文件 下载完成自动删除控制文件(.aria2后缀名文件) 下载完成自动删除种子文件(.torrent后缀名文件) 下载完成自动删除空目录 BT 下载完成自动清除垃圾文件(文件类型过滤功能) BT 下载完成自动清除小文件(文件大小过滤功能) 有一定的防版权投诉、防迅雷吸血效果 更好的 PT 下载支持 使用 Aria2 Pro Core 项目最新静态编译二进制文件 多平台：amd64, i386, arm64, armhf 全功能：Async DNS, BitTorrent, Firefox3 Cookie, GZip, HTTPS, Message Digest, Metalink, XML-RPC, SFTP 单服务器线程数最大值无上限（已破解线程数限制） 防掉线程优化 最新依赖库，下载更安全、稳定、快速 持续更新最新版本 支持与 RCLONE 联动，更多扩展功能与玩法： OneDrive、Google Drive 等网盘离线下载 百度网盘转存到 OneDrive 、Google Drive 等其他网盘 支持新一代互联网协议 IPv6 定时自动更新 BT tracker 列表（无需重启） 项目地址https://github.com/P3TERX/aria2.sh 支持项目请随手点个star，可以让更多的人发现、使用并受益。你的支持是我持续开发维护的动力。 系统要求CentOS 6+ &#x2F; Debian 6+ &#x2F; Ubuntu 14.04+ 架构支持x86_64 &#x2F; i386 &#x2F; ARM64 &#x2F; ARM32v7 &#x2F; ARM32v6 使用说明 为了确保能正常使用，请先安装基础组件wget、curl、ca-certificates，以 Debian 为例子： 1apt install wget curl ca-certificates 下载脚本 1wget -N git.io/aria2.sh &amp;&amp; chmod +x aria2.sh 运行脚本 1./aria2.sh 选择你要执行的选项 1234567891011121314151617181920212223242526Aria2 一键安装管理脚本 增强版 [v2.7.4] by P3TERX.COM 0. 升级脚本——————————————————————— 1. 安装 Aria2 2. 更新 Aria2 3. 卸载 Aria2——————————————————————— 4. 启动 Aria2 5. 停止 Aria2 6. 重启 Aria2——————————————————————— 7. 修改 配置 8. 查看 配置 9. 查看 日志10. 清空 日志———————————————————————11. 手动更新 BT-Tracker12. 自动更新 BT-Tracker———————————————————————Aria2 状态: 已安装 | 已启动自动更新 BT-Tracker: 已开启请输入数字 [0-12]: 其他操作启动：/etc/init.d/aria2 start | service aria2 start 停止：/etc/init.d/aria2 stop | service aria2 stop 重启：/etc/init.d/aria2 restart | service aria2 restart 查看状态：/etc/init.d/aria2 status | service aria2 status 配置文件路径：/root/.aria2c/aria2.conf （配置文件有中文注释，若语言设置有问题会导致中文乱码） 默认下载目录：/root/downloads RPC 密钥：随机生成，可使用选项7. 修改 配置文件自定义","tags":["Aria2"],"categories":["WebSite"]},{"title":"SQL常用语句简要","path":"/posts/df08585d.html","content":"1，查看字段和属性1desc user; = show columns from user; mysql对用户密码的加密方式是MySQLSHA1加密 2，where,and的用法1select user,host,password from mysql.user where user=&#x27;root&#x27; and host=&#x27;localhost&#x27;; 3，建立表1create table linux(username varchar(6) not null, password varchar(50) not null ); 4，行操作12345insert into linux values ( &#x27;ha_weii&#x27;,&#x27;redhat&#x27; );update linux set username=&#x27;haweii&#x27; where username=&#x27;ha_weii&#x27;delete from linux where username=&#x27;haweii&#x27; 5，列操作12345alter table linux add age varchar(4);alter table linux add classroom varchar(5) after age;alter table linux drop age; 6，修改数据表名1alter table old_table_name rename new_table_name 7，修改数据库名123cd /var/lib/mysql/mv old_database_name new_database_namesystemctl restart mariadb 8，删除数据表，数据库12drop table linux;drop databases westos; 9，远程登陆数据库1mysql -h 远程ip -uusername -ppassword 10，本地用户管理1234567891011create user ha_weii@localhost identified by &#x27;redhat&#x27;;grant instert,update,delete,select on linux.* to ha_weii@localhost;grant允许用户把自己拥有的权限授予其他的用户。show grants for ha_weii@localhost;注意：这里查看到的权限有一个是usage，这个权限是创建用户之后就会授予的权限，该权限只能用于数据库登陆revoke update on linux.*　from ha_weii@locahost;drop user ha_weii@localhost; 如果使用grant,revoke命令对授权表进行修改，那么服务器会注意到更改并立即将授权表重新载入内存。如果手动修改授权表（使用insert，update或delete等），则应该执行mysqladmin flush-privileges或mysqladmin reload告诉服务器再重新装载授权表，否则手动的更改将不会生效，除非重启服务器。 11，更改用户密码12345mysqladmin -uroot -predhat password &#x27;linux&#x27;update mysql.user set Password=password(&#x27;linux&#x27;) where user=&#x27;root&#x27;;alter user root@localhost identified by &#x27;linux&#x27; 12，模糊查询like‘%’匹配所有‘‘匹配单字符必须和LIKE共同使用:也就是说通配符只能在有like的情况下使用，如果是和’&#x3D;’一起使用，那就只是普通的字符了。 查询名字是张开头的： 1select * from user where name like &#x27;张%&#x27;; 查询名字以张开头且后跟一个字符的： 1select * from user where name like &#x27;张&#x27;;","tags":["MySQL","Database"],"categories":["Language"]},{"title":"数据库的小技巧","path":"/posts/ab330c32.html","content":"1，卸载数据库123yum remove mariadb-server -yrm -rf /var/lib/mysql 注意还要删除库文件 2，破译超级用户的密码123456789101112131415161718192021systemctl stop mariadb.servicemysqld_safe --skip-grant-tables &amp; 跳过授权表并打入后台运行，这里会卡住，多敲几下回车mysql 无密码登陆update mysql.user set Password=password(&#x27;linux&#x27;) where User=&#x27;root&#x27;; 修改密码，注意要使用password()exitfg 调入前台ctrl+z 挂起进程killall -9 mysqld_safe kill所有和mysqld_safe相关的进程ps aux | grep mysqlkill -9 进程idsystemctl start mariadb 3，数据库备份与导入 Text1mysqldump -uroot -predhat linux &gt; /mnt/linux.sql 123456789mysql -uroot -predhat linux &lt; /mnt/linux.sql如果没有linux这个库，那么还需要建立一个库方法一:mysql -uroot -predhat -e &#x27;create database linux;&#x27;方法二: 在linux.sql文件的前面加上create database linux;use linux;","tags":["Database","MariaDB","Tips"],"categories":["Language"]},{"title":"Python中requests使用","path":"/posts/51b39d74.html","content":"快速上手迫不及待了吗？本页内容为如何入门 Requests 提供了很好的指引。其假设你已经安装了 Requests。如果还没有，去安装一个看看吧。 首先，确认一下： Requests 已安装 Requests 是最新的 我们从一些简单的示例开始吧。 发送请求使用 Requests 发送网络请求非常简单。 一开始要导入 Requests 模块： Text12&gt;&gt;&gt; import requests 然后，尝试获取某个网页。本例子中，我们来获取 Github 的公共时间线： Text12&gt;&gt;&gt; r = requests.get(&#x27;https://api.github.com/events&#x27;) 现在，我们有一个名为 r 的 [Response](https://docs.python-requests.org/zh_CN/latest/api.html#requests.Response) 对象。我们可以从这个对象中获取所有我们想要的信息。 Requests 简便的 API 意味着所有 HTTP 请求类型都是显而易见的。例如，你可以这样发送一个 HTTP POST 请求： Text1&gt;&gt;&gt; r = requests.post(&#x27;http://httpbin.org/post&#x27;, data = &#123;&#x27;key&#x27;:&#x27;value&#x27;&#125;) 漂亮，对吧？那么其他 HTTP 请求类型：PUT，DELETE，HEAD 以及 OPTIONS 又是如何的呢？都是一样的简单： Text1234&gt;&gt;&gt; r = requests.put(&#x27;http://httpbin.org/put&#x27;, data = &#123;&#x27;key&#x27;:&#x27;value&#x27;&#125;)&gt;&gt;&gt; r = requests.delete(&#x27;http://httpbin.org/delete&#x27;)&gt;&gt;&gt; r = requests.head(&#x27;http://httpbin.org/get&#x27;)&gt;&gt;&gt; r = requests.options(&#x27;http://httpbin.org/get&#x27;) 都很不错吧，但这也仅是 Requests 的冰山一角呢。 传递 URL 参数你也许经常想为 URL 的查询字符串(query string)传递某种数据。如果你是手工构建 URL，那么数据会以键&#x2F;值对的形式置于 URL 中，跟在一个问号的后面。例如， httpbin.org/get?key=val。 Requests 允许你使用 params 关键字参数，以一个字符串字典来提供这些参数。举例来说，如果你想传递 key1=value1 和 key2=value2 到 httpbin.org/get ，那么你可以使用如下代码： Text12&gt;&gt;&gt; payload = &#123;&#x27;key1&#x27;: &#x27;value1&#x27;, &#x27;key2&#x27;: &#x27;value2&#x27;&#125;&gt;&gt;&gt; r = requests.get(&quot;http://httpbin.org/get&quot;, params=payload) 通过打印输出该 URL，你能看到 URL 已被正确编码： Text12&gt;&gt;&gt; print(r.url)http://httpbin.org/get?key2=value2&amp;key1=value1 注意字典里值为 None 的键都不会被添加到 URL 的查询字符串里。 你还可以将一个列表作为值传入： Text123456&gt;&gt;&gt; payload = &#123;&#x27;key1&#x27;: &#x27;value1&#x27;, &#x27;key2&#x27;: [&#x27;value2&#x27;, &#x27;value3&#x27;]&#125;&gt;&gt;&gt; r = requests.get(&#x27;http://httpbin.org/get&#x27;, params=payload)&gt;&gt;&gt; print(r.url)http://httpbin.org/get?key1=value1&amp;key2=value2&amp;key2=value3 响应内容我们能读取服务器响应的内容。再次以 GitHub 时间线为例： Text12345&gt;&gt;&gt; import requests&gt;&gt;&gt; r = requests.get(&#x27;https://api.github.com/events&#x27;)&gt;&gt;&gt; r.textu&#x27;[&#123;&quot;repository&quot;:&#123;&quot;open_issues&quot;:0,&quot;url&quot;:&quot;https://github.com/... Requests 会自动解码来自服务器的内容。大多数 unicode 字符集都能被无缝地解码。 请求发出后，Requests 会基于 HTTP 头部对响应的编码作出有根据的推测。当你访问 r.text 之时，Requests 会使用其推测的文本编码。你可以找出 Requests 使用了什么编码，并且能够使用 r.encoding 属性来改变它： Text123&gt;&gt;&gt; r.encoding&#x27;utf-8&#x27;&gt;&gt;&gt; r.encoding = &#x27;ISO-8859-1&#x27; 如果你改变了编码，每当你访问 r.text ，Request 都将会使用 r.encoding 的新值。你可能希望在使用特殊逻辑计算出文本的编码的情况下来修改编码。比如 HTTP 和 XML 自身可以指定编码。这样的话，你应该使用 r.content 来找到编码，然后设置 r.encoding 为相应的编码。这样就能使用正确的编码解析 r.text 了。 在你需要的情况下，Requests 也可以使用定制的编码。如果你创建了自己的编码，并使用 codecs 模块进行注册，你就可以轻松地使用这个解码器名称作为 r.encoding 的值， 然后由 Requests 来为你处理编码。 二进制响应内容你也能以字节的方式访问请求响应体，对于非文本请求： Text12&gt;&gt;&gt; r.contentb&#x27;[&#123;&quot;repository&quot;:&#123;&quot;open_issues&quot;:0,&quot;url&quot;:&quot;https://github.com/... Requests 会自动为你解码 gzip 和 deflate 传输编码的响应数据。 例如，以请求返回的二进制数据创建一张图片，你可以使用如下代码： Text1234&gt;&gt;&gt; from PIL import Image&gt;&gt;&gt; from io import BytesIO&gt;&gt;&gt; i = Image.open(BytesIO(r.content)) JSON 响应内容Requests 中也有一个内置的 JSON 解码器，助你处理 JSON 数据： Text12345&gt;&gt;&gt; import requests&gt;&gt;&gt; r = requests.get(&#x27;https://api.github.com/events&#x27;)&gt;&gt;&gt; r.json()[&#123;u&#x27;repository&#x27;: &#123;u&#x27;open_issues&#x27;: 0, u&#x27;url&#x27;: &#x27;https://github.com/... 如果 JSON 解码失败， r.json() 就会抛出一个异常。例如，响应内容是 401 (Unauthorized)，尝试访问 r.json() 将会抛出 ValueError: No JSON object could be decoded 异常。 需要注意的是，成功调用 r.json() 并不意味着响应的成功。有的服务器会在失败的响应中包含一个 JSON 对象（比如 HTTP 500 的错误细节）。这种 JSON 会被解码返回。要检查请求是否成功，请使用 r.raise_for_status() 或者检查 r.status_code 是否和你的期望相同。 原始响应内容在罕见的情况下，你可能想获取来自服务器的原始套接字响应，那么你可以访问 r.raw。 如果你确实想这么干，那请你确保在初始请求中设置了 stream=True。具体你可以这么做： Text12345&gt;&gt;&gt; r = requests.get(&#x27;https://api.github.com/events&#x27;, stream=True)&gt;&gt;&gt; r.raw&lt;requests.packages.urllib3.response.HTTPResponse object at 0x101194810&gt;&gt;&gt;&gt; r.raw.read(10)&#x27;\\x1f\\x8b\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x03&#x27; 但一般情况下，你应该以下面的模式将文本流保存到文件： Text123with open(filename, &#x27;wb&#x27;) as fd: for chunk in r.iter_content(chunk_size): fd.write(chunk) 使用 Response.iter_content 将会处理大量你直接使用 Response.raw 不得不处理的。 当流下载时，上面是优先推荐的获取内容方式。 Note that chunk_size can be freely adjusted to a number that may better fit your use cases. 定制请求头如果你想为请求添加 HTTP 头部，只要简单地传递一个 dict 给 headers 参数就可以了。 例如，在前一个示例中我们没有指定 content-type: Text1234&gt;&gt;&gt; url = &#x27;https://api.github.com/some/endpoint&#x27;&gt;&gt;&gt; headers = &#123;&#x27;user-agent&#x27;: &#x27;my-app/0.0.1&#x27;&#125;&gt;&gt;&gt; r = requests.get(url, headers=headers) 注意: 定制 header 的优先级低于某些特定的信息源，例如： 如果在 .netrc 中设置了用户认证信息，使用 headers&#x3D; 设置的授权就不会生效。而如果设置了 auth= 参数，.netrc 的设置就无效了。 如果被重定向到别的主机，授权 header 就会被删除。 代理授权 header 会被 URL 中提供的代理身份覆盖掉。 在我们能判断内容长度的情况下，header 的 Content-Length 会被改写。 更进一步讲，Requests 不会基于定制 header 的具体情况改变自己的行为。只不过在最后的请求中，所有的 header 信息都会被传递进去。 注意: 所有的 header 值必须是 string、bytestring 或者 unicode。尽管传递 unicode header 也是允许的，但不建议这样做。 更加复杂的 POST 请求通常，你想要发送一些编码为表单形式的数据——非常像一个 HTML 表单。要实现这个，只需简单地传递一个字典给 data 参数。你的数据字典在发出请求时会自动编码为表单形式： Text123456789101112&gt;&gt;&gt; payload = &#123;&#x27;key1&#x27;: &#x27;value1&#x27;, &#x27;key2&#x27;: &#x27;value2&#x27;&#125;&gt;&gt;&gt; r = requests.post(&quot;http://httpbin.org/post&quot;, data=payload)&gt;&gt;&gt; print(r.text)&#123; ... &quot;form&quot;: &#123; &quot;key2&quot;: &quot;value2&quot;, &quot;key1&quot;: &quot;value1&quot; &#125;, ...&#125; 你还可以为 data 参数传入一个元组列表。在表单中多个元素使用同一 key 的时候，这种方式尤其有效： Text12345678910111213&gt;&gt;&gt; payload = ((&#x27;key1&#x27;, &#x27;value1&#x27;), (&#x27;key1&#x27;, &#x27;value2&#x27;))&gt;&gt;&gt; r = requests.post(&#x27;http://httpbin.org/post&#x27;, data=payload)&gt;&gt;&gt; print(r.text)&#123; ... &quot;form&quot;: &#123; &quot;key1&quot;: [ &quot;value1&quot;, &quot;value2&quot; ] &#125;, ...&#125; 很多时候你想要发送的数据并非编码为表单形式的。如果你传递一个 string 而不是一个 dict，那么数据会被直接发布出去。 例如，Github API v3 接受编码为 JSON 的 POST&#x2F;PATCH 数据： Text123456&gt;&gt;&gt; import json&gt;&gt;&gt; url = &#x27;https://api.github.com/some/endpoint&#x27;&gt;&gt;&gt; payload = &#123;&#x27;some&#x27;: &#x27;data&#x27;&#125;&gt;&gt;&gt; r = requests.post(url, data=json.dumps(payload)) 此处除了可以自行对 dict 进行编码，你还可以使用 json 参数直接传递，然后它就会被自动编码。这是 2.4.2 版的新加功能： Text1234&gt;&gt;&gt; url = &#x27;https://api.github.com/some/endpoint&#x27;&gt;&gt;&gt; payload = &#123;&#x27;some&#x27;: &#x27;data&#x27;&#125;&gt;&gt;&gt; r = requests.post(url, json=payload) POST一个多部分编码(Multipart-Encoded)的文件Requests 使得上传多部分编码文件变得很简单： Text123456789101112&gt;&gt;&gt; url = &#x27;http://httpbin.org/post&#x27;&gt;&gt;&gt; files = &#123;&#x27;file&#x27;: open(&#x27;report.xls&#x27;, &#x27;rb&#x27;)&#125;&gt;&gt;&gt; r = requests.post(url, files=files)&gt;&gt;&gt; r.text&#123; ... &quot;files&quot;: &#123; &quot;file&quot;: &quot;&lt;censored...binary...data&gt;&quot; &#125;, ...&#125; 你可以显式地设置文件名，文件类型和请求头： Text123456789101112&gt;&gt;&gt; url = &#x27;http://httpbin.org/post&#x27;&gt;&gt;&gt; files = &#123;&#x27;file&#x27;: (&#x27;report.xls&#x27;, open(&#x27;report.xls&#x27;, &#x27;rb&#x27;), &#x27;application/vnd.ms-excel&#x27;, &#123;&#x27;Expires&#x27;: &#x27;0&#x27;&#125;)&#125;&gt;&gt;&gt; r = requests.post(url, files=files)&gt;&gt;&gt; r.text&#123; ... &quot;files&quot;: &#123; &quot;file&quot;: &quot;&lt;censored...binary...data&gt;&quot; &#125;, ...&#125; 如果你想，你也可以发送作为文件来接收的字符串： Text123456789101112&gt;&gt;&gt; url = &#x27;http://httpbin.org/post&#x27;&gt;&gt;&gt; files = &#123;&#x27;file&#x27;: (&#x27;report.csv&#x27;, &#x27;some,data,to,send another,row,to,send &#x27;)&#125;&gt;&gt;&gt; r = requests.post(url, files=files)&gt;&gt;&gt; r.text&#123; ... &quot;files&quot;: &#123; &quot;file&quot;: &quot;some,data,to,send\\ another,row,to,send\\ &quot; &#125;, ...&#125; 如果你发送一个非常大的文件作为 multipart/form-data 请求，你可能希望将请求做成数据流。默认下 requests 不支持, 但有个第三方包 requests-toolbelt 是支持的。你可以阅读 toolbelt 文档 来了解使用方法。 在一个请求中发送多文件参考 高级用法 一节。 警告 我们强烈建议你用二进制模式(binary mode)打开文件。这是因为 Requests 可能会试图为你提供 Content-Length header，在它这样做的时候，这个值会被设为文件的字节数（bytes）。如果用文本模式(text mode)打开文件，就可能会发生错误。 响应状态码我们可以检测响应状态码： Text123&gt;&gt;&gt; r = requests.get(&#x27;http://httpbin.org/get&#x27;)&gt;&gt;&gt; r.status_code200 为方便引用，Requests还附带了一个内置的状态码查询对象： Text12&gt;&gt;&gt; r.status_code == requests.codes.okTrue 如果发送了一个错误请求(一个 4XX 客户端错误，或者 5XX 服务器错误响应)，我们可以通过 [Response.raise_for_status()](https://docs.python-requests.org/zh_CN/latest/api.html#requests.Response.raise_for_status) 来抛出异常： Text123456789&gt;&gt;&gt; bad_r = requests.get(&#x27;http://httpbin.org/status/404&#x27;)&gt;&gt;&gt; bad_r.status_code404&gt;&gt;&gt; bad_r.raise_for_status()Traceback (most recent call last): File &quot;requests/models.py&quot;, line 832, in raise_for_status raise http_errorrequests.exceptions.HTTPError: 404 Client Error 但是，由于我们的例子中 r 的 status_code 是 200 ，当我们调用 raise_for_status() 时，得到的是： Text12&gt;&gt;&gt; r.raise_for_status()None 一切都挺和谐哈。 响应头我们可以查看以一个 Python 字典形式展示的服务器响应头： Text12345678910&gt;&gt;&gt; r.headers&#123; &#x27;content-encoding&#x27;: &#x27;gzip&#x27;, &#x27;transfer-encoding&#x27;: &#x27;chunked&#x27;, &#x27;connection&#x27;: &#x27;close&#x27;, &#x27;server&#x27;: &#x27;nginx/1.0.4&#x27;, &#x27;x-runtime&#x27;: &#x27;148ms&#x27;, &#x27;etag&#x27;: &#x27;&quot;e1ca502697e5c9317743dc078f67693f&quot;&#x27;, &#x27;content-type&#x27;: &#x27;application/json&#x27;&#125; 但是这个字典比较特殊：它是仅为 HTTP 头部而生的。根据 RFC 2616， HTTP 头部是大小写不敏感的。 因此，我们可以使用任意大写形式来访问这些响应头字段： Text12345&gt;&gt;&gt; r.headers[&#x27;Content-Type&#x27;]&#x27;application/json&#x27;&gt;&gt;&gt; r.headers.get(&#x27;content-type&#x27;)&#x27;application/json&#x27; 它还有一个特殊点，那就是服务器可以多次接受同一 header，每次都使用不同的值。但 Requests 会将它们合并，这样它们就可以用一个映射来表示出来，参见 RFC 7230: A recipient MAY combine multiple header fields with the same field name into one “field-name: field-value” pair, without changing the semantics of the message, by appending each subsequent field value to the combined field value in order, separated by a comma. 接收者可以合并多个相同名称的 header 栏位，把它们合为一个 “field-name: field-value” 配对，将每个后续的栏位值依次追加到合并的栏位值中，用逗号隔开即可，这样做不会改变信息的语义。 Cookie如果某个响应中包含一些 cookie，你可以快速访问它们： Text12345&gt;&gt;&gt; url = &#x27;http://example.com/some/cookie/setting/url&#x27;&gt;&gt;&gt; r = requests.get(url)&gt;&gt;&gt; r.cookies[&#x27;example_cookie_name&#x27;]&#x27;example_cookie_value&#x27; 要想发送你的cookies到服务器，可以使用 cookies 参数： Text123456&gt;&gt;&gt; url = &#x27;http://httpbin.org/cookies&#x27;&gt;&gt;&gt; cookies = dict(cookies_are=&#x27;working&#x27;)&gt;&gt;&gt; r = requests.get(url, cookies=cookies)&gt;&gt;&gt; r.text&#x27;&#123;&quot;cookies&quot;: &#123;&quot;cookies_are&quot;: &quot;working&quot;&#125;&#125;&#x27; Cookie 的返回对象为 [RequestsCookieJar](https://docs.python-requests.org/zh_CN/latest/api.html#requests.cookies.RequestsCookieJar)，它的行为和字典类似，但接口更为完整，适合跨域名跨路径使用。你还可以把 Cookie Jar 传到 Requests 中： Text1234567&gt;&gt;&gt; jar = requests.cookies.RequestsCookieJar()&gt;&gt;&gt; jar.set(&#x27;tasty_cookie&#x27;, &#x27;yum&#x27;, domain=&#x27;httpbin.org&#x27;, path=&#x27;/cookies&#x27;)&gt;&gt;&gt; jar.set(&#x27;gross_cookie&#x27;, &#x27;blech&#x27;, domain=&#x27;httpbin.org&#x27;, path=&#x27;/elsewhere&#x27;)&gt;&gt;&gt; url = &#x27;http://httpbin.org/cookies&#x27;&gt;&gt;&gt; r = requests.get(url, cookies=jar)&gt;&gt;&gt; r.text&#x27;&#123;&quot;cookies&quot;: &#123;&quot;tasty_cookie&quot;: &quot;yum&quot;&#125;&#125;&#x27; 重定向与请求历史默认情况下，除了 HEAD, Requests 会自动处理所有重定向。 可以使用响应对象的 history 方法来追踪重定向。 [Response.history](https://docs.python-requests.org/zh_CN/latest/api.html#requests.Response.history) 是一个 [Response](https://docs.python-requests.org/zh_CN/latest/api.html#requests.Response) 对象的列表，为了完成请求而创建了这些对象。这个对象列表按照从最老到最近的请求进行排序。 例如，Github 将所有的 HTTP 请求重定向到 HTTPS： Text12345678910&gt;&gt;&gt; r = requests.get(&#x27;http://github.com&#x27;)&gt;&gt;&gt; r.url&#x27;https://github.com/&#x27;&gt;&gt;&gt; r.status_code200&gt;&gt;&gt; r.history[&lt;Response [301]&gt;] 如果你使用的是GET、OPTIONS、POST、PUT、PATCH 或者 DELETE，那么你可以通过 allow_redirects 参数禁用重定向处理： Text12345&gt;&gt;&gt; r = requests.get(&#x27;http://github.com&#x27;, allow_redirects=False)&gt;&gt;&gt; r.status_code301&gt;&gt;&gt; r.history[] 如果你使用了 HEAD，你也可以启用重定向： Text12345&gt;&gt;&gt; r = requests.head(&#x27;http://github.com&#x27;, allow_redirects=True)&gt;&gt;&gt; r.url&#x27;https://github.com/&#x27;&gt;&gt;&gt; r.history[&lt;Response [301]&gt;] 超时你可以告诉 requests 在经过以 timeout 参数设定的秒数时间之后停止等待响应。基本上所有的生产代码都应该使用这一参数。如果不使用，你的程序可能会永远失去响应： Text1234&gt;&gt;&gt; requests.get(&#x27;http://github.com&#x27;, timeout=0.001)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;requests.exceptions.Timeout: HTTPConnectionPool(host=&#x27;github.com&#x27;, port=80): Request timed out. (timeout=0.001) 注意 timeout 仅对连接过程有效，与响应体的下载无关。 timeout 并不是整个下载响应的时间限制，而是如果服务器在 timeout 秒内没有应答，将会引发一个异常（更精确地说，是在 timeout 秒内没有从基础套接字上接收到任何字节的数据时）If no timeout is specified explicitly, requests do not time out. 错误与异常遇到网络问题（如：DNS 查询失败、拒绝连接等）时，Requests 会抛出一个 ConnectionError 异常。 如果 HTTP 请求返回了不成功的状态码， [Response.raise_for_status()](https://docs.python-requests.org/zh_CN/latest/api.html#requests.Response.raise_for_status) 会抛出一个 HTTPError 异常。 若请求超时，则抛出一个 Timeout 异常。 若请求超过了设定的最大重定向次数，则会抛出一个 TooManyRedirects 异常。 所有Requests显式抛出的异常都继承自 requests.exceptions.RequestException 。 高级用法本篇文档涵盖了 Requests 的一些高级特性。 会话对象会话对象让你能够跨请求保持某些参数。它也会在同一个 Session 实例发出的所有请求之间保持 cookie， 期间使用 urllib3 的 connection pooling 功能。所以如果你向同一主机发送多个请求，底层的 TCP 连接将会被重用，从而带来显著的性能提升。 (参见 HTTP persistent connection). 会话对象具有主要的 Requests API 的所有方法。 我们来跨请求保持一些 cookie: Text1234567s = requests.Session()s.get(&#x27;http://httpbin.org/cookies/set/sessioncookie/123456789&#x27;)r = s.get(&quot;http://httpbin.org/cookies&quot;)print(r.text)# &#x27;&#123;&quot;cookies&quot;: &#123;&quot;sessioncookie&quot;: &quot;123456789&quot;&#125;&#125;&#x27; 会话也可用来为请求方法提供缺省数据。这是通过为会话对象的属性提供数据来实现的： Text123456s = requests.Session()s.auth = (&#x27;user&#x27;, &#x27;pass&#x27;)s.headers.update(&#123;&#x27;x-test&#x27;: &#x27;true&#x27;&#125;)# both &#x27;x-test&#x27; and &#x27;x-test2&#x27; are sents.get(&#x27;http://httpbin.org/headers&#x27;, headers=&#123;&#x27;x-test2&#x27;: &#x27;true&#x27;&#125;) 任何你传递给请求方法的字典都会与已设置会话层数据合并。方法层的参数覆盖会话的参数。 不过需要注意，就算使用了会话，方法级别的参数也不会被跨请求保持。下面的例子只会和第一个请求发送 cookie ，而非第二个： Text123456789s = requests.Session()r = s.get(&#x27;http://httpbin.org/cookies&#x27;, cookies=&#123;&#x27;from-my&#x27;: &#x27;browser&#x27;&#125;)print(r.text)# &#x27;&#123;&quot;cookies&quot;: &#123;&quot;from-my&quot;: &quot;browser&quot;&#125;&#125;&#x27;r = s.get(&#x27;http://httpbin.org/cookies&#x27;)print(r.text)# &#x27;&#123;&quot;cookies&quot;: &#123;&#125;&#125;&#x27; 如果你要手动为会话添加 cookie，就使用 Cookie utility 函数 来操纵 [Session.cookies](https://docs.python-requests.org/zh_CN/latest/api.html#requests.Session.cookies)。 会话还可以用作前后文管理器： Text12with requests.Session() as s: s.get(&#x27;http://httpbin.org/cookies/set/sessioncookie/123456789&#x27;) 这样就能确保 with 区块退出后会话能被关闭，即使发生了异常也一样。 从字典参数中移除一个值 有时你会想省略字典参数中一些会话层的键。要做到这一点，你只需简单地在方法层参数中将那个键的值设置为 None ，那个键就会被自动省略掉。 包含在一个会话中的所有数据你都可以直接使用。学习更多细节请阅读 会话 API 文档。 请求与响应对象任何时候进行了类似 requests.get() 的调用，你都在做两件主要的事情。其一，你在构建一个 Request 对象， 该对象将被发送到某个服务器请求或查询一些资源。其二，一旦 requests 得到一个从服务器返回的响应就会产生一个 Response 对象。该响应对象包含服务器返回的所有信息，也包含你原来创建的 Request 对象。如下是一个简单的请求，从 Wikipedia 的服务器得到一些非常重要的信息： Text1&gt;&gt;&gt; r = requests.get(&#x27;http://en.wikipedia.org/wiki/Monty_Python&#x27;) 如果想访问服务器返回给我们的响应头部信息，可以这样做： Text123456789&gt;&gt;&gt; r.headers&#123;&#x27;content-length&#x27;: &#x27;56170&#x27;, &#x27;x-content-type-options&#x27;: &#x27;nosniff&#x27;, &#x27;x-cache&#x27;:&#x27;HIT from cp1006.eqiad.wmnet, MISS from cp1010.eqiad.wmnet&#x27;, &#x27;content-encoding&#x27;:&#x27;gzip&#x27;, &#x27;age&#x27;: &#x27;3080&#x27;, &#x27;content-language&#x27;: &#x27;en&#x27;, &#x27;vary&#x27;: &#x27;Accept-Encoding,Cookie&#x27;,&#x27;server&#x27;: &#x27;Apache&#x27;, &#x27;last-modified&#x27;: &#x27;Wed, 13 Jun 2012 01:33:50 GMT&#x27;,&#x27;connection&#x27;: &#x27;close&#x27;, &#x27;cache-control&#x27;: &#x27;private, s-maxage=0, max-age=0,must-revalidate&#x27;, &#x27;date&#x27;: &#x27;Thu, 14 Jun 2012 12:59:39 GMT&#x27;, &#x27;content-type&#x27;:&#x27;text/html; charset=UTF-8&#x27;, &#x27;x-cache-lookup&#x27;: &#x27;HIT from cp1006.eqiad.wmnet:3128,MISS from cp1010.eqiad.wmnet:80&#x27;&#125; 然而，如果想得到发送到服务器的请求的头部，我们可以简单地访问该请求，然后是该请求的头部： Text123&gt;&gt;&gt; r.request.headers&#123;&#x27;Accept-Encoding&#x27;: &#x27;identity, deflate, compress, gzip&#x27;,&#x27;Accept&#x27;: &#x27;*/*&#x27;, &#x27;User-Agent&#x27;: &#x27;python-requests/0.13.1&#x27;&#125; 准备的请求 （Prepared Request）当你从 API 或者会话调用中收到一个 [Response](https://docs.python-requests.org/zh_CN/latest/api.html#requests.Response) 对象时，request 属性其实是使用了 PreparedRequest。有时在发送请求之前，你需要对 body 或者 header （或者别的什么东西）做一些额外处理，下面演示了一个简单的做法： Text123456789101112131415161718192021from requests import Request, Sessions = Session()req = Request(&#x27;GET&#x27;, url, data=data, headers=header)prepped = req.prepare()# do something with prepped.body# do something with prepped.headersresp = s.send(prepped, stream=stream, verify=verify, proxies=proxies, cert=cert, timeout=timeout)print(resp.status_code) 由于你没有对 Request 对象做什么特殊事情，你立即准备和修改了 PreparedRequest 对象，然后把它和别的参数一起发送到 requests.* 或者 Session.*。 然而，上述代码会失去 Requests [Session](https://docs.python-requests.org/zh_CN/latest/api.html#requests.Session) 对象的一些优势， 尤其 [Session](https://docs.python-requests.org/zh_CN/latest/api.html#requests.Session) 级别的状态，例如 cookie 就不会被应用到你的请求上去。要获取一个带有状态的 [PreparedRequest](https://docs.python-requests.org/zh_CN/latest/api.html#requests.PreparedRequest)， 请用 [Session.prepare_request()](https://docs.python-requests.org/zh_CN/latest/api.html#requests.Session.prepare_request) 取代 [Request.prepare()](https://docs.python-requests.org/zh_CN/latest/api.html#requests.Request.prepare) 的调用，如下所示： Text12345678910111213141516171819202122from requests import Request, Sessions = Session()req = Request(&#x27;GET&#x27;, url, data=data headers=headers)prepped = s.prepare_request(req)# do something with prepped.body# do something with prepped.headersresp = s.send(prepped, stream=stream, verify=verify, proxies=proxies, cert=cert, timeout=timeout)print(resp.status_code) SSL 证书验证Requests 可以为 HTTPS 请求验证 SSL 证书，就像 web 浏览器一样。SSL 验证默认是开启的，如果证书验证失败，Requests 会抛出 SSLError: Text12&gt;&gt;&gt; requests.get(&#x27;https://requestb.in&#x27;)requests.exceptions.SSLError: hostname &#x27;requestb.in&#x27; doesn&#x27;t match either of &#x27;*.herokuapp.com&#x27;, &#x27;herokuapp.com&#x27; 在该域名上我没有设置 SSL，所以失败了。但 Github 设置了 SSL: Text12&gt;&gt;&gt; requests.get(&#x27;https://github.com&#x27;, verify=True)&lt;Response [200]&gt; 你可以为 verify 传入 CA_BUNDLE 文件的路径，或者包含可信任 CA 证书文件的文件夹路径： Text1&gt;&gt;&gt; requests.get(&#x27;https://github.com&#x27;, verify=&#x27;/path/to/certfile&#x27;) 或者将其保持在会话中： Text12s = requests.Session()s.verify = &#x27;/path/to/certfile&#x27; 注解 如果 verify 设为文件夹路径，文件夹必须通过 OpenSSL 提供的 c_rehash 工具处理。 你还可以通过 REQUESTS_CA_BUNDLE 环境变量定义可信任 CA 列表。 如果你将 verify 设置为 False，Requests 也能忽略对 SSL 证书的验证。 Text12&gt;&gt;&gt; requests.get(&#x27;https://kennethreitz.org&#x27;, verify=False)&lt;Response [200]&gt; 默认情况下， verify 是设置为 True 的。选项 verify 仅应用于主机证书。 私有证书对于私有证书，你也可以传递一个 CA_BUNDLE 文件的路径给 verify。你也可以设置 # REQUEST_CA_BUNDLE 环境变量。 客户端证书你也可以指定一个本地证书用作客户端证书，可以是单个文件（包含密钥和证书）或一个包含两个文件路径的元组： 12&gt;&gt;&gt; requests.get(&#x27;https://kennethreitz.org&#x27;, cert=(&#x27;/path/client.cert&#x27;, &#x27;/path/client.key&#x27;))&lt;Response [200]&gt; 或者保持在会话中： 12s = requests.Session()s.cert = &#x27;/path/client.cert&#x27; 如果你指定了一个错误路径或一个无效的证书: 12&gt;&gt;&gt; requests.get(&#x27;https://kennethreitz.org&#x27;, cert=&#x27;/wrong_path/client.pem&#x27;)SSLError: [Errno 336265225] _ssl.c:347: error:140B0009:SSL routines:SSL_CTX_use_PrivateKey_file:PEM lib 警告 本地证书的私有 key 必须是解密状态。目前，Requests 不支持使用加密的 key。 CA 证书Requests 默认附带了一套它信任的根证书，来自于 Mozilla trust store。然而它们在每次 Requests 更新时才会更新。这意味着如果你固定使用某一版本的 Requests，你的证书有可能已经 太旧了。 从 Requests 2.4.0 版之后，如果系统中装了 certifi 包，Requests 会试图使用它里边的 证书。这样用户就可以在不修改代码的情况下更新他们的可信任证书。 为了安全起见，我们建议你经常更新 certifi！ 响应体内容工作流默认情况下，当你进行网络请求后，响应体会立即被下载。你可以通过 stream 参数覆盖这个行为，推迟下载响应体直到访问 [Response.content](https://docs.python-requests.org/zh_CN/latest/api.html#requests.Response.content) 属性： Text12tarball_url = &#x27;https://github.com/kennethreitz/requests/tarball/master&#x27;r = requests.get(tarball_url, stream=True) 此时仅有响应头被下载下来了，连接保持打开状态，因此允许我们根据条件获取内容： Text123if int(r.headers[&#x27;content-length&#x27;]) &lt; TOO_LONG: content = r.content ... 你可以进一步使用 [Response.iter_content](https://docs.python-requests.org/zh_CN/latest/api.html#requests.Response.iter_content) 和 [Response.iter_lines](https://docs.python-requests.org/zh_CN/latest/api.html#requests.Response.iter_lines) 方法来控制工作流，或者以 [Response.raw](https://docs.python-requests.org/zh_CN/latest/api.html#requests.Response.raw) 从底层 urllib3 的 &#96;urllib3.HTTPResponse 读取未解码的响应体。 如果你在请求中把 stream 设为 True，Requests 无法将连接释放回连接池，除非你 消耗了所有的数据，或者调用了 [Response.close](https://docs.python-requests.org/zh_CN/latest/api.html#requests.Response.close)。 这样会带来连接效率低下的问题。如果你发现你在使用 stream=True 的同时还在部分读取请求的 body（或者完全没有读取 body），那么你就应该考虑使用 with 语句发送请求，这样可以保证请求一定会被关闭： 12with requests.get(&#x27;http://httpbin.org/get&#x27;, stream=True) as r: # 在此处理响应。 保持活动状态（持久连接）好消息——归功于 urllib3，同一会话内的持久连接是完全自动处理的！同一会话内你发出的任何请求都会自动复用恰当的连接！ 注意：只有所有的响应体数据被读取完毕连接才会被释放为连接池；所以确保将 stream 设置为 False 或读取 Response 对象的 content 属性。 流式上传Requests支持流式上传，这允许你发送大的数据流或文件而无需先把它们读入内存。要使用流式上传，仅需为你的请求体提供一个类文件对象即可： 12with open(&#x27;massive-body&#x27;) as f: requests.post(&#x27;http://some.url/streamed&#x27;, data=f) 警告 我们强烈建议你用二进制模式（binary mode）打开文件。这是因为 requests 可能会为你提供 header 中的 Content-Length，在这种情况下该值会被设为文件的字节数。如果你用文本模式打开文件，就可能碰到错误。 块编码请求对于出去和进来的请求，Requests 也支持分块传输编码。要发送一个块编码的请求，仅需为你的请求体提供一个生成器（或任意没有具体长度的迭代器）： 12345def gen(): yield &#x27;hi&#x27; yield &#x27;there&#x27;requests.post(&#x27;http://some.url/chunked&#x27;, data=gen()) 对于分块的编码请求，我们最好使用 Response.iter_content() 对其数据进行迭代。在理想情况下，你的 request 会设置 stream=True，这样你就可以通过调用 iter_content 并将分块大小参数设为 None，从而进行分块的迭代。如果你要设置分块的最大体积，你可以把分块大小参数设为任意整数。 POST 多个分块编码的文件你可以在一个请求中发送多个文件。例如，假设你要上传多个图像文件到一个 HTML 表单，使用一个多文件 field 叫做 “images”: Text1&lt;input type=&quot;file&quot; name=&quot;images&quot; multiple=&quot;true&quot; required=&quot;true&quot;/&gt; 要实现，只要把文件设到一个元组的列表中，其中元组结构为 (form_field_name, file_info): 123456789101112&gt;&gt;&gt; url = &#x27;http://httpbin.org/post&#x27;&gt;&gt;&gt; multiple_files = [ (&#x27;images&#x27;, (&#x27;foo.png&#x27;, open(&#x27;foo.png&#x27;, &#x27;rb&#x27;), &#x27;image/png&#x27;)), (&#x27;images&#x27;, (&#x27;bar.png&#x27;, open(&#x27;bar.png&#x27;, &#x27;rb&#x27;), &#x27;image/png&#x27;))]&gt;&gt;&gt; r = requests.post(url, files=multiple_files)&gt;&gt;&gt; r.text&#123; ... &#x27;files&#x27;: &#123;&#x27;images&#x27;: &#x27;data:image/png;base64,iVBORw ....&#x27;&#125; &#x27;Content-Type&#x27;: &#x27;multipart/form-data; boundary=3131623adb2043caaeb5538cc7aa0b3a&#x27;, ...&#125; 警告 我们强烈建议你用二进制模式（binary mode）打开文件。这是因为 requests 可能会为你提供 header 中的 Content-Length，在这种情况下该值会被设为文件的字节数。如果你用文本模式打开文件，就可能碰到错误。 事件挂钩Requests有一个钩子系统，你可以用来操控部分请求过程，或信号事件处理。 可用的钩子: response: 从一个请求产生的响应 你可以通过传递一个 &#123;hook_name: callback_function&#125; 字典给 hooks 请求参数为每个请求分配一个钩子函数： 1hooks=dict(response=print_url) callback_function 会接受一个数据块作为它的第一个参数。 12def print_url(r, *args, **kwargs): print(r.url) 若执行你的回调函数期间发生错误，系统会给出一个警告。 若回调函数返回一个值，默认以该值替换传进来的数据。若函数未返回任何东西，也没有什么其他的影响。 我们来在运行期间打印一些请求方法的参数： 123&gt;&gt;&gt; requests.get(&#x27;http://httpbin.org&#x27;, hooks=dict(response=print_url))http://httpbin.org&lt;Response [200]&gt; 自定义身份验证Requests 允许你使用自己指定的身份验证机制。 任何传递给请求方法的 auth 参数的可调用对象，在请求发出之前都有机会修改请求。 自定义的身份验证机制是作为 requests.auth.AuthBase 的子类来实现的，也非常容易定义。Requests 在 requests.auth 中提供了两种常见的的身份验证方案： HTTPBasicAuth 和 HTTPDigestAuth 。 假设我们有一个web服务，仅在 X-Pizza 头被设置为一个密码值的情况下才会有响应。虽然这不太可能，但就以它为例好了。 123456789101112from requests.auth import AuthBaseclass PizzaAuth(AuthBase): &quot;&quot;&quot;Attaches HTTP Pizza Authentication to the given Request object.&quot;&quot;&quot; def __init__(self, username): # setup any auth-related data here self.username = username def __call__(self, r): # modify and return the request r.headers[&#x27;X-Pizza&#x27;] = self.username return r 然后就可以使用我们的PizzaAuth来进行网络请求: 12&gt;&gt;&gt; requests.get(&#x27;http://pizzabin.org/admin&#x27;, auth=PizzaAuth(&#x27;kenneth&#x27;))&lt;Response [200]&gt; 流式请求使用 [Response.iter_lines()](https://docs.python-requests.org/zh_CN/latest/api.html#requests.Response.iter_lines) 你可以很方便地对流式 API （例如 Twitter 的流式 API ） 进行迭代。简单地设置 stream 为 True 便可以使用 [iter_lines](https://docs.python-requests.org/zh_CN/latest/api.html#requests.Response.iter_lines) 对相应进行迭代： 1234567891011import jsonimport requestsr = requests.get(&#x27;http://httpbin.org/stream/20&#x27;, stream=True)for line in r.iter_lines(): # filter out keep-alive new lines if line: decoded_line = line.decode(&#x27;utf-8&#x27;) print(json.loads(decoded_line)) 当使用 decode_unicode&#x3D;True 在 [Response.iter_lines()](https://docs.python-requests.org/zh_CN/latest/api.html#requests.Response.iter_lines) 或 [Response.iter_content()](https://docs.python-requests.org/zh_CN/latest/api.html#requests.Response.iter_content) 中时，你需要提供一个回退编码方式，以防服务器没有提供默认回退编码，从而导致错误： 12345678r = requests.get(&#x27;http://httpbin.org/stream/20&#x27;, stream=True)if r.encoding is None: r.encoding = &#x27;utf-8&#x27;for line in r.iter_lines(decode_unicode=True): if line: print(json.loads(line)) 警告 [iter_lines](https://docs.python-requests.org/zh_CN/latest/api.html#requests.Response.iter_lines) 不保证重进入时的安全性。多次调用该方法 会导致部分收到的数据丢失。如果你要在多处调用它，就应该使用生成的迭代器对象: 1234567lines = r.iter_lines()# 保存第一行以供后面使用，或者直接跳过first_line = next(lines)for line in lines: print(line) 代理如果需要使用代理，你可以通过为任意请求方法提供 proxies 参数来配置单个请求: 12345678import requestsproxies = &#123; &quot;http&quot;: &quot;http://10.10.1.10:3128&quot;, &quot;https&quot;: &quot;http://10.10.1.10:1080&quot;,&#125;requests.get(&quot;http://example.org&quot;, proxies=proxies) 你也可以通过环境变量 HTTP_PROXY 和 HTTPS_PROXY 来配置代理。 123456$ export HTTP_PROXY=&quot;http://10.10.1.10:3128&quot;$ export HTTPS_PROXY=&quot;http://10.10.1.10:1080&quot;$ python&gt;&gt;&gt; import requests&gt;&gt;&gt; requests.get(&quot;http://example.org&quot;) 若你的代理需要使用HTTP Basic Auth，可以使用 http://user:password@host&#x2F; 语法： 123proxies = &#123; &quot;http&quot;: &quot;http://user:pass@10.10.1.10:3128/&quot;,&#125; 要为某个特定的连接方式或者主机设置代理，使用 scheme:&#x2F;&#x2F;hostname 作为 key， 它会针对指定的主机和连接方式进行匹配。 1proxies = &#123;&#x27;http://10.20.1.128&#x27;: &#x27;http://10.10.1.10:5323&#x27;&#125; 注意，代理 URL 必须包含连接方式。 SOCKS2.10.0 新版功能. 除了基本的 HTTP 代理，Request 还支持 SOCKS 协议的代理。这是一个可选功能，若要使用， 你需要安装第三方库。 你可以用 pip 获取依赖: Text1$ pip install requests[socks] 安装好依赖以后，使用 SOCKS 代理和使用 HTTP 代理一样简单： 1234proxies = &#123; &#x27;http&#x27;: &#x27;socks5://user:pass@host:port&#x27;, &#x27;https&#x27;: &#x27;socks5://user:pass@host:port&#x27;&#125; 合规性Requests 符合所有相关的规范和 RFC，这样不会为用户造成不必要的困难。但这种对规范的考虑导致一些行为对于不熟悉相关规范的人来说看似有点奇怪。 编码方式当你收到一个响应时，Requests 会猜测响应的编码方式，用于在你调用 [Response.text](https://docs.python-requests.org/zh_CN/latest/api.html#requests.Response.text) 方法时对响应进行解码。Requests 首先在 HTTP 头部检测是否存在指定的编码方式，如果不存在，则会使用 charade 来尝试猜测编码方式。 只有当 HTTP 头部不存在明确指定的字符集，并且 Content-Type 头部字段包含 text 值之时， Requests 才不去猜测编码方式。在这种情况下， RFC 2616 指定默认字符集必须是 ISO-8859-1 。Requests 遵从这一规范。如果你需要一种不同的编码方式，你可以手动设置 [Response.encoding](https://docs.python-requests.org/zh_CN/latest/api.html#requests.Response.encoding) 属性，或使用原始的 [Response.content](https://docs.python-requests.org/zh_CN/latest/api.html#requests.Response.content)。 HTTP动词Requests 提供了几乎所有HTTP动词的功能：GET、OPTIONS、HEAD、POST、PUT、PATCH、DELETE。以下内容为使用 Requests 中的这些动词以及 Github API 提供了详细示例。 我将从最常使用的动词 GET 开始。HTTP GET 是一个幂等方法，从给定的 URL 返回一个资源。因而，当你试图从一个 web 位置获取数据之时，你应该使用这个动词。一个使用示例是尝试从 Github 上获取关于一个特定 commit 的信息。假设我们想获取 Requests 的 commit a050faf 的信息。我们可以这样去做： 12&gt;&gt;&gt; import requests&gt;&gt;&gt; r = requests.get(&#x27;https://api.github.com/repos/requests/requests/git/commits/a050faf084662f3a352dd1a941f2c7c9f886d4ad&#x27;) 我们应该确认 GitHub 是否正确响应。如果正确响应，我们想弄清响应内容是什么类型的。像这样去做： 1234&gt;&gt;&gt; if (r.status_code == requests.codes.ok):... print(r.headers[&#x27;content-type&#x27;])...application/json; charset=utf-8 可见，GitHub 返回了 JSON 数据，非常好，这样就可以使用 r.json 方法把这个返回的数据解析成 Python 对象。 12345678910&gt;&gt;&gt; commit_data = r.json()&gt;&gt;&gt; print(commit_data.keys())[u&#x27;committer&#x27;, u&#x27;author&#x27;, u&#x27;url&#x27;, u&#x27;tree&#x27;, u&#x27;sha&#x27;, u&#x27;parents&#x27;, u&#x27;message&#x27;]&gt;&gt;&gt; print(commit_data[u&#x27;committer&#x27;])&#123;u&#x27;date&#x27;: u&#x27;2012-05-10T11:10:50-07:00&#x27;, u&#x27;email&#x27;: u&#x27;me@kennethreitz.com&#x27;, u&#x27;name&#x27;: u&#x27;Kenneth Reitz&#x27;&#125;&gt;&gt;&gt; print(commit_data[u&#x27;message&#x27;])makin&#x27; history 到目前为止，一切都非常简单。嗯，我们来研究一下 GitHub 的 API。我们可以去看看文档，但如果使用 Requests 来研究也许会更有意思一点。我们可以借助 Requests 的 OPTIONS 动词来看看我们刚使用过的 url 支持哪些 HTTP 方法。 123&gt;&gt;&gt; verbs = requests.options(r.url)&gt;&gt;&gt; verbs.status_code500 额，这是怎么回事？毫无帮助嘛！原来 GitHub，与许多 API 提供方一样，实际上并未实现 OPTIONS 方法。这是一个恼人的疏忽，但没关系，那我们可以使用枯燥的文档。然而，如果 GitHub 正确实现了 OPTIONS，那么服务器应该在响应头中返回允许用户使用的 HTTP 方法，例如： 123&gt;&gt;&gt; verbs = requests.options(&#x27;http://a-good-website.com/api/cats&#x27;)&gt;&gt;&gt; print verbs.headers[&#x27;allow&#x27;]GET,HEAD,POST,OPTIONS 转而去查看文档，我们看到对于提交信息，另一个允许的方法是 POST，它会创建一个新的提交。由于我们正在使用 Requests 代码库，我们应尽可能避免对它发送笨拙的 POST。作为替代，我们来玩玩 GitHub 的 Issue 特性。 本篇文档是回应 Issue #482 而添加的。鉴于该问题已经存在，我们就以它为例。先获取它。 1234567891011&gt;&gt;&gt; r = requests.get(&#x27;https://api.github.com/requests/kennethreitz/requests/issues/482&#x27;)&gt;&gt;&gt; r.status_code200&gt;&gt;&gt; issue = json.loads(r.text)&gt;&gt;&gt; print(issue[u&#x27;title&#x27;])Feature any http verb in docs&gt;&gt;&gt; print(issue[u&#x27;comments&#x27;])3 Cool，有 3 个评论。我们来看一下最后一个评论。 12345678&gt;&gt;&gt; r = requests.get(r.url + u&#x27;/comments&#x27;)&gt;&gt;&gt; r.status_code200&gt;&gt;&gt; comments = r.json()&gt;&gt;&gt; print comments[0].keys()[u&#x27;body&#x27;, u&#x27;url&#x27;, u&#x27;created_at&#x27;, u&#x27;updated_at&#x27;, u&#x27;user&#x27;, u&#x27;id&#x27;]&gt;&gt;&gt; print comments[2][u&#x27;body&#x27;]Probably in the &quot;advanced&quot; section 嗯，那看起来似乎是个愚蠢之处。我们发表个评论来告诉这个评论者他自己的愚蠢。那么，这个评论者是谁呢？ 12&gt;&gt;&gt; print(comments[2][u&#x27;user&#x27;][u&#x27;login&#x27;])kennethreitz 好，我们来告诉这个叫 Kenneth 的家伙，这个例子应该放在快速上手指南中。根据 GitHub API 文档，其方法是 POST 到该话题。我们来试试看。 123456&gt;&gt;&gt; body = json.dumps(&#123;u&quot;body&quot;: u&quot;Sounds great! I&#x27;ll get right on it!&quot;&#125;)&gt;&gt;&gt; url = u&quot;https://api.github.com/repos/requests/requests/issues/482/comments&quot;&gt;&gt;&gt; r = requests.post(url=url, data=body)&gt;&gt;&gt; r.status_code404 额，这有点古怪哈。可能我们需要验证身份。那就有点纠结了，对吧？不对。Requests 简化了多种身份验证形式的使用，包括非常常见的 Basic Auth。 12345678910&gt;&gt;&gt; from requests.auth import HTTPBasicAuth&gt;&gt;&gt; auth = HTTPBasicAuth(&#x27;fake@example.com&#x27;, &#x27;not_a_real_password&#x27;)&gt;&gt;&gt; r = requests.post(url=url, data=body, auth=auth)&gt;&gt;&gt; r.status_code201&gt;&gt;&gt; content = r.json()&gt;&gt;&gt; print(content[u&#x27;body&#x27;])Sounds great! I&#x27;ll get right on it. 太棒了！噢，不！我原本是想说等我一会，因为我得去喂我的猫。如果我能够编辑这条评论那就好了！幸运的是，GitHub 允许我们使用另一个 HTTP 动词 PATCH 来编辑评论。我们来试试。 123456789&gt;&gt;&gt; print(content[u&quot;id&quot;])5804413&gt;&gt;&gt; body = json.dumps(&#123;u&quot;body&quot;: u&quot;Sounds great! I&#x27;ll get right on it once I feed my cat.&quot;&#125;)&gt;&gt;&gt; url = u&quot;https://api.github.com/repos/requests/requests/issues/comments/5804413&quot;&gt;&gt;&gt; r = requests.patch(url=url, data=body, auth=auth)&gt;&gt;&gt; r.status_code200 非常好。现在，我们来折磨一下这个叫 Kenneth 的家伙，我决定要让他急得团团转，也不告诉他是我在捣蛋。这意味着我想删除这条评论。GitHub 允许我们使用完全名副其实的 DELETE 方法来删除评论。我们来清除该评论。 12345&gt;&gt;&gt; r = requests.delete(url=url, auth=auth)&gt;&gt;&gt; r.status_code204&gt;&gt;&gt; r.headers[&#x27;status&#x27;]&#x27;204 No Content&#x27; 很好。不见了。最后一件我想知道的事情是我已经使用了多少限额（ratelimit）。查查看，GitHub 在响应头部发送这个信息，因此不必下载整个网页，我将使用一个 HEAD 请求来获取响应头。 123456&gt;&gt;&gt; r = requests.head(url=url, auth=auth)&gt;&gt;&gt; print r.headers...&#x27;x-ratelimit-remaining&#x27;: &#x27;4995&#x27;&#x27;x-ratelimit-limit&#x27;: &#x27;5000&#x27;... 很好。是时候写个 Python 程序以各种刺激的方式滥用 GitHub 的 API，还可以使用 4995 次呢。 定制动词有时候你会碰到一些服务器，处于某些原因，它们允许或者要求用户使用上述 HTTP 动词之外的定制动词。比如说 WEBDAV 服务器会要求你使用 MKCOL 方法。别担心，Requests 一样可以搞定它们。你可以使用内建的 .request 方法，例如： 123&gt;&gt;&gt; r = requests.request(&#x27;MKCOL&#x27;, url, data=data)&gt;&gt;&gt; r.status_code200 # Assuming your call was correct 这样你就可以使用服务器要求的任意方法动词了。 响应头链接字段许多 HTTP API 都有响应头链接字段的特性，它们使得 API 能够更好地自我描述和自我显露。 GitHub 在 API 中为 分页 使用这些特性，例如: 1234&gt;&gt;&gt; url = &#x27;https://api.github.com/users/kennethreitz/repos?page=1&amp;per_page=10&#x27;&gt;&gt;&gt; r = requests.head(url=url)&gt;&gt;&gt; r.headers[&#x27;link&#x27;]&#x27;&lt;https://api.github.com/users/kennethreitz/repos?page=2&amp;per_page=10&gt;; rel=&quot;next&quot;, &lt;https://api.github.com/users/kennethreitz/repos?page=6&amp;per_page=10&gt;; rel=&quot;last&quot;&#x27; Requests 会自动解析这些响应头链接字段，并使得它们非常易于使用: 12345&gt;&gt;&gt; r.links[&quot;next&quot;]&#123;&#x27;url&#x27;: &#x27;https://api.github.com/users/kennethreitz/repos?page=2&amp;per_page=10&#x27;, &#x27;rel&#x27;: &#x27;next&#x27;&#125;&gt;&gt;&gt; r.links[&quot;last&quot;]&#123;&#x27;url&#x27;: &#x27;https://api.github.com/users/kennethreitz/repos?page=7&amp;per_page=10&#x27;, &#x27;rel&#x27;: &#x27;last&#x27;&#125; 传输适配器从 v1.0.0 以后，Requests 的内部采用了模块化设计。部分原因是为了实现传输适配器（Transport Adapter），你可以看看关于它的最早描述。传输适配器提供了一个机制，让你可以为 HTTP 服务定义交互方法。尤其是它允许你应用服务前的配置。 Requests 自带了一个传输适配器，也就是 [HTTPAdapter](https://docs.python-requests.org/zh_CN/latest/api.html#requests.adapters.HTTPAdapter)。 这个适配器使用了强大的 urllib3，为 Requests 提供了默认的 HTTP 和 HTTPS 交互。每当 [Session](https://docs.python-requests.org/zh_CN/latest/api.html#requests.Session) 被初始化，就会有适配器附着在 [Session](https://docs.python-requests.org/zh_CN/latest/api.html#requests.Session) 上，其中一个供 HTTP 使用，另一个供 HTTPS 使用。 Request 允许用户创建和使用他们自己的传输适配器，实现他们需要的特殊功能。创建好以后，传输适配器可以被加载到一个会话对象上，附带着一个说明，告诉会话适配器应该应用在哪个 web 服务上。 12&gt;&gt;&gt; s = requests.Session()&gt;&gt;&gt; s.mount(&#x27;http://www.github.com&#x27;, MyAdapter()) 这个 mount 调用会注册一个传输适配器的特定实例到一个前缀上面。加载以后，任何使用该会话的 HTTP 请求，只要其 URL 是以给定的前缀开头，该传输适配器就会被使用到。 传输适配器的众多实现细节不在本文档的覆盖范围内，不过你可以看看接下来这个简单的 SSL 用例。更多的用法，你也许该考虑为 [BaseAdapter](https://docs.python-requests.org/zh_CN/latest/api.html#requests.adapters.BaseAdapter) 创建子类。 示例: 指定的 SSL 版本Requests 开发团队刻意指定了内部库（urllib3）的默认 SSL 版本。一般情况下这样做没有问题，不过是不是你可能会需要连接到一个服务节点，而该节点使用了和默认不同的 SSL 版本。 你可以使用传输适配器解决这个问题，通过利用 HTTPAdapter 现有的大部分实现，再加上一个 ssl_version 参数并将它传递到 urllib3 中。我们会创建一个传输适配器，用来告诉 urllib3 让它使用 SSLv3： 123456789import sslfrom requests.adapters import HTTPAdapterfrom requests.packages.urllib3.poolmanager import PoolManagerclass Ssl3HttpAdapter(HTTPAdapter): &quot;&quot;&quot;&quot;Transport adapter&quot; that allows us to use SSLv3.&quot;&quot;&quot; def init_poolmanager(self, connections, maxsize, block=False): self.poolmanager = PoolManager(num_pools=connections,maxsize=maxsize,block=block,ssl_version=ssl.PROTOCOL_SSLv3) 阻塞和非阻塞使用默认的传输适配器，Requests 不提供任何形式的非阻塞 IO。 [Response.content](https://docs.python-requests.org/zh_CN/latest/api.html#requests.Response.content) 属性会阻塞，直到整个响应下载完成。如果你需要更多精细控制，该库的数据流功能（见 流式请求） 允许你每次接受少量的一部分响应，不过这些调用依然是阻塞式的。 如果你对于阻塞式 IO 有所顾虑，还有很多项目可以供你使用，它们结合了 Requests 和 Python 的某个异步框架。典型的优秀例子是 grequests 和 requests-futures。 Header 排序在某些特殊情况下你也许需要按照次序来提供 header，如果你向 headers 关键字参数传入一个 OrderedDict，就可以向提供一个带排序的 header。然而，Requests 使用的默认 header 的次序会被优先选择，这意味着如果你在 headers 关键字参数中覆盖了默认 header，和关键字参数中别的 header 相比，它们也许看上去会是次序错误的。 如果这个对你来说是个问题，那么用户应该考虑在 [Session](https://docs.python-requests.org/zh_CN/latest/api.html#requests.Session) 对象上面设置默认 header，只要将 [Session](https://docs.python-requests.org/zh_CN/latest/api.html#requests.Session.headers) 设为一个定制的 OrderedDict 即可。这样就会让它成为优选的次序。 超时（timeout）为防止服务器不能及时响应，大部分发至外部服务器的请求都应该带着 timeout 参数。在默认情况下，除非显式指定了 timeout 值，requests 是不会自动进行超时处理的。如果没有 timeout，你的代码可能会挂起若干分钟甚至更长时间。 连接超时指的是在你的客户端实现到远端机器端口的连接时（对应的是connect()_），Request 会等待的秒数。一个很好的实践方法是把连接超时设为比 3 的倍数略大的一个数值，因为 TCP 数据包重传窗口 (TCP packet retransmission window) 的默认大小是 3。 一旦你的客户端连接到了服务器并且发送了 HTTP 请求，读取超时指的就是客户端等待服务器发送请求的时间。（特定地，它指的是客户端要等待服务器发送字节之间的时间。在 99.9% 的情况下这指的是服务器发送第一个字节之前的时间）。 如果你制订了一个单一的值作为 timeout，如下所示： 12r = requests.get(&#x27;https://github.com&#x27;, timeout=5) 这一 timeout 值将会用作 connect 和 read 二者的 timeout。如果要分别制定，就传入一个元组： 12r = requests.get(&#x27;https://github.com&#x27;, timeout=(3.05, 27)) 如果远端服务器很慢，你可以让 Request 永远等待，传入一个 None 作为 timeout 值，然后就冲咖啡去吧。 1r = requests.get(&#x27;https://github.com&#x27;, timeout=None)","tags":["Module","Python"],"categories":["Language"]},{"title":"Python中的init","path":"/posts/8eca888d.html","content":"123class Test():\tdef __init__(self, name, age): print(name + &quot;今年&quot; + str(age) + &quot;岁了&quot;) 12Test(&quot;冰糖&quot;, 22) 12345# __init__方法会直接调用# 执行结果冰糖 今年22岁了","tags":["Python"],"categories":["Language"]},{"title":"Python占位符","path":"/posts/514dbe02.html","content":"占位符%常用占位符：%s字符串%d整型%f浮点型格式: “要格式化的字符串” %（真实数值，形式为真实值或者变量名） 占位符 例一、123n = 1.565# %0.2f表示四舍五入,保留两位小数 其中.2是必须设置的保留位数,前面的0可以为任意数print(&quot;这个数是%0.2f 阿巴阿巴&quot; % n) 123# 输出结果&gt; 这个数是1.56阿巴阿巴 例二、123456789pc = input(&quot;电脑名牌是 &quot;)ra = input(&quot;比例是: &quot;)mo = input(&quot;价格是: &quot;)info = &quot;&quot;&quot;I buy the computer from USA. The brand is %s and the ratio is %s, so the price is %s yuan.&quot;&quot;&quot;%(pc,ra,mo)print(info)","tags":["Python"],"categories":["Language"]},{"title":"selenium自动化8种元素定位方式","path":"/posts/ad699.html","content":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from selenium import webdriverbrowser = webdriver.Chrome()browser.get(&quot;[http://www.baidu.com](http://www.baidu.com)&quot;)# 元素定位1 IDser = browser.find_element_by_id(&#x27;kw&#x27;)# 元素定位2 nameser = browser.find_element_by_name(&#x27;wd&#x27;)# 元素定位3 classser = browser.find_element_by_class_name(&#x27;s_ipt&#x27;)# 元素定位4 标签定位 tag_name //不推荐,标签一般不止一个,无法精确定位,易报错ser = browser.find_element_by_tag_name(&#x27;input&#x27;)# 元素定位5 文本链接定位 link_text 输关键字ser = browser.find_element_by_link_text(&#x27;新闻&#x27;).click()# 元素定位6 partial_link_text 以模糊链接进行定位ser = browser.find_element_by_partial_link_text(&#x27;&#x27;)# 元素定位7-1 CSS定位 #idser = browser.find_element_by_css_selector(&#x27;#kw&#x27;)# 元素定位7-2 CSS定位 .classser = browser.find_element_by_css_selector(&#x27;.s_ipt&#x27;)# 元素定位7-3 CSS定位 其他属性定位 语法：[属性名=属性值]ser = browser.find_element_by_css_selector(&#x27;[class=&quot;s_ipt&quot;]&#x27;)# 元素定位8 相对路径/绝对路径定位 xpathser = browser.find_element_by_xpath(&#x27;//*[@id=&quot;kw&quot;]&#x27;)ser.send_keys(&#x27;冰糖&#x27;)","tags":["Module","Python"],"categories":["Language"]},{"title":"Python中DDT模块使用02","path":"/posts/d4c3d989.html","content":"说明：一般进行接口测试时，每个接口的传参都不止一种情况，一般会考虑正向、逆向等多种组合。在测试一个接口时通常会编写多条case，而这些case除了传参不同外，其实并没什么区别。这个时候就可以利用ddt来管理测试数据，提高代码复用率。 ※但要注意：正向和逆向的要分开写※ 安装： pip install ddt四种模式： 一、引入装饰器@ddt；导入数据的@data；拆分数据的@unpack；导入外部数据的@file_data 1、读取元组数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546#一定要和单元测试框架一起用import unittest,osfrom ddt import ddt,data,unpack,file_data&#x27;&#x27;&#x27;NO.1单组元素&#x27;&#x27;&#x27;@ddtclass Testwork(unittest.TestCase): @data(1,2,3) def test_01(self,value): #value用来接收data的数据 print(value)if __name__ == &#x27;__main__&#x27;: unittest.main()结果：=&gt;1 2 3&#x27;&#x27;&#x27;NO.2多组未分解元素&#x27;&#x27;&#x27;@ddtclass Testwork(unittest.TestCase): @data((1,2,3),(4,5,6)) def test_01(self,value): print(value)if __name__ == &#x27;__main__&#x27;: unittest.main()结果：=&gt;(1, 2, 3) (4, 5, 6)&#x27;&#x27;&#x27;NO.3多组分解元素&#x27;&#x27;&#x27;@ddtclass Testwork(unittest.TestCase): @data((1,2,3),(4,5,6)) @unpack #拆分数据 def test_01(self,value1,value2,value3): #每组数据有3个值，所以设置3个形参 print(value)if __name__ == &#x27;__main__&#x27;: unittest.main()结果：=&gt;1 2 3 4 5 6 2、读取列表数据1234567891011121314151617181920212223242526272829303132import unittest,osfrom ddt import ddt,data,unpack,file_data&#x27;&#x27;&#x27;NO.1单组元素和多组元素未分解都一样,下面看嵌套，考眼力了~&#x27;&#x27;&#x27;@ddtclass Testwork(unittest.TestCase): @data([&#123;&#x27;name&#x27;:&#x27;lili&#x27;,&#x27;age&#x27;:12&#125;,&#123;&#x27;sex&#x27;:&#x27;male&#x27;,&#x27;job&#x27;:&#x27;teacher&#x27;&#125;]) # @unpack def test_01(self,a): print(a)if __name__ == &#x27;__main__&#x27;: unittest.main()结果：=&gt;[&#123;&#x27;name&#x27;: &#x27;lili&#x27;, &#x27;age&#x27;: 12&#125;, &#123;&#x27;sex&#x27;: &#x27;male&#x27;, &#x27;job&#x27;: &#x27;teacher&#x27;&#125;]※上面结果可以看出：无法运用到requests数据请求中，所以不是很实用※&#x27;&#x27;&#x27;NO.2多组元素分解&#x27;&#x27;&#x27;@ddtclass Testwork(unittest.TestCase): @data([&#123;&#x27;name&#x27;:&#x27;lili&#x27;,&#x27;age&#x27;:12&#125;,&#123;&#x27;sex&#x27;:&#x27;male&#x27;,&#x27;job&#x27;:&#x27;teacher&#x27;&#125;]) @unpack def test_01(self,a,b): print(a,b)if __name__ == &#x27;__main__&#x27;: unittest.main()结果：=&gt;&#123;&#x27;name&#x27;: &#x27;lili&#x27;, &#x27;age&#x27;: 12&#125; &#123;&#x27;sex&#x27;: &#x27;male&#x27;, &#x27;job&#x27;: &#x27;teacher&#x27;&#125;※拆分后的运行结果，不带有[ ]，拆分是将列表中的2个字典拆分，所以有2个数据※ 3、读取字典数据12345678910111213141516171819202122232425262728293031323334353637import unittest,osfrom ddt import ddt,data,unpack,file_data&#x27;&#x27;&#x27;※字典的读取比较特殊，因为在拆分的时候，形参和实参的key值要一致，否则就报错※&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;NO.1单组数据&#x27;&#x27;&#x27;@ddtclass Testwork(unittest.TestCase): @data(&#123;&#x27;name&#x27;:&#x27;lili&#x27;,&#x27;age&#x27;:&#x27;16&#x27;&#125;,&#123;&#x27;sex&#x27;:&#x27;female&#x27;,&#x27;job&#x27;:&#x27;nurser&#x27;&#125;) # @unpack def test_01(self,a): print(a)if __name__ == &#x27;__main__&#x27;: unittest.main()结果：=&gt;&#123;&#x27;name&#x27;: &#x27;lili&#x27;, &#x27;age&#x27;: &#x27;16&#x27;&#125; &#123;&#x27;sex&#x27;: &#x27;female&#x27;, &#x27;job&#x27;: &#x27;nurser&#x27;&#125;※以上运行的结果数据，就可以用来作为requests的请求参数~！※&#x27;&#x27;&#x27;NO.2多数据拆分，重点来了&#x27;&#x27;&#x27;@ddtclass Testwork(unittest.TestCase): @data(&#123;&#x27;name&#x27;:&#x27;lili&#x27;,&#x27;age&#x27;:&#x27;16&#x27;&#125;,&#123;&#x27;name&#x27;:&#x27;female&#x27;,&#x27;age&#x27;:&#x27;nurser&#x27;&#125;) @unpack def test_01(self,name,age): print(name,age)if __name__ == &#x27;__main__&#x27;: unittest.main()结果：=&gt;lili 16 female nurser※重点来了：首先结果展示的数据是字典里的value，没有打印key的值；其次@data里的数据key值和def方法里的形参名称一定要一致，否则，打印的时候，就会报莫名的参数错误，这里就不做展示，爱学习的同学可以尝试一下~！※ 4、读取文件数据12345678910111213141516171819202122232425import unittest,osfrom ddt import ddt,data,unpack,file_data&#x27;&#x27;&#x27;数据格式必须为json，且必须为双引号的键值对形式，如果不是json格式，有列表等其它格式嵌套的话，无论是否有@unpack，形参和参数数量都要和key值相等&#x27;&#x27;&#x27;@ddtclass testwork(unittest.TestCase): testdata=[&#123;&#x27;a&#x27;:&#x27;lili&#x27;,&#x27;b&#x27;:12&#125;,&#123;&#x27;a&#x27;:&#x27;sasa&#x27;,&#x27;b&#x27;:66&#125;] @data(*testdata) # @unpack def test_01(self,value): print(value) @file_data(os.getcwd()+&#x27;/jsonll.txt&#x27;) def test_02(self,value2): print(value2)if __name__ == &#x27;__main__&#x27;: unittest.main()结果：=&gt;&#123;&#x27;a&#x27;: &#x27;lili&#x27;, &#x27;b&#x27;: 12&#125; &#123;&#x27;a&#x27;: &#x27;sasa&#x27;, &#x27;b&#x27;: 66&#125; nick male 29 链接：https://www.jianshu.com/p/78998bcf3e05","tags":["Module","Python"],"categories":["Language"]},{"title":"Python装饰器理解","path":"/posts/bc334a8b.html","content":"12# 导入模块import time 12345678# 先写一个装饰器def hx(func): st = time.time() func() ed = time.time() res = ed - st print(&#x27;消耗时间&#123;&#125;秒&#x27;.format(res)) 123456# 装饰@hxdef tm(): print(&#x27;函数正在运行...&#x27;) time.sleep(2) 12# 调用函数tm 1234# 得到结果函数正在运行...消耗时间2.0117568969726562秒 参考链接：https://blog.csdn.net/weixin_42134789/article/details/84635252?utm_source=app&amp;app_version=5.0.1&amp;code=app_1562916241&amp;uLinkId=usr1mkqgl919blen","tags":["Python"],"categories":["Language"]},{"title":"Python中DDT模块","path":"/posts/25f5f58b.html","content":"Python+unittest+DDT实现的数据驱动测试 前言数据驱动测试： 避免编写重复代码 数据与测试脚本分离 通过使用数据驱动测试，来验证多组数据测试场景通常来说，多用于单元测试和接口测试 ddt介绍Data-Driven Tests（DDT）即数据驱动测试，可以实现不同数据运行同一个测试用例。ddt本质其实就是装饰器，一组数据一个场景。 ddt模块包含了一个类的装饰器ddt和三个个方法的装饰器： data：包含多个你想要传给测试用例的参数，可以为列表、元组、字典等； file_data:会从json或yaml中加载数据； unpack:分割元素，如以下示例： @data([a,d],[c,d]) 如果没有@unpack，那么[a,b]当成一个参数传入用例运行 如果有**@unpack**，那么[a,b]被分解开，按照用例中的两个参数传递 安装Text1pip install ddt 使用data装饰器传递整体列表，字典、元组 123456789101112131415import unittestfrom ddt import ddt,data,unpackdef add(a,b): return a+b@ddtclass MyTest(unittest.TestCase): # @data([1,2,3,4,5,6,7]) @data(&#123;&quot;a&quot;:&quot;1&quot;,&quot;b&quot;:2&#125;) # @data((1,2,3)) def test(self,data): print(data)if __name__ == &#x27;__main__&#x27;: unittest.main(verbosity=2) 嵌套列表、元组、字典的整体传递方式 12345678910111213141516import unittestfrom ddt import ddt,data,unpackdef add(a,b): return a+b@ddtclass MyTest(unittest.TestCase): # @data(*[[1,2,3],[1,0,1],[0,0,0],[1,1,3]]) # @data(*[&#123;&quot;a&quot;:1&#125;, &#123;&quot;a&quot;:2&#125;, &#123;&quot;a&quot;:3&#125;, &#123;&quot;a&quot;:4&#125;]) @data(*[(1,5), (4,2), (6,7), (5,6)]) def test(self,data): print(data)if __name__ == &#x27;__main__&#x27;: unittest.main(verbosity=2) 使用unpack装饰器unpack 依次传递元组 12345678910111213141516171819import unittestfrom ddt import ddt,data,unpackdef add(a,b): return a+b@ddtclass MyTest(unittest.TestCase): @data((1,2,3),(1,0,1),(0,0,0),(1,1,3)) @unpack def test(self,a,b,c): print(a,b,c) if a+b == c: print(True) else: print(False)if __name__ == &#x27;__main__&#x27;: unittest.main(verbosity=2) 输出结果： Text123456781 2 3True1 0 1True0 0 0True1 1 3False 依次传递字典 123456789101112131415161718192021import unittestfrom ddt import ddt,data,unpackdef add(a,b): return a+b@ddtclass MyTest(unittest.TestCase): @data(&#123;&quot;a&quot;:1,&quot;b&quot;:1,&quot;c&quot;:2&#125;, &#123;&quot;a&quot;:0,&quot;b&quot;:0,&quot;c&quot;:0&#125;, &#123;&quot;a&quot;:-1,&quot;b&quot;:1,&quot;c&quot;:0&#125;) @unpack def test(self,a,b,c): print(a,b,c) if a + b == c: print(True) else: print(False)if __name__ == &#x27;__main__&#x27;: unittest.main(verbosity=2) 输出结果： Text1234561 1 2True0 0 0True-1 1 0True 依次传递列表 12345678910111213141516171819import unittestfrom ddt import ddt,data,unpackdef add(a,b): return a+b@ddtclass MyTest(unittest.TestCase): @data([1,2,3],[1,0,1],[0,0,0],[1,1,3]) @unpack def test(self,a,b,c): print(a,b,c) if a + b == c: print(True) else: print(False)if __name__ == &#x27;__main__&#x27;: unittest.main(verbosity=2) 输出结果： Text123456781 2 3True1 0 1True0 0 0True1 1 3False 使用file_data装饰器ddt支持从文件中加载数据，@file_data()装饰器会从json或yaml中加载数据。只有以“.yml” 和 “.yaml” 结尾的文件被加载为Yaml文件。所有其他格式文件都作为json文件加载，比如txt。 传递json数据 test.json文件 1234567891011121314151617&#123; &quot;case1&quot;: &#123; &quot;a&quot;: 1, &quot;b&quot;: 1, &quot;c&quot;: 2 &#125;, &quot;case2&quot;: &#123; &quot;a&quot;: -1, &quot;b&quot;: 1, &quot;c&quot;: 0 &#125;, &quot;case3&quot;: &#123; &quot;a&quot;: 0, &quot;b&quot;: 0, &quot;c&quot;: 0 &#125;&#125; View Code 123456789101112131415import unittestfrom ddt import ddt,file_datadef add(a,b): return a+b@ddtclass MyTest(unittest.TestCase): @file_data(&quot;test.json&quot;) def test(self, a, b, c): print(a,b,c)if __name__ == &#x27;__main__&#x27;: unittest.main(verbosity=2) 传递多层json文件test.json文件 1234567891011121314151617181920212223&#123; &quot;case1&quot;: &#123; &quot;data&quot;: &#123; &quot;a&quot;: 1, &quot;b&quot;: 1 &#125;, &quot;result&quot;: 2 &#125;, &quot;case2&quot;: &#123; &quot;data&quot;: &#123; &quot;a&quot;: 0, &quot;b&quot;: 1 &#125;, &quot;result&quot;: 1 &#125;, &quot;case3&quot;: &#123; &quot;data&quot;: &#123; &quot;a&quot;: 0, &quot;b&quot;: 0 &#125;, &quot;result&quot;: 0 &#125;&#125; View 123456789101112131415import unittestfrom ddt import ddt,file_datadef add(a,b): return a+b@ddtclass MyTest(unittest.TestCase): @file_data(&quot;test.json&quot;) def test(self,data,result): print(data,result)if __name__ == &#x27;__main__&#x27;: unittest.main(verbosity=2) 传递yml数据 yml 需要安装yml（pip install PyYAML）test.yml 12345678def add(a,b): return a+b@ddtclass MyTest(unittest.TestCase): @file_data(&quot;test.yml&quot;) def test(self,a,b,c): print(a,b,c) Text12345参考refer:https://www.pythonf.cn/read/108350https://www.cnblogs.com/nancyzhu/p/8563884.htmlhttps://www.cnblogs.com/-wenli/p/13397984.html","tags":["Module","Python"],"categories":["Language"]},{"title":"pymysql同时执行多条语句","path":"/posts/263c9770.html","content":"说明：1. pymysql在8.0版本以前（不包含8.0）是默认可以同时执行多条sql语句的，但是在8.0之后不再设置为默认，需要手动配置2. 配置方法是在获取数据连接时，配置参数client_flag=CLIENT.MULTI_STATEMENTS 使用：1234567891011121314# 导入模块import pymysql# 导入同时可执行多条语句的方法from pymysql.constants import CLIENT# 连接数据库 同时设置可同时执行多条语句的参数mdb = pymysql.connect(user=&#x27;root&#x27;,password=&#x27;cs123456&#x27;,host=&#x27;localhost&#x27;,port=3306,database=&#x27;test01&#x27;,client_flag=CLIENT.MULTI_STATEMENTS)# 设置游标cur = mdb.cursor()","tags":["Module","Python"],"categories":["Language"]},{"title":"Python文件代码模板","path":"/posts/d8a67b85.html","content":"123456# -*- coding: UTF-8 -*-# @Time: $&#123;DATE&#125; $&#123;TIME&#125;# @Author: Rock Candy# @E-mail: NotNoneX@Gmail.com# @File: $&#123;NAME&#125;.py image-20230408114339198","tags":["Python"],"categories":["Language"]},{"title":"Pycharm配置镜像源","path":"/posts/291376b9.html","content":"长期有效的配置方案： Step one：WIN+R—-&gt;cmd，输入如下命令（这里选择的是清华源）： pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple 如果想采用其他镜像源也可以嗷，这里列举几个镜像源： http://mirrors.aliyun.com/pypi/simple/ 阿里云 https://pypi.mirrors.ustc.edu.cn/simple/ 中国科技大学 http://pypi.douban.com/simple/ 豆瓣 https://pypi.tuna.tsinghua.edu.cn/simple/ 清华大学 http://pypi.mirrors.ustc.edu.cn/simple/ 中国科学技术大学 配置镜像源","tags":["Python","Pycharm","IDEA"],"categories":["Language"]},{"title":"Python常用命名规则","path":"/posts/841b0d9a.html","content":"1.模块名一般使用全部小写 如 myphone 2.类名第一个字母大写，如果有多个单词，每一个单词的第一个字母大写如 : MyPhone 3.函数名 ： 小写， 如果有多个单词用下划线隔开 如 my_phone 4.常量名字一般全大写 ： MYPHONE","tags":["Python"],"categories":["Language"]},{"title":"Nginx学习笔记_基于Docker","path":"/posts/97ab3dc4.html","content":"B站视频笔记，2020最新 Nginx教程全面讲解（Nginx快速上手） 一共14集，每集5到10分钟，基于docker快速搭建的nginx Nginx介绍1.1引言为什么要学习Nginx问题1：客户端到底要将请求发送给哪台服务器问题2：如果所有客户端的请求都发送给了服务器1问题3：客户端发送的请求可能是申请动态资源的，也有申请静态资源的 11 服务器搭建集群后 Nginx学习笔记 11 在搭建集群后，使用Nginx做反向代理 Nginx学习笔记 1.2Nginx介绍Nginx是由俄罗斯人研发的，应对Rambler的网站[并发]，并且2004年发布的第一个版本 1234Nginx的特点1.稳定性极强，7*24小时不间断运行(就是一直运行)2.Nginx提供了非常丰富的配置实例3.占用内存小，并发能力强(随便配置一下就是5w+,而tomcat的默认线程池是150) Nginx的安装2.1安装Nginx使用docker-compose安装 12345#在/opt目录下创建docker_nginx目录cd /optmkdir docker_nginx#创建docker-compose.yml文件并编写下面的内容,保存退出vim docker-compose.yml 12345678version: &#x27;3.1&#x27;services: nginx: restart: always image: daocloud.io/library/nginx:latest container_name: nginx ports: - 80:80 执行 1docker-compose up -d 访问80端口，看到下图说明安装成功（大家输入自己服务器的Ip就可以访问80端口了） Nginx学习笔记 2.2Nginx的配置文件12345#查看当前nginx的配置需要进入docker容器中docker exec -it 容器id bash#进入容器后cd /etc/nginx/cat nginx.conf nginx.conf文件内容如下 1234567891011121314151617181920212223242526272829303132333435363738394041user nginx;worker_processes 1;error_log /var/log/nginx/error.log warn;pid /var/run/nginx.pid;# 以上同城为全局块# worker_processes的数值越大，Nginx的并发能力就越强# error_log代表Nginx错误日志存放的位置# pid是Nginx运行的一个标识events &#123; worker_connections 1024;&#125;# events块# worker_connections的数值越大，Nginx的并发能力就越强http &#123; include /etc/nginx/mime.types; default_type application/octet-stream; log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf;&#125;# http块# include代表引入一个外部文件# include /etc/nginx/mime.types;\tmime.types中存放着大量媒体类型#include /etc/nginx/conf.d/*.conf;\t引入了conf.d下以.conf为结尾的配置文件 conf.d目录下只有一个default.conf文件，内容如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253server &#123; listen 80; listen [::]:80; server_name localhost; #charset koi8-r; #access_log /var/log/nginx/host.access.log main; location / &#123; root /usr/share/nginx/html; index index.html index.htm; &#125;\t# location块\t# root:将接受到的请求根据/usr/share/nginx/html去查找静态资源\t# index:默认去上述的路径中找到index.html或index.htm #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&#x27;s document root # concurs with nginx&#x27;s one # #location ~ /\\.ht &#123; # deny all; #&#125;&#125;# server块# listen代表Nginx监听的端口号# server_name代表Nginx接受请求的IP 2.3修改docker-compose文件123456#退出容器exit#关闭容器docker-compose down#修改docker-compose.yml文件如下 12345678910version: &#x27;3.1&#x27;services: nginx: restart: always image: daocloud.io/library/nginx:latest container_name: nginx ports: - 80:80 volumes: - /opt/docker_nginx/conf.d/:/etc/nginx/conf.d 1234#重新构建容器docker-compose bulid#重新启动容器docker-compose up -d 这时我们再次访问80端口是访问不到的，因为我们映射了数据卷之后还没有编写server块中的内容 我们在&#x2F;opt&#x2F;docker_nginx&#x2F;conf.d下新建default.conf，并插入如下内容 12345678910server &#123; listen 80; listen [::]:80; server_name localhost; location / &#123; root /usr/share/nginx/html; index index.html index.htm; &#125;&#125; 12#重启nginxdocker-compose restart 这时我们再访问80端口，可以看到是访问成功的 Nginx的反向代理3.1正向代理和反向代理介绍1234正向代理：1.正向代理服务是由客户端设立的2.客户端了解代理服务器和目标服务器都是谁3.帮助咱们实现突破访问权限，提高访问的速度，对目标服务器隐藏客户端的ip地址 在这里插入图片描述 1234反向代理：1.反向代理服务器是配置在服务端的2.客户端不知道访问的到底是哪一台服务器3.达到负载均衡，并且可以隐藏服务器真正的ip地址 Nginx学习笔记 3.2基于Nginx实现反向代理123准备一个目标服务器启动tomcat服务器编写nginx的配置文件(/opt/docker_nginx/conf.d/default.conf)，通过Nginx访问到tomcat服务器 准备tomcat服务器 123456docker run -d -p 8080:8080 --name tomcat daocloud.io/library/tomcat:8.5.15-jre8#或者已经下载了tomcat镜像docker run -d -p 8080:8080 --name tomcat 镜像的标识#添加数据卷docker run -it -v /宿主机绝对目录:/容器内目录 镜像名 default.conf文件内容如下 123456789server &#123; listen 80; listen [::]:80; server_name localhost; location / &#123; proxy_pass http://cvki.cn:8080/; &#125;&#125; 这时我们访问80端口可以看到8080端口tomcat的默认首页 3.3关于Nginx的location路径映射123优先级关系：(location = ) &gt; (location /xxx/yyy/zzz) &gt; (location ^~) &gt; (location ~,~*) &gt; (location /起始路径) &gt; (location /) 12345# 1. = 匹配location / &#123;\t#精准匹配，主机名后面不能带任何字符串\t#例如www.baidu.com不能是www.baidu.com/id=xxx&#125; 12345#2. 通用匹配location /xxx &#123;\t#匹配所有以/xxx开头的路径\t#例如127.0.0.1:8080/xxx\txxx可以为空，为空则和=匹配一样&#125; 1234#3. 正则匹配location ~ /xxx &#123;\t#匹配所有以/xxx开头的路径&#125; 1234#4. 匹配开头路径location ^~ /xxx/xx &#123;\t#匹配所有以/xxx/xx开头的路径&#125; 1234#5. 匹配结尾路径location ~* \\.(gif/jpg/png)$ &#123;\t#匹配以.gif、.jpg或者.png结尾的路径&#125; 修改&#x2F;opt&#x2F;docker_nginx&#x2F;conf.d&#x2F;default.conf如下 1234567891011121314151617server &#123; listen 80; listen [::]:80; server_name localhost;\tlocation /index &#123; proxy_pass http://cvki.cn:8081/;\t#tomcat首页 &#125;\tlocation ^~ /CR/ &#123; proxy_pass http://cvki.cn:8080/CR/;\t#毕设前台首页 &#125; location / &#123; proxy_pass http://cvki.cn:8080/CRAdmin/;\t#毕设后台首页 &#125;&#125; 123456#重启nginxdocker-compose restart#访问cvki.cn/index可以进入tomcat首页#访问cvki.cn/CR/XXX可以进入毕设前台首页#访问cvki.cn或者cvki.cn:80可以进入毕设后台首页 Nginx负载均衡12345678Nginx为我们默认提供了三种负载均衡的策略：1.轮询： 将客户端发起的请求，平均分配给每一台服务器2.权重： 会将客户端的请求，根据服务器的权重值不同，分配不同的数量3.ip_hash: 基于发起请求的客户端的ip地址不同，他始终会将请求发送到指定的服务器上 就是说如果这个客户端的请求的ip地址不变，那么处理请求的服务器将一直是同一个 4.1轮询想实现Nginx轮询负载均衡机制只需要修改配置文件如下 12345678910111213upstream my_server&#123; server cvki.cn:8080; server cvki.cn:8081;&#125;server &#123; listen 80; listen [::]:80; server_name localhost;\tlocation / &#123; proxy_pass http://my_server/;\t#tomcat首页 &#125;&#125; 12345678910111213upstream 名字&#123; server ip:端口; server 域名:端口;&#125;server &#123; listen 80; listen [::]:80; server_name localhost;\tlocation / &#123; proxy_pass http://upstream的名字/; &#125;&#125; 12#重启nginxdocker-compose restart 多次刷新cvki.cn页面，根据版本号我们可以发现我们进入的是不同的tomcat Nginx学习笔记 Nginx学习笔记 4.2权重实现权重的方式：在配置文件中upstream块中加上weight 12345678910111213upstream my_server&#123; server cvki.cn:8080 weight=10; server cvki.cn:8081 weight=2;&#125;server &#123; listen 80; listen [::]:80; server_name localhost;\tlocation / &#123; proxy_pass http://my_server/;\t#tomcat首页 &#125;&#125; 4.3ip_hash实现ip_hash方式：在配置文件upstream块中加上ip_hash; 1234567891011121314upstream my_server&#123;\tip_hash; server cvki.cn:8080 weight=10; server cvki.cn:8081 weight=2;&#125;server &#123; listen 80; listen [::]:80; server_name localhost;\tlocation / &#123; proxy_pass http://my_server/;\t#tomcat首页 &#125;&#125; Nginx动静分离1234Nginx的并发能力公式： worker_processes * worker_connections / 4|2 = Nginx最终的并发能力动态资源需要/4，静态资源需要/2Nginx通过动静分离来提升Nginx的并发能力，更快的给用户响应 5.1动态资源代理1234#配置如下location / &#123; proxy_pass 路径;&#125; 5.2静态资源代理123456789#停掉nginxdocker-compose down修改docker-compose.yml添加静态资源数据卷不同版本的静态资源位置可能不同，可以在2.2中查看默认的位置（location块中root后的路径）#启动nginxdocker-compose up -d 1234567891011version: &#x27;3.1&#x27;services: nginx: restart: always image: daocloud.io/library/nginx:latest container_name: nginx ports: - 80:80 volumes: - /opt/docker_nginx/conf.d/:/etc/nginx/conf.d - /opt/docker_nginx/html/:/usr/share/nginx/html 12345678在/opt/docker_nginx/html下新建一个index.html在index.html里面随便写点东西展示修改nginx的配置文件location / &#123; root /usr/share/nginx/html; index index.html;&#125; 123456#配置如下location / &#123; root 静态资源路径; index 默认访问路径下的什么资源; autoindex on;#代表展示静态资源的全部内容，以列表的形式展开&#125; 123#重启nginxdocker-compose restart#访问cvki.cn如下 Nginx学习笔记 Nginx集群6.1引言1234单点故障，避免nginx的宕机，导致整个程序的崩溃准备多台Nginx准备keepalived，监听nginx的健康情况准备haproxy，提供一个虚拟的路径，统一的去接收用户的请求 Nginx学习笔记 6.2搭建123456789#先准备好以下文件放入/opt/docker_nginx_cluster目录中#然后启动容器\t注意确保80、8081和8082端口未被占用(或者修改docker-compose.yml中的端口)docker-compose up -d然后我们访问8081端口可以看到master，访问8082端口可以看到slave因为我们设置了81端口的master优先级未200比82端口的slave优先级100高，所以我们访问80端口看到的是master现在我们模仿8081端口的nginx宕机了docker stop 8081端口nginx容器的ID这时我们再去访问80端口看到的就是slave了 Dockerfile 1234567891011FROM nginx:1.13.5-alpineRUN apk update &amp;&amp; apk upgradeRUN apk add --no-cache bash curl ipvsadm iproute2 openrc keepalivedCOPY entrypoint.sh /entrypoint.shRUN chmod +x /entrypoint.shCMD [&quot;/entrypoint.sh&quot;] entrypoint.sh 1234567#!/bin/sh#/usr/sbin/keepalvined -n -l -D -f /etc/keepalived/keepalived.conf --dont-fork --log-console &amp;/usr/sbin/keepalvined -D -f /etc/keepalived/keepalived.confnginx -g &quot;daemon off;&quot; docker-compose.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445version: &quot;3.1&quot;services: nginx_master: build: context: ./ dockerfile: ./Dockerfile ports: -8081:80 volumes: - ./index-master.html:/usr/share/nnginx/html/index.html - ./favicon.ico:/usr/share/nnginx/html/favicon.ico - ./keepalived-master.conf:/etv/keepalived/keepalived.conf networks: static-network: ipv4_address:172.20.128.2 cap_add: - NET_ADMIN nginx_slave: build: context: ./ dockerfile: ./Dockerfile ports: -8082:80 volumes: - ./index-slave.html:/usr/share/nnginx/html/index.html - ./favicon.ico:/usr/share/nnginx/html/favicon.ico - ./keepalived-slave.conf:/etv/keepalived/keepalived.conf networks: static-network: ipv4_address:172.20.128.3 cap_add: - NET_ADMIN proxy: image: haproxy:1.7-apline ports: - 80:6301 volumes: - ./happroxy.cfg:/usr/local/etc/haproxy/haproxy.cfg networks: - static-networknetworks: static-network: ipam: congig: - subnet: 172.20.0.0/16 keepalived-master.conf 12345678910111213141516171819202122232425vrrp_script chk_nginx &#123; script &quot;pidof nginx&quot; interval 2&#125;vrrp_instance VI_1 &#123; state MASTER interface etch0\t#容器内部的网卡名称 virtual_router_id 33 priority 200\t#优先级 advert_int 1 autheentication &#123; auth_type PASS auth_pass letmein\t&#125;\tvirtual_ipaddress &#123; 172.20.128.50\t#虚拟路径 &#125;\ttrack_script &#123; chk_nginx &#125;&#125; keepalived-slave.conf 12345678910111213141516171819202122232425vrrp_script chk_nginx &#123; script &quot;pidof nginx&quot; interval 2&#125;vrrp_instance VI_1 &#123; state BACKUP interface etch0\t#容器内部的网卡名称 virtual_router_id 33 priority 100\t#优先级 advert_int 1 autheentication &#123; auth_type PASS auth_pass letmein\t&#125;\tvirtual_ipaddress &#123; 172.20.128.50\t#虚拟路径 &#125;\ttrack_script &#123; chk_nginx &#125;&#125; haproxy.cfg 123456789101112131415161718192021222324global\tlog 127.0.0.1 local0\tmaxconn 4096\tdaemon\tnbproc 4\tdefaults\tlog 127.0.0.1 local3\tmode http\toption dontlognull\toption redispatch\tretries 2\tmaxconn 2000\tbalance roundrobin\ttimeout connect 5000ms\ttimeout client 5000ms\ttimeout server 5000ms\tfrontend main\tbind *:6301\tdefault_backend webserver\tbackend webserveer\tserver nginx_master 127.20.127.50:80 check inter 2000 rise 2 fall 5 index-master.html 1&lt;h1&gt;master！&lt;/h1&gt; index-slave.html 1&lt;h1&gt;slave！&lt;/h1&gt;","tags":["Docker","Nginx"],"categories":["Nginx"]},{"title":"Python删除Hexo所有文章链接","path":"/posts/566736d9.html","content":"零、一步步实现hexo删除文章链接一、文件读取写入测试1234567891011# 文件读取 mdr = open(&quot;./link.md&quot;, mode=&#x27;r&#x27;) nr = mdr.read() print(nr) # 文件写入 mdw = open(&quot;./link.md&quot;, mode=&#x27;w&#x27;) mdw.write(&#x27;&#x27;&#x27;--- title: cs1 date: 2022-11-27 23:08:36 tags: ---&#x27;&#x27;&#x27;) 二、正则替换测试123456789101112131415import re # 打开文件获取原内容 fr = open(&#x27;./link.md&#x27;, mode=&#x27;r&#x27;) frn = fr.read() print(frn) # 正则修改内容 写入内容 fw = open(&#x27;./link.md&#x27;, mode=&#x27;w&#x27;) change = re.sub(r&#x27;(?&lt;=abbrlink: print(change) # 关闭文件 fw.write(change) fr.close() fw.close() 三、文章目录及文件路径读取1234567891011121314151617181920212223242526272829 import os path = &quot;./MDNote&quot; # 文件夹路径 print(&#x27;-&#x27; * 25, &#x27;目录路径&#x27;, &#x27;-&#x27; * 25) def get_dir(path): # 获取目录路径 for root, dirs, files in os.walk(path): # 遍历path,进入每个目录都调用visit函数，，有3个参数，root表示目录路径，dirs表示当前目录的目录名，files代表当前目录的文件名 for dir in dirs: # print(dir) #文件夹名 print(os.path.join(root, dir)) # 把目录和文件名合成一个路径 get_dir(path) &#x27;&#x27;&#x27; 文件路径 &#x27;&#x27;&#x27;print(&#x27; &#x27;, &#x27;-&#x27; * 25, &#x27;文件路径&#x27;, &#x27;-&#x27; * 25) def get_file(path): # 获取文件路径 for root, dirs, files in os.walk(path): for file in files: # print(file) #文件名 print(os.path.join(root, file)) get_file(path) 四、正则过滤指定文件(排除其他格式文件仅保留md)12345678910111213import os, re path = &quot;.\\MDNote&quot; # 文件夹路径 op = os.walk(path) # 获取目录及文件 for root, dirs, files in op: # 单独遍历 root表示目录路径，dirs表示当前目录的目录名，files代表当前目录的文件名 # print(root, dirs, files) for file in files: # print(file) rege = re.search(r&#x27;.*\\.md&#x27;, file) # 正则过滤md文件 if rege != None: mdpt = os.path.join(root, file) print(mdpt) 五、函数封装获取所有指定后缀文件路径1234567891011121314151617import os, re # 传入指定路径和文件后缀def delAbbr(path, suffix): regEx = r&#x27;.*\\.&#x27; + suffix # 正则 匹配指定后缀 getS = os.walk(path) # 获取目录及文件 for root, dirs, files in getS: # 单独遍历 root表示目录路径，dirs表示当前目录的目录名，files代表当前目录的文件名 for file in files: if re.search(regEx, file) != None: pat = os.path.join(root, file) print(pat) path = &quot;.\\MDNote&quot; suffix = &#x27;md&#x27; delAbbr(path, suffix) 六、最终封装 删除所有链接1234567891011121314151617181920212223242526272829303132333435363738394041# -*- coding: UTF-8 -*- # @Time: 2022/11/28 15:57 # @Author: Crystal Sugar # @E-mail: NotNoneX@Gmail.com # @File: 最终结果.py &#x27;&#x27;&#x27; 删除Hexo中所有链接&#x27;&#x27;&#x27; import os, re def delAbbr(path, suffix): inp = input(&#x27;确认处理文件吗?( 按y确认,否则取消 ) &#x27;) if inp == &#x27;y&#x27;: print(&#x27;-&#x27; * 25, &#x27;开始处理&#x27;, &#x27;-&#x27; * 25) # 筛选文件正则 &amp; 文件处理正则 regEx = r&#x27;.*\\.&#x27; + suffix # 正则 匹配指定后缀 regE = r&#x27;(?&lt;=abbrlink: num = 0 getS = os.walk(path) # 获取目录及文件 for root, dirs, files in getS: # 单独遍历 root表示目录路径，dirs表示当前目录的目录名，files代表当前目录的文件名 for file in files: if re.search(regEx, file) != None: pat = os.path.join(root, file) opmd = open(pat, mode=&#x27;r&#x27;, encoding=&#x27;utf8&#x27;) # 打开文件 rdmd = opmd.read() # 读取文件 opmd.close() # 关闭释放 newMD = re.sub(regE, &#x27;&#x27;, rdmd, flags=re.M) # 正则替换 wtmd = open(pat, mode=&#x27;w&#x27;, encoding=&#x27;utf8&#x27;) # 打开源文件 覆盖 num += 1 print(&#x27;正在处理第&#x27;, num, &#x27;个文件&#x27;) wtmd.write(newMD) # 写入处理后的内容 wtmd.close() # 关闭 print(&#x27;-&#x27; * 25, &#x27;处理完成&#x27;, &#x27;-&#x27; * 25) else: print(&#x27;操作已取消&#x27;) path = &quot;.\\MDNote&quot; suffix = &#x27;md&#x27; delAbbr(path, suffix)","tags":["Python","GitHub"],"categories":["Source"]},{"title":"Nginx 学习","path":"/posts/3937bea5.html","content":"什么是nginx？Nginx (engine x)是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP&#x2F;POP3&#x2F;SMTP（邮件）服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Pam6Πep）开发的，第一个公开的版本0.1.0发布于2004年6月1日。2011年6月1日，nginx 1.0.4发布。 其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网页等。在全球活跃的网站中有12.18%的使用比例，大约为2220万个网站。 Nginx是一个安装非常简单、配置文件非常简洁（且能支持perl语法）、Bug非常少的服务。Nginx 启动特别容易，并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能不间断服务的情况下进行软件版本的升级。 nginx的代码是完全使用C语言开发。官方数据测试表明能够支持高达 50,000 个并发连接数的响应。 Nginx 作用？ Http代理，反向代理：作为web服务器最常用的功能之一，尤其是方向代理。 正向代理：代理客户端 正向代理类似一个跳板机，代理访问外部资源比如我们国内访问谷歌，直接访问访问不到，我们可以通过一个正向代理服务器，请求发到代理服，代理服务器能够访问谷歌，这样由代理去谷歌取到返回数据，再返回给我们，这样我们就能访问谷歌了 img 正向代理的用途： 1（1）访问原来无法访问的资源，如google (2) 可以做缓存，加速访问资源（3）对客户端访问授权，上网进行认证（4）代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息 反向代理：代理服务器 反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器 img 反向代理的作用： 1（1）保证内网的安全，阻止web攻击，大型网站，通常将反向代理作为公网访问地址，Web服务器是内网（2）负载均衡，通过反向代理服务器来优化网站的负载 一句话总结正向代理与方向代理的区别： 1正向代理即是客户端代理, 代理客户端, 服务端不知道实际发起请求的客户端. 反向代理即是服务端代理, 代理服务端, 客户端不知道实际提供服务的服务端. Nginx提供的负载均衡策略有两种：内置策略和拓展策略。内置策略为轮询，Ip hash。拓展策略，就天马行空没有你想不到，没有他做不到。 轮询 img 加权轮询 img iphash 对客户端请求的ip进行hash操作，然后根据hash结果来将同一个客户端的ip请求分发给同一台服务器进行处理，可以解决session不共享的问题。（redis也能实现，也推荐使用redis） img 动静分离，在我们的软件开发中，有一些请求需要后台处理，有些请求不需要经过后台处理的（如：css、html、jsp、js等等文件），这些不需要经过后台处理的文件称之为静态文件。让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作。提高资源响应的速度。 img 目前，通过使用nginx大大提高了我们网站的响应速度，优化了用户体验，让网站的健壮更上一层楼！ Nginx 安装 windows 安装 1、下载nginxhttp://nginx.org/en/download.html 下载稳定版下载后解压如下： img 2、启动nginx img 3、测试访问( 默认端口是80 http默认的端口是80):http://localhost/80 img Linux安装1、下载nginxhttp://nginx.org/en/download.html 下载稳定版2、上传到linux img 3、解压 nginx[root@localhost nginx-1.20.2]# tar -zxvf nginx-1.20.2.tar.gz4、配置configure 需要配置—prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx 否则回出错误[root@localhost nginx-1.20.2]# ./configure --prefix=/usr/local/nginx不加—prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx 的错误（make时也会出错【 make make: *** 没有规则可以创建“default”需要的目标“build”。 停止。】）： img 5、执行make[root@localhost nginx-1.20.2]# make 6、执行make install[root@localhost nginx-1.20.2]# make install 7、查看安装编译目录 12[root@localhost nginx-1.20.2]# whereis nginxnginx: /usr/local/nginx 8、启动nginx 1234567[root@localhost nginx-1.20.2]# cd /usr/local/nginx/[root@localhost nginx]# lsconf html logs sbin[root@localhost nginx]# cd sbin/[root@localhost sbin]# lsnginx nginx.old[root@localhost sbin]# ./nginx 9、测试nginx ，访问默认端口：80 123456789101112131415161718192021222324[root@localhost sbin]# curl http://localhost&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;&lt;style&gt; body &#123; width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;&lt;p&gt;If you see this page, the nginx web server is successfully installed andworking. Further configuration is required.&lt;/p&gt;&lt;p&gt;For online documentation and support please refer to&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;Commercial support is available at&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; Nginx常用命令123456cd /usr/local/bin/sbin/./nginx 启动./nginx -s stop 停止./nginx -s quit 安全退出./nginx -s reload 重新加载配置文件ps aux|grep nginx 查看nginx进程 nginx.conf配置文件（转载于:https://my.oschina.net/u/2552286/blog/3056865） 1.全局块：主要设置一些影响nginx 服务器整体运行的配置指令。如：用户（组），生成worker process 数，日志存放路径，配置文件引入，pid文件路径2.events 块影响nginx 服务器与用户的网络连接。如：每个worker processs 的最大连接数，事件驱动模型 3.http块nginx 配置中的重要部分，代理，缓存等功能都可以在此配置。如：文件引入，mime-type 定义，连接超时，单连接请求数上限 4.server 块与“虚拟主机”的概念有密切关系。每个server 块相当于一台虚拟主机，最常见的两个配置项是监听配置和虚拟主机的名称或IP配置 5.location 块在server 块中，可以有多个。地址定向，数据缓存，和应答控制等功能都是在这部分实现。 listen address[:port]; #配置网络监听listen :80 | :8080 | 8080; #监听所有的80 和 8080 端口listen 192.168.1.1:8080; #监听192.168.1.1地址的8080端口listen 192.168.1.11; #监听192.168.1.11 的所有端口 server_name name ….; #虚拟主机配置server_name www.xx.com yy.com; #虚拟主机名为www.xx.com 和 yy.comserver_name xx.com www.yy.; #可以使用通配符，但只能放在首段或尾段server_name ~^www\\d+.xx.com$ #可以使用正则表达式,但必须使用 ~ 开头匹配规则按：准确匹配，通配符（开始）匹配 ，通配符（结尾）匹配，正则匹配 location [ &#x3D; | ~ | ~ *| ^~ ] uri {…} #位置配置在一不使用 &#x3D;、、*、^~ 时的匹配规则：先搜索【标准的uri】如果有多个可以匹配，那么就记录匹配度最高的一个。然后再搜索【正则uri】，当第一个【正则uri】匹配成功时就结束搜索并使用它。如果【正则uri】都没有匹配到，就使用【标准uri】就是刚搜索的那个。【&#x3D;】 ： 只能用在【标准uri】前，如果匹配成功了，就停止搜索并使用它。【~ | *】：只能用在【正则uri】前，前面区分大小写，后面不区分大小写【^】: 只能用在【标准uri】前，搜索所有【标准uri】找到匹配度最高的一个结束搜索并使用它 root path; 配置请求的根目录path 为服务器资源的根目录路径,如：location &#x2F;data&#x2F; {root &#x2F;usr&#x2F;local&#x2F;web;}当请求为 &#x2F;data&#x2F;index.htm 时， 将映射至 &#x2F;usr&#x2F;local&#x2F;web&#x2F;data&#x2F;index.hm alias path; 更改location 的URIlocation ~ ^&#x2F;data&#x2F;(.+.(htm|htm))${alias &#x2F;usr&#x2F;local&#x2F;app&#x2F;$1;}当请求为 &#x2F;data&#x2F;index.htm 时， 将映射至 &#x2F;usr&#x2F;local&#x2F;app&#x2F;index.htm index file …; 设置网站的默认首页 error_page code … uri #设置网站的错误页面error_page 404 &#x2F;404.htmerror_page 403 http://www.xx.com/403.htmerror_page 410 &#x3D;301 &#x2F;fes.htm # 当服务器产生410时，返回 fes.htm ，并客户端http status 为 301 allow address | CIDR | all; # 基于ip配置nginx 的访问权限 - 允许 deny address | CIDR | all; # 基于ip配置nginx 的访问权限 - 拒绝location &#x2F; {deny 192.168.1.10;allow 192.168.2.45;allow 192.168.3.78;deny all;}遇到 deny 或 allow 指定是按顺序对当前客户端的连接进行访问权限检查 auth_basic string | off; 基于密码配置nginx 的访问权限 auth_basic_user_file file; 使用文件来配置用户名和密码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163# =========================全局块============================# user user [grop]; # 指定可以运行nginx 服务器的用户及组。只被设置的用户及组才有权限管理# user nobody nobody; # 所用用户可用，默认配置user nginx nginx; # worker_processes number | auto; # 控制并发处理，值越大，支持的并发数越多# worker_processes 1; # 默认值 ，最多产生1个worker_processesworker_processes auto;# pid file; # pid 存放路径.相对或绝对路径# pid logs/nginx.pid; # 默认在安装目录logs/nginx.pidpid /var/run/nginx.pid;# error_log file | stder [debug | info | notice | warn | error | crit | alert | emerg]; #错误日志存放路径# error_log logs/error.log error; # 可在 全局块，http 块 ,serveer 块，location 块中配置error_log /data/wwwlogs/error_nginx.log crit;# include file; # 配置文件引入，可以是相对/绝对路径。指令可以放在配置文件的任意地方(任意块中)worker_rlimit_nofile 51200;# ===========================events 块===============================events &#123; #accept_mutex on|off; # 网络连接序列化。解决“惊群”问题 accept_mutex on; # 默认为开启状态 #multi_accept on|off; # 是否允许worker process同时接收多个网络连接， multi_accept off; # 默认为关闭 #use method; # 事件驱动模型选择，select 、 poll 、 kqueue 、 epoll 、 rtsig 、 /dev/poll 、 eventport use epoll; #worker_connections number; # worker process 的最大连接数。 worker_connections 512; # 默认值为512。注意设置不能大于操作系统支持打开的最大文件句柄数量。&#125;# ==========================http块============================http &#123; # 定义 mime-type (网络资源的媒体类型)。 指定能识别前端请求的资源类型 include mime.types; # 引入外部文件 ，在外部文件中有定义types 块 default_type application/octet-stream; # 默认为 text/plain 。 http块、server块、location块中可配置 # access_log path [format[buffer=size]]; # 定义服务日志，记录前端的请求日志 # access_log logs/access.log combined; # combined 是默认定义的日志格式字符串名称 access_log off; # 关闭日志 # log_format name stirng # 定义了日志格式，以便access_log 使用 # log_format combined &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; # &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; # &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; # sendfile on|off; # 配置允许 sendfile 方式传输文件 sendfile off; # 默认关闭，可在http块、server块、location块 中定义 # sendfile_max_chunk size; # 配置worker process 每次调用sendfile()传输的数据最最大值 # sendfile_max_chunk 0; # 默认为0 不限制。 可在http块、server块、location块 中定义 sendfile_max_chunk 128k; # keepalive_timeout timeout [header_timeout]; # 配置连接超时时间, 可在http块、server块、location块 中定义 # keepalive_timeout 75s; # 默认为75秒，与用户建立会话连接后，nginx 服务器可以保持这些连接打开的时间。 keepalive_timeout 120 100s; # 在服务器端保持连接的时间设置为120s,发给用户端的应答报文头部中keep-alive 域的设置为100s # keepalive_requests number; # 单连接请求数上限 keepalive_requests 100; # 默认为 100 server_names_hash_bucket_size 128; client_header_buffer_size 32k; large_client_header_buffers 4 32k; client_max_body_size 1024m; tcp_nopush on; server_tokens off; tcp_nodelay on; fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 128k; #Gzip Compression gzip on; gzip_buffers 16 8k; gzip_comp_level 6; gzip_http_version 1.1; gzip_min_length 256; gzip_proxied any; gzip_vary on; gzip_types text/xml application/xml application/atom+xml application/rss+xml application/xhtml+xml image/svg+xml text/javascript application/javascript application/x-javascript text/x-json application/json application/x-web-app-manifest+json text/css text/plain text/x-component font/opentype application/x-font-ttf application/vnd.ms-fontobject image/x-icon; gzip_disable &quot;MSIE [1-6]\\.(?!.*SV1)&quot;; # If you have a lot of static files to serve through Nginx then caching of the files&#x27; metadata (not the actual files&#x27; contents) can save some latency. open_file_cache max=1000 inactive=20s; open_file_cache_valid 30s; open_file_cache_min_uses 2; open_file_cache_errors on;######################## default ############################# server &#123;# listen 8067;# server_name _;# access_log /data/wwwlogs/access_nginx.log combined;# root /data/wwwroot/default;# index index.html index.htm index.jsp;# location /nginx_status &#123;# stub_status on;# access_log off;# allow 127.0.0.1;# deny all;# &#125;# location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf|flv|ico)$ &#123;# expires 30d;# access_log off;# &#125;# location ~ .*\\.(js|css)?$ &#123;# expires 7d;# access_log off;# &#125;# location ~ &#123;# proxy_pass http://127.0.0.1:8080;# include proxy.conf;# &#125;# &#125;# server&#123;# listen 8087;# server_name _;# root /home/wwwroot/default;# location / &#123;# &#125;# &#125; upstream backend&#123; server 127.0.0.1:8080 weight=1 max_fails=2 fail_timeout=2; server 139.224.209.104:8080 backup; &#125; server&#123; listen 80; listen 443 ssl; server_name wmcenter.xy-asia.com; #ssl on; default_type &#x27;text/html&#x27;; charset utf-8; ssl_certificate /usr/local/cert/1634560_wmcenter.xy-asia.com.pem; ssl_certificate_key /usr/local/cert/1634560_wmcenter.xy-asia.com.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; root html; index index.html index.htm; location ~ .*\\.(js|css)?$ &#123; expires 1h; proxy_pass http://backend; &#125; location / &#123; proxy_pass http://backend; add_header backendIP $upstream_addr; # proxy_next_upstream error timeout invalid_header http_500 http_502 http_503; # proxy_set_header Host $host; # proxy_set_header X-Real-IP $remote_addr; # proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # proxy_set_header X-Forwarded-Proto https; # proxy_redirect http://http://127.0.0.1:8080 $scheme://127.0.0.1:8080; # port_in_redirect on; # proxy_redirect off; include proxy.conf; &#125; # error_log /home/wwwlogs/xywm.log; &#125; # 缓存配置 proxy_temp_file_write_size 264k; proxy_temp_path /data/wwwlogs/nginx_temp; proxy_cache_path /data/wwwlogs/nginx_cache levels=1:2 keys_zone=prc:200m inactive=5d max_size=400m; proxy_ignore_headers X-Accel-Expires Expires Cache-Control Set-Cookie; ########################## vhost ############################# include vhost/*.conf;&#125;","tags":["Nginx"],"categories":["Nginx"]},{"title":"图片接口收集","path":"/posts/959d0420.html","content":"必应壁纸 来自于缙哥哥博客：1366768分辨率图片地址：https://api.dujin.org/bing/1366.php19201080分辨率图片地址：https://api.dujin.org/bing/1920.php手机标准分辨率1080*1920图片地址：https://api.dujin.org/bing/m.php img [IMGAPI-图片API] https://imgapi.cn/bing.php img 动漫图片 [acg (1871×1052) (cyfan.top)]img https://www.dmoe.cc/random.phpimg https://img.paulzzh.com/touhou/randomimg https://img.xjh.me/random_img.php?return=302img 现代化图片 https://unsplash.it/1600/900?randomimg https://unsplash.it/1600/900?randomimg 真人美女 https://imgapi.cn/cos.phpimg https://3650000.xyz/api/img https://cdn.seovx.com/?mom=302img 综合类 https://imgapi.cn/api.phpimg","tags":["Api"],"categories":["lnternet"]},{"title":"Python文件基本操作","path":"/posts/cdfc731f.html","content":"文件的存储方式 在计算机中，文件是以 二进制的方式保存在磁盘上的 文本文件和二进制文件 文本文件 可以使用文本编辑软件查看 本质上还是二进制文件 二进制文件 保存的内容 不是给人直接阅读的，而是提供给其它软件使用的 二进制文件不能使用 文件编辑软件 查看 文件基本操作操作文件的套路 在计算机 中要操作文件一共包含三个步骤：1.打开文件 2.读、写文件 读 将文件内容读入内容 写 将内存内容写入文件 3.关闭文件 操作文件的函数&#x2F;方法 序号 函数&#x2F;方法 说明 1 open 打开文件，并且返回文件操作对象 2 read 将文件内容读取到内存 3 write 将指定内容写入文件 4 close 关闭文件 open 函数负责打开文件，并且返回文件对象 read &#x2F;write &#x2F; close 三个方法都需要通过文件对象 来调用 read方法——读取文件 open 函数的第一个参数是要打开的文件名（文件名区分大小写） 如果文件存在，返回 文件操作对象 如果文件不存在，会抛出异常 read 方法可以一次性 读入 并 返回文件的所有内容 close 方法负责关闭文件 如果忘记关闭文件，会造成系统资源消耗，而且会影响到后续对文件的访问 注意：方法执行后，会把文件指针 移动到 文件的末尾 读取文件 示例： 123456789# 1.打开文件file = open(&quot;read.txt&quot;)# 2. 读取文件内容text = file.read()print(text)# 3.关闭文件file.close() 注： 在开发中，通常会先编写 打开 和 关闭 的代码，再编写中间针对文件的 读 &#x2F; 写 操作。 文件指针 文件指针 标记 从哪个位置开始读取数据 第一次打开 文件时，通常文件指针会指向文件的开始位置 当执行了 read 方法后，文件指针 会移动到 读取内容的末尾 默认情况下会移动到 文件末尾 读取文件 注意：如果执行了一次 read 方法，读取了所有内容，那么再次调用 read 方法，是不能读取到任何的内容，因为第一次读取之后，文件指针移动到了文件末尾，再次调用不会读取到任何的内容。 打开文件的方式 open 函数默认以 只读方式 打开文件，并且返回文件对象 语法如下： 1f = open(&quot;文件名&quot;, &quot;访问方式&quot;) 访问方式 说明 r 以只读方式打开文件。文件的指针将会放在文件的开头，这是默认模式。如果文件不存在，抛出异常 w 以只写方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件 a 以追加方式打开文件。如果该文件已存在，文件指针将会放在文件的末尾。如果文件不存在，创建新文件进行写入 r+ 以读写方式打开文件。文件的指针将会放在文件的开头。如果文件不存在，抛出异常 w+ 以读写方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件 a+ 以读写方式打开文件。如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入 示例： 以只写方式打开文件: 12345678# 1.打开文件file = open(&quot;read.txt&quot;, &quot;w&quot;) # 以只写方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件# 2. 写入文件file.write(&quot;vvcat&quot;)# 3.关闭文件file.close() 以追加方式打开文件: 12345678# 1.打开文件file = open(&quot;read.txt&quot;, &quot;a&quot;) # 以追加方式打开文件。如果该文件已存在，文件指针将会放在文件的末尾。如果文件不存在，创建新文件进行写入# 2. 写入文件file.write(&quot;vvcat&quot;)# 3.关闭文件file.close() 注： 频繁的移动文件指针，会影响文件的读写效率。 按行读取文件内容 read 方法默认会把文件的 所有内容一次性读取到内存 如果文件太大，对内存的占用会非常严重 readline 方法 readline 方法可以一次读取一行内容 方法执行后，会把文件指针移动到下一行，准备再次读取 示例： 1234567891011121314151617# 打开文件file = open(&quot;read.txt&quot;)while True: # 读取一行内容 text = file.readline() # 判断是否读到内容 if not text: break # 每读取一行的末尾已经有了一个 &#x27;&#x27; print(text, end=&quot;&quot;)# 关闭文件file.close() 按行读取 复制文件 小文件复制 打开一个已有文件，读取完整内容，并写入到另外一个文件 1234567891011# 1.打开文件file_read = open(&quot;read.txt&quot;)file_write = open(&quot;read[复件].txt&quot;, &quot;w&quot;)# 2. 读、写text = file_read.read() # 读取文件的内容file_write.write(text) # 把读取的内容写到新的文件中# 3.关闭文件file_read.close()file_write.close() 文件复制 大文件复制 打开一个已有文件，逐行读取内容，并顺序写入到另一个文件中 123456789101112131415161718# 1.打开文件file_read = open(&quot;read.txt&quot;)file_write = open(&quot;read[复件].txt&quot;, &quot;w&quot;)# 2. 读、写while True: # 读取一行内容 text = file_read.readline() # 判断是否读取到内容 if not text: break file_write.write(text)# 3.关闭文件file_read.close()file_write.close() 大文件复制** ** 文件&#x2F;目录的常用管理操作 在 Python 中，需要执行常规的 文件 &#x2F; 目录 管理操作：创建、重命名、删除、改变路径、查看目录内容… 需要导入 os 模块 文件操作 序号 方法名 说明 示例 1 rename 重命名文件 os.rename(源文件名, 目标文件名) 2 remove 删除文件 os.remove(文件名) 目录操作 序号 方法名 说明 示例 1 listdir 目录列表 os.listdir(目录名) 2 mkdir 创建目录 os.mkdir(目录名) 3 rmdir 删除目录 os.rmdir(目录名) 4 getcwd 获取当前目录 os.getcwd() 5 chdir 修改工作目录 os.chdir(目标目录) 6 path.isdir 判断是否是目录 os.path.isdir(文件路径) 注：文件或者目录操作都支持 相对路径 和 绝对路径 重命名文件 重命名 执行程序代码后： 运行后 删除文件： 删除文件 执行代码后： 运行后 目录列表 目录列表 查看目录列表 执行代码后： 运行后 判断是否是目录 判断是否是目录 判断是否是目录 执行代码后： 运行结果 创建目录 创建目录 执行代码后： 运行结果 删除目录 删除目录 执行代码后： 运行结果 获取当前目录 获取当前目录 执行代码后： 运行结果","tags":["Python"],"categories":["Language"]},{"title":"Python中re正则模块(详细版)","path":"/posts/440461c0.html","content":"正则表达式什么是正则表达式？ 正则表达式是对字符串（包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为“元字符”））操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。正则表达式是一种文本模式，该模式描述在搜索文本时要匹配的一个或多个字符串。 正则表达式可以干什么? 快速高效的查找与分析字符串 进行有规律查找比对字符串，也叫：模式匹配 具有查找、比对、匹配、替换、插入、添加、删除等能力。 字符串是编程时涉及到的最多的一种数据结构，对字符串进行操作的需求几乎无处不在。比如我们编写爬虫收集数据，首先都得到网页源码，但是我们要如何提取有效数据呢，这时候我们就需要使用正则表达式来进行匹配了 re模块正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。Python 自1.5版本起增加了re 模块，它提供 Perl 风格的正则表达式模式。re 模块使 Python 语言拥有全部的正则表达式功能。 由于Python的字符串本身也用\\转义，所以要特别注意： 123s = &#x27;ABC\\\\-001&#x27; # Python的字符串# 对应的正则表达式字符串变成：# &#x27;ABC\\-001&#x27; 因此建议使用Python的r前缀，就不用考虑转义的问题了： 123s = r&#x27;ABC\\-001&#x27; # Python的字符串# 对应的正则表达式字符串不变：# &#x27;ABC\\-001&#x27; re模块符号大全正则表达式模式模式字符串使用特殊的语法来表示一个正则表达式： 字母和数字表示他们自身。一个正则表达式模式中的字母和数字匹配同样的字符串。 多数字母和数字前加一个反斜杠时会拥有不同的含义。 标点符号只有被转义时才匹配自身，否则它们表示特殊的含义。 反斜杠本身需要使用反斜杠转义。 由于正则表达式通常都包含反斜杠，所以你最好使用原始字符串来表示它们。模式元素(如 r’\\t’，等价于 \\t )匹配相应的特殊字符。 下表列出了正则表达式模式语法中的特殊元素。如果你使用模式的同时提供了可选的标志参数，某些模式元素的含义会改变。 模式 描述 ^ 匹配字符串的开头 $ 匹配字符串的末尾。 . 匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。 […] 用来表示一组字符,单独列出：[amk] 匹配 ‘a’，’m’或’k’ [^…] 不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。 re* 匹配0个或多个的表达式。 re+ 匹配1个或多个的表达式。 re? 匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式 re{ n} 匹配n个前面表达式。例如，”o{2}”不能匹配”Bob”中的”o”，但是能匹配”food”中的两个o。 re{ n,} 精确匹配n个前面表达式。例如，”o{2,}”不能匹配”Bob”中的”o”，但能匹配”foooood”中的所有o。”o{1,}”等价于”o+”。”o{0,}”则等价于”o*”。 re{ n, m} 匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式 a|b 匹配a或b (re) 匹配括号内的表达式，也表示一个组 (?imx) 正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。 (?-imx) 正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。 (?: re) 类似 (…), 但是不表示一个组 (?imx: re) 在括号中使用i, m, 或 x 可选标志 (?-imx: re) 在括号中不使用i, m, 或 x 可选标志 (?#…) 注释. (?&#x3D; re) 前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。 (?! re) 前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功。 (?&gt; re) 匹配的独立模式，省去回溯。 \\w 匹配数字字母下划线 \\W 匹配非数字字母下划线 \\s 匹配任意空白字符，等价于 [\\t \\r\\f]。 \\S 匹配任意非空字符 \\d 匹配任意数字，等价于 [0-9]。 \\D 匹配任意非数字 \\A 匹配字符串开始 \\Z 匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。 \\z 匹配字符串结束 \\G 匹配最后匹配完成的位置。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \\B 匹配非单词边界。’er\\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 , \\t, 等。 匹配一个换行符。匹配一个制表符, 等 \\1…\\9 匹配第n个分组的内容。 \\10 匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。 注意：表中re指的是表达式而不是字面的re这两个字母 正则表达式修饰符 - 可选标志正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位 OR(|) 它们来指定。如 re.I | re.M 被设置成 I 和 M 标志： 修饰符 描述 re.I 使匹配对大小写不敏感 re.L 做本地化识别（locale-aware）匹配 re.M 多行匹配，影响 ^ 和 $ re.S 使 . 匹配包括换行在内的所有字符 re.U 根据Unicode字符集解析字符。这个标志影响 \\w, \\W, \\b, \\B. re.X 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。 正则表达式对象re.RegexObject re.compile() 返回 RegexObject 对象。 re.MatchObject group() 返回被 RE 匹配的字符串。 start() 返回匹配开始的位置 end() 返回匹配结束的位置 span() 返回一个元组包含匹配 (开始,结束) 的位置 准备知识我们先来看看廖雪峰老师讲解的正则表达式： 正则表达式是用字符串表示的，所以，我们要首先了解如何用字符来描述字符。 在正则表达式中，如果直接给出字符，就是精确匹配。 使用特殊符号表示字符：用\\d可以匹配一个数字，\\w可以匹配一个字母或数字，例如： &#39;00\\d&#39;可以匹配&#39;007&#39;，但无法匹配&#39;00A&#39;； &#39;\\d\\d\\d&#39;可以匹配&#39;010&#39;； &#39;\\w\\w\\d&#39;可以匹配&#39;py3&#39;。 &#39;.&#39;可以匹配任意字符，所以： &#39;py.&#39;可以匹配&#39;pyc&#39;、&#39;py3&#39;、&#39;py!&#39;等等。 要匹配变长的字符，在正则表达式中，用*表示任意个字符（包括0个），用+表示至少一个字符，用?表示0个或1个字符，用&#123;n&#125;表示n个字符，用&#123;n,m&#125;表示n-m个字符。 来看一个复杂的例子：\\d&#123;3&#125;\\s+\\d&#123;3,8&#125;。 我们来从左到右解读一下： \\d&#123;3&#125;表示匹配3个数字，例如&#39;010&#39;； \\s可以匹配一个空格（也包括Tab等空白符），所以\\s+表示至少有一个空格，例如匹配&#39; &#39;，&#39; &#39;等； \\d&#123;3,8&#125;表示3-8个数字，例如&#39;1234567&#39;。 综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。 如果要匹配&#39;010-12345&#39;这样的号码呢？由于&#39;-&#39;是特殊字符，在正则表达式中，要用&#39;\\&#39;转义，所以，上面的正则是\\d&#123;3&#125;\\-\\d&#123;3,8&#125;。 但是，仍然无法匹配&#39;010 - 12345&#39;，因为带有空格。所以我们需要更复杂的匹配方式。 进阶要做更精确地匹配，可以用[]表示范围，比如： [0-9a-zA-Z\\_]可以匹配一个数字、字母或者下划线； [0-9a-zA-Z\\_]+可以匹配至少由一个数字、字母或者下划线组成的字符串，比如&#39;a100&#39;，&#39;0_Z&#39;，&#39;Py3000&#39;等等； [a-zA-Z\\_][0-9a-zA-Z\\_]*可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串，也就是Python合法的变量； [a-zA-Z\\_][0-9a-zA-Z\\_]&#123;0, 19&#125;更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。 A|B可以匹配A或B，所以(P|p)ython可以匹配&#39;Python&#39;或者&#39;python&#39;。 ^表示行的开头，^\\d表示必须以数字开头。 $表示行的结束，\\d$表示必须以数字结束。 py也可以匹配&#39;python&#39;，但是加上^py$就变成了整行匹配，就只能匹配&#39;py&#39;了。 re模常用方法re.match()re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。 函数语法： 1re.match(pattern, string, flags=0) 函数参数说明： 参数 描述 pattern 匹配的正则表达式 string 要匹配的字符串。 flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见上方可选标志表格 匹配成功re.match方法返回一个匹配的对象，否则返回None。 实例： 1234import reprint(re.match(&#x27;www&#x27;,&#x27;www.baidu.com&#x27;).span())print(re.match(&#x27;baidu&#x27;,&#x27;www.baidu.com&#x27;)) 输出： 12(0, 3)None 第一个匹配成功，第二个则失败 re.search()re.search 扫描整个字符串并返回第一个成功的匹配。 函数语法： 1re.search(pattern, string, flags=0) 函数参数说明： 参数 描述 pattern 匹配的正则表达式 string 要匹配的字符串。 flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见上方可选标志表格 匹配成功re.search方法返回一个匹配的对象，否则返回None。 实例： 1234import reprint(re.search(&#x27;www&#x27;,&#x27;www.baidu.com&#x27;))print(re.search(&#x27;baidu&#x27;,&#x27;www.baidu.com&#x27;)) 输出： 12&lt;_sre.SRE_Match object; span=(0, 3), match=&#x27;www&#x27;&gt;&lt;_sre.SRE_Match object; span=(4, 9), match=&#x27;baidu&#x27;&gt; compile 函数compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，re函数使用。 提前编译可减少多次正则匹配的运行时间 语法格式为： 1re.compile(pattern[, flags]) 参数： pattern : 一个字符串形式的正则表达式 flags 可选，表示匹配模式 re.findall()在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。 注意： match 和 search 是匹配一次 findall 匹配所有。 用法1直接使用的语法格式为： 1re.findall(pattern, string, flags) 参数： pattern 正则表达式 string 待匹配的字符串 flags re的一些flag，可不写 实例： 1print(re.findall(pattern=&#x27;\\d+&#x27;, string=&#x27;abafa 124ddwa56&#x27;)) 输出： 1[&#x27;124&#x27;, &#x27;56&#x27;] 用法2compile后使用findall的语法格式为： 1re.findall(string, pos, endpos) 参数： string 待匹配的字符串。 pos 可选参数，指定字符串的起始位置，默认为 0。 endpos 可选参数，指定字符串的结束位置，默认为字符串的长度。 实例： 123456import remat=re.compile(r&#x27;\\d+&#x27;)#匹配数字print(mat.findall(&#x27;abafa 124ddwa56&#x27;))print(mat.findall(&#x27;abafa 124ddwa56&#x27;,0,7))#匹配从0位开始，到7位结束 输出： 12[&#x27;124&#x27;, &#x27;56&#x27;][&#x27;1&#x27;] re.finditer和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。 1re.finditer(pattern, string, flags=0) 实例： 12345import reit = re.finditer(r&quot;\\d+&quot;, &quot;12a32bc43jf3&quot;)for match in it: print(match.group()) 输出： 12341232433 re.splitsplit 方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下： 1re.split(pattern, string[, maxsplit=0, flags=0]) 参数： 参数 描述 pattern 匹配的正则表达式 string 要匹配的字符串。 maxsplit 分隔次数，maxsplit&#x3D;1 分隔一次，默认为 0，不限制次数。 flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见上方可选标志表格 实例： 用正则表达式切分字符串比用固定的字符更灵活，请看正常的切分代码： 12&gt;&gt;&gt; &#x27;a b c&#x27;.split(&#x27; &#x27;)[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;c&#x27;] 发现无法识别连续的空格，用正则表达式试试： 12&gt;&gt;&gt; re.split(r&#x27;\\s+&#x27;, &#x27;a b c&#x27;)[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;] 无论多少个空格都可以正常分割。加入,试试： 12&gt;&gt;&gt; re.split(r&#x27;[\\s\\,]+&#x27;, &#x27;a,b, c d&#x27;)[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;] 再加入;试试： 12&gt;&gt;&gt; re.split(r&#x27;[\\s\\,\\;]+&#x27;, &#x27;a,b;; c d&#x27;)[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;] groups()我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。 匹配对象方法 描述 group(num&#x3D;0) 匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。 groups() 返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。 实例: 1234567import rem = re.match(r&#x27;^(\\d&#123;3&#125;)-(\\d&#123;3,8&#125;)$&#x27;, &#x27;010-12345&#x27;)print(m.group(0))print(m.group(1))print(m.group(2))print(m.groups()) 输出： 1234010-1234501012345(&#x27;010&#x27;, &#x27;12345&#x27;) re.subPython 的re模块提供了re.sub用于替换字符串中的匹配项。 语法： 1re.sub(pattern, repl, string, count=0, flags=0) 参数： pattern : 正则中的模式字符串。 repl : 替换的字符串，也可为一个函数。 string : 要被查找替换的原始字符串。 count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。 flags : 编译时用的匹配模式，数字形式。 前三个为必选参数，后两个为可选参数。 实例： 1234567891011import rephone = &quot;2004-959-559 # 这是一个电话号码&quot;# 删除注释num = re.sub(r&#x27;#.*$&#x27;, &quot;&quot;, phone)print(&quot;电话号码 : &quot;, num)# 移除非数字的内容num = re.sub(r&#x27;\\D&#x27;, &quot;&quot;, phone)print(&quot;电话号码 : &quot;, num) repl 参数可以是一个函数以下实例中将字符串中的匹配的数字乘于 2： 实例： 123456789import re # 将匹配的数字乘于 2def double(matched): value = int(matched.group(&#x27;value&#x27;)) return str(value * 2) s = &#x27;A23G4HFD567&#x27;print(re.sub(&#x27;(?P&lt;value&gt;\\d+)&#x27;, double, s)) 输出： 1A46G8HFD1134 贪婪匹配需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0： 12&gt;&gt;&gt; re.match(r&#x27;^(\\d+)(0*)$&#x27;, &#x27;102300&#x27;).groups()(&#x27;102300&#x27;, &#x27;&#x27;) 由于\\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。 必须让\\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\\d+采用非贪婪匹配： 12&gt;&gt;&gt; re.match(r&#x27;^(\\d+?)(0*)$&#x27;, &#x27;102300&#x27;).groups()(&#x27;1023&#x27;, &#x27;00&#x27;) 正则表达式实例字符匹配 实例 描述 python 匹配 “python”. 字符类 实例 描述 [Pp]ython 匹配 “Python” 或 “python” rub[ye] 匹配 “ruby” 或 “rube” [aeiou] 匹配中括号内的任意一个字母 [0-9] 匹配任何数字。类似于 [0123456789] [a-z] 匹配任何小写字母 [A-Z] 匹配任何大写字母 [a-zA-Z0-9] 匹配任何字母及数字 [^aeiou] 除了aeiou字母以外的所有字符 [^0-9] 匹配除了数字外的字符 特殊字符类 实例 描述 . 匹配除 “ ” 之外的任何单个字符。要匹配包括 ‘ ’ 在内的任何字符，请使用象 ‘[. ]’ 的模式。 \\d 匹配一个数字字符。等价于 [0-9]。 \\D 匹配一个非数字字符。等价于 [^0-9]。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f \\r\\t\\v]。 \\S 匹配任何非空白字符。等价于 [^ \\f \\r\\t\\v]。 \\w 匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。 \\W 匹配任何非单词字符。等价于 ‘[^A-Za-z0-9_]’。","tags":["Module","Python","RegEx"],"categories":["Language"]},{"title":"Python中re正则模块","path":"/posts/e7c9958.html","content":"正则表达式的概述1. 正则表达式的介绍 在实际开发过程中经常会有查找符合某些复杂规则的字符串的需要，比如:邮箱、图片地址、手机号码等，这时候想匹配或者查找符合某些规则的字符串就可以使用正则表达式了。 2. 正则表达式概念 正则表达式就是记录文本规则的代码 3. 正则表达式的样子 0\\d{2}-\\d{8} 这个就是一个正则表达式，表达的意思是匹配的是座机号码 4. 正则表达式的特点 正则表达式的语法很令人头疼，可读性差 正则表达式通用行很强，能够适用于很多编程语言 re模块介绍1. re模块的介绍 在Python中需要通过正则表达式对字符串进行匹配的时候，可以使用一个 re 模块 12345678# 导入re模块import re# 使用match方法进行匹配操作result = re.match(正则表达式,要匹配的字符串)# 如果上一步匹配到数据的话，可以使用group方法来提取数据result.group() 2. re模块的使用 1234567import re# 使用match方法进行匹配操作result = re.match(&quot;cvki&quot;,&quot;abc.cvki.def&quot;)# 获取匹配结果info = result.group()print(info) 运行结果: 1cvki 匹配单个字符1. 匹配单个字符 在上一小节中，了解到通过re模块能够完成使用正则表达式来匹配字符串 本小节，将要讲解正则表达式的单字符匹配 代码 功能 . 匹配任意1个字符（除了 ） [ ] 匹配[ ]中列举的字符 \\d 匹配数字，即0-9 \\D 匹配非数字，即不是数字 \\s 匹配空白，即 空格，tab键 \\S 匹配非空白 \\w 匹配非特殊字符，即a-z、A-Z、0-9、_、汉字 \\W 匹配特殊字符，即非字母、非数字、非汉字 示例1：. 12345678910import reret = re.match(&quot;.&quot;,&quot;M&quot;)print(ret.group())ret = re.match(&quot;t.o&quot;,&quot;too&quot;)print(ret.group())ret = re.match(&quot;t.o&quot;,&quot;two&quot;)print(ret.group()) 运行结果： 123Mtootwo 示例2：[] 1234567891011121314151617181920212223242526272829303132import re# 如果hello的首字符小写，那么正则表达式需要小写的hret = re.match(&quot;h&quot;,&quot;hello Python&quot;) print(ret.group())# 如果hello的首字符大写，那么正则表达式需要大写的Hret = re.match(&quot;H&quot;,&quot;Hello Python&quot;) print(ret.group())# 大小写h都可以的情况ret = re.match(&quot;[hH]&quot;,&quot;hello Python&quot;)print(ret.group())ret = re.match(&quot;[hH]&quot;,&quot;Hello Python&quot;)print(ret.group())ret = re.match(&quot;[hH]ello Python&quot;,&quot;Hello Python&quot;)print(ret.group())# 匹配0到9第一种写法ret = re.match(&quot;[0123456789]Hello Python&quot;,&quot;7Hello Python&quot;)print(ret.group())# 匹配0到9第二种写法ret = re.match(&quot;[0-9]Hello Python&quot;,&quot;7Hello Python&quot;)print(ret.group())ret = re.match(&quot;[0-35-9]Hello Python&quot;,&quot;7Hello Python&quot;)print(ret.group())# 下面这个正则不能够匹配到数字4，因此ret为Noneret = re.match(&quot;[0-35-9]Hello Python&quot;,&quot;4Hello Python&quot;)# print(ret.group()) 运行结果： 12345678hHhHHello Python7Hello Python7Hello Python7Hello Python 示例3：\\d 123456789101112131415161718192021import re# 普通的匹配方式ret = re.match(&quot;嫦娥1号&quot;,&quot;嫦娥1号发射成功&quot;) print(ret.group())ret = re.match(&quot;嫦娥2号&quot;,&quot;嫦娥2号发射成功&quot;) print(ret.group())ret = re.match(&quot;嫦娥3号&quot;,&quot;嫦娥3号发射成功&quot;) print(ret.group())# 使用\\d进行匹配ret = re.match(&quot;嫦娥\\d号&quot;,&quot;嫦娥1号发射成功&quot;) print(ret.group())ret = re.match(&quot;嫦娥\\d号&quot;,&quot;嫦娥2号发射成功&quot;) print(ret.group())ret = re.match(&quot;嫦娥\\d号&quot;,&quot;嫦娥3号发射成功&quot;) print(ret.group()) 运行结果： 123456嫦娥1号嫦娥2号嫦娥3号嫦娥1号嫦娥2号嫦娥3号 示例4：\\D 12345678import rematch_obj = re.match(&quot;\\D&quot;, &quot;f&quot;)if match_obj: # 获取匹配结果 print(match_obj.group())else: print(&quot;匹配失败&quot;) 运行结果: 1f 示例5：\\s 1234567891011121314151617import re# 空格属于空白字符match_obj = re.match(&quot;hello\\sworld&quot;, &quot;hello world&quot;)if match_obj: result = match_obj.group() print(result)else: print(&quot;匹配失败&quot;)# \\t 属于空白字符match_obj = re.match(&quot;hello\\sworld&quot;, &quot;hello\\tworld&quot;)if match_obj: result = match_obj.group() print(result)else: print(&quot;匹配失败&quot;) 运行结果: 12hello worldhello world 示例6：\\S 123456789101112131415import rematch_obj = re.match(&quot;hello\\Sworld&quot;, &quot;hello&amp;world&quot;)if match_obj:result = match_obj.group()print(result)else:print(&quot;匹配失败&quot;)match_obj = re.match(&quot;hello\\Sworld&quot;, &quot;hello$world&quot;)if match_obj:result = match_obj.group()print(result)else:print(&quot;匹配失败&quot;) 运行结果: 1hello&amp;world 示例7：\\w 123456789import re# 匹配非特殊字符中的一位match_obj = re.match(&quot;\\w&quot;, &quot;A&quot;)if match_obj: # 获取匹配结果 print(match_obj.group())else: print(&quot;匹配失败&quot;) 执行结果: 1A 示例8：\\W 1234567# 匹配特殊字符中的一位match_obj = re.match(&quot;\\W&quot;, &quot;&amp;&quot;)if match_obj: # 获取匹配结果 print(match_obj.group())else: print(&quot;匹配失败&quot;) 执行结果: 1&amp; 匹配多个字符1. 匹配多个字符 代码 功能 * 匹配前一个字符出现0次或者无限次，即可有可无 + 匹配前一个字符出现1次或者无限次，即至少有1次 ? 匹配前一个字符出现1次或者0次，即要么有1次，要么没有 {m} 匹配前一个字符出现m次 {m,n} 匹配前一个字符出现从m到n次 示例1：* 需求：匹配出一个字符串第一个字母为大小字符，后面都是小写字母并且这些小写字母可 有可无 12345678910import reret = re.match(&quot;[A-Z][a-z]*&quot;,&quot;M&quot;)print(ret.group())ret = re.match(&quot;[A-Z][a-z]*&quot;,&quot;MnnM&quot;)print(ret.group())ret = re.match(&quot;[A-Z][a-z]*&quot;,&quot;Aabcdef&quot;)print(ret.group()) 运行结果： 123MMnnAabcdef 示例2：+ 需求：匹配一个字符串，第一个字符是t,最后一个字符串是o,中间至少有一个字符 1234567import rematch_obj = re.match(&quot;t.+o&quot;, &quot;two&quot;)if match_obj: print(match_obj.group())else: print(&quot;匹配失败&quot;) 运行结果： 1two 示例3：? 需求：匹配出这样的数据，但是https 这个s可能有，也可能是http 这个s没有 1234567import rematch_obj = re.match(&quot;https?&quot;, &quot;http&quot;)if match_obj: print(match_obj.group())else: print(&quot;匹配失败&quot;) 运行结果： 1https 示例4：{m}、{m,n} 需求：匹配出，8到20位的密码，可以是大小写英文字母、数字、下划线 1234567import reret = re.match(&quot;[a-zA-Z0-9_]&#123;6&#125;&quot;,&quot;12a3g45678&quot;)print(ret.group())ret = re.match(&quot;[a-zA-Z0-9_]&#123;8,20&#125;&quot;,&quot;1ad12f23s34455ff66&quot;)print(ret.group()) 运行结果： 1212a3g41ad12f23s34455ff66 匹配开头和结尾1. 匹配开头和结尾 代码 功能 ^ 匹配字符串开头 $ 匹配字符串结尾 示例1：^ 需求：匹配以数字开头的数据 123456789import re# 匹配以数字开头的数据match_obj = re.match(&quot;^\\d.*&quot;, &quot;3hello&quot;)if match_obj: # 获取匹配结果 print(match_obj.group())else: print(&quot;匹配失败&quot;) 运行结果: 13hello 示例2：$ 需求: 匹配以数字结尾的数据 12345678import re# 匹配以数字结尾的数据match_obj = re.match(&quot;.*\\d$&quot;, &quot;hello5&quot;)if match_obj: # 获取匹配结果 print(match_obj.group())else: print(&quot;匹配失败&quot;) 运行结果： 1hello5 示例3：^ 和 $ 需求: 匹配以数字开头中间内容不管以数字结尾 123456match_obj = re.match(&quot;^\\d.*\\d$&quot;, &quot;4hello4&quot;)if match_obj: # 获取匹配结果 print(match_obj.group())else: print(&quot;匹配失败&quot;) 运行结果: 14hello4 2.除了指定字符以外都匹配 需求: 第一个字符除了aeiou的字符都匹配 12345678import rematch_obj = re.match(&quot;[^aeiou]&quot;, &quot;h&quot;)if match_obj: # 获取匹配结果 print(match_obj.group())else: print(&quot;匹配失败&quot;) 执行结果 1h 匹配分组1. 匹配分组相关正则表达式 代码 功能 (ab) 将括号中字符作为一个分组 um 引用分组num匹配到的字符串 (?P) 分组起别名 (?P&#x3D;name) 引用别名为name分组匹配到的字符串 示例1：| 需求：在列表中[“apple”, “banana”, “orange”, “pear”]，匹配apple和pear 12345678910111213import re# 水果列表fruit_list = [&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;, &quot;pear&quot;]# 遍历数据for value in fruit_list: # | 匹配左右任意一个表达式 match_obj = re.match(&quot;apple|pear&quot;, value) if match_obj: print(&quot;%s是我想要的&quot; % match_obj.group()) else: print(&quot;%s不是我要的&quot; % value) 执行结果: 1234apple是我想要的banana不是我要的orange不是我要的pear是我想要的 示例2：( ) 需求：匹配出163、126、qq等邮箱 123456789import rematch_obj = re.match(&quot;[a-zA-Z0-9_]&#123;4,20&#125;@(163|126|qq|sina|yahoo)\\.com&quot;, &quot;hello@163.com&quot;)if match_obj: print(match_obj.group()) # 获取分组数据 print(match_obj.group(1))else: print(&quot;匹配失败&quot;) 执行结果: 12hello@163.com163 需求: 匹配qq:10567这样的数据，提取出来qq文字和qq号码 123456789101112import rematch_obj = re.match(&quot;(qq):([1-9]\\d&#123;4,10&#125;)&quot;, &quot;qq:10567&quot;)if match_obj: print(match_obj.group()) # 分组:默认是1一个分组，多个分组从左到右依次加1 print(match_obj.group(1)) # 提取第二个分组数据 print(match_obj.group(2))else: print(&quot;匹配失败&quot;) 执行结果: 12qq10567 示例3： um 需求：匹配出hh 12345678910111213match_obj = re.match(&quot;&lt;[a-zA-Z1-6]+&gt;.*&lt;/[a-zA-Z1-6]+&gt;&quot;, &quot;&lt;html&gt;hh&lt;/div&gt;&quot;)if match_obj: print(match_obj.group())else: print(&quot;匹配失败&quot;)match_obj = re.match(&quot;&lt;([a-zA-Z1-6]+)&gt;.*&lt;/\\\\1&gt;&quot;, &quot;&lt;html&gt;hh&lt;/html&gt;&quot;)if match_obj: print(match_obj.group())else: print(&quot;匹配失败&quot;) 运行结果： 12&lt;html&gt;hh&lt;/div&gt;&lt;html&gt;hh&lt;/html&gt; 需求：匹配出http://www.itcast.cn 123456match_obj = re.match(&quot;&lt;([a-zA-Z1-6]+)&gt;&lt;([a-zA-Z1-6]+)&gt;.*&lt;/\\\\2&gt;&lt;/\\\\1&gt;&quot;, &quot;www.itcast.cn&quot;)if match_obj: print(match_obj.group())else: print(&quot;匹配失败&quot;) 运行结果： 1www.itcast.cn 示例4：(?P) (?P&#x3D;name) 需求：匹配出http://www.itcast.cn 123456match_obj = re.match(&quot;&lt;(?P&lt;name1&gt;[a-zA-Z1-6]+)&gt;&lt;(?P&lt;name2&gt;[a-zA-Z1-6]+)&gt;.*&lt;/(?P=name2)&gt;&lt;/(?P=name1)&gt;&quot;, &quot;www.itcast.cn&quot;)if match_obj: print(match_obj.group())else: print(&quot;匹配失败&quot;) 运行结果： 1www.itcast.cn 小结 正则表达式是匹配符合某些规则的字符串数据 re.match() 根据正则表达式从头开始匹配字符串数据 匹配单个字符 . 表示匹配任意1个字符（除了 ）[ ] 表示匹配[ ]中列举的1个字符\\d 表示匹配一个数字，即0-9\\D 表示匹配一个非数字，即不是数字\\s 表示匹配一个空白字符，即 空格，tab键\\S | 匹配一个非空白字符\\w | 匹配一个非特殊字符，即a-z、A-Z、0-9、_、汉字\\W | 匹配一个特殊字符，即非字母、非数字、非汉字 匹配多个字符 *表示匹配前一个字符出现0次或者无限次，即可有可无+表示匹配前一个字符出现1次或者无限次，即至少有1次?表示匹配前一个字符出现1次或者0次，即要么有1次，要么没有{m}表示匹配前一个字符出现m次{m,n}表示匹配前一个字符出现从m到n次 匹配开头和结尾 1.匹配出163的邮箱地址，且@符号之前有4到20位，例如&#104;&#x65;&#108;&#x6c;&#111;&#x40;&#x31;&#54;&#51;&#46;&#99;&#x6f;&#x6d;2.匹配出11位手机号码3.匹配出微博中的话题, 比如: #幸福是奋斗出来的# 匹配分组 | 表示匹配左右任意一个表达式(ab) 表示将括号中字符作为一个分组 um 表示引用分组num匹配到的字符串(?P) 表示分组起别名(?P&#x3D;name) 表示引用别名为name分组匹配到的字符串(分组数据)：分组数是从左到右的方式进行分配的，最左边的是第一个分组，依次类推","tags":["Module","Python","RegEx"],"categories":["Language"]},{"title":"NPM令实用使用技巧总结","path":"/posts/4441436c.html","content":"创建项目1234// 创建项目npm init// 直接使用默认值创建项目npm init -y 镜像源相关1234561.查看镜像源npm get registry2.切换官方源npm config set registry http://www.npmjs.org3.切换淘宝源npm config set registry http://registry.npm.taobao.org 安装模块使用npm install 模块名来安装，你可以使用其简写npm i 一次性安装多个模块无需为你要安装的每个模块都输入一遍npm i指令，像这样 123npm i gulp-pugnpm i gulp-debugnpm i gulp-sass 你只需要输入一行命令即可一次性批量安装模块 1npm i gulp-pug gulp-debug gulp-sass 如果安装的所有模块的前缀是相同的，则可以这样安装，无需输入完整模块名 1npm i gulp&#123;-debug,-sass,-pug&#125; 使用一些安装标志的快捷方式如果你想安装一些包到生产环境依赖下面，你通常是这样安装： 123npm i gulp --save-prod// 或者npm i gulp -P 同理，开发环境下的依赖安装，你可以用-D代替–save-dev 123npm i gulp --save-dev// 或者npm i gulp -D 当你不带任何安装标志时，npm 默认将模块作为依赖项目添加到package.json文件中。如果你想避免这样，你可以使用no-save,这样安装： npm i vue --no-save npm install –save 和npm install –save-dev的区别以npm安装webpack为例： 1npm install echarts 会把echarts包安装到node_modules目录中 不会修改package.json 之后运行npm install命令时，不会自动安装echarts npm install echarts –save 会把echarts包安装到node_modules目录中 会在package.json的dependencies属性下添加echarts 之后运行npm install命令时，会自动安装echarts到node_modules目录中 之后运行npm install –production或者注明NODE_ENV变量值为production时，会自动安装echarts到node_modules目录中 npm install echarts –save-dev 会把echarts 包安装到node_modules目录中 会在package.json的devDependencies属性下添加echarts 之后运行npm install命令时，会自动安装echarts 到node_modules目录中 之后运行npm install –production或者注明NODE_ENV变量值为production时，不会自动安装echarts 到node_modules目录中 总结devDependencies节点下的模块是我们在开发时需要用的，比如项目中使用的 gulp ，压缩css、js的模块。这些模块在我们的项目部署后是不需要的，所以我们可以使用 -save-dev 的形式安装。 像 echarts 这些模块是项目运行必备的，应该安装在 dependencies 节点下，所以我们应该使用 --save 的形式安装。 获取安装包信息使用npm view xxx或npm v xxx可以查看包信息，例如： 1npm v vue 安装指定版本安装包如果你想安装一个不是最新版本的安装包，你可以指定某个版本来安装，如： 1npm i vue@2.5.15 鉴于记住标签比记住版本数字容易多了，你可以使用用npm v命令来查到的版本信息列表里面的dist-tag来安装,比如 1npm i vue@beta 升级依赖包12345678// 更新全局包：npm update &lt;name&gt; -g// 更新生产环境依赖包：npm update &lt;name&gt; --save// 更新开发环境依赖包：npm update &lt;name&gt; --save-dev 卸载包如果你不想转到package.json文件并手动删除依赖包，则可以用以下方法删除： 1npm uninstall vue 这个命令会删除node_modules文件夹及package.json中对应的包。当然，你也可以用rm,un或者r来达到相同的效果: 1npm rm vue 如果由于某些原因，你只想从node_modules文件夹中删除安装包，但是想在package.json中保留其依赖项，那么你可以使用no-save标志，如： 1npm rm vue --no-save 依赖枚举如果你想看一下你的项目依赖了哪些安装包，你可以这样看： 1npm ls 这个命令会将你项目的依赖列举出来，并且各个安装包的依赖也会显示出来。如果你只想看本项目的依赖，你可以这样： 1npm ls --depth=0 这样打印出来的结果就是本项目的依赖，像这样： 123├── jquery@3.3.1├── vue@2.5.17└── yarn@1.12.3 当然，你也可以加上g来看看你全局安装的依赖包，如： 1npm ls -g -depth 0 过期依赖枚举大多数时候，你需要保持本地依赖的更新，你可以在项目目录下先查看一下安装包有没有版本更新，如： npm outdate 这个命令将会列出所有你可能有更新的过时的安装包列表，如图：- 执行测试你可以使用npm run tests来执行测试用例，但是你可以更方便地用npm test或者npm t来执行。 显示可用脚本我们可以通过打开package.json文件来查看有哪些可执行的脚本，但是我们还可以这样查看： 1npm run 如果在package.json中有如下配置： 1234&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;jest&quot;, &quot;build&quot;: &quot;gulp build&quot;&#125; 那么执行这个命令之后，会显示以下信息： 123456Lifecycle scripts included in npm: test jestavailable via `npm run-script`: build gulp-build 列出所有NPM环境的可用变量你可以使用这个命令来列出所有NPM环境的可用变量： 1npm run env | grep npm_ 执行后，将会打印出这样的信息： 1234npm_config_fetch_retry_maxtimeout=60000npm_config_tag_version_prefix=vnpm_config_strict_ssl=truenpm_config_sso_type=oauth 这样变量的用处就是，可以在脚本中使用它们，还可以创建自己的变量。 创建自己的NPM可用变量你可以在package.json中添加新的 key 来创建自己的npm变量，可以是任何 key ，我更喜欢将所有的npm变量都放在一个config中，这样看起来比较清晰： 123&quot;config&quot;: &#123; &quot;build_folder&quot;:&quot;./dist&quot;&#125; 你添加了之后，重新执行npm run env | grep npm_，就能看到以下信息： 12345npm_package_config_build_folder=./distnpm_config_fetch_retry_maxtimeout=60000npm_config_tag_version_prefix=vnpm_config_strict_ssl=truenpm_config_sso_type=oauth 默认情况下，npm会重命名你的变量，给其加上前缀npm_package，并将其结构保留在package.json文件中，即变为config_build_folder。 在npm脚本中使用npm变量你可以看到可用变量的完整列表，如果你想使用这些变量中的任何值，就可以在package.json中使用了，如： 123&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;gulp build --dist $npm_package_config_build_folder&quot;&#125; 当你执行npm run build的时候，实际执行的是这样： 1gulp build --dist ./dist","tags":["NodeJS"],"categories":["Language"]},{"title":"国内外域名注册商推荐","path":"/posts/3ed61bf5.html","content":"国外域名注册12# namesilo：便宜到没朋友https://www.namesilo.com/ 12# godaddy：狗爹，一家存活很久的域名大厂，就是有点贵https://www.godaddy.com/ 12# amazon：亚马逊不用过多介绍了吧https://aws.amazon.com/ 12# 他家的我没有用过，朋友给我推荐过，价格稍贵https://www.gname.com/ 国内域名注册12# 腾讯云，你可能没用过，但是你肯定听过腾讯！https://dnspod.cloud.tencent.com/ 123# 华为云，被某类人群水上天的一家公司（博主有幸用过他家服务）# 新用户.com.xyz域名只要1元，但是续费简直不要太贵https://www.huaweicloud.com/product/domain.html 12# 新网，也算国内云计算的老大哥了，服务也很靠谱https://www.xinnet.com/domain/domain.html 12# 爱名网，主做二手域名，有些高词条域名很给力，快速起站必备https://www.22.cn/","tags":["Domain"],"categories":["lnternet"]},{"title":"Docker是啥","path":"/posts/2c6bb2ba.html","content":"Docker是啥?什么是DockerDocker 是一个开源的应用容器引擎，简单的来说，它就是一个箱子，把一件件物品归纳在里面，运输时便不用一件件搬了，直接搬箱子就行了，简称“一次封装，到处运行”官网介绍为”将软件打包成标准化单元以进行开发、交付和部署” Docker的官网:docker.com Docker有什么特点1.更快速的交付和部署Docker在整个开发周期都可以完美的辅助你实现快速交付。Docker允许开发者在装有应用和服务本地容器做开发。可以直接集成到可持续开发流程中。例如：开发者可以使用一个标准的镜像来构建一套开发容器，开发完成之后，运维人员可以直接使用这个容器来部署代码。 Docker 可以快速创建容器，快速迭代应用程序，并让整个过程全程可见，使团队中的其他成员更容易理解应用程序是如何创建和工作的。 Docker 容器很轻很快！容器的启动时间是秒级的，大量地节约开发、测试、部署的时间。 2.高效的部署和扩容Docker 容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑、服务器等。 这种兼容性可以让用户把一个应用程序从一个平台直接迁移到另外一个。Docker的兼容性和轻量特性可以很轻松的实现负载的动态管理。你可以快速扩容或方便的下线的你的应用和服务，这种速度趋近实时。 3.更高的资源利用率Docker 对系统资源的利用率很高，一台主机上可以同时运行数千个 Docker 容器。容器除了运行其中应用外，基本不消耗额外的系统资源，使得应用的性能很高，同时系统的开销尽量小。传统虚拟机方式运行 10 个不同的应用就要起 10 个虚拟机，而Docker 只需要启动 10 个隔离的应用即可。 4.更简单的管理使用 Docker，只需要小小的修改，就可以替代以往大量的更新工作。所有的修改都以增量的方式被分发和更新，从而实现自动化并且高效的管理。 Docker的好处Docker的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现“这段代码在我机器上没问题啊”这类问题；——一致的运行环境 可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。——更快速的启动时间 避免公用的服务器，资源会容易受到其他用户的影响。——隔离性 善于处理集中爆发的服务器使用压力；——弹性伸缩，快速扩展 可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。——迁移方便 使用Docker可以通过定制应用镜像来实现持续集成、持续交付、部署。——持续交付和部署 安装Docker介绍完docker，肯定就要安装docker了 准备1.一台服务器 2.一双手 3.shell工具 4.环境 Debian系统 配置安装环境注:这里只介绍Debian的安装方法，其他系统也都大同小异，可以去官方文档查看(https://docs.docker.com/) 1.安装常用软件 12apt install wget curl sudo vim git更新:apt update -y 2.配置docker存储库 12sudo apt-get updatesudo apt-get install \\ca-certificates \\curl \\gnupg \\lsb-release image-20220806110724001 3.添加 Docker 的官方 GPG 密钥 12sudo mkdir -p /etc/apt/keyringscurl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg 4.使用以下命令设置存储库 1echo \\&quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian \\$(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null 安装Docker引擎1.更新apt包索引，安装最新版本的 Docker Engine、containerd 和 Docker Compose 12sudo apt-get updatesudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin 输入y并回车 image-20220806110939248 2.通过运行映像来验证 Docker 引擎是否已正确安装。 1sudo docker run hello-world image-20220806111006566 到此Docker安装完成 常用命令开机启动Docker 1systemctl enable docker 卸载Docker 123sudo apt-get purge docker-ce docker-ce-cli containerd.iosudo rm -rf /var/lib/dockersudo rm -rf /var/lib/containerd","tags":["Docker"],"categories":["Docker"]},{"title":"11_JavaScript_HTML_DOM_导航","path":"/posts/5c1b8836.html","content":"通过 HTML DOM，您能够使用节点关系来导航节点树。 DOM 节点根据 W3C HTML DOM 标准，HTML 文档中的所有事物都是节点： 整个文档是文档节点 每个 HTML 元素是元素节点 HTML 元素内的文本是文本节点 每个 HTML 属性是属性节点 所有注释是注释节点 有了 HTML DOM，节点树中的所有节点都能通过 JavaScript 访问。 能够创建新节点，还可以修改和删除所有节点。 节点关系节点树中的节点彼此之间有一定的等级关系。 术语（父、子和同胞，parent、child 以及 sibling）用于描述这些关系。 在节点树中，顶端节点被称为根（根节点）。 每个节点都有父节点，除了根（根节点没有父节点）。 节点能够拥有一定数量的子 同胞（兄弟或姐妹）指的是拥有相同父的节点。 123456789101112&lt;html&gt; &lt;head&gt; &lt;title&gt;DOM 教程&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;DOM 第一课&lt;/h1&gt; &lt;p&gt;Hello world!&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 从以上的 HTML 中您能读到以下信息： 12345- &lt;html&gt; 是根节点- &lt;html&gt; 没有父- &lt;html&gt; 是 &lt;head&gt; 和 &lt;body&gt; 的父- &lt;head&gt; 是 &lt;html&gt; 的第一个子- &lt;body&gt; 是 &lt;html&gt; 的最后一个子 同时： 123456- &lt;head&gt; 有一个子：&lt;title&gt;- &lt;title&gt; 有一个子（文本节点）：&quot;DOM 教程&quot;- &lt;body&gt; 有两个子：&lt;h1&gt;和&lt;p&gt;- &lt;h1&gt;有一个子：&quot;DOM 第一课&quot;- &lt;p&gt;有一个子：&quot;Hello world!&quot;- &lt;h1&gt;和&lt;p&gt;是同胞 在节点之间导航通过 JavaScript，您可以使用以下节点属性在节点之间导航： parentNode childNodes[nodenumber] firstChild lastChild nextSibling previousSibling 子节点和节点值DOM 处理中的一种常见错误是认为元素节点中包含文本。 实例：1&lt;title id=&quot;demo&quot;&gt;DOM 教程&lt;/title&gt; （上面例子中的）元素节点 &lt;title&gt; 不包含文本。 它包含了值为 “DOM 教程” 的文本节点。 文本节点的值能够通过节点的 innerHTML 属性进行访问： 1var myTitle = document.getElementById(&quot;demo&quot;).innerHTML; 访问 innerHTML 属性等同于访问首个子节点的 nodeValue： 1var myTitle = document.getElementById(&quot;demo&quot;).firstChild.nodeValue; 也可以这样访问第一个子节点： 1var myTitle = document.getElementById(&quot;demo&quot;).childNodes[0].nodeValue; 以下三个例子取回 &lt;h1&gt; 元素的文本并复制到 &lt;p&gt; 元素中： 实例 1123456789101112&lt;html&gt;&lt;body&gt;&lt;h1 id=&quot;id01&quot;&gt;我的第一张页面&lt;/h1&gt;&lt;p id=&quot;id02&quot;&gt;Hello!&lt;/p&gt;&lt;script&gt; document.getElementById(&quot;id02&quot;).innerHTML = document.getElementById(&quot;id01&quot;).innerHTML;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 实例 2123456789101112&lt;html&gt;&lt;body&gt;&lt;h1 id=&quot;id01&quot;&gt;我的第一张页面&lt;/h1&gt;&lt;p id=&quot;id02&quot;&gt;Hello!&lt;/p&gt;&lt;script&gt; document.getElementById(&quot;id02&quot;).innerHTML = document.getElementById(&quot;id01&quot;).firstChild.nodeValue;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 实例 3123456789101112&lt;html&gt;&lt;body&gt;&lt;h1 id=&quot;id01&quot;&gt;我的第一张页面&lt;/h1&gt;&lt;p id=&quot;id02&quot;&gt;Hello!&lt;/p&gt;&lt;script&gt; document.getElementById(&quot;id02&quot;).innerHTML = document.getElementById(&quot;id01&quot;).childNodes[0].nodeValue;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; InnerHTML在本教程中，我们使用 innerHTML 取回 HTML 元素的内容。 不过，学习以上其他的方法有助于理解 DOM 的树结构和导航。 DOM 根节点有两个特殊属性允许访问完整文档： document.body - 文档的 body document.documentElement - 完整文档 实例123456789101112131415&lt;html&gt;&lt;body&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;div&gt;&lt;p&gt;DOM 很有用！&lt;/p&gt;&lt;p&gt;本例演示 &lt;b&gt;document.body&lt;/b&gt; 属性。&lt;/p&gt;&lt;/div&gt;&lt;script&gt; alert(document.body.innerHTML);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 实例123456789101112131415&lt;html&gt;&lt;body&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;div&gt;&lt;p&gt;DOM 很有用！&lt;/p&gt;&lt;p&gt;本例演示 &lt;b&gt;document.documentElement&lt;/b&gt; 属性。&lt;/p&gt;&lt;/div&gt;&lt;script&gt;alert(document.documentElement.innerHTML);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; nodeName 属性nodeName 属性规定节点的名称。 nodeName 是只读的 元素节点的 nodeName 等同于标签名 属性节点的 nodeName 是属性名称 文本节点的 nodeName 总是 #text 文档节点的 nodeName 总是 #document 实例123456&lt;h1 id=&quot;id01&quot;&gt;我的第一张网页&lt;/h1&gt;&lt;p id=&quot;id02&quot;&gt;Hello!&lt;/p&gt;&lt;script&gt;document.getElementById(&quot;id02&quot;).innerHTML = document.getElementById(&quot;id01&quot;).nodeName;&lt;/script&gt; 注释：nodeName 总是包含 HTML 元素的大写标签名。 nodeValue 属性nodeValue 属性规定节点的值。 元素节点的 nodeValue 是 undefined 文本节点的 nodeValue 是文本文本 属性节点的 nodeValue 是属性值 nodeType 属性nodeType 属性返回节点的类型。nodeType 是只读的。 实例123456&lt;h1 id=&quot;id01&quot;&gt;我的第一张网页&lt;/h1&gt;&lt;p id=&quot;id02&quot;&gt;Hello!&lt;/p&gt;&lt;script&gt;document.getElementById(&quot;id02&quot;).innerHTML = document.getElementById(&quot;id01&quot;).nodeType;&lt;/script&gt; 最重要的 nodeType 属性是： 节点 类型 例子 ELEMENT_NODE 1 &lt;h1 class=&quot;heading&quot;&gt;W3School&lt;/h1&gt; ATTRIBUTE_NODE 2 class &#x3D; “heading” （弃用） TEXT_NODE 3 W3School COMMENT_NODE 8 &lt;!-- 这是注释 --&gt; DOCUMENT_NODE 9 HTML 文档本身（ 的父） DOCUMENT_TYPE_NODE 10 &lt;!Doctype html&gt; Type 2 在 HTML DOM 中已弃用。XML DOM 中未弃用。","tags":["JavaScript"],"categories":["Language"]},{"title":"01_JavaScript_HTML_DOM","path":"/posts/3b0de40a.html","content":"通过 HTML DOM，JavaScript 能够访问和改变 HTML 文档的所有元素。 HTML DOM（文档对象模型）当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model）。 HTML DOM 模型被结构化为对象树： 对象的 HTML DOM 树DOM HTML 树 通过这个对象模型，JavaScript 获得创建动态 HTML 的所有力量： JavaScript 能改变页面中的所有 HTML 元素 JavaScript 能改变页面中的所有 HTML 属性 JavaScript 能改变页面中的所有 CSS 样式 JavaScript 能删除已有的 HTML 元素和属性 JavaScript 能添加新的 HTML 元素和属性 JavaScript 能对页面中所有已有的 HTML 事件作出反应 JavaScript 能在页面中创建新的 HTML 事件 您将学到什么在本教程下面的章节中，您将学到： 如何改变 HTML 元素的内容 如何改变 HTML 元素的样式（CSS） 如何对 HTML DOM 事件作出反应 如何添加和删除 HTML 元素 什么是 DOM？DOM 是一项 W3C (World Wide Web Consortium) 标准。 DOM 定义了访问文档的标准： “W3C 文档对象模型（DOM）是中立于平台和语言的接口，它允许程序和脚本动态地访问、更新文档的内容、结构和样式。” W3C DOM 标准被分为 3 个不同的部分： Core DOM - 所有文档类型的标准模型 XML DOM - XML 文档的标准模型 HTML DOM - HTML 文档的标准模型 什么是 HTML DOM？HTML DOM 是 HTML 的标准对象模型和编程接口。它定义了： 作为对象的 HTML 元素 所有 HTML 元素的属性 访问所有 HTML 元素的方法 所有 HTML 元素的事件 换言之：HTML DOM 是关于如何获取、更改、添加或删除 HTML 元素的标准。","tags":["JavaScript"],"categories":["Language"]},{"title":"04_JavaScript_语法","path":"/posts/beb0ec09.html","content":"JavaScript *语法*是一套规则，它定义了 JavaScript 的语言结构。 123var x, y;\t// 如何声明变量x = 7; y = 8;\t// 如何赋值z = x + y;\t// 如何计算值 JavaScript 值JavaScript 语句定义两种类型的值：混合值和变量值。 混合值被称为字面量（literal）。变量值被称为变量。 JavaScript 字面量书写混合值最重要的规则是： 写数值有无小数点均可： 12315.9010011 字符串是文本，由双引号或单引号包围： 123&quot;Bill Gates&quot;&#x27;Bill Gates&#x27; JavaScript 变量在编程语言中，变量用于存储数据值。 JavaScript 使用 var 关键词来声明变量。 = 号用于为变量赋值。 在本例中，x 被定义为变量。然后，x 被赋的值是 7： 123var x;x = 7; JavaScript 运算符JavaScript 使用算数运算符（+ - * /）来计算值： 1(7 + 8) * 10 JavaScript 使用赋值运算符（=）向变量赋值： 123var x, y;var x = 7;var y = 8; JavaScript 表达式表达式是值、变量和运算符的组合，计算结果是值。 16 * 10 表达式也可包含变量值： 1x * 10 值可以是多种类型，比如数值和字符串。 例如，”Bill” + “ “ + “Gates”，计算为 “Bill Gates”： 1&quot;Bill&quot; + &quot; &quot; + &quot;Gates&quot; JavaScript 关键词JavaScript 关键词用于标识被执行的动作。 var 关键词告知浏览器创建新的变量： 12var x = 7 + 8;var y = x * 10; JavaScript 注释并非所有 JavaScript 语句都被“执行”。 双斜杠 // 或 /* 与 **&#x2F;* 之间的代码被视为注释。 注释会被忽略，不会被执行： 123var x = 7; // 会执行// var x = 8; 不会执行 JavaScript 标识符标识符是名称。 在 JavaScript 中，标识符用于命名变量（以及关键词、函数和标签）。 在大多数编程语言中，合法名称的规则大多相同。 在 JavaScript 中，首字符必须是字母、下划线（-）或美元符号（$）。 连串的字符可以是字母、数字、下划线或美元符号。 提示：数值不可以作为首字符。这样，JavaScript 就能轻松区分标识符和数值。 JavaScript 对大小写敏感所有 JavaScript 标识符对大小写敏感。 变量 lastName 和 lastname，是两个不同的变量。 12lastName = &quot;Gates&quot;;lastname = &quot;Jobs&quot;; JavaScript 不会把 VAR 或 Var 译作关键词 var。 JavaScript 与驼峰式大小写历史上，程序员曾使用三种把多个单词连接为一个变量名的方法： 连字符：1first-name, last-name, master-card, inter-city. 注释：JavaScript 中不能使用连字符。它是为减法预留的。 下划线：1first_name, last_name, master_card, inter_city. 驼峰式大小写（Camel Case）：1FirstName, LastName, MasterCard, InterCity. camelCase JavaScript 程序员倾向于使用以小写字母开头的驼峰大小写： 1firstName, lastName, masterCard, interCity","tags":["JavaScript"],"categories":["Language"]},{"title":"RegEx","path":"/posts/1641f36c.html","content":"什么是正则表达式? 正则表达式是一组由字母和符号组成的特殊文本, 它可以用来从文本中找出满足你想要的格式的句子. 一个正则表达式是在一个主体字符串中从左到右匹配字符串时的一种样式.例如”Regular expression”是一个完整的句子, 但我们常使用缩写的术语”regex”或”regexp”.正则表达式可以用来替换文本中的字符串,验证形式,提取字符串等等. 想象你正在写一个应用, 然后你想设定一个用户命名的规则, 让用户名包含字符,数字,下划线和连字符,以及限制字符的个数,好让名字看起来没那么丑.我们使用以下正则表达式来验证一个用户名: 以上的正则表达式可以接受 john_doe, jo-hn_doe, john12_as.但不匹配Jo, 因为它包含了大写的字母而且太短了. 1. 基本匹配正则表达式其实就是在执行搜索时的格式, 它由一些字母和数字组合而成.例如: 一个正则表达式 the, 它表示一个规则: 由字母t开始,接着是h,再接着是e. “the” &#x3D;&gt; The fat cat sat on the mat. 在线练习 正则表达式123匹配字符串123. 它逐个字符的与输入的正则表达式做比较. 正则表达式是大小写敏感的, 所以The不会匹配the. “The” &#x3D;&gt; The fat cat sat on the mat. 在线练习 2. 元字符正则表达式主要依赖于元字符.元字符不代表他们本身的字面意思, 他们都有特殊的含义. 一些元字符写在方括号中的时候有一些特殊的意思. 以下是一些元字符的介绍: 元字符 描述 . 句号匹配任意单个字符除了换行符. [ ] 字符种类. 匹配方括号内的任意字符. [^ ] 否定的字符种类. 匹配除了方括号里的任意字符 * 匹配&gt;&#x3D;0个重复的在*号之前的字符. + 匹配&gt;1个重复的+号前的字符. ? 标记?之前的字符为可选. {n,m} 匹配num个中括号之前的字符 (n &lt;&#x3D; num &lt;&#x3D; m). (xyz) 字符集, 匹配与 xyz 完全相等的字符串. &#124; 或运算符,匹配符号前或后的字符. &#92; 转义字符,用于匹配一些保留的字符 [ ] ( ) { } . * + ? ^ $ \\ &#124; ^ 从开始行开始匹配. $ 从末端开始匹配. 2.1 点运算符 ..是元字符中最简单的例子..匹配任意单个字符, 但不匹配换行符.例如, 表达式.ar匹配一个任意字符后面跟着是a和r的字符串. “.ar” &#x3D;&gt; The car parked in the garage. 在线练习 2.2 字符集字符集也叫做字符类.方括号用来指定一个字符集.在方括号中使用连字符来指定字符集的范围.在方括号中的字符集不关心顺序.例如, 表达式[Tt]he 匹配 the 和 The. “[Tt]he” &#x3D;&gt; The car parked in the garage. 在线练习 方括号的句号就表示句号.表达式 ar[.] 匹配 ar.字符串 “ar[.]” &#x3D;&gt; A garage is a good place to park a car. 在线练习 2.2.1 否定字符集一般来说 ^ 表示一个字符串的开头, 但它用在一个方括号的开头的时候, 它表示这个字符集是否定的.例如, 表达式[^c]ar 匹配一个后面跟着ar的除了c的任意字符. “[^c]ar” &#x3D;&gt; The car parked in the garage. 在线练习 2.3 重复次数后面跟着元字符 +, * or ? 的, 用来指定匹配子模式的次数.这些元字符在不同的情况下有着不同的意思. 2.3.1 * 号*号匹配 在*之前的字符出现大于等于0次.例如, 表达式 a* 匹配以0或更多个a开头的字符, 因为有0个这个条件, 其实也就匹配了所有的字符. 表达式[a-z]* 匹配一个行中所有以小写字母开头的字符串. “[a-z]“ &#x3D;&gt; The car parked in the garage* #21. 在线练习 *字符和.字符搭配可以匹配所有的字符.*.*和表示匹配空格的符号\\s连起来用, 如表达式\\s*cat\\s*匹配0或更多个空格开头和0或更多个空格结尾的cat字符串. “\\scat\\s“ &#x3D;&gt; The fat*** cat sat on the concat***enation. 在线练习 2.3.2 + 号+号匹配+号之前的字符出现 &gt;&#x3D;1 次个字符.例如表达式c.+t 匹配以首字母c开头以t结尾,中间跟着任意个字符的字符串. “c.+t” &#x3D;&gt; The fat cat sat on the mat. 在线练习 2.3.3 ? 号在正则表达式中元字符 ? 标记在符号前面的字符为可选, 即出现 0 或 1 次.例如, 表达式 [T]?he 匹配字符串 he 和 The. “[T]he” &#x3D;&gt; The car is parked in the garage. 在线练习 “[T]?he” &#x3D;&gt; The car is parked in the garage. 在线练习 2.4 &#123;&#125; 号在正则表达式中 &#123;&#125; 是一个量词, 常用来一个或一组字符可以重复出现的次数.例如, 表达式 [0-9]&#123;2,3&#125; 匹配 23 位 09 的数字. “[0-9]{2,3}” &#x3D;&gt; The number was 9.9997 but we rounded it off to 10.0. 在线练习 我们可以省略第二个参数.例如, [0-9]&#123;2,&#125; 匹配至少两位 0~9 的数字. 如果逗号也省略掉则表示重复固定的次数.例如, [0-9]&#123;3&#125; 匹配3位数字 “[0-9]{2,}” &#x3D;&gt; The number was 9.9997 but we rounded it off to 10.0. 在线练习 “[0-9]{3}” &#x3D;&gt; The number was 9.9997 but we rounded it off to 10.0. 在线练习 2.5 (...) 特征标群特征标群是一组写在 (...) 中的子模式. 例如之前说的 &#123;&#125; 是用来表示前面一个字符出现指定次数. 但如果在 &#123;&#125; 前加入特征标群则表示整个标群内的字符重复 N 次. 例如, 表达式 (ab)* 匹配连续出现 0 或更多个 ab. 我们还可以在 () 中用或字符 | 表示或. 例如, (c|g|p)ar 匹配 car 或 gar 或 par. “(c|g|p)ar” &#x3D;&gt; The car is parked in the garage. 在线练习 2.6 | 或运算符或运算符就表示或, 用作判断条件. 例如 (T|t)he|car 匹配 (T|t)he 或 car. “(T|t)he|car” &#x3D;&gt; The car is parked in the garage. 在线练习 2.7 转码特殊字符反斜线 \\ 在表达式中用于转码紧跟其后的字符. 用于指定 &#123; &#125; [ ] / \\ + * . $ ^ | ? 这些特殊字符. 如果想要匹配这些特殊字符则要在其前面加上反斜线 \\. 例如 . 是用来匹配除换行符外的所有字符的. 如果想要匹配句子中的 . 则要写成 \\.. “(f|c|m)at.?” &#x3D;&gt; The fat cat sat on the mat. 在线练习 2.8 锚点在正则表达式中, 想要匹配指定开头或结尾的字符串就要使用到锚点. ^ 指定开头, $ 指定结尾. 2.8.1 ^ 号^ 用来检查匹配的字符串是否在所匹配字符串的开头. 例如, 在 abc 中使用表达式 ^a 会得到结果 a. 但如果使用 ^b 将匹配不到任何结果. 因为在字符串 abc 中并不是以 b 开头. 例如, ^(T|t)he 匹配以 The 或 the 开头的字符串. “(T|t)he” &#x3D;&gt; The car is parked in the garage. 在线练习 “^(T|t)he” &#x3D;&gt; The car is parked in the garage. 在线练习 2.8.2 $ 号同理于 ^ 号, $ 号用来匹配字符是否是最后一个. 例如, (at\\.)$ 匹配以 at. 结尾的字符串. “(at.)” &#x3D;&gt; The fat cat. sat. on the mat. 在线练习 “(at.)$” &#x3D;&gt; The fat cat. sat. on the mat. 在线练习 3. 简写字符集正则表达式提供一些常用的字符集简写. 如下: 简写 描述 . 除换行符外的所有字符 \\w 匹配所有字母数字, 等同于 [a-zA-Z0-9_] \\W 匹配所有非字母数字, 即符号, 等同于: [^\\w] \\d 匹配数字: [0-9] \\D 匹配非数字: [^\\d] \\s 匹配所有空格字符, 等同于: [\\t \\f\\r\\p&#123;Z&#125;] \\S 匹配所有非空格字符: [^\\s] 4. 前后关联约束(前后预查)前置约束和后置约束都属于非捕获簇(用于匹配不在匹配列表中的格式).前置约束用于判断所匹配的格式是否在另一个确定的格式之后. 例如, 我们想要获得所有跟在 $ 符号后的数字, 我们可以使用正向向后约束 (?&lt;=\\$)[0-9\\.]*.这个表达式匹配 $ 开头, 之后跟着 0,1,2,3,4,5,6,7,8,9,. 这些字符可以出现大于等于 0 次. 前后关联约束如下: 符号 描述 ?&#x3D; 前置约束-存在 ?! 前置约束-排除 ?&lt;&#x3D; 后置约束-存在 ?&lt;! 后置约束-排除 4.1 ?=... 前置约束(存在)?=... 前置约束(存在), 表示第一部分表达式必须跟在 ?=...定义的表达式之后. 返回结果只满足第一部分表达式.定义一个前置约束(存在)要使用 (). 在括号内部使用一个问号和等号: (?=...). 前置约束的内容写在括号中的等号后面.例如, 表达式 [T|t]he(?=\\sfat) 匹配 The 和 the, 在括号中我们又定义了前置约束(存在) (?=\\sfat) ,即 The 和 the 后面紧跟着 (空格)fat. “[T|t]he(?&#x3D;\\sfat)” &#x3D;&gt; The fat cat sat on the mat. 在线练习 4.2 ?!... 前置约束-排除前置约束-排除 ?! 用于筛选所有匹配结果, 筛选条件为 其后不跟随着定义的格式前置约束-排除 定义和 前置约束(存在) 一样, 区别就是 = 替换成 ! 也就是 (?!...). 表达式 [T|t]he(?!\\sfat) 匹配 The 和 the, 且其后不跟着 (空格)fat. “[T|t]he(?!\\sfat)” &#x3D;&gt; The fat cat sat on the mat. 在线练习 4.3 ?&lt;= ... 后置约束-存在后置约束-存在 记作(?&lt;=...) 用于筛选所有匹配结果, 筛选条件为 其前跟随着定义的格式.例如, 表达式 (?&lt;=[T|t]he\\s)(fat|mat) 匹配 fat 和 mat, 且其前跟着 The 或 the. “(? The fat cat sat on the mat. 在线练习 4.4 ?&lt;!... 后置约束-排除后置约束-排除 记作 (?&lt;!...) 用于筛选所有匹配结果, 筛选条件为 其前不跟着定义的格式.例如, 表达式 (?&lt;!(T|t)he\\s)(cat) 匹配 cat, 且其前不跟着 The 或 the. “(?&lt;![T|t]he\\s)(cat)” &#x3D;&gt; The cat sat on cat. 在线练习 5. 标志标志也叫修饰语, 因为它可以用来修改表达式的搜索结果.这些标志可以任意的组合使用, 它也是整个正则表达式的一部分. 标志 描述 i 忽略大小写. g 全局搜索. m 多行的: 锚点元字符 ^ $ 工作范围在每行的起始. 5.1 忽略大小写 (Case Insensitive)修饰语 i 用于忽略大小写.例如, 表达式 /The/gi 表示在全局搜索 The, 在后面的 i 将其条件修改为忽略大小写, 则变成搜索 the 和 The, g 表示全局搜索. “The” &#x3D;&gt; The fat cat sat on the mat. 在线练习 “&#x2F;The&#x2F;gi” &#x3D;&gt; The fat cat sat on the mat. 在线练习 5.2 全局搜索 (Global search)修饰符 g 常用于执行一个全局搜索匹配, 即(不仅仅返回第一个匹配的, 而是返回全部).例如, 表达式 /.(at)/g 表示搜索 任意字符(除了换行) + at, 并返回全部结果. “&#x2F;.(at)&#x2F;“ &#x3D;&gt; The fat cat sat on the mat. 在线练习 “&#x2F;.(at)&#x2F;g” &#x3D;&gt; The fat cat sat on the mat. 在线练习 5.3 多行修饰符 (Multiline)多行修饰符 m 常用于执行一个多行匹配. 像之前介绍的 (^,$) 用于检查格式是否是在待检测字符串的开头或结尾. 但我们如果想要它在每行的开头和结尾生效, 我们需要用到多行修饰符 m. 例如, 表达式 /at(.)?$/gm 表示在待检测字符串每行的末尾搜索 at后跟一个或多个 . 的字符串, 并返回全部结果. “&#x2F;.at(.)?$&#x2F;“ &#x3D;&gt; The fat cat sat on the mat. 在线练习 “&#x2F;.at(.)?$&#x2F;gm” &#x3D;&gt; The fat cat sat on the mat. 在线练习 6. 贪婪匹配与惰性匹配 (Greedy vs lazy matching)正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 ? 将贪婪匹配模式转化为惰性匹配模式。 “&#x2F;(.*at)&#x2F;“ &#x3D;&gt; The fat cat sat on the mat. 在线练习 “&#x2F;(.*?at)&#x2F;“ &#x3D;&gt; The fat cat sat on the mat. 在线练习 额外补充 正整数: ^\\d+$ 负整数: ^-\\d+$ 手机国家号: ^+?[\\d\\s]&#123;3,&#125;$ 手机号: ^+?[\\d\\s]+(?[\\d\\s]&#123;10,&#125;$ 整数: ^-?\\d+$ 用户名: ^[\\w\\d_.]&#123;4,16&#125;$ 数字和英文字母: ^[a-zA-Z0-9]*$ 数字和应为字母和空格: ^[a-zA-Z0-9 ]*$ 密码: ^(?=^.&#123;6,&#125;$)((?=.*[A-Za-z0-9])(?=.*[A-Z])(?=.*[a-z]))^.*$ 邮箱: ^([a-zA-Z0-9._%-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]&#123;2,4&#125;)*$ IP4 地址: ^((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))*$ 纯小写字母: ^([a-z])*$ 纯大写字母: ^([A-Z])*$ URL: ^(((http|https|ftp):\\/\\/)?([[a-zA-Z0-9]\\-\\.])+(\\.)([[a-zA-Z0-9]])&#123;2,4&#125;([[a-zA-Z0-9]\\/+=%&amp;_\\.~?\\-]*))*$ VISA 信用卡号: ^(4[0-9]&#123;12&#125;(?:[0-9]&#123;3&#125;)?)*$ 日期 (MM&#x2F;DD&#x2F;YYYY): ^(0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])[- /.](19|20)?[0-9]&#123;2&#125;$ 日期 (YYYY&#x2F;MM&#x2F;DD): ^(19|20)?[0-9]&#123;2&#125;[- /.](0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])$ MasterCard 信用卡号: ^(5[1-5][0-9]&#123;14&#125;)*$","tags":["RegEx"],"categories":["RegEx"]},{"title":"Git5分钟教程","path":"/posts/5ff07a04.html","content":"许多人认为 Git 太混乱，或认为它是一种复杂的版本控制系统，其实不然，这篇文章有助于大家快速上手使用 Git。 img 入门使用Git前，需要先建立一个仓库(repository)。您可以使用一个已经存在的目录作为Git仓库或创建一个空目录。 使用您当前目录作为Git仓库，我们只需使它初始化。 1git init 使用我们指定目录作为Git仓库。 1git init newrepo 从现在开始，我们将假设您在Git仓库根目录下，除非另有说明。 添加新文件我们有一个仓库，但什么也没有，可以使用add命令添加文件。 1git add filename 可以使用add… 继续添加任务文件。 提交版本现在我们已经添加了这些文件，我们希望它们能够真正被保存在Git仓库。 为此，我们将它们提交到仓库。 1git commit -m &quot;Adding files&quot; 如果您不使用-m，会出现编辑器来让你写自己的注释信息。 当我们修改了很多文件，而不想每一个都add，想commit自动来提交本地修改，我们可以使用-a标识。 1git commit -a -m &quot;Changed some files&quot; git commit 命令的-a选项可将所有被修改或者已删除的且已经被git管理的文档提交到仓库中。 千万注意，-a不会造成新文件被提交，只能修改。 发布版本我们先从服务器克隆一个库并上传。 1git clone ssh://example.com/~/www/project.git 现在我们修改之后可以进行推送到服务器。 1git push ssh://example.com/~/www/project.git 取回更新如果您已经按上面的进行push，下面命令表示，当前分支自动与唯一一个追踪分支进行合并。 1git pull 从非默认位置更新到指定的url。 1git pull http://git.example.com/project.git 已经超过了五分钟？删除如何你想从资源库中删除文件，我们使用rm。 1git rm file 分支与合并分支在本地完成，速度快。要创建一个新的分支，我们使用branch命令。 1git branch test branch命令不会将我们带入分支，只是创建一个新分支。所以我们使用checkout命令来更改分支。 1git checkout test 第一个分支，或主分支，被称为”master”。 1git checkout master 对其他分支的更改不会反映在主分支上。如果想将更改提交到主分支，则需切换回master分支，然后使用合并。 12git checkout mastergit merge test 如果您想删除分支，我们使用-d标识。 1git branch -d test","tags":["Git"],"categories":["Git"]},{"title":"07_Web_Geolocation_API","path":"/posts/32a67362.html","content":"定位用户的位置HTML Geolocation API 用于获取用户的地理位置。 由于这可能会损害隐私，除非用户批准，否则位置不可用。 注释：地理定位对于带有 GPS 的设备（如智能手机）最为准确。 所有浏览器都支持 Geolocation API： Chrome IE Firefox Safari Opera 支持 支持 支持 支持 支持 注释：从 Chrome 50 开始，Geolocation API 将仅适用于安全上下文，例如 HTTPS。如果您的站点托管在非安全源（例如 HTTP）上，则获取用户位置的请求将不再起作用。 使用 Geolocation APIgetCurrentPosition() 方法用于返回用户的位置。 下面的例子返回用户位置的纬度和经度： 实例123456789101112131415&lt;script&gt;const x = document.getElementById(&quot;demo&quot;);function getLocation() &#123; if (navigator.geolocation) &#123; navigator.geolocation.getCurrentPosition(showPosition); &#125; else &#123; x.innerHTML = &quot;Geolocation is not supported by this browser.&quot;; &#125;&#125;function showPosition(position) &#123; x.innerHTML = &quot;Latitude: &quot; + position.coords.latitude + &quot;&lt;br&gt;Longitude: &quot; + position.coords.longitude;&#125;&lt;/script&gt; 例子解释： 检查是否支持 Geolocation 如果支持，请运行 getCurrentPosition() 方法。如果没有，则向用户显示一条消息 如果 getCurrentPosition() 方法成功，则返回一个 coordinates 对象给参数 (showPosition) 中规定的函数 showPosition() 函数输出纬度和经度 上面的例子是一个非常基本的地理定位脚本，没有错误处理。 处理错误和拒绝getCurrentPosition() 方法的第二个参数用于处理错误。如果无法获取用户的位置，它规定要运行的函数： 实例12345678910111213141516function showError(error) &#123; switch(error.code) &#123; case error.PERMISSION_DENIED: x.innerHTML = &quot;User denied the request for Geolocation.&quot; break; case error.POSITION_UNAVAILABLE: x.innerHTML = &quot;Location information is unavailable.&quot; break; case error.TIMEOUT: x.innerHTML = &quot;The request to get user location timed out.&quot; break; case error.UNKNOWN_ERROR: x.innerHTML = &quot;An unknown error occurred.&quot; break; &#125;&#125; 在地图中显示结果如需在地图中显示结果，您需要访问地图服务，例如 Google 地图。 在下面的例子中，返回的纬度和经度用于在 Google 地图中显示位置（使用静态图像）： 实例12345678function showPosition(position) &#123; let latlon = position.coords.latitude + &quot;,&quot; + position.coords.longitude; let img_url = &quot;https://maps.googleapis.com/maps/api/staticmap?center= &quot;+latlon+&quot;&amp;zoom=14&amp;size=400x300&amp;sensor=false&amp;key=YOUR_KEY&quot;; document.getElementById(&quot;mapholder&quot;).innerHTML = &quot;&lt;img src=&#x27;&quot;+img_url+&quot;&#x27;&gt;&quot;;&#125; Location-specific 信息此页面演示了如何在地图上显示用户的位置。 Geolocation 对于特定于位置的信息也非常有用，例如： 最新的本地信息 显示用户附近的兴趣点 逐向导航（Turn-by-turn navigation）(GPS) getCurrentPosition() 方法 - 返回数据getCurrentPosition() 方法在成功时返回一个对象。会始终返回纬度、经度和精度属性。如果可用，则返回其他属性： 属性 返回 coords.latitude 以十进制数表示的纬度（始终返回）。 coords.longitude 以十进制数表示的经度（始终返回）。 coords.accuracy 位置精度（始终返回）。 coords.altitude 平均海平面以上的高度（以米计）（如果可用则返回）。 coords.altitudeAccuracy 位置的高度精度（如果可用则返回）。 coords.heading 从北顺时针方向的航向（如果可用则返回）。 coords.speed 以米&#x2F;秒计的速度（如果可用则返回）。 timestamp 响应的日期&#x2F;时间（如果可用则返回）。 Geolocation 对象 - 其他有趣的方法Geolocation 对象还有其他有趣的方法： watchPosition() - 返回用户的当前位置，并随着用户移动（如汽车中的 GPS）继续返回更新的位置。 clearWatch() - 停止 watchPosition () 方法。 下面的例子展示了 watchPosition() 方法。你需要准确的 GPS 设备来测试（比如智能手机）： 实例1234567891011121314&lt;script&gt;const x = document.getElementById(&quot;demo&quot;);function getLocation() &#123; if (navigator.geolocation) &#123; navigator.geolocation.watchPosition(showPosition); &#125; else &#123; x.innerHTML = &quot;Geolocation is not supported by this browser.&quot;; &#125;&#125;function showPosition(position) &#123; x.innerHTML = &quot;Latitude: &quot; + position.coords.latitude + &quot;&lt;br&gt;Longitude: &quot; + position.coords.longitude;&#125;&lt;/script&gt;","tags":["JavaScript"],"categories":["Language"]},{"title":"06_JavaScript_Fetch_API","path":"/posts/737ae60e.html","content":"Fetch API 接口允许 Web 浏览器向 Web 服务器发出 HTTP 请求。 不再需要 XMLHttpRequest。 浏览器支持表中的数字注明了完全支持 Fetch API 的首个浏览器版本： Chrome IE Firefox Safari Opera Chrome 42 Edge 14 Firefox 40 Safari 10.1 Opera 29 2011 年 6 月 2016 年 8 月 2015 年 8 月 2017 年 3 月 2015 年 4 月 Fetch API 实例下面的例子获取文件并显示内容： 实例123fetch(file).then(x =&gt; x.text()).then(y =&gt; myDisplay(y)); 由于 Fetch 基于 async 和 await，因此上面的例子这么写可能更容易理解： 实例12345async function getText(file) &#123; let x = await fetch(file); let y = await x.text(); myDisplay(y);&#125; 甚至可以更好：请使用易于理解的名称而不是 x 和 y： 实例12345async function getText(file) &#123; let myObject = await fetch(file); let myText = await myObject.text(); myDisplay(myText);&#125;","tags":["JavaScript"],"categories":["Language"]},{"title":"05_Web_Worker_API","path":"/posts/ec081a96.html","content":"Web Worker 是在后台运行的 JavaScript，不会影响页面的性能。 什么是 Web Worker？在 HTML 页面中执行脚本时，页面在脚本完成之前是无响应的。 Web Worker 是在后台运行的 JavaScript，独立于其他脚本，不会影响页面的性能。你可以继续做任何你想做的事情：点击、选取内容等，同时 web worker 在后台运行。 浏览器支持表中的数字注明了完全支持 Web Workers 的首个浏览器版本： Chrome IE Firefox Safari Opera Chrome 4 IE 10 Firefox 3.5 Safari 4 Opera 11.5 2010 年 1 月 2012 年 9 月 2009 年 6 月 2009 年 6 月 2011 年 6 月 Web Worker 实例下面的例子创建了一个简单的 Web Worker，它在后台计算数字： 实例计数： 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;JavaScript Web Workers API&lt;/h1&gt;&lt;p&gt;Count numbers: &lt;output id=&quot;result&quot;&gt;&lt;/output&gt;&lt;/p&gt;&lt;button onclick=&quot;startWorker()&quot;&gt;开始 Worker&lt;/button&gt; &lt;button onclick=&quot;stopWorker()&quot;&gt;停止 Worker&lt;/button&gt;&lt;script&gt;let w;function startWorker() &#123; if(typeof(w) == &quot;undefined&quot;) &#123; w = new Worker(&quot;demo_workers.js&quot;); &#125; w.onmessage = function(event) &#123; document.getElementById(&quot;result&quot;).innerHTML = event.data; &#125;;&#125;function stopWorker() &#123; w.terminate(); w = undefined;&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 检查 Web Worker 浏览器在创建 web worker 之前，请检查用户的浏览器是否支持它： 123456if (typeof(Worker) !== &quot;undefined&quot;) &#123; // Yes! Web worker support! // Some code.....&#125; else &#123; // Sorry! No Web Worker support..&#125; 创建 Web Worker 文件现在，让我们在外部 JavaScript 中创建我们的 Web Worker。 在这里，我们创建了一个重要的脚本。该脚本存储在 “demo_workers.js” 文件中： 123456789let i = 0;function timedCount() &#123; i ++; postMessage(i); setTimeout(&quot;timedCount()&quot;,500);&#125;timedCount(); 上面代码的重要部分是 postMessage() 方法 - 用于将消息发送回 HTML 页面。 注释：通常 web worker 不用于这种简单的脚本，而是用于 CPU 密集型任务。 创建 Web Worker 对象现在我们有了 web worker 文件，我们需要从 HTML 页面调用它。 以下代码行检查 worker 是否已存在，如果不存在，它会创建一个新的 web worker 对象并运行 “demo_workers.js” 中的代码： 123if (typeof(w) == &quot;undefined&quot;) &#123; w = new Worker(&quot;demo_workers.js&quot;);&#125; 然后我们可以发送和接收来自 web worker 的消息。 向 web worker 添加一个 “onmessage” 事件侦听器。 123w.onmessage = function(event)&#123; document.getElementById(&quot;result&quot;).innerHTML = event.data;&#125;; 当 Web Worker 发布消息时，将执行事件侦听器中的代码。来自 Web Worker 的数据存储在 event.data 中。 终止 Web Worker当 web worker 对象被创建时，它会继续监听消息（即使在外部脚本完成之后）直到它被终止。 如需终止 web worker，并释放浏览器&#x2F;计算机资源，请使用 terminate() 方法： 1w.terminate(); 重用 Web Worker如果将 worker 变量设置为 undefined，则在它终止后，您可以重用以下代码： 1w = undefined; 完整的 Web Worker 实例代码我们已经在 .js 文件中看到了 Worker 代码。下面是 HTML 页面的代码： 实例12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;p&gt;Count numbers: &lt;output id=&quot;result&quot;&gt;&lt;/output&gt;&lt;/p&gt;&lt;button onclick=&quot;startWorker()&quot;&gt;Start Worker&lt;/button&gt;&lt;button onclick=&quot;stopWorker()&quot;&gt;Stop Worker&lt;/button&gt;&lt;script&gt;let w;function startWorker() &#123; if (typeof(w) == &quot;undefined&quot;) &#123; w = new Worker(&quot;demo_workers.js&quot;); &#125; w.onmessage = function(event) &#123; document.getElementById(&quot;result&quot;).innerHTML = event.data; &#125;;&#125;function stopWorker() &#123; w.terminate(); w = undefined;&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Web Worker 和 DOM由于 Web Worker 位于外部文件中，因此他们无法访问以下 JavaScript 对象： window 对象 document 对象 parent 对象","tags":["JavaScript"],"categories":["Language"]},{"title":"04_Web_Storage_API","path":"/posts/682f32c5.html","content":"Web Storage API 是一种用于在浏览器中存储和检索数据的简单语法。他非常容易使用： 实例12localStorage.setItem(&quot;name&quot;, &quot;Bill Gates&quot;);localStorage.getItem(&quot;name&quot;); 所有浏览器都支持 Web Storage API： Chrome IE Firefox Safari Opera Chrome IE&#x2F;Edge Firefox Safari Opera 支持 支持 支持 支持 支持 localStorage 对象localStorage 对象提供对特定网站的本地存储的访问。它允许您存储、读取、添加、修改和删除该域的数据项。 存储的数据没有到期日期，并且在浏览器关闭时不会被删除。 这些数据将在几天、几周和几年内均可用。 setItem() 方法localStorage.setItem() 方法将数据项存储在 storage 中。 它接受一个名称和一个值作为参数： 实例1localStorage.setItem(&quot;name&quot;, &quot;Bill Gates&quot;); getItem() 方法localStorage.getItem() 方法从存储（storage）中检索数据项。 它接受一个名称作为参数： 实例1localStorage.getItem(&quot;name&quot;); sessionStorage 对象sessionStorage 对象与 localStorage 对象相同。 不同之处在于 sessionStorage 对象存储会话的数据。 当浏览器关闭时，数据会被删除。 实例1sessionStorage.getItem(&quot;name&quot;); setItem() 方法sessionStorage.setItem() 方法将数据项存储在存储（storage）中。 它接受一个名称和一个值作为参数： 实例1sessionStorage.setItem(&quot;name&quot;, &quot;Bill Gates&quot;); getItem() 方法sessionStorage.getItem() 方法从存储（storage）中检索数据项。 它接受一个名称作为参数： 实例1sessionStorage.getItem(&quot;name&quot;); Storage 对象属性和方法 属性&#x2F;方法 描述 key(n) 返回存储中第 n 个键的名称。 length 返回存储在 Storage 对象中的数据项数。 getItem(keyname) 返回指定的键名的值。 setItem(keyname, value) 将键添加到存储中，或者如果键已经存在，则更新该键的值。 removeItem(keyname) 从存储中删除该键。 clear() 清空所有键。 Web Storage API 相关页面 属性 描述 window.localStorage 允许在 Web 浏览器中保存键&#x2F;值对。存储没有到期日期的数据。 window.sessionStorage 允许在 Web 浏览器中保存键&#x2F;值对。存储一个会话的数据。","tags":["JavaScript"],"categories":["Language"]},{"title":"03_Web_History_API","path":"/posts/3d952d4d.html","content":"Web History API 提供了访问 windows.history 对象的简单方法。 window.history 对象包含用户访问过的 URL（网站）。 所有浏览器都支持 Web History API： Chrome IE Firefox Safari Opera 支持 支持 支持 支持 支持 History back() 方法back() 方法加载 windows.history 列表中的前一个 URL。 这与单击浏览器中的“后退箭头”相同。 实例 后退1234567&lt;button onclick=&quot;myFunction()&quot;&gt;后退&lt;/button&gt;&lt;script&gt;function myFunction() &#123; window.history.back();&#125;&lt;/script&gt; History go() 方法go() 方法从历史列表中加载一个特定的 URL： 实例 后退两页1234567&lt;button onclick=&quot;myFunction()&quot;&gt;后退两页&lt;/button&gt;&lt;script&gt;function myFunction() &#123; window.history.go(-2);&#125;&lt;/script&gt; History 对象属性 属性 描述 length 返回历史列表中的 URL 数量。 History 对象方法 方法 描述 back() 加载历史列表中的上一个 URL。 forward() 加载历史列表中的下一个 URL。 go() 从历史列表中加载特定的 URL。","tags":["JavaScript"],"categories":["Language"]},{"title":"02_JavaScript_验证_API","path":"/posts/af2d633e.html","content":"约束验证 DOM 方法 属性 描述 checkValidity() 如果 input 元素包含有效数据，则返回 true。 setCustomValidity() 设置 input 元素的 validationMessage 属性。 如果输入字段包含无效数据，则显示一条消息： checkValidity() 方法12345678910111213&lt;input id=&quot;id1&quot; type=&quot;number&quot; min=&quot;100&quot; max=&quot;300&quot; required&gt;&lt;button onclick=&quot;myFunction()&quot;&gt;OK&lt;/button&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;function myFunction() &#123; const inpObj = document.getElementById(&quot;id1&quot;); if (!inpObj.checkValidity()) &#123; document.getElementById(&quot;demo&quot;).innerHTML = inpObj.validationMessage; &#125;&#125;&lt;/script&gt; 约束验证 DOM 属性 属性 描述 validity 包含与输入元素有效性相关的布尔属性。 validationMessage 包含当有效性为 false 时浏览器将显示的消息。 willValidate 指示是否将验证 input 元素。 有效性属性input 元素的有效性属性包含许多与数据有效性相关的属性： 属性 描述 customError 如果设置了自定义有效性消息，则设置为 true。 patternMismatch 如果元素的值与其 pattern 属性不匹配，则设置为 true。 rangeOverflow 如果元素的值大于其 max 属性，则设置为 true。 rangeUnderflow 如果元素的值小于其 min 属性，则设置为 true。 stepMismatch 如果元素的值对其 step 属性无效，则设置为 true。 tooLong 如果元素的值超过其 maxLength 属性，则设置为 true。 typeMismatch 如果元素的值对其 type 属性无效，则设置为 true。 valueMissing 如果元素（具有 required 属性）没有值，则设置为 true。 valid 如果元素的值有效，则设置为 true。 实例如果输入字段中的数字大于 100（input 元素的 max 属性），则显示一条消息： rangeOverflow 属性12345678910111213&lt;input id=&quot;id1&quot; type=&quot;number&quot; max=&quot;100&quot;&gt;&lt;button onclick=&quot;myFunction()&quot;&gt;OK&lt;/button&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;function myFunction() &#123; let text = &quot;Value OK&quot;; if (document.getElementById(&quot;id1&quot;).validity.rangeOverflow) &#123; text = &quot;Value too large&quot;; &#125;&#125;&lt;/script&gt; 如果输入字段中的数字小于 100（input 元素的 min 属性），则显示一条消息： rangeUnderflow 属性12345678910111213&lt;input id=&quot;id1&quot; type=&quot;number&quot; min=&quot;100&quot;&gt;&lt;button onclick=&quot;myFunction()&quot;&gt;OK&lt;/button&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;function myFunction() &#123; let text = = &quot;Value OK&quot;; if (document.getElementById(&quot;id1&quot;).validity.rangeUnderflow) &#123; text = &quot;Value too small&quot;; &#125;&#125;&lt;/script&gt;","tags":["JavaScript"],"categories":["Language"]},{"title":"01_Web_API_-_简介","path":"/posts/a9d1f8a3.html","content":"Web API 是开发人员的梦想。 它可以扩展浏览器的功能 它可以极大简化复杂的功能 它可以为复杂的代码提供简单的语法 什么是 Web API？API 指的是应用程序编程接口（Application Programming Interface）。 Web API 是 Web 的应用程序编程接口。 浏览器 API 可以扩展 Web 浏览器的功能。 服务器 API 可以扩展 Web 服务器的功能。 浏览器 API所有浏览器都有一组内置的 Web API 来支持复杂的操作，并帮助访问数据。 例如，Geolocation API 可以返回浏览器所在位置的坐标。 实例获取用户所在位置的经纬度： 1234567891011121314const myElement = document.getElementById(&quot;demo&quot;);function getLocation() &#123; if (navigator.geolocation) &#123; navigator.geolocation.getCurrentPosition(showPosition); &#125; else &#123; myElement.innerHTML = &quot;Geolocation is not supported by this browser.&quot;; &#125;&#125;function showPosition(position) &#123; myElement.innerHTML = &quot;Latitude: &quot; + position.coords.latitude + &quot;&lt;br&gt;Longitude: &quot; + position.coords.longitude;&#125; 第三方 API第三方 API 未内置于您的浏览器中。 要使用这些 API，您必须从 Web 下载代码。 举例： YouTube API - 允许您在网站上显示视频。 Twitter API - 允许您在网站上显示推文。 Facebook API - 允许您在网站上显示 Facebook 信息。","tags":["JavaScript"],"categories":["Language"]},{"title":"08_JavaScript_Cookies","path":"/posts/fd5ae78e.html","content":"Cookie 让您在网页中存储用户信息。 什么是 cookie？Cookie 是在您的计算机上存储在小的文本文件中的数据。 当 web 服务器向浏览器发送网页后，连接被关闭，服务器会忘记用户的一切。 Cookie 是为了解决“如何记住用户信息”而发明的： 当用户访问网页时，他的名字可以存储在 cookie 中。 下次用户访问该页面时，cookie 会“记住”他的名字。 Cookie 保存在名称值对中，如： 1username = Bill Gates 当浏览器从服务器请求一个网页时，将属于该页的 cookie 添加到该请求中。这样服务器就获得了必要的数据来“记住”用户的信息。 如果浏览器已关闭本地 cookie 支持，则以下实例均无法工作。 通过 JavaScript 创建 cookieJavaScript 可以用 document.cookie 属性创建、读取、删除 cookie。 通过 JavaScript，可以这样创建 cookie： 1document.cookie = &quot;username=Bill Gates&quot;; 您还可以添加有效日期（UTC 时间）。默认情况下，在浏览器关闭时会删除 cookie： 1document.cookie = &quot;username=Bill Gates; expires=Sun, 31 Dec 2017 12:00:00 UTC&quot;; 通过 path 参数，您可以告诉浏览器 cookie 属于什么路径。默认情况下，cookie 属于当前页。 1document.cookie = &quot;username=Bill Gates; expires=Sun, 31 Dec 2017 12:00:00 UTC; path=/&quot;; 通过 JavaScript 读取 cookie通过 JavaScript，可以这样读取 cookie： 1var x = document.cookie; document.cookie 会在一条字符串中返回所有 cookie，比如：cookie1&#x3D;value; cookie2&#x3D;value; cookie3&#x3D;value; 通过 JavaScript 改变 cookie通过使用 JavaScript，你可以像你创建 cookie 一样改变它： 1document.cookie = &quot;username=Steve Jobs; expires=Sun, 31 Dec 2017 12:00:00 UTC; path=/&quot;; 旧 cookie 被覆盖。 通过 JavaScript 删除 cookie删除 cookie 非常简单。 删除 cookie 时不必指定 cookie 值： 直接把 expires 参数设置为过去的日期即可： 1document.cookie = &quot;username=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;&quot;; 您应该定义 cookie 路径以确保删除正确的 cookie。 如果你不指定路径，一些浏览器不会让你删除 cookie。 Cookie 字符串document.cookie 属性看起来像一个正常的文本字符串。但它不是。 即使你向 document.cookie 写一份完整的 cookie 字符串，当再次读取时，你只能看到它的名称-值对。 如果设置了新 cookie，则旧的 cookie 不会被覆盖。新的 Cookie 会被添加到 document.cookie，所以如果你读取 document.cookie，你得到的东西会像这样： 1cookie1 = value; cookie2 = value; 如果你想找到一个指定 cookie 的值，你必须编写 JavaScript 函数来搜索 cookie 字符串中的 cookie 值。 JavaScript Cookie 实例在下面的示例中，我们将创建一个 cookie 来存储访问者的名称。 访客第一次到达网页时，会要求他填写姓名。然后将该名称存储在 cookie 中。 下次访客到达同一页时，他将收到一条欢迎消息。 例如，我们将创建 3 个JavaScript函数： 设置 cookie 值的函数 获取 cookie 值的函数 检查 cookie 值的函数 设置 cookie 的函数首先，我们创建一个函数，将访问者的名字存储在 cookie 变量中： 实例123456function setCookie(cname, cvalue, exdays) &#123; var d = new Date(); d.setTime(d.getTime() + (exdays*24*60*60*1000)); var expires = &quot;expires=&quot;+ d.toUTCString(); document.cookie = cname + &quot;=&quot; + cvalue + &quot;;&quot; + expires + &quot;;path=/&quot;;&#125; 例子解释：上面这个函数的的参数是：cookie 的名字（cname），cookie 的值（cvalue），以及知道 cookie 过期的天数（exdays）。 通过把 cookie 名称、cookie 值和过期字符串相加，该函数就设置了 cookie。 获取 cookie 的函数然后，我们创建一个函数返回指定 cookie 的值： 实例123456789101112131415function getCookie(cname) &#123; var name = cname + &quot;=&quot;; var decodedCookie = decodeURIComponent(document.cookie); var ca = decodedCookie.split(&#x27;;&#x27;); for(var i = 0; i &lt;ca.length; i++) &#123; var c = ca[i]; while (c.charAt(0) == &#x27; &#x27;) &#123; c = c.substring(1); &#125; if (c.indexOf(name) == 0) &#123; return c.substring(name.length, c.length); &#125; &#125; return &quot;&quot;;&#125; 函数解释：把 cookie 作为参数（cname）。 创建变量（name）与要搜索的文本（CNAME”&#x3D;”）。 解码 cookie 字符串，处理带有特殊字符的 cookie，例如 “$”。 用分号把 document.cookie 拆分到名为 ca（decodedCookie.split(‘;’)）的数组中。 遍历 ca 数组（i &#x3D; 0; i &lt; ca.length; i++），然后读出每个值 c &#x3D; ca[i]。 如果找到 cookie（c.indexOf(name) &#x3D;&#x3D; 0），则返回该 cookie 的值（c.substring(name.length, c.length）。 如果未找到 cookie，则返回 “”。 检测 cookie 的函数最后，我们创建检查 cookie 是否设置的函数。 如果已设置 cookie，将显示一个问候。 如果未设置 cookie，会显示一个提示框，询问用户的名字，并存储用户名 cookie 365 天，通过调用 setCookie 函数： 实例1234567891011function checkCookie() &#123; var username = getCookie(&quot;username&quot;); if (username != &quot;&quot;) &#123; alert(&quot;Welcome again &quot; + username); &#125; else &#123; username = prompt(&quot;Please enter your name:&quot;, &quot;&quot;); if (username != &quot;&quot; &amp;&amp; username != null) &#123; setCookie(&quot;username&quot;, username, 365); &#125; &#125;&#125; 现在组合起来实例123456789101112131415161718192021222324252627282930313233function setCookie(cname, cvalue, exdays) &#123; var d = new Date(); d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000)); var expires = &quot;expires=&quot;+d.toUTCString(); document.cookie = cname + &quot;=&quot; + cvalue + &quot;;&quot; + expires + &quot;;path=/&quot;;&#125;function getCookie(cname) &#123; var name = cname + &quot;=&quot;; var ca = document.cookie.split(&#x27;;&#x27;); for(var i = 0; i &lt; ca.length; i++) &#123; var c = ca[i]; while (c.charAt(0) == &#x27; &#x27;) &#123; c = c.substring(1); &#125; if (c.indexOf(name) == 0) &#123; return c.substring(name.length, c.length); &#125; &#125; return &quot;&quot;;&#125;function checkCookie() &#123; var user = getCookie(&quot;username&quot;); if (user != &quot;&quot;) &#123; alert(&quot;Welcome again &quot; + user); &#125; else &#123; user = prompt(&quot;Please enter your name:&quot;, &quot;&quot;); if (user != &quot;&quot; &amp;&amp; user != null) &#123; setCookie(&quot;username&quot;, user, 365); &#125; &#125;&#125; 上面的例子会在页面加载后运行 checkCookie() 函数。","tags":["JavaScript"],"categories":["Language"]},{"title":"07_JavaScript_Timing_事件","path":"/posts/a961a274.html","content":"JavaScript 可以在时间间隔内执行。 这就是所谓的定时事件（ Timing Events）。 Timing 事件window 对象允许以指定的时间间隔执行代码。 这些时间间隔称为定时事件。 通过 JavaScript 使用的有两个关键的方法： setTimeout(function, milliseconds) 在等待指定的毫秒数后执行函数。 setInterval(function, milliseconds) 等同于 setTimeout()，但持续重复执行该函数。 setTimeout() 和 setInterval() 都属于 HTML DOM Window 对象的方法。 setTimeout() 方法1window.setTimeout(function, milliseconds); window.setTimeout() 方法可以不带 window 前缀来编写。 第一个参数是要执行的函数。 第二个参数指示执行之前的毫秒数。 实例单击按钮。等待 3 秒，然后页面会提示 “Hello”： 1234567&lt;button onclick=&quot;setTimeout(myFunction, 3000)&quot;&gt;试一试&lt;/button&gt;&lt;script&gt;function myFunction() &#123; alert(&#x27;Hello&#x27;); &#125;&lt;/script&gt; 如何停止执行？clearTimeout() 方法停止执行 setTimeout() 中规定的函数。 1window.clearTimeout(timeoutVariable) window.clearTimeout() 方法可以不带 window 前缀来写。 clearTimeout() 使用从 setTimeout() 返回的变量： 12myVar = setTimeout(function, milliseconds);clearTimeout(myVar); 实例类似上例，但是添加了“停止”按钮： 123&lt;button onclick=&quot;myVar = setTimeout(myFunction, 3000)&quot;&gt;试一试&lt;/button&gt;&lt;button onclick=&quot;clearTimeout(myVar)&quot;&gt;停止执行&lt;/button&gt; setInterval() 方法setInterval() 方法在每个给定的时间间隔重复给定的函数。 1window.setInterval(function, milliseconds); window.setInterval() 方法可以不带 window 前缀来写。 第一个参数是要执行的函数。 第二个参数每个执行之间的时间间隔的长度。 本例每秒执行一次函数 “myTimer”（就像数字手表）。 实例显示当前时间： 123456var myVar = setInterval(myTimer, 1000); function myTimer() &#123; var d = new Date(); document.getElementById(&quot;demo&quot;).innerHTML = d.toLocaleTimeString();&#125; 一秒有 1000 毫秒。 如何停止执行？clearInterval() 方法停止 setInterval() 方法中指定的函数的执行。 1window.clearInterval(timerVariable) window.clearInterval() 方法可以不带 window 前缀来写。 clearInterval() 方法使用从 setInterval() 返回的变量： 12myVar = setInterval(function, milliseconds);clearInterval(myVar); 实例类似上例，但是我们添加了一个“停止时间”按钮： 1234567891011&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;button onclick=&quot;clearInterval(myVar)&quot;&gt;停止时间&lt;/button&gt;&lt;script&gt;var myVar = setInterval(myTimer, 1000); function myTimer() &#123; var d = new Date(); document.getElementById(&quot;demo&quot;).innerHTML = d.toLocaleTimeString();&#125;&lt;/script&gt;","tags":["JavaScript"],"categories":["Language"]},{"title":"06_JavaScript_弹出框","path":"/posts/434c99a2.html","content":"JavaScript 有三种类型的弹出框：警告框、确认框和提示框。 警告框如果要确保信息传递给用户，通常会使用警告框。 当警告框弹出时，用户将需要单击“确定”来继续。 语法1window.alert(&quot;sometext&quot;); window.alert() 方法可以不带 window 前缀来写。 实例1alert(&quot;我是一个警告框！&quot;); 确认框如果您希望用户验证或接受某个东西，则通常使用“确认”框。 当确认框弹出时，用户将不得不单击“确定”或“取消”来继续进行。 如果用户单击“确定”，该框返回 true。如果用户单击“取消”，该框返回 false。 语法1window.confirm(&quot;sometext&quot;); window.confirm() 方法可以不带 window 前缀来编写。 实例123456var r = confirm(&quot;请按按钮&quot;);if (r == true) &#123; x = &quot;您按了确认！&quot;;&#125; else &#123; x = &quot;您按了取消！&quot;;&#125; 提示框如果您希望用户在进入页面前输入值，通常会使用提示框。 当提示框弹出时，用户将不得不输入值后单击“确定”或点击“取消”来继续进行。 如果用户单击“确定”，该框返回输入值。如果用户单击“取消”，该框返回 NULL。 语法1window.prompt(&quot;sometext&quot;,&quot;defaultText&quot;); window.prompt() 方法可以不带 window 前缀来编写。 实例1234var person = prompt(&quot;请输入您的姓名&quot;, &quot;比尔盖茨&quot;);if (person != null) &#123; document.getElementById(&quot;demo&quot;).innerHTML = &quot;你好 &quot; + person + &quot;！今天过的怎么样？&quot;;&#125; 折行如需在弹出框中显示折行，请在反斜杠后面加一个字符 n。 实例1alert(&quot;Hello How are you?&quot;);","tags":["JavaScript"],"categories":["Language"]},{"title":"05_JavaScript_Window_Navigator","path":"/posts/9e8ed782.html","content":"window.navigator 对象包含有关访问者的信息。 Window Navigatorwindow.navigator 对象可以不带 window 前缀来写。 一些例子： navigator.appName navigator.appCodeName navigator.platform 浏览器 CookiecookieEnabled 属性返回 true，如果 cookie 已启用，否则返回 false： 实例12345&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;document.getElementById(&quot;demo&quot;).innerHTML = &quot;cookiesEnabled is &quot; + navigator.cookieEnabled;&lt;/script&gt; 浏览器应用程序名称appName 属性返回浏览器的应用程序名称： 实例12345&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;document.getElementById(&quot;demo&quot;).innerHTML = &quot;navigator.appName is &quot; + navigator.appName;&lt;/script&gt; 很陌生吧，”Netscape” 是 IE11、Chrome、Firefox 以及 Safari 的应用程序名称的统称。 浏览器应用程序代码名称appCodeName 属性返回浏览器的应用程序代码名称： 实例12345&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;document.getElementById(&quot;demo&quot;).innerHTML = &quot;navigator.appCodeName is &quot; + navigator.appCodeName;&lt;/script&gt; “Mozilla” 是 Chrome、Firefox、IE、Safari 以及 Opera 的应用程序代码名称。 浏览器引擎product 属性返回浏览器引擎的产品名称： 实例12345&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;document.getElementById(&quot;demo&quot;).innerHTML = &quot;navigator.product is &quot; + navigator.product;&lt;/script&gt; 浏览器版本appVersion 属性返回有关浏览器的版本信息： 实例12345&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;document.getElementById(&quot;demo&quot;).innerHTML = navigator.appVersion;&lt;/script&gt; 浏览器代理userAgent 属性返回由浏览器发送到服务器的用户代理报头（user-agent header）： 实例12345&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;document.getElementById(&quot;demo&quot;).innerHTML = navigator.userAgent;&lt;/script&gt; 警告！！！来自 navigator 对象的信息通常是误导性的，不应该用于检测浏览器版本，因为： 不同浏览器能够使用相同名称 导航数据可被浏览器拥有者更改 某些浏览器会错误标识自身以绕过站点测试 浏览器无法报告发布晚于浏览器的新操作系统 浏览器平台platform 属性返回浏览器平台（操作系统）： 实例12345&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;document.getElementById(&quot;demo&quot;).innerHTML = navigator.platform;&lt;/script&gt; 浏览器语言language 属性返回浏览器语言： 实例12345&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;document.getElementById(&quot;demo&quot;).innerHTML = navigator.language;&lt;/script&gt; 浏览器是否在线？onLine 属性返回 true，假如浏览器在线： 实例12345&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;document.getElementById(&quot;demo&quot;).innerHTML = navigator.onLine;&lt;/script&gt; Java 是否启用？javaEnabled() 方法返回 true，如果 Java 已启用： 实例12345&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;document.getElementById(&quot;demo&quot;).innerHTML = navigator.javaEnabled();&lt;/script&gt;","tags":["JavaScript"],"categories":["Language"]},{"title":"04_JavaScript_Window_History","path":"/posts/6854ee37.html","content":"window.history 对象包含浏览器历史。 Window Historywindow.history 对象可不带 window 书写。 为了保护用户的隐私，JavaScript 访问此对象存在限制。 一些方法： history.back() - 等同于在浏览器点击后退按钮 history.forward() - 等同于在浏览器中点击前进按钮 Window History Backhistory.back() 方法加载历史列表中前一个 URL。 这等同于在浏览器中点击后退按钮。 实例在页面中创建后退按钮： 1234567891011121314&lt;html&gt;&lt;head&gt;&lt;script&gt;function goBack() &#123; window.history.back() &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; value=&quot;Back&quot; onclick=&quot;goBack()&quot;&gt;&lt;/body&gt;&lt;/html&gt; Window History Forwardhistory forward() 方法加载历史列表中下一个 URL。 这等同于在浏览器中点击前进按钮。 实例在页面中创建前进按钮： 1234567891011121314&lt;html&gt;&lt;head&gt;&lt;script&gt;function goForward() &#123; window.history.forward() &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; value=&quot;Forward&quot; onclick=&quot;goForward()&quot;&gt;&lt;/body&gt;&lt;/html&gt;","tags":["JavaScript"],"categories":["Language"]},{"title":"03_JavaScript_Window_Location","path":"/posts/36ba911.html","content":"window.location 对象可用于获取当前页面地址（URL）并把浏览器重定向到新页面。 Window Locationwindow.location 对象可不带 window 前缀书写。 一些例子： window.location.href 返回当前页面的 href (URL) window.location.hostname 返回 web 主机的域名 window.location.pathname 返回当前页面的路径或文件名 window.location.protocol 返回使用的 web 协议（http: 或 https:） window.location.assign 加载新文档 Window Location Hrefwindow.location.href 属性返回当前页面的 URL。 实例显示当前页面的 href (URL)： 1document.getElementById(&quot;demo&quot;).innerHTML = &quot;页面位置是 &quot; + window.location.href; 结果是： 1页面位置是 http://www.w3school.com.cn/js/js_window_location.asp Window Location 主机名window.location.hostname 属性返回（当前页面的）因特网主机的名称。 实例显示主机的名称： 1document.getElementById(&quot;demo&quot;).innerHTML = &quot;页面主机名是 &quot; + window.location.hostname; 结果是： 1页面主机名是 www.w3school.com.cn Window Location 路径名window.location.pathname 属性返回当前页面的路径名。 实例显示当前 URL 的路径名： 1document.getElementById(&quot;demo&quot;).innerHTML = &quot;页面路径是 &quot; + window.location.pathname; 结果是： 1页面路径是 /js/js_window_location.asp Window Location 协议window.location.protocol 属性返回页面的 web 协议。 实例显示 web 协议： 1document.getElementById(&quot;demo&quot;).innerHTML = &quot;页面协议是 &quot; + window.location.protocol; 结果是： 1页面协议是 http: Window Location 端口window.location.port 属性返回（当前页面的）互联网主机端口的编号。 实例显示主机的端口号： 1document.getElementById(&quot;demo&quot;).innerHTML = &quot;端口号是： &quot; + window.location.port; 大多数浏览器不会显示默认端口号（http 为 80，https 为 443）。 Window Location Assignwindow.location.assign() 方法加载新文档。 实例加载新文档： 1234567891011121314&lt;html&gt;&lt;head&gt;&lt;script&gt;function newDoc() &#123; window.location.assign(&quot;https://www.w3school.com.cn&quot;) &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; value=&quot;Load new document&quot; onclick=&quot;newDoc()&quot;&gt;&lt;/body&gt;&lt;/html&gt;","tags":["JavaScript"],"categories":["Language"]},{"title":"02_JavaScript_Window_Screen","path":"/posts/d1fe9222.html","content":"window.screen 对象包含用户屏幕的信息。 Window Screenwindow.screen 对象不带 window 前缀也可以写： 属性： screen.width screen.height screen.availWidth screen.availHeight screen.colorDepth screen.pixelDepth Window Screen 宽度screen.width 属性返回以像素计的访问者屏幕宽度。 实例显示以像素计的屏幕宽度： 1document.getElementById(&quot;demo&quot;).innerHTML = &quot;Screen Width: &quot; + screen.width; 结果将是： 1Screen Width: 1920 Window Screen 高度screen.height 属性返回以像素计的访问者屏幕的高度。 实例显示以像素计的屏幕高度： 1document.getElementById(&quot;demo&quot;).innerHTML = &quot;Screen Height: &quot; + screen.height; 结果将是： 1Screen Height: 1080 Window Screen 可用宽度screen.availWidth 属性返回访问者屏幕的宽度，以像素计，减去诸如窗口工具条之类的界面特征。 实例显示以像素计的屏幕可用宽度： 1document.getElementById(&quot;demo&quot;).innerHTML = &quot;Available Screen Width: &quot; + screen.availWidth; 结果将是： 1Available Screen Width: 1920 Window Screen 可用高度screen.availHeight 属性返回访问者屏幕的高度，以像素计，减去诸如窗口工具条之类的界面特征。 实例显示以像素计的屏幕可用高度： 1document.getElementById(&quot;demo&quot;).innerHTML = &quot;Available Screen Height: &quot; + screen.availHeight; 结果将是： 1Available Screen Height: 1040 Window Screen 色深screen.colorDepth 属性返回用于显示一种颜色的比特数。 所有现代计算机都使用 24 位或 32 位硬件的色彩分辨率： 24 bits &#x3D;16,777,216 种不同的 “True Colors” 32 bits &#x3D; 4,294,967,296 中不同的 “Deep Colors” 更老的计算机使用 14 位：65,536 种不同的 “High Colors” 分辨率。 异常古老的计算机，以及老式的手机使用 8 位：256 中不同的 “VGA colors”。 实例显示以位计的屏幕色彩深度： 1document.getElementById(&quot;demo&quot;).innerHTML = &quot;Screen Color Depth: &quot; + screen.colorDepth; 结果将是： 1Screen Color Depth: 24 HTML 中使用的 #rrggbb (rgb) 值代表 “True Colors” （16,777,216 中不同的颜色）。 Window Screen 像素深度screen.pixelDepth 属性返回屏幕的像素深度。 实例显示以位计的屏幕像素深度： 1document.getElementById(&quot;demo&quot;).innerHTML = &quot;Screen Pixel Depth: &quot; + screen.pixelDepth; 结果将是： 1Screen Pixel Depth: 24 对于现代计算机，颜色深度和像素深度是相等的。","tags":["JavaScript"],"categories":["Language"]},{"title":"01_JavaScript_Window_-_浏览器对象模型","path":"/posts/de742218.html","content":"浏览器对象模型（Browser Object Model (BOM)）允许 JavaScript 与浏览器对话。 浏览器对象模型（Browser Object Model (BOM)）不存在浏览器对象模型（BOM）的官方标准。 现代的浏览器已经（几乎）实现了 JavaScript 交互相同的方法和属性，因此它经常作为 BOM 的方法和属性被提到。 Window 对象所有浏览器都支持 window 对象。它代表浏览器的窗口。 所有全局 JavaScript 对象，函数和变量自动成为 window 对象的成员。 全局变量是 window 对象的属性。 全局函数是 window 对象的方法。 甚至（HTML DOM 的）document 对象也是 window 对象属性： 1window.document.getElementById(&quot;header&quot;); 等同于： 1document.getElementById(&quot;header&quot;); 窗口尺寸两个属性可用用于确定浏览器窗口的尺寸。 这两个属性都以像素返回尺寸： window.innerHeight - 浏览器窗口的内高度（以像素计） window.innerWidth - 浏览器窗口的内宽度（以像素计） 浏览器窗口（浏览器视口）不包括工具栏和滚动条。 对于 Internet Explorer 8, 7, 6, 5： document.documentElement.clientHeight document.documentElement.clientWidth 或 document.body.clientHeight document.body.clientWidth 一个实用的 JavaScript 解决方案（包括所有浏览器）： 实例1234567var w = window.innerWidth|| document.documentElement.clientWidth|| document.body.clientWidth;var h = window.innerHeight|| document.documentElement.clientHeight|| document.body.clientHeight; 该例显示浏览器窗口的高度和宽度：（不包括工具栏和滚动条） 其他窗口方法一些其他方法： window.open() - 打开新窗口 window.close() - 关闭当前窗口 window.moveTo() -移动当前窗口 window.resizeTo() -重新调整当前窗口","tags":["JavaScript"],"categories":["Language"]},{"title":"14_JavaScript_HTML_DOM_节点列表","path":"/posts/9e3be64b.html","content":"HTML DOM NodeList 对象NodeList 对象是从文档中提取的节点列表（集合）。 NodeList 对象与 HTMLCollection 对象几乎相同。 如使用 getElementsByClassName() 方法，某些（老的）浏览器会返回 NodeList 对象而不是 HTMLCollection。 所有浏览器都会为 childNodes 属性返回 NodeList 对象。 大多数浏览器会为 querySelectorAll() 方法返回 NodeList 对象。 下面的代码选取文档中的所有 节点： 实例1var myNodeList = document.querySelectorAll(&quot;p&quot;); NodeList 中的元素可通过索引号进行访问。 如需访问第二个 节点，您可以这样写： 1y = myNodeList[1]; 注释：索引从 0 开始。 HTML DOM Node List 长度length 属性定义节点列表中的节点数： 实例12var myNodelist = document.querySelectorAll(&quot;p&quot;);document.getElementById(&quot;demo&quot;).innerHTML = myNodelist.length; 例子解释： 创建所有 元素的列表 显示该列表的长度 length 属性在您希望遍历节点列表中的节点时很有用： 实例改变节点列表中所有 元素的背景色： 12345var myNodelist = document.querySelectorAll(&quot;p&quot;);var i;for (i = 0; i &lt; myNodelist.length; i++) &#123; myNodelist[i].style.backgroundColor = &quot;red&quot;;&#125; HTMLCollection 与 NodeList 的区别HTMLCollection（前一章）是 HTML 元素的集合。 NodeList 是文档节点的集合。 NodeList 和 HTML 集合几乎完全相同。 HTMLCollection 和 NodeList 对象都是类数组的对象列表（集合）。 它们都有定义列表（集合）中项目数的 length 属性。 它们都可以通过索引 (0, 1, 2, 3, 4, …) 像数组那样访问每个项目。 访问 HTMLCollection 项目，可以通过它们的名称、id 或索引号。 访问 NodeList 项目，只能通过它们的索引号。 只有 NodeList 对象能包含属性节点和文本节点。 节点列表不是数组！ 节点数组看起来像数组，但并不是。 您能够遍历节点列表并像数组那样引用其节点。 不过，您无法对节点列表使用数组方法，比如 valueOf()、push()、pop() 或 join()。","tags":["JavaScript"],"categories":["Language"]},{"title":"13_JavaScript_HTML_DOM_集合","path":"/posts/bc26fe1a.html","content":"HTMLCollection 对象getElementsByTagName() 方法返回 HTMLCollection 对象。 HTMLCollection 对象是类数组的 HTML 元素列表（集合）。 下面的代码选取文档中的所有 元素： 实例1var x = document.getElementsByTagName(&quot;p&quot;); 该集合中的元素可通过索引号进行访问。 如需访问第二个 元素，您可以这样写： 1y = x[1]; 注释：索引从 0 开始。 HTML HTMLCollection 长度length 属性定义了 HTMLCollection 中元素的数量： 实例12var myCollection = document.getElementsByTagName(&quot;p&quot;);document.getElementById(&quot;demo&quot;).innerHTML = myCollection.length; 实例解释： 创建所有 元素的集合 显示集合的长度 length 属性在您需要遍历集合中元素时是有用的： 实例改变所有 元素的背景色： 12345var myCollection = document.getElementsByTagName(&quot;p&quot;);var i;for (i = 0; i &lt; myCollection.length; i++) &#123; myCollection[i].style.backgroundColor = &quot;red&quot;;&#125; HTMLCollection 并非数组！HTMLCollection 也许看起来像数组，但并非数组。 您能够遍历列表并通过数字引用元素（就像数组那样）。 不过，您无法对 HTMLCollection 使用数组方法，比如 valueOf()、pop()、push() 或 join()。","tags":["JavaScript"],"categories":["Language"]},{"title":"12_JavaScript_HTML_DOM_元素（节点）","path":"/posts/b897ba9b.html","content":"添加和删除节点（HTML 元素） 创建新 HTML 元素（节点）如需向 HTML DOM 添加新元素，您必须首先创建这个元素（元素节点），然后将其追加到已有元素。 实例12345678910111213&lt;div id=&quot;div1&quot;&gt;&lt;p id=&quot;p1&quot;&gt;这是一个段落。&lt;/p&gt;&lt;p id=&quot;p2&quot;&gt;这是另一个段落。&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var para = document.createElement(&quot;p&quot;);var node = document.createTextNode(&quot;这是新文本。&quot;);para.appendChild(node);var element = document.getElementById(&quot;div1&quot;);element.appendChild(para);&lt;/script&gt; 例子解释这段代码创建了一个新的 &lt;p&gt; 元素： 1var para = document.createElement(&quot;p&quot;); 如需向 &lt;p&gt; 元素添加文本，则必须首先创建文本节点。这段代码创建了一个文本节点： 1var node = document.createTextNode(&quot;这是一个新段落。&quot;); 然后您需要向 &lt;p&gt; 元素追加这个文本节点： 1para.appendChild(node); 最后您需要向已有元素追加这个新元素。 这段代码查找一个已有的元素： 1var element = document.getElementById(&quot;div1&quot;); 这段代码向这个已有的元素追加新元素： 1element.appendChild(para); 创建新 HTML 元素 - insertBefore()前面例子中的 appendChild() 方法，追加新元素作为父的最后一个子。 除此之外您还可以使用 insertBefore() 方法： 实例1234567891011121314&lt;div id=&quot;div1&quot;&gt;&lt;p id=&quot;p1&quot;&gt;这是一个段落。&lt;/p&gt;&lt;p id=&quot;p2&quot;&gt;这是另一个段落。&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var para = document.createElement(&quot;p&quot;);var node = document.createTextNode(&quot;这是新文本。&quot;);para.appendChild(node);var element = document.getElementById(&quot;div1&quot;);var child = document.getElementById(&quot;p1&quot;);element.insertBefore(para, child);&lt;/script&gt; 删除已有 HTML 元素如需删除 HTML 元素，请使用 remove() 方法： 实例12345678&lt;div&gt; &lt;p id=&quot;p1&quot;&gt;This is a paragraph.&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;This is another paragraph.&lt;/p&gt;&lt;/div&gt;&lt;script&gt;const elmnt = document.getElementById(&quot;p1&quot;); elmnt.remove();&lt;/script&gt; 例子解释这个 HTML 文档包含一个带有两个子节点（两个 &lt;p&gt; 元素）的 &lt;div&gt; 元素： 1234&lt;div&gt; &lt;p id=&quot;p1&quot;&gt;This is a paragraph.&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;This is another paragraph.&lt;/p&gt;&lt;/div&gt; 找到需要删除的元素： 1const elmnt = document.getElementById(&quot;p1&quot;); 然后对该元素执行 remove() 方法： 1elmnt.remove(); 注意：remove() 方法在旧浏览器中不起作用，请参阅下面的例子，了解如何改用 removeChild()。 删除子节点对于不支持 remove() 方法的浏览器，您必须找到父节点才能删除一个元素： 实例12345678910&lt;div id=&quot;div1&quot;&gt; &lt;p id=&quot;p1&quot;&gt;This is a paragraph.&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;This is another paragraph.&lt;/p&gt;&lt;/div&gt;&lt;script&gt;const parent = document.getElementById(&quot;div1&quot;);const child = document.getElementById(&quot;p1&quot;);parent.removeChild(child);&lt;/script&gt; 例子解释此 HTML 文档包含一个带有两个子节点（两个 &lt;p&gt; 元素）的 &lt;div&gt; 元素： 1234&lt;div id=&quot;div1&quot;&gt; &lt;p id=&quot;p1&quot;&gt;This is a paragraph.&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;This is another paragraph.&lt;/p&gt;&lt;/div&gt; 找到 id=&quot;div1&quot; 的元素： 1const parent = document.getElementById(&quot;div1&quot;); 找到 id=&quot;p1&quot; 的 &lt;p&gt; 元素： 1const child = document.getElementById(&quot;p1&quot;); 从父元素中删除子： 1parent.removeChild(child); 这是一个常见的解决方法：找到要删除的子节点，并使用其 parentNode 属性找到父节点： 12const child = document.getElementById(&quot;p1&quot;);child.parentNode.removeChild(child); 替换 HTML 元素如需替换元素的，请使用 replaceChild() 方法： 实例1234567891011121314&lt;div id=&quot;div1&quot;&gt;&lt;p id=&quot;p1&quot;&gt;这是一个段落。&lt;/p&gt;&lt;p id=&quot;p2&quot;&gt;这是另一个段落。&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var para = document.createElement(&quot;p&quot;);var node = document.createTextNode(&quot;这是新文本。&quot;);para.appendChild(node);var parent = document.getElementById(&quot;div1&quot;);var child = document.getElementById(&quot;p1&quot;);parent.replaceChild(para, child);&lt;/script&gt;","tags":["JavaScript"],"categories":["Language"]},{"title":"10_JavaScript_HTML_DOM_事件监听程序","path":"/posts/9f0ec037.html","content":"addEventListener() 方法实例添加当用户点击按钮时触发的事件监听器： 1document.getElementById(&quot;myBtn&quot;).addEventListener(&quot;click&quot;, displayDate); addEventListener() 方法为指定元素指定事件处理程序。 addEventListener() 方法为元素附加事件处理程序而不会覆盖已有的事件处理程序。 您能够向一个元素添加多个事件处理程序。 您能够向一个元素添加多个相同类型的事件处理程序，例如两个 “click” 事件。 您能够向任何 DOM 对象添加事件处理程序而非仅仅 HTML 元素，例如 window 对象。 addEventListener() 方法使我们更容易控制事件如何对冒泡作出反应。 当使用 addEventListener() 方法时，JavaScript 与 HTML 标记是分隔的，已达到更佳的可读性；即使在不控制 HTML 标记时也允许您添加事件监听器。 您能够通过使用 removeEventListener() 方法轻松地删除事件监听器。 语法1element.addEventListener(event, function, useCapture); 第一个参数是事件的类型（比如 “click” 或 “mousedown”）。 第二个参数是当事件发生时我们需要调用的函数。 第三个参数是布尔值，指定使用事件冒泡还是事件捕获。此参数是可选的。 注意：请勿对事件使用 “on” 前缀；请使用 “click” 代替 “onclick”。 向元素添加事件处理程序实例当用户点击某个元素时提示 “Hello World!”： 1element.addEventListener(&quot;click&quot;, function()&#123; alert(&quot;Hello World!&quot;); &#125;); 您也可以引用外部“命名”函数： 实例当用户点击某个元素时提示 “Hello World!”： 12345element.addEventListener(&quot;click&quot;, myFunction);function myFunction() &#123; alert (&quot;Hello World!&quot;);&#125; 向相同元素添加多个事件处理程序addEventListener() 方法允许您向相同元素添加多个事件，同时不覆盖已有事件： 实例12element.addEventListener(&quot;click&quot;, myFunction);element.addEventListener(&quot;click&quot;, mySecondFunction); 您能够向相同元素添加不同类型的事件： 实例123element.addEventListener(&quot;mouseover&quot;, myFunction);element.addEventListener(&quot;click&quot;, mySecondFunction);element.addEventListener(&quot;mouseout&quot;, myThirdFunction); 向 Window 对象添加事件处理程序addEventListener() 允许您将事件监听器添加到任何 HTML DOM 对象上，比如 HTML 元素、HTML 对象、window 对象或其他支持事件的对象，比如 xmlHttpRequest 对象。 实例添加当用户调整窗口大小时触发的事件监听器： 123window.addEventListener(&quot;resize&quot;, function()&#123; document.getElementById(&quot;demo&quot;).innerHTML = sometext;&#125;); 传递参数当传递参数值时，请以参数形式使用调用指定函数的“匿名函数”： 实例1element.addEventListener(&quot;click&quot;, function()&#123; myFunction(p1, p2); &#125;); 事件冒泡还是事件捕获？在 HTML DOM 中有两种事件传播的方法：冒泡和捕获。 事件传播是一种定义当发生事件时元素次序的方法。假如 元素内有一个 ，然后用户点击了这个 元素，应该首先处理哪个元素“click”事件？ 在冒泡中，最内侧元素的事件会首先被处理，然后是更外侧的：首先处理 元素的点击事件，然后是 元素的点击事件。 在捕获中，最外侧元素的事件会首先被处理，然后是更内侧的：首先处理 元素的点击事件，然后是 元素的点击事件。 在 addEventListener() 方法中，你能够通过使用“useCapture”参数来规定传播类型： 1addEventListener(event, function, useCapture); 默认值是 false，将使用冒泡传播，如果该值设置为 true，则事件使用捕获传播。 实例12document.getElementById(&quot;myP&quot;).addEventListener(&quot;click&quot;, myFunction, true);document.getElementById(&quot;myDiv&quot;).addEventListener(&quot;click&quot;, myFunction, true); removeEventListener() 方法removeEventListener() 方法会删除已通过 addEventListener() 方法附加的事件处理程序： 实例1element.removeEventListener(&quot;mousemove&quot;, myFunction); 浏览器支持表格中的数字规定了完全支持这些方法的首个浏览器版本。 方法 addEventListener() 1.0 9.0 1.0 1.0 7.0 removeEventListener() 1.0 9.0 1.0 1.0 7.0 注释：IE 8、Opera 6.0 及其更早版本不支持 addEventListener() 和 removeEventListener() 方法。不过，对于这些特殊的浏览器版本，您可以使用 attachEvent() 方法向元素添加事件处理程序，并由 detachEvent() 方法删除： 12element.attachEvent(event, function);element.detachEvent(event, function); 实例跨浏览器解决方案： 123456var x = document.getElementById(&quot;myBtn&quot;);if (x.addEventListener) &#123; // 针对主流浏览器，除了 IE 8 及更正版本 x.addEventListener(&quot;click&quot;, myFunction);&#125; else if (x.attachEvent) &#123; // 针对 IE 8 及更早版本 x.attachEvent(&quot;onclick&quot;, myFunction);&#125;","tags":["JavaScript"],"categories":["Language"]},{"title":"09_JavaScript_HTML_DOM_事件","path":"/posts/d56372ae.html","content":"HTML DOM 允许 JavaScript 对 HTML 事件作出反应 对事件作出反应JavaScript 能够在事件发生时执行，比如当用户点击某个 HTML 元素时。 为了在用户点击元素时执行代码，请向 HTML 事件属性添加 JavaScript 代码： 1onclick=JavaScript HTML 事件的例子： 当用户点击鼠标时 当网页加载后 当图像加载后 当鼠标移至元素上时 当输入字段被改变时 当 HTML 表单被提交时 当用户敲击按键时 在本例中，当用户点击 &lt;h1&gt; 时，会改变其内容： 实例12345678&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1 onclick=&quot;this.innerHTML = &#x27;Hello!&#x27;&quot;&gt;点击此文本！&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 在本例中，从事件处理程序调用函数： 实例1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1 onclick=&quot;changeText(this)&quot;&gt;点击此文本！&lt;/h1&gt;&lt;script&gt;function changeText(id) &#123; id.innerHTML = &quot;Hello:)&quot;;&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; HTML 事件属性如需向 HTML 元素分配事件，您能够使用事件属性。 实例向 button 元素分配 onclick 事件： 1&lt;button onclick=&quot;displayDate()&quot;&gt;试一试&lt;/button&gt; 在上例中，名为 displayDate 的函数会在按钮被点击时执行。 使用 HTML DOM 分配事件HTML DOM 允许您使用 JavaScript 向 HTML 元素分配事件： 实例为 button 元素指定 onclick 事件： 123&lt;script&gt;document.getElementById(&quot;myBtn&quot;).onclick = displayDate;&lt;/script&gt; 在上例中，名为 displayDate 的函数被分配到 id&#x3D;”myBtn” 的 HTML 元素。 当点击按钮时将执行函数。 onload 和 onunload 事件当用户进入后及离开页面时，会触发 onload 和 onunload 事件。 onload 事件可用于检测访问者的浏览器类型和浏览器版本，然后基于该信息加载网页的恰当版本。 onload 和 onunload 事件可用于处理 cookie。 实例1&lt;body onload=&quot;checkCookies()&quot;&gt; onchange 事件onchange 事件经常与输入字段验证结合使用。 下面是一个如何使用 onchange 的例子。当用户改变输入字段内容时，会调用 upperCase() 函数。 实例1&lt;input type=&quot;text&quot; id=&quot;fname&quot; onchange=&quot;upperCase()&quot;&gt; onmouseover 和 onmouseout 事件onmouseover 和 onmouseout 事件可用于当用户将鼠标移至 HTML 元素上或移出时触发某个函数： 实例123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;div onmouseover=&quot;mOver(this)&quot; onmouseout=&quot;mOut(this)&quot; style=&quot;background-color:#D94A38;width:120px;height:20px;padding:40px;&quot;&gt;请把鼠标移上来&lt;/div&gt;&lt;script&gt;function mOver(obj) &#123; obj.innerHTML = &quot;谢谢您&quot;&#125;function mOut(obj) &#123; obj.innerHTML = &quot;请把鼠标移上来&quot;&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; onmousedown, onmouseup 以及 onclick 事件onmousedown, onmouseup 以及 onclick 事件构成了完整的鼠标点击事件。 首先当鼠标按钮被点击时，onmousedown 事件被触发；然后当鼠标按钮被释放时，onmouseup 事件被触发；最后，当鼠标点击完成后，onclick 事件被触发。 实例12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;div onmousedown=&quot;mDown(this)&quot; onmouseup=&quot;mUp(this)&quot;style=&quot;background-color:#D94A38;width:90px;height:20px;padding:40px;&quot;&gt;点击鼠标&lt;/div&gt;&lt;script&gt;function mDown(obj) &#123; obj.style.backgroundColor = &quot;#1ec5e5&quot;; obj.innerHTML = &quot;松开鼠标&quot;;&#125;function mUp(obj) &#123; obj.style.backgroundColor=&quot;#D94A38&quot;; obj.innerHTML=&quot;谢谢您&quot;;&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 更多实例 onmousedown 和 onmouseup 当用户按下鼠标按钮时改变图像。 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script&gt;function lighton() &#123; document.getElementById(&#x27;myimage&#x27;).src = &quot;/i/eg_bulbon.gif&quot;;&#125;function lightoff() &#123; document.getElementById(&#x27;myimage&#x27;).src = &quot;/i/eg_bulboff.gif&quot;;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;img id=&quot;myimage&quot; onmousedown=&quot;lighton()&quot; onmouseup=&quot;lightoff()&quot; src=&quot;/i/eg_bulboff.gif&quot; /&gt;&lt;p&gt;点击鼠标并按住！&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; onload 当页面已完成加载时显示报警框。 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body onload=&quot;checkCookies()&quot;&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;function checkCookies() &#123; var text = &quot;&quot;; if (navigator.cookieEnabled == true) &#123; text = &quot;Cookie 已启用&quot;; &#125; else &#123; text = &quot;Cookie 未启用&quot;; &#125; document.getElementById(&quot;demo&quot;).innerHTML = text;&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; onfocus 当输入字段获得焦点时改变其背景色。 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script&gt;function myFunction(x) &#123; x.style.background = &quot;yellow&quot;;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;请输入您的名字：&lt;input type=&quot;text&quot; onfocus=&quot;myFunction(this)&quot;&gt;&lt;p&gt;当输入字段获得焦点时，将触发一个更改背景颜色的函数。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 鼠标事件 当指针移动到元素上时改变其颜色。 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1 onmouseover=&quot;style.color=&#x27;red&#x27;&quot;onmouseout=&quot;style.color=&#x27;black&#x27;&quot;&gt;鼠标移动到此文本上&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; HTML DOM Event 对象参考手册如需所有 HTML DOM 事件的列表，请访问我们完整的 HTML DOM 事件对象参考手册。","tags":["JavaScript"],"categories":["Language"]},{"title":"08_JavaScript_HTML_DOM_动画","path":"/posts/62c71ec9.html","content":"学习使用 JavaScript 来创建 HTML 动画。 基础页面为了演示如何通过 JavaScript 来创建 HTML 动画，我们将使用一张简单的网页： 实例12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;我的第一部 JavaScript 动画&lt;/h1&gt;&lt;div id=&quot;animation&quot;&gt;我的动画在这里。&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 创建动画容器所有动画都应该与容器元素关联。 实例123&lt;div id =&quot;container&quot;&gt; &lt;div id =&quot;animate&quot;&gt;我的动画在这里。&lt;/div&gt;&lt;/div&gt; 为元素添加样式应该通过 style &#x3D; “position: relative“ 创建容器元素。 应该通过 style &#x3D; “position: absolute“ 创建动画元素。 实例123456789101112#container &#123; width: 400px; height: 400px; position: relative; background: yellow;&#125;#animate &#123; width: 50px; height: 50px; position: absolute; background: red;&#125; 动画代码JavaScript 动画是通过对元素样式进行渐进式变化编程完成的。 这种变化通过一个计数器来调用。当计数器间隔很小时，动画看上去就是连贯的。 基础代码是： 实例123456789var id = setInterval(frame, 5);function frame() &#123; if (/* 测试是否完成 */) &#123; clearInterval(id); &#125; else &#123; /* 改变元素样式的代码 */ &#125;&#125; 使用 JavaScript 创建动画实例1234567891011121314function myMove() &#123; var elem = document.getElementById(&quot;animate&quot;); var pos = 0; var id = setInterval(frame, 5); function frame() &#123; if (pos == 350) &#123; clearInterval(id); &#125; else &#123; pos++; elem.style.top = pos + &#x27;px&#x27;; elem.style.left = pos + &#x27;px&#x27;; &#125; &#125;&#125;","tags":["JavaScript"],"categories":["Language"]},{"title":"07_JavaScript_HTML_DOM_-_改变_CSS","path":"/posts/46219af.html","content":"HTML DOM 允许 JavaScript 更改 HTML 元素的样式。 改变 HTML 样式如需更改 HTML 元素的样式，请使用此语法： 1document.getElementById(id).style.property = new style 下面的例子更改了 &lt;p&gt; 元素的样式： 实例12345678910111213&lt;html&gt;&lt;body&gt;&lt;p id=&quot;p2&quot;&gt;Hello World!&lt;/p&gt;&lt;script&gt;document.getElementById(&quot;p2&quot;).style.color = &quot;blue&quot;;&lt;/script&gt;&lt;p&gt;上面的段落已被脚本改变。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 使用事件HTML DOM 允许您在事件发生时执行代码。 当“某些事情”在 HTML 元素上发生时，浏览器会生成事件： 点击某个元素时 页面加载时 输入字段被更改时 您将在本教程的下一章学到更多有关事件的知识。 本例会在用户点击按钮时，更改 id&#x3D;”id1” 的 HTML 元素的样式： 实例123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1 id=&quot;id1&quot;&gt;我的标题 1&lt;/h1&gt;&lt;button type=&quot;button&quot; onclick=&quot;document.getElementById(&#x27;id1&#x27;).style.color = &#x27;red&#x27;&quot;&gt;点击我！&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;","tags":["JavaScript"],"categories":["Language"]},{"title":"06_JavaScript_表单","path":"/posts/169018f.html","content":"JavaScript 表单验证HTML 表单验证可以通过 JavaScript 完成。 如果表单域 (fname) 为空，该函数会提示一条消息，并返回 false，以防止表单被提交： JavaScript 实例1234567function validateForm() &#123; let x = document.forms[&quot;myForm&quot;][&quot;fname&quot;].value; if (x == &quot;&quot;) &#123; alert(&quot;Name must be filled out&quot;); return false; &#125;&#125; 提交表单时可以调用该函数： HTML 表单实例1234&lt;form name=&quot;myForm&quot; action=&quot;/action_page.php&quot; onsubmit=&quot;return validateForm()&quot; method=&quot;post&quot;&gt;Name: &lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&lt;/form&gt; JavaScript 可以验证数字输入JavaScript 通常用于验证数字输入： 请输入 1 到 10 之间的数字： 提交 输入没问题 自动 HTML 表单验证HTML 表单验证可以由浏览器自动执行： 如果表单字段 (fname) 为空，则 required 属性会阻止提交此表单： HTML 表单实例1234&lt;form action=&quot;/action_page.php&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;fname&quot; required&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&lt;/form&gt; 提示：自动 HTML 表单验证在 Internet Explorer 9 或更早版本中不起作用。 数据验证数据验证是确保用户输入干净、正确和有用的过程。 典型的验证任务是： 用户是否填写了所有必填字段？ 用户是否输入了有效日期？ 用户是否在数字字段中输入了文本？ 大多数情况下，数据验证的目的是确保用户输入正确。 验证可以通过许多不同的方法定义，并以许多不同的方式部署。 服务器端验证由 Web 服务器在输入发送到服务器后执行。 在将输入发送到 Web 服务器之前，客户端验证由 Web 浏览器执行。 HTML 约束验证HTML5 引入了一种新的 HTML 验证概念，称为约束验证。 HTML 约束验证基于： 约束验证 HTML input 属性 约束验证 CSS 伪选择器 约束验证 DOM 属性和方法 约束验证 HTML input 属性 属性 描述 disabled 规定应禁用 input 元素。 max 规定 input 元素的最大值。 min 规定 input 元素的最小值。 pattern 规定 input 元素的值模式。 required 规定 input 字段必填。 type 规定 input 元素的类型。 如需完整列表，请访问 HTML Input 属性。 约束验证 CSS 伪选择器 选择器 描述 :disabled 选择规定了 “disabled” 属性的 input 元素。 :invalid 选择有无效值的 input 元素。 :optional 选择未规定 “required” 属性的 input 元素。 :required 选择规定了 “required” 属性的 input 元素。 :valid 选择具有有效值的 input 元素。 如需完整列表，请访问 CSS 伪类。","tags":["JavaScript"],"categories":["Language"]},{"title":"05_JavaScript_HTML_DOM_-_改变_HTML","path":"/posts/a947b9dc.html","content":"HTML DOM 允许 JavaScript 改变 HTML 元素的内容。 改变 HTML 输出流JavaScript 能够创建动态 HTML 内容： 1Fri May 27 2022 16:14:05 GMT+0800 (中国标准时间) 在 JavaScript 中，document.write() 可用于直接写入 HTML 输出流： 实例12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;script&gt;document.write(Date());&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 千万不要在文档加载后使用 document.write()。这么做会覆盖文档。 改变 HTML 内容修改 HTML 文档内容最简单的方法是，使用 innerHTML 属性。 如需修改 HTML 元素的内容，请使用此语法： 1document.getElementById(id).innerHTML = new text 本例修改了 &lt;p&gt; 元素的内容： 实例1234567891011&lt;html&gt;&lt;body&gt;&lt;p id=&quot;p1&quot;&gt;Hello World!&lt;/p&gt;&lt;script&gt;document.getElementById(&quot;p1&quot;).innerHTML = &quot;hello kitty!&quot;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 例子解释： 上面的 HTML 文档包含 id&#x3D;”p1” 的 &lt;p&gt; 元素 我们使用 HTML DOM 来获取 id&#x3D;”p1” 的这个元素 JavaScript 把该元素的内容（innerHTML）更改为 “Hello Kitty!” 本例修改了 &lt;h1&gt; 元素的内容： 实例12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1 id=&quot;header&quot;&gt;Old Header&lt;/h1&gt;&lt;script&gt;var element = document.getElementById(&quot;header&quot;);element.innerHTML = &quot;New Header&quot;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 例子解释： 上面的 HTML 含有 id&#x3D;”header” 的一个 &lt;h1&gt; 元素 我们使用了 HTML DOM 来获取 id&#x3D;”header” 的元素 JavaScript 更改此元素的内容（innerHTML） 改变属性的值如需修改 HTML 属性的值，请使用如下语法： 1document.getElementById(id).attribute = new value 本例修改了 &lt;img&gt; 元素的 src 属性的值： 实例123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;img id=&quot;myImage&quot; src=&quot;smiley.gif&quot;&gt;&lt;script&gt;document.getElementById(&quot;myImage&quot;).src = &quot;landscape.jpg&quot;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 例子解释： 上面的 HTML 文档含有一个 id&#x3D;”myImage” 的 &lt;img&gt; 元素 我们使用 HTML DOM 来获取 id&#x3D;”myImage” 的元素 JavaScript 把此元素的 src 属性从 “smiley.gif” 更改为 “landscape.jpg”","tags":["JavaScript"],"categories":["Language"]},{"title":"04_JavaScript_HTML_DOM_元素","path":"/posts/833d50f5.html","content":"JavaScript HTML DOM 元素本章向您讲解如何查找和访问 HTML 页面中的 HTML 元素。 查找 HTML 元素通常，通过 JavaScript，您需要操作 HTML 元素。 为了达成此目的，您需要首先找到这些元素。有好几种完成此任务的方法： 通过 id 查找 HTML 元素 通过标签名查找 HTML 元素 通过类名查找 HTML 元素 通过 CSS 选择器查找 HTML 元素 通过 HTML 对象集合查找 HTML 元素 通过 id 查找 HTML 元素DOM 中查找 HTML 元素最简单的方法是，使用元素的 id。 本例查找 id&#x3D;”intro” 的元素： 实例1var myElement = document.getElementById(&quot;intro&quot;); 如果元素被找到，此方法会以对象返回该元素（在 myElement 中）。 如果未找到元素，myElement 将包含 null。 通过标签名查找 HTML 元素本例查找所有 &lt;p&gt; 元素： 实例1var x = document.getElementsByTagName(&quot;p&quot;); 本例查找 id&#x3D;”main” 的元素，然后查找 “main” 中所有 &lt;p&gt; 元素： 实例12var x = document.getElementById(&quot;main&quot;);var y = x.getElementsByTagName(&quot;p&quot;); 通过类名查找 HTML 元素如果您需要找到拥有相同类名的所有 HTML 元素，请使用 getElementsByClassName()。 本例返回包含 class&#x3D;”intro” 的所有元素的列表： 实例1var x = document.getElementsByClassName(&quot;intro&quot;); 通过类名查找元素不适用于 Internet Explorer 8 及其更早版本。 通过 CSS 选择器查找 HTML 元素如果您需要查找匹配指定 CSS 选择器（id、类名、类型、属性、属性值等等）的所有 HTML 元素，请使用 querySelectorAll() 方法。 本例返回 class&#x3D;”intro” 的所有 &lt;p&gt; 元素列表： 实例1var x = document.querySelectorAll(&quot;p.intro&quot;); querySelectorAll() 不适用于 Internet Explorer 8 及其更早版本。 通过 HTML 对象选择器查找 HTML 对象本例查找 id&#x3D;”frm1” 的 form 元素，在 forms 集合中，然后显示所有元素值： 实例1234567var x = document.forms[&quot;frm1&quot;];var text = &quot;&quot;; var i;for (i = 0; i &lt; x.length; i++) &#123; text += x.elements[i].value + &quot;&lt;br&gt;&quot;;&#125;document.getElementById(&quot;demo&quot;).innerHTML = text; 以下 HTML 对象（和对象集合）也是可访问的： document.forms document.head document.images document.links document.scripts document.title","tags":["JavaScript"],"categories":["Language"]},{"title":"03_HTML_DOM_Document_对象","path":"/posts/12b93407.html","content":"HTML DOM 文档对象是您的网页中所有其他对象的拥有者。 HTML DOM Document 对象文档对象代表您的网页。 如果您希望访问 HTML 页面中的任何元素，那么您总是从访问 document 对象开始。 下面是一些如何使用 document 对象来访问和操作 HTML 的实例。 查找 HTML 元素 方法 描述 document.getElementById(id) 通过元素 id 来查找元素 document.getElementsByTagName(name) 通过标签名来查找元素 document.getElementsByClassName(name) 通过类名来查找元素 改变 HTML 元素 方法 描述 element.innerHTML &#x3D; new html content 改变元素的 inner HTML element.attribute &#x3D; new value 改变 HTML 元素的属性值 element.setAttribute(attribute, value) 改变 HTML 元素的属性值 element.style.property &#x3D; new style 改变 HTML 元素的样式 添加和删除元素 方法 描述 document.createElement(element) 创建 HTML 元素 document.removeChild(element) 删除 HTML 元素 document.appendChild(element) 添加 HTML 元素 document.replaceChild(element) 替换 HTML 元素 document.write(text) 写入 HTML 输出流 添加事件处理程序 方法 描述 document.getElementById(id).onclick &#x3D; function(){code} 向 onclick 事件添加事件处理程序 查找 HTML 对象首个 HTML DOM Level 1 (1998)，定义了 11 个 HTML 对象、对象集合和属性。它们在 HTML5 中仍然有效。 后来，在 HTML DOM Level 3，加入了更多对象、集合和属性。 属性 描述 DOM document.anchors 返回拥有 name 属性的所有 &lt;a&gt; 元素。 1 document.applets 返回所有 &lt;applet&gt; 元素（HTML5 不建议使用） 1 document.baseURI 返回文档的绝对基准 URI 3 document.body 返回 &lt;body&gt; 元素 1 document.cookie 返回文档的 cookie 1 document.doctype 返回文档的 doctype 3 document.documentElement 返回 &lt;html&gt; 元素 3 document.documentMode 返回浏览器使用的模式 3 document.documentURI 返回文档的 URI 3 document.domain 返回文档服务器的域名 1 document.domConfig 废弃。返回 DOM 配置 3 document.embeds 返回所有 &lt;embed&gt; 元素 3 document.forms 返回所有 &lt;form&gt;元素 1 document.head 返回 &lt;head&gt; 元素 3 document.images 返回所有 &lt;img&gt; 元素 1 document.implementation 返回 DOM 实现 3 document.inputEncoding 返回文档的编码（字符集） 3 document.lastModified 返回文档更新的日期和时间 3 document.links 返回拥有 href 属性的所有 &lt;area&gt; 和 &lt;a&gt; 元素 1 document.readyState 返回文档的（加载）状态 3 document.referrer 返回引用的 URI（链接文档） 1 document.scripts 返回所有 &lt;script&gt; 元素 3 document.strictErrorChecking 返回是否强制执行错误检查 3 document.title 返回 &lt;title&gt; 元素 1 document.URL 返回文档的完整 URL 1","tags":["JavaScript"],"categories":["Language"]},{"title":"02_JavaScript_-_HTML_DOM_方法","path":"/posts/7ed31fb4.html","content":"HTML DOM 方法是您能够（在 HTML 元素上）执行的*动作*。 HTML DOM 属性是您能够设置或改变的 HTML 元素的*值*。 DOM 编程界面HTML DOM 能够通过 JavaScript 进行访问（也可以通过其他编程语言）。 在 DOM 中，所有 HTML 元素都被定义为对象。 编程界面是每个对象的属性和方法。 属性是您能够获取或设置的值（就比如改变 HTML 元素的内容）。 方法是您能够完成的动作（比如添加或删除 HTML 元素）。 实例下面的例子改变了 id&#x3D;”demo” 的 元素的内容： 1234567891011&lt;html&gt;&lt;body&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;document.getElementById(&quot;demo&quot;).innerHTML = &quot;Hello World!&quot;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在上面的例子中，getElementById 是方法，而 innerHTML 是属性。 getElementById 方法访问 HTML 元素最常用的方法是使用元素的 id。 在上面的例子中，getElementById 方法使用 id&#x3D;”demo” 来查找元素。 innerHTML 属性获取元素内容最简单的方法是使用 innerHTML 属性。 innerHTML 属性可用于获取或替换 HTML 元素的内容。 innerHTML 属性可用于获取或改变任何 HTML 元素，包括 &lt;html&gt; 和 &lt;body&gt;。","tags":["JavaScript"],"categories":["Language"]},{"title":"04_JavaScript_Async","path":"/posts/5a2acf7c.html","content":"“async and await make promises easier to write” async 使函数返回 Promise await 使函数等待 Promise Async 语法函数前的关键字 async 使函数返回 promise： 实例123async function myFunction() &#123; return &quot;Hello&quot;;&#125; 等同于： 123async function myFunction() &#123; return Promise.resolve(&quot;Hello&quot;);&#125; 以下是使用 Promise 的方法： 1234myFunction().then( function(value) &#123; /* 成功时的代码 */ &#125;, function(error) &#123; /* 出错时的代码 */ &#125;); 实例1234567async function myFunction() &#123; return &quot;Hello&quot;;&#125;myFunction().then( function(value) &#123;myDisplayer(value);&#125;, function(error) &#123;myDisplayer(error);&#125;); 或者更简单，因为您期望正常值（正常响应，而不是错误）： 实例123456async function myFunction() &#123; return &quot;Hello&quot;;&#125;myFunction().then( function(value) &#123;myDisplayer(value);&#125;); Await 语法函数前的关键字 await 使函数等待 promise： 1let value = await promise; await 关键字只能在 async 函数中使用。 实例让我们慢慢来学习如何使用它。 基础语法12345678async function myDisplay() &#123; let myPromise = new Promise(function(myResolve, myReject) &#123; myResolve(&quot;I love You !!&quot;); &#125;); document.getElementById(&quot;demo&quot;).innerHTML = await myPromise;&#125;myDisplay(); 等待超时12345678async function myDisplay() &#123; let myPromise = new Promise(function(myResolve, myReject) &#123; setTimeout(function() &#123; myResolve(&quot;I love You !!&quot;); &#125;, 3000); &#125;); document.getElementById(&quot;demo&quot;).innerHTML = await myPromise;&#125;myDisplay(); 等待文件1234567891011121314async function getFile() &#123; let myPromise = new Promise(function(myResolve, myReject) &#123; let req = new XMLHttpRequest(); req.open(&#x27;GET&#x27;, &quot;mycar.html&quot;); req.onload = function() &#123; if (req.status == 200) &#123;myResolve(req.response);&#125; else &#123;myResolve(&quot;File not Found&quot;);&#125; &#125;; req.send(); &#125;); document.getElementById(&quot;demo&quot;).innerHTML = await myPromise;&#125;getFile(); 浏览器支持ECMAScript 2017 引入了 JavaScript 关键字 async 和 await。 下表注明了首个完全支持两者的浏览器版本： Chrome IE Firefox Safari Opera Chrome 55 Edge 15 Firefox 52 Safari 11 Opera 42 2016 年 12 月 2017 年 4 月 2017 年 3 月 2017 年 9 月 2016 年 12 月","tags":["JavaScript"],"categories":["Language"]},{"title":"03_JavaScript_Promise","path":"/posts/eb71b4ba.html","content":"“I Promise a Result!” “Producing code（生产代码）” 是需要一些时间的代码 “Consuming code（消费代码）” 是必须等待结果的代码 Promise 是一个 JavaScript 对象，它链接生成代码和消费代码 JavaScript Promise 对象JavaScript Promise 对象包含生产代码和对消费代码的调用： Promise 语法123456789101112let myPromise = new Promise(function(myResolve, myReject) &#123;// &quot;Producing Code&quot;（可能需要一些时间） myResolve(); // 成功时 myReject(); // 出错时&#125;);// &quot;Consuming Code&quot; （必须等待一个兑现的承诺）myPromise.then( function(value) &#123; /* 成功时的代码 */ &#125;, function(error) &#123; /* 出错时的代码 */ &#125;); 当执行代码获得结果时，它应该调用两个回调之一： 结果 调用 成功 myResolve(result value) 出错 myReject(error object) Promise 对象属性JavaScript Promise 对象可以是： Pending Fulfilled Rejected Promise 对象支持两个属性：state 和 result。 当 Promise 对象 “pending”（工作）时，结果是 undefined。 当 Promise 对象 “fulfilled” 时，结果是一个值。 当一个 Promise 对象是 “rejected” 时，结果是一个错误对象。 myPromise.state myPromise.result “pending” undefined “fulfilled” 结果值 “rejected” error 对象 您无法访问 Promise 属性 state 和 result。 您必须使用 Promise 方法来处理 Promise。 如何使用 Promise以下是使用 Promise 的方法： 1234myPromise.then( function(value) &#123; /* code if successful */ &#125;, function(error) &#123; /* code if some error */ &#125;); Promise.then() 有两个参数，一个是成功时的回调，另一个是失败时的回调。 两者都是可选的，因此您可以为成功或失败添加回调。 实例1234567891011121314151617181920function myDisplayer(some) &#123; document.getElementById(&quot;demo&quot;).innerHTML = some;&#125;let myPromise = new Promise(function(myResolve, myReject) &#123; let x = 0;// 生成代码（这可能需要一些时间） if (x == 0) &#123; myResolve(&quot;OK&quot;); &#125; else &#123; myReject(&quot;Error&quot;); &#125;&#125;);myPromise.then( function(value) &#123;myDisplayer(value);&#125;, function(error) &#123;myDisplayer(error);&#125;); JavaScript Promise 实例为了演示 Promise 的使用，我们将使用上一章中的回调实例： 等待超时 等待文件 等待超时使用回调的例子12345setTimeout(function() &#123; myFunction(&quot;I love You !!!&quot;); &#125;, 3000);function myFunction(value) &#123; document.getElementById(&quot;demo&quot;).innerHTML = value;&#125; 使用 Promise 的例子1234567let myPromise = new Promise(function(myResolve, myReject) &#123; setTimeout(function() &#123; myResolve(&quot;I love You !!&quot;); &#125;, 3000);&#125;);myPromise.then(function(value) &#123; document.getElementById(&quot;demo&quot;).innerHTML = value;&#125;); 等待文件使用回调的例子1234567891011121314function getFile(myCallback) &#123; let req = new XMLHttpRequest(); req.open(&#x27;GET&#x27;, &quot;mycar.html&quot;); req.onload = function() &#123; if (req.status == 200) &#123; myCallback(req.responseText); &#125; else &#123; myCallback(&quot;Error: &quot; + req.status); &#125; &#125; req.send();&#125;getFile(myDisplayer); 使用 Promise 的例子1234567891011121314151617let myPromise = new Promise(function(myResolve, myReject) &#123; let req = new XMLHttpRequest(); req.open(&#x27;GET&#x27;, &quot;mycar.htm&quot;); req.onload = function() &#123; if (req.status == 200) &#123; myResolve(req.response); &#125; else &#123; myReject(&quot;File not Found&quot;); &#125; &#125;; req.send();&#125;);myPromise.then( function(value) &#123;myDisplayer(value);&#125;, function(error) &#123;myDisplayer(error);&#125;); 浏览器支持ECMAScript 2015，也称为 ES6，引入了 JavaScript Promise 对象。 下表注明了首个完全支持 Promise 对象的浏览器版本： Chrome IE Firefox Safari Opera Chrome 33 Edge 12 Firefox 29 Safari 7.1 Opera 20 2014 年 2 月 2015 年 7 月 2014 年 4 月 2014 年 9 月 2014 年 3 月","tags":["JavaScript"],"categories":["Language"]},{"title":"02_JavaScript_异步","path":"/posts/b27ba98d.html","content":"“I will finish later!” 与其他函数并行运行的函数称为异步（asynchronous） 一个很好的例子是 JavaScript setTimeout() 异步 JavaScript上一章中使用的例子做了很大地简化。 其目的是演示回调函数的语法： 实例12345678910function myDisplayer(some) &#123; document.getElementById(&quot;demo&quot;).innerHTML = some;&#125;function myCalculator(num1, num2, myCallback) &#123; let sum = num1 + num2; myCallback(sum);&#125;myCalculator(5, 5, myDisplayer); 在上面的例子中，myDisplayer 是函数的名称。 它作为参数传递给 myCalculator()。 在现实世界中，回调最常与异步函数一起使用。 一个典型的例子是 JavaScript setTimeout()。 等待超时在使用 JavaScript 函数 setTimeout() 时，可以指定超时时执行的回调函数： 实例12345setTimeout(myFunction, 3000);function myFunction() &#123; document.getElementById(&quot;demo&quot;).innerHTML = &quot;I love You !!&quot;;&#125; 在上面的示例中，myFunction 被用作回调。 函数（函数名）作为参数传递给 setTimeout()。 3000 是超时前的毫秒数，所以 3 秒后会调用 myFunction()。 当您将函数作为参数传递时，请记住不要使用括号。 正确：setTimeout(myFunction, 3000); 错误：setTimeout(myFunction(), 3000); 若不将函数的名称作为参数传递给另一个函数，您始终可以传递整个函数： 实例12345setTimeout(function() &#123; myFunction(&quot;I love You !!!&quot;); &#125;, 3000);function myFunction(value) &#123; document.getElementById(&quot;demo&quot;).innerHTML = value;&#125; 在上面的例子中，function()&#123; myFunction(&quot;I love You !!!&quot;); &#125; 用作回调。它是一个完整的函数。完整的函数作为参数被传递给 setTimeout()。 3000 是超时前的毫秒数，所以 3 秒后会调用 myFunction()。 等待间隔：在使用 JavaScript 函数 setInterval() 时，可以指定每个间隔执行的回调函数： 实例123456789setInterval(myFunction, 1000);function myFunction() &#123; let d = new Date(); document.getElementById(&quot;demo&quot;).innerHTML= d.getHours() + &quot;:&quot; + d.getMinutes() + &quot;:&quot; + d.getSeconds();&#125; 在上面的例子中，myFunction 用作回调。 函数（函数名）作为参数传递给 setInterval()。 1000 是间隔之间的毫秒数，因此 myFunction() 将每秒调用一次。 等待文件如果您创建函数来加载外部资源（如脚本或文件），则在内容完全加载之前无法使用这些内容。 这是使用回调的最佳时机。 此例加载一个 HTML 文件 (mycar.html)，并在文件完全加载后在网页中显示该 HTML 文件： 等待文件：123456789101112131415161718function myDisplayer(some) &#123; document.getElementById(&quot;demo&quot;).innerHTML = some;&#125;function getFile(myCallback) &#123; let req = new XMLHttpRequest(); req.open(&#x27;GET&#x27;, &quot;mycar.html&quot;); req.onload = function() &#123; if (req.status == 200) &#123; myCallback(this.responseText); &#125; else &#123; myCallback(&quot;Error: &quot; + req.status); &#125; &#125; req.send();&#125;getFile(myDisplayer); 在上面的示例中，myDisplayer 用作回调。 函数（函数名）作为参数传递给 getFile()。 以下是 mycar.html 的副本： mycar.html123456&lt;img src=&quot;img_car.jpg&quot; alt=&quot;Nice car&quot; style=&quot;width:100%&quot;&gt;&lt;p&gt;A car is a wheeled, self-powered motor vehicle used for transportation.Most definitions of the term specify that cars are designed to run primarily on roads, to have seating for one to eight people, to typically have four wheels.&lt;/p&gt;&lt;p&gt;(Wikipedia)&lt;/p&gt;","tags":["JavaScript"],"categories":["Language"]},{"title":"01_JavaScript_回调","path":"/posts/5ffcf0fc.html","content":"“I will call back later!” 回调 (callback) 是作为参数传递给另一个函数的函数 这种技术允许函数调用另一个函数 回调函数可以在另一个函数完成后运行 函数序列JavaScript 函数按照它们被调用的顺序执行。而不是以它们被定义的顺序。 此例最终将显示 “Goodbye”： 实例12345678910function myFirst() &#123; myDisplayer(&quot;Hello&quot;);&#125;function mySecond() &#123; myDisplayer(&quot;Goodbye&quot;);&#125;myFirst();mySecond(); 本例子最终会显示 “Hello”： 实例12345678910function myFirst() &#123; myDisplayer(&quot;Hello&quot;);&#125;function mySecond() &#123; myDisplayer(&quot;Goodbye&quot;);&#125;mySecond();myFirst(); 顺序控制有时您希望更好地控制何时执行函数。 假设您要进行计算，然后显示结果。 您可以调用计算器函数 (myCalculator)，保存结果，然后调用另一个函数 (myDisplayer) 来显示结果： 实例1234567891011function myDisplayer(some) &#123; document.getElementById(&quot;demo&quot;).innerHTML = some;&#125;function myCalculator(num1, num2) &#123; let sum = num1 + num2; return sum;&#125;let result = myCalculator(5, 5);myDisplayer(result); 或者，您可以调用计算器函数 (myCalculator)，并让计算器函数调用显示函数 (myDisplayer)： 实例12345678910function myDisplayer(some) &#123; document.getElementById(&quot;demo&quot;).innerHTML = some;&#125;function myCalculator(num1, num2) &#123; let sum = num1 + num2; myDisplayer(sum);&#125;myCalculator(5, 5); 上面第一个例子的问题是你必须调用两个函数来显示结果。 第二个例子的问题是您无法阻止计算器函数显示结果。 现在是引入回调的时候了。 JavaScript 回调回调是作为参数传递给另一个函数的函数。 使用回调，您可以通过回调调用计算器函数（myCalculator），并在计算完成后让计算器函数运行回调： 实例12345678910function myDisplayer(some) &#123; document.getElementById(&quot;demo&quot;).innerHTML = some;&#125;function myCalculator(num1, num2, myCallback) &#123; let sum = num1 + num2; myCallback(sum);&#125;myCalculator(5, 5, myDisplayer); 在上面的例子中， myDisplayer 是函数的名称。 它作为参数传递给 myCalculator()。 当您将函数作为参数传递时，请记住不要使用括号。 正确：myCalculator(5, 5, myDisplayer); 错误：myCalculator(5, 5, myDisplayer()); 何时使用回调？上面的例子并不是很令人兴奋。 它们经过简化了，为的是向您讲解回调的语法。 回调真正闪光之处是异步函数，其中一个函数必须等待另一个函数（例如等待文件加载）。","tags":["JavaScript"],"categories":["Language"]},{"title":"03_JavaScript_Static_方法","path":"/posts/2eb1597c.html","content":"static 类方法是在类本身上定义的。 您不能在对象上调用 static 方法，只能在对象类上调用。 实例1234567891011121314151617class Car &#123; constructor(name) &#123; this.name = name; &#125; static hello() &#123; return &quot;Hello!!&quot;; &#125;&#125;let myCar = new Car(&quot;Ford&quot;);// 您可以在 Car 类上调用 &#x27;hello()&#x27; ：document.getElementById(&quot;demo&quot;).innerHTML = Car.hello();// 但不能在 Car 对象上调用：// document.getElementById(&quot;demo&quot;).innerHTML = myCar.hello();// 此举将引发错误。 如果要在 static 方法中使用 myCar 对象，可以将其作为参数发送： 实例12345678910class Car &#123; constructor(name) &#123; this.name = name; &#125; static hello(x) &#123; return &quot;Hello &quot; + x.name; &#125;&#125;let myCar = new Car(&quot;Ford&quot;);document.getElementById(&quot;demo&quot;).innerHTML = Car.hello(myCar);","tags":["JavaScript"],"categories":["Language"]},{"title":"02_JavaScript_类继承","path":"/posts/b4b37bb0.html","content":"类继承如需创建类继承，请使用 extends 关键字。 使用类继承创建的类继承了另一个类的所有方法： 实例创建一个名为 “Model” 的类，它将继承 “Car” 类的方法： 123456789101112131415161718192021class Car &#123; constructor(brand) &#123; this.carname = brand; &#125; present() &#123; return &#x27;I have a &#x27; + this.carname; &#125;&#125;class Model extends Car &#123; constructor(brand, mod) &#123; super(brand); this.model = mod; &#125; show() &#123; return this.present() + &#x27;, it is a &#x27; + this.model; &#125;&#125;let myCar = new Model(&quot;Ford&quot;, &quot;Mustang&quot;);document.getElementById(&quot;demo&quot;).innerHTML = myCar.show(); super() 方法引用父类。 通过在 constructor 方法中调用 super() 方法，我们调用了父级的 constructor 方法，获得了父级的属性和方法的访问权限。 继承对于代码可重用性很有用：在创建新类时重用现有类的属性和方法。 Getter 和 Setter类还允许您使用 getter 和 setter。 为您的属性使用 getter 和 setter 很聪明，特别是如果您想在返回它们之前或在设置它们之前对值做一些特殊的事情。 如需在类中添加 getter 和 setter，请使用 get 和 set 关键字。 实例为 “carname” 属性创建 getter 和 setter： 123456789101112131415class Car &#123; constructor(brand) &#123; this.carname = brand; &#125; get cnam() &#123; return this.carname; &#125; set cnam(x) &#123; this.carname = x; &#125;&#125;let myCar = new Car(&quot;Ford&quot;);document.getElementById(&quot;demo&quot;).innerHTML = myCar.cnam; 注释：即使 getter 是一个方法，当你想要获取属性值时也不要使用括号。 getter&#x2F;setter 方法的名称不能与属性名称相同，在本例中为 carname。 许多程序员在属性名称前使用下划线字符 _ 将 getter&#x2F;setter 与实际属性分开： 实例您可以使用下划线字符将 getter&#x2F;setter 与实际属性分开： 123456789101112131415class Car &#123; constructor(brand) &#123; this._carname = brand; &#125; get carname() &#123; return this._carname; &#125; set carname(x) &#123; this._carname = x; &#125;&#125;let myCar = new Car(&quot;Ford&quot;);document.getElementById(&quot;demo&quot;).innerHTML = myCar.carname; 如需使用 setter，请使用与设置属性值相同的语法，不带括号： 实例使用 setter 将汽车名称更改为 “Volvo”： 123456789101112131415class Car &#123; constructor(brand) &#123; this._carname = brand; &#125; get carname() &#123; return this._carname; &#125; set carname(x) &#123; this._carname = x; &#125;&#125;let myCar = new Car(&quot;Ford&quot;);myCar.carname = &quot;Volvo&quot;;document.getElementById(&quot;demo&quot;).innerHTML = myCar.carname; Hoisting与函数和其他 JavaScript 声明不同，类声明不会被提升。 这意味着您必须先声明类，然后才能使用它： 实例123456789101112//您还不能使用该类。//myCar = new Car(&quot;Ford&quot;)//This would raise an error.class Car &#123; constructor(brand) &#123; this.carname = brand; &#125;&#125;//现在您可以使用该类：let myCar = new Car(&quot;Ford&quot;) 注释：对于其他声明，如函数，在声明之前尝试使用它时不会出错，因为 JavaScript 声明的默认行为是提升（将声明移到顶部）","tags":["JavaScript"],"categories":["Language"]},{"title":"01_JavaScript_类","path":"/posts/31f292a9.html","content":"ECMAScript 2015，也称为 ES6，引入了 JavaScript 类。 JavaScript 类是 JavaScript 对象的模板。 JavaScript 类的语法请使用关键字 class 创建一个类。 请始终添加一个名为 constructor() 的方法： 语法123class ClassName &#123; constructor() &#123; ... &#125;&#125; 实例123456class Car &#123; constructor(name, year) &#123; this.name = name; this.year = year; &#125;&#125; 上面的例子创建了一个名为 “Car” 的类。 该类有两个初始属性：”name” 和 “year”。 JavaScript 类不是对象。 它是 JavaScript 对象的模板。 使用类当您有了一个类时，可以使用该类来创建对象： 实例12let myCar1 = new Car(&quot;Ford&quot;, 2014);let myCar2 = new Car(&quot;Audi&quot;, 2019); 上面的例子使用 Car 类来创建两个 Car 对象。 在创建新对象时会自动调用构造方法（constructor method）。 构造方法构造方法是一种特殊的方法： 它必须有确切的名称的 “constructor” 创建新对象时自动执行 用于初始化对象属性 如果您没有定义构造方法，JavaScript 会添加一个空的构造方法。 类方法创建类方法的语法与对象方法相同。 请使用关键字 class 创建一个类。 请始终添加 constructor() 方法。 然后添加任意数量的方法。 语法123456class ClassName &#123; constructor() &#123; ... &#125; method_1() &#123; ... &#125; method_2() &#123; ... &#125; method_3() &#123; ... &#125;&#125; 创建一个名为 “age” 的类方法，它返回车年： 实例1234567891011121314class Car &#123; constructor(name, year) &#123; this.name = name; this.year = year; &#125; age() &#123; let date = new Date(); return date.getFullYear() - this.year; &#125;&#125;let myCar = new Car(&quot;Ford&quot;, 2014);document.getElementById(&quot;demo&quot;).innerHTML =&quot;My car is &quot; + myCar.age() + &quot; years old.&quot;; 您可以向类方法发送参数： 实例12345678910111213141516class Car &#123; constructor(name, year) &#123; this.name = name; this.year = year; &#125; age(x) &#123; return x - this.year; &#125;&#125;let date = new Date();let year = date.getFullYear();let myCar = new Car(&quot;Ford&quot;, 2014);document.getElementById(&quot;demo&quot;).innerHTML=&quot;My car is &quot; + myCar.age(year) + &quot; years old.&quot;; 浏览器支持下表注明首个完全支持 JavaScript 类的浏览器版本： Chrome IE Firefox Safari Opera Chrome 49 Edge 12 Firefox 45 Safari 9 Opera 36 2016 年 3 月 2015 年 7 月 2016 年 3 月 2015 年 10 月 2016 年 3 月 “use strict”类中的语法必须以“严格模式”编写。 如果您不遵循“严格模式”规则，将收到错误消息。 实例在“严格模式”下，如果您使用变量而不声明它，会得到错误： 1234567891011class Car &#123; constructor(name, year) &#123; this.name = name; this.year = year; &#125; age() &#123; // date = new Date(); // This will not work let date = new Date(); // This will work return date.getFullYear() - this.year; &#125;&#125;","tags":["JavaScript"],"categories":["Language"]},{"title":"06_JavaScript_闭包","path":"/posts/d7264e1b.html","content":"JavaScript 变量属于本地或全局作用域。 全局变量能够通过闭包实现局部（私有）。 全局变量函数能够访问函数内部定义的所有变量，比如： 实例1234function myFunction() &#123; var a = 4; return a * a;&#125; 但是函数也能访问函数外部定义的变量，比如： 实例1234var a = 4;function myFunction() &#123; return a * a;&#125; 在最后这个例子中，a 是全局变量。 在网页中，全局变量属于 window 对象。 全局变量能够被页面中（以及窗口中）的所有脚本使用和修改。 在第一个例子中，a 是局部变量。 局部变量只能用于其被定义的函数内部。对于其他函数和脚本代码来说它是不可见的。 拥有相同名称的全局变量和局部变量是不同的变量。修改一个，不会改变其他。 不通过关键词 var 创建的变量总是全局的，即使它们在函数中创建。 变量的生命周期全局变量活得和您的应用程序（窗口、网页）一样久。 局部变量活得不长。它们在函数调用时创建，在函数完成后被删除。 一个计数器的困境假设您想使用变量来计数，并且您希望此计数器可用于所有函数。 您可以使用全局变量和函数来递增计数器： 实例1234567891011121314// 初始化计数器var counter = 0;// 递增计数器的函数function add() &#123; counter += 1;&#125;// 调用三次 add()add();add();add();// 此时计数器应该是 3 上述解决方案有一个问题：页面上的任何代码都可以更改计数器，而无需调用 add()。 对于 add() 函数，计数器应该是局部的，以防止其他代码更改它： 实例123456789101112131415// 初始化计数器var counter = 0;// 递增计数器的函数function add() &#123; var counter = 0; counter += 1;&#125;// 调用三次 add()add();add();add();//此时计数器应该是 3。但它是 0。 它没有用，因为我们显示全局计数器而不是本地计数器。 通过让函数返回它，我们可以删除全局计数器并访问本地计数器： 实例12345678910111213// 递增计数器的函数function add() &#123; var counter = 0; counter += 1; return counter;&#125;// 调用三次 add()add();add();add();//此时计数器应该是 3。但它是 1。 它没有用，因为我们每次调用函数时都会重置本地计数器。 JavaScript 内部函数可以解决这个问题。 JavaScript 嵌套函数所有函数都有权访问全局作用域。 事实上，在 JavaScript 中，所有函数都有权访问它们“上面”的作用域。 JavaScript 支持嵌套函数。嵌套函数可以访问其上的作用域。 在本例中，内部函数 plus() 可以访问父函数中的 counter 计数器变量： 实例123456function add() &#123; var counter = 0; function plus() &#123;counter += 1;&#125; plus(); return counter; &#125; 这样即可解决计数器困境，如果我们能够从外面访问 plus() 函数。 我们还需要找到只执行一次 counter = 0 的方法。 我们需要闭包（closure）。 JavaScript 闭包记得自调用函数吗？这种函数会做什么呢？ 实例12345678910var add = (function () &#123; var counter = 0; return function () &#123;return counter += 1;&#125;&#125;)();add();add();add();// 计数器目前是 3 例子解释变量 add 的赋值是自调用函数的返回值。 这个自调用函数只运行一次。它设置计数器为零（0），并返回函数表达式。 这样 add 成为了函数。最“精彩的”部分是它能够访问父作用域中的计数器。 这被称为 JavaScript 闭包。它使函数拥有“私有”变量成为可能。 计数器被这个匿名函数的作用域保护，并且只能使用 add 函数来修改。 闭包指的是有权访问父作用域的函数，即使在父函数关闭之后。","tags":["JavaScript"],"categories":["Language"]},{"title":"05_JavaScript_函数_Apply","path":"/posts/6c06aa61.html","content":"方法重用通过 apply() 方法，您能够编写用于不同对象的方法。 JavaScript apply() 方法apply() 方法与 call() 方法非常相似： 在本例中，person 的 fullName 方法被应用到 person1： 实例12345678910var person = &#123; fullName: function() &#123; return this.firstName + &quot; &quot; + this.lastName; &#125;&#125;var person1 = &#123; firstName: &quot;Bill&quot;, lastName: &quot;Gates&quot;,&#125;person.fullName.apply(person1); // 将返回 &quot;Bill Gates&quot; call() 和 apply() 之间的区别不同之处是： call() 方法分别接受参数。 apply() 方法接受数组形式的参数。 如果要使用数组而不是参数列表，则 apply() 方法非常方便。 带参数的 apply() 方法apply() 方法接受数组中的参数： 实例12345678910var person = &#123; fullName: function(city, country) &#123; return this.firstName + &quot; &quot; + this.lastName + &quot;,&quot; + city + &quot;,&quot; + country; &#125;&#125;var person1 = &#123; firstName:&quot;Bill&quot;, lastName: &quot;Gates&quot;&#125;person.fullName.apply(person1, [&quot;Oslo&quot;, &quot;Norway&quot;]); 与 call() 方法对比： 实例12345678910var person = &#123; fullName: function(city, country) &#123; return this.firstName + &quot; &quot; + this.lastName + &quot;,&quot; + city + &quot;,&quot; + country; &#125;&#125;var person1 = &#123; firstName:&quot;Bill&quot;, lastName: &quot;Gates&quot;&#125;person.fullName.call(person1, &quot;Oslo&quot;, &quot;Norway&quot;); 在数组上模拟 max 方法您可以使用 Math.max() 方法找到（数字列表中的）最大数字： 实例1Math.max(1,2,3); // 会返回 3 由于 JavaScript 数组没有 max() 方法，因此您可以应用 Math.max() 方法。 实例1Math.max.apply(null, [1,2,3]); // 也会返回 3 第一个参数（null）无关紧要。在本例中未使用它。 这些例子会给出相同的结果： 实例1Math.max.apply(Math, [1,2,3]); // 也会返回 3 实例1Math.max.apply(&quot; &quot;, [1,2,3]); // 也会返回 3 实例1Math.max.apply(0, [1,2,3]); // 也会返回 3 JavaScript 严格模式在 JavaScript 严格模式下，如果 apply() 方法的第一个参数不是对象，则它将成为被调用函数的所有者（对象）。在“非严格”模式下，它成为全局对象。","tags":["JavaScript"],"categories":["Language"]},{"title":"04_JavaScript_函数_Call","path":"/posts/dfeac5bd.html","content":"方法重用使用 call() 方法，您可以编写能够在不同对象上使用的方法。 函数是对象方法在 JavaScript 中，函数是对象的方法。 如果一个函数不是 JavaScript 对象的方法，那么它就是全局对象的函数（参见前一章）。 下面的例子创建了带有三个属性的对象（firstName、lastName、fullName）。 实例12345678var person = &#123; firstName:&quot;Bill&quot;, lastName: &quot;Gates&quot;, fullName: function () &#123; return this.firstName + &quot; &quot; + this.lastName; &#125;&#125;person.fullName(); // 将返回 &quot;Bill Gates&quot; fullName 属性是一个方法。person 对象是该方法的拥有者。 fullName 属性属于 person 对象的方法。 JavaScript call() 方法call() 方法是预定义的 JavaScript 方法。 它可以用来调用所有者对象作为参数的方法。 通过 call()，您能够使用属于另一个对象的方法。 本例调用 person 的 fullName 方法，并用于 person1： 实例1234567891011121314var person = &#123; fullName: function() &#123; return this.firstName + &quot; &quot; + this.lastName; &#125;&#125;var person1 = &#123; firstName:&quot;Bill&quot;, lastName: &quot;Gates&quot;,&#125;var person2 = &#123; firstName:&quot;Steve&quot;, lastName: &quot;Jobs&quot;,&#125;person.fullName.call(person1); // 将返回 &quot;Bill Gates&quot; 本例调用 person 的 fullName 方法，并用于 person2： 实例1234567891011121314var person = &#123; fullName: function() &#123; return this.firstName + &quot; &quot; + this.lastName; &#125;&#125;var person1 = &#123; firstName:&quot;Bill&quot;, lastName: &quot;Gates&quot;,&#125;var person2 = &#123; firstName:&quot;Steve&quot;, lastName: &quot;Jobs&quot;,&#125;person.fullName.call(person2); // 将返回 &quot;Steve Jobs&quot; 带参数的 call() 方法call() 方法可接受参数： 实例12345678910var person = &#123; fullName: function(city, country) &#123; return this.firstName + &quot; &quot; + this.lastName + &quot;,&quot; + city + &quot;,&quot; + country; &#125;&#125;var person1 = &#123; firstName:&quot;Bill&quot;, lastName: &quot;Gates&quot;&#125;person.fullName.call(person1, &quot;Seattle&quot;, &quot;USA&quot;);","tags":["JavaScript"],"categories":["Language"]},{"title":"03_JavaScript_函数调用","path":"/posts/3478022c.html","content":"JavaScript 函数内部的代码会在“某物”调用它时执行。 调用 JavaScript 函数在函数被定义时，函数内部的代码不会执行。 在函数被调用时，函数内部的代码会被执行。 调用函数通常也可以说“启动函数”或“执行函数”。 在本教程中，我们使用“调用”。 以函数形式调用函数实例1234function myFunction(a, b) &#123; return a * b;&#125;myFunction(10, 2); // 将返回 20 以上函数不属于任何对象。但是在 JavaScript 中，始终存在一种默认的全局对象。 在 HTML 中，默认全局对象是 HTML 页面本身，所有上面的函数“属于”HTML 页面。 在浏览器中，这个页面对象就是浏览器窗口。上面的函数自动成为一个窗口函数。 myFunction() 和 window.myFunction() 是同一个函数： 实例1234function myFunction(a, b) &#123; return a * b;&#125;window.myFunction(10, 2); // 也会返回 20 这是调用函数的常见方法，但并不是一个好习惯。 全局变量、方法或函数很容易在全局对象中产生命名冲突和漏洞。 this 关键词在 JavaScript 中，被称为 this 的事物，指的是“拥有”当前代码的对象。 this 的值，在函数中使用时，是“拥有”该函数的对象。 请注意 this 并不是变量。它属于关键词。您无法改变 this 的值。 全局对象当不带拥有者对象调用对象时，this 的值成为全局对象。 在 web 浏览器中，全局对象就是浏览器对象。 本例以 this 的值返回这个 window 对象： 实例12345var x = myFunction(); // x 将成为 window 对象function myFunction() &#123; return this;&#125; 调用一个函数作为一个全局函数，会导致 this 的值成为全局对象。 作为变量来使用 window 对象很容易使程序崩溃。 作为方法来调用函数在 JavaScript 中，您可以把函数定义为对象方法。 下面的例子创建了一个对象（myObject），带有两个属性（firstName 和 lastName），以及一个方法（fullName）： 实例12345678var myObject = &#123; firstName:&quot;Bill&quot;, lastName: &quot;Gates&quot;, fullName: function () &#123; return this.firstName + &quot; &quot; + this.lastName; &#125;&#125;myObject.fullName(); // 将返回 &quot;Bill Gates&quot; fullName 方法是一个函数。该函数属于对象。myObject 是函数的拥有者。 被称为 this 的事物，是“拥有”这段 JavaScript 代码的对象。在此例中，this 的值是 myObject。 测试一下！修改这个 fullName 方法来返回 this 的值： 实例12345678var myObject = &#123; firstName:&quot;Bill&quot;, lastName: &quot;Gates&quot;, fullName: function () &#123; return this; &#125;&#125;myObject.fullName(); // 将返回 [object Object]（拥有者对象） 以对象方法来调用函数，会导致 this 的值成为对象本身。 通过函数构造器来调用函数如果函数调用的前面是 new 关键字，那么这是一个构造函数调用。 它看起来像你创建一个新的函数，但由于 JavaScript 函数是对象，你实际上创建一个新对象： 实例123456789// 这是函数构造器：function myFunction(arg1, arg2) &#123; this.firstName = arg1; this.lastName = arg2;&#125;// 创建了一个新对象：var x = new myFunction(&quot;Bill&quot;, &quot;Gates&quot;);x.firstName; // 会返回 &quot;Bill&quot; 构造器调用会创建新对象。新对象会从其构造器继承属性和方法。 构造器内的 this 关键词没有值。 this 的值会成为调用函数时创建的新对象。","tags":["JavaScript"],"categories":["Language"]},{"title":"02_JavaScript_函数参数","path":"/posts/bd150aee.html","content":"JavaScript *函数*不会对参数值进行任何检查。 函数参数在本教程中稍早的时间，您已经学到了函数可以拥有参数： 123functionName(parameter1, parameter2, parameter3) &#123; 要执行的代码&#125; 函数参数（parameter）指的是在函数定义中列出的名称。 函数参数（argument）指的是传递到函数或由函数接收到的真实值。 参数规则JavaScript 函数定义不会为参数（parameter）规定数据类型。 JavaScript 函数不会对所传递的参数（argument）实行类型检查。 JavaScript 函数不会检查所接收参数（argument）的数量。 参数默认如果调用参数时省略了参数（少于被声明的数量），则丢失的值被设置为：undefined。 有时这是可以接受的，但是有时最好给参数指定默认值： 实例12345function myFunction(x, y) &#123; if (y === undefined) &#123; y = 0; &#125; &#125; 如果函数调用的参数太多（超过声明），则可以使用 arguments 对象来达到这些参数。 arguments 对象JavaScript 函数有一个名为 arguments 对象的内置对象。 arguments 对象包含函数调用时使用的参数数组。 这样，您就可以简单地使用函数来查找（例如）数字列表中的最高值： 实例123456789101112x = findMax(1, 123, 500, 115, 44, 88);function findMax() &#123; var i; var max = -Infinity; for (i = 0; i &lt; arguments.length; i++) &#123; if (arguments[i] &gt; max) &#123; max = arguments[i]; &#125; &#125; return max;&#125; 或创建一个函数来总和所有输入值： 实例123456789x = sumAll(1, 123, 500, 115, 44, 88);function sumAll() &#123; var i, sum = 0; for (i = 0; i &lt; arguments.length; i++) &#123; sum += arguments[i]; &#125; return sum;&#125; 参数通过值传递函数调用中的参数（parameter）是函数的参数（argument）。 JavaScript 参数通过值传递：函数只知道值，而不是参数的位置。 如果函数改变了参数的值，它不会改变参数的原始值。 参数的改变在函数之外是不可见的。 对象是由引用传递的在 JavaScript 中，对象引用是值。 正因如此，对象的行为就像它们通过引用来传递： 如果函数改变了对象属性，它也改变了原始值。 对象属性的改变在函数之外是可见的。","tags":["JavaScript"],"categories":["Language"]},{"title":"01_JavaScript_函数定义","path":"/posts/8444f2b1.html","content":"JavaScript 函数是通过 function 关键词*定义*的。 您可以使用函数*声明*或函数*表达式*。 函数声明在本教程中稍早之前，您学到了通过如下语法声明函数： 123function functionName(parameters) &#123; 要执行的代码&#125; 被声明的函数不会直接执行。它们被“保存供稍后使用”，将在稍后执行，当它们被调用时。 实例123function myFunction(a, b) &#123; return a * b;&#125; 分号用于分隔可执行的 JavaScript 语句。 由于函数声明不是可执行的语句，以分号结尾并不常见。 函数表达式JavaScript 函数也可以使用表达式来定义。 函数表达式可以在变量中存储： 实例1var x = function (a, b) &#123;return a * b&#125;; 在变量中保存函数表达式之后，此变量可用作函数： 实例12var x = function (a, b) &#123;return a * b&#125;;var z = x(4, 3); 上面的函数实际上是一个匿名函数（没有名称的函数）。 存放在变量中的函数不需要函数名。他们总是使用变量名调用。 上面的函数使用分号结尾，因为它是可执行语句的一部分。 Function() 构造器正如您在之前的例子中看到的，JavaScript 函数是通过 function 关键词定义的。 函数也可以通过名为 Function() 的内建 JavaScript 函数构造器来定义。 实例123var myFunction = new Function(&quot;a&quot;, &quot;b&quot;, &quot;return a * b&quot;);var x = myFunction(4, 3); 您实际上无需使用函数构造器。上面的例子这么写也是一样的： 实例123var myFunction = function (a, b) &#123;return a * b&#125;;var x = myFunction(4, 3); 大多数情况下，您可以避免在 JavaScript 中使用 new 关键词。 函数提升在本教程中稍早前，您已经学到了“提升”（hoisting）。 Hoisting 是 JavaScript 将声明移动到当前作用域顶端的默认行为。 Hoisting 应用于变量声明和函数声明。 正因如此，JavaScript 函数能够在声明之前被调用： 12345myFunction(5); function myFunction(y) &#123; return y * y;&#125; 使用表达式定义的函数不会被提升。 自调用函数函数表达式可以作为“自调用”。 自调用表达式是自动被调用（开始）的，在不进行调用的情况下。 函数表达式会自动执行，假如表达式后面跟着 ()。 您无法对函数声明进行自调用。 您需要在函数周围添加括号，以指示它是一个函数表达式： 实例123(function () &#123; var x = &quot;Hello!!&quot;; // 我会调用我自己&#125;)(); 上面的函数实际上是一个匿名的自调用函数（没有名称的函数）。 函数可用作值JavaScript 函数可被用作值： 实例12345function myFunction(a, b) &#123; return a * b;&#125;var x = myFunction(4, 3); JavaScript 函数可用在表达式中： 实例12345function myFunction(a, b) &#123; return a * b;&#125;var x = myFunction(4, 3) * 2; 函数是对象JavaScript 中的 typeof 运算符会为函数返回 “function“。 但是最好是把 JavaScript 函数描述为对象。 JavaScript 函数都有属性和方法。 arguments.length 会返回函数被调用时收到的参数数目： 实例123function myFunction(a, b) &#123; return arguments.length;&#125; toString() 方法以字符串返回函数： 实例12345function myFunction(a, b) &#123; return a * b;&#125;var txt = myFunction.toString(); 定义为对象属性的函数，被称为对象的方法。 为创建新对象而设计的函数，被称为对象构造函数（对象构造器）。 箭头函数箭头函数允许使用简短的语法来编写函数表达式。 您不需要 function 关键字、return 关键字和花括号。 实例1234567// ES5var x = function(x, y) &#123; return x * y;&#125;// ES6const x = (x, y) =&gt; x * y; 箭头函数没有自己的 this。它们不适合定义对象方法。 箭头函数未被提升。它们必须在使用前进行定义。 使用 const 比使用 var 更安全，因为函数表达式始终是常量值。 如果函数是单个语句，则只能省略 return 关键字和大括号。因此，保留它们可能是一个好习惯： 实例1const x = (x, y) =&gt; &#123; return x * y &#125;; IE11 或更早的版本不支持箭头函数。","tags":["JavaScript"],"categories":["Language"]},{"title":"15_JavaScript_Set_对象","path":"/posts/737c5f8c.html","content":"Set 是唯一值的集合。 每个值在 Set 中只能出现一次。 一个 Set 可以容纳任何数据类型的任何值。 如何创建 Set创建一个 Set 并添加现有变量： 实例123456789101112// 创建新的变量const a = &quot;a&quot;;const b = &quot;b&quot;;const c = &quot;c&quot;;// 创建 Setconst letters = new Set();// Add the values to the Setletters.add(a);letters.add(b);letters.add(c); 创建 Set 并添加文字值： 实例1234567// 创建 Setconst letters = new Set();// 向 Set 添加一些值letters.add(&quot;a&quot;);letters.add(&quot;b&quot;);letters.add(&quot;c&quot;); 将 Array 传递给 new Set() 构造函数： 实例12// 创建新的 Setconst letters = new Set([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]); 对于 Set，typeof 返回对象： 1typeof letters; // 返回 object。 对于 Set，instanceof Set 返回 true： 1letters instanceof Set; // 返回 true 向 Set 添加元素实例12letters.add(&quot;d&quot;);letters.add(&quot;e&quot;); 如果您添加相等的元素，则只会保存第一个元素： 实例12345678letters.add(&quot;a&quot;);letters.add(&quot;b&quot;);letters.add(&quot;c&quot;);letters.add(&quot;c&quot;);letters.add(&quot;c&quot;);letters.add(&quot;c&quot;);letters.add(&quot;c&quot;);letters.add(&quot;c&quot;); Set 对象的方法和属性 new Set() 创建新的 Set 对象。 add() 向 Set 添加新元素。 clear() 从 Set 中删除所有元素。 delete() 删除由其值指定的元素。 entries() 返回 Set 对象中值的数组。 has() 如果值存在则返回 true。 forEach() 为每个元素调用回调。 keys() 返回 Set 对象中值的数组。 values() 与 keys() 相同。 size 返回元素计数。","tags":["JavaScript"],"categories":["Language"]},{"title":"14_JavaScript_Map_对象","path":"/posts/8ce5bf5.html","content":"Map 对象存有键值对，其中的键可以是任何数据类型。 Map 对象记得键的原始插入顺序。 Map 对象具有表示映射大小的属性。 基本的 Map() 方法 Method Description new Map() 创建新的 Map 对象。 set() 为 Map 对象中的键设置值。 get() 获取 Map 对象中键的值。 entries() 返回 Map 对象中键&#x2F;值对的数组。 keys() 返回 Map 对象中键的数组。 values() 返回 Map 对象中值的数组。 Map() 属性 Property Description size 获取 Map 对象中某键的值。 创建 Map 对象能够使用对象作为键是 Map 的一个重要特性。 实例123456789101112// 创建对象const apples = &#123;name: &#x27;Apples&#x27;&#125;;const bananas = &#123;name: &#x27;Bananas&#x27;&#125;;const oranges = &#123;name: &#x27;Oranges&#x27;&#125;;// 创建新的 Mapconst fruits = new Map();// Add new Elements to the Mapfruits.set(apples, 500);fruits.set(bananas, 300);fruits.set(oranges, 200); 您可以将 Array 传递给 new Map() 构造函数： 实例1234567891011// 返回const apples = &#123;name: &#x27;Apples&#x27;&#125;;const bananas = &#123;name: &#x27;Bananas&#x27;&#125;;const oranges = &#123;name: &#x27;Oranges&#x27;&#125;;// 创建新的 Mapconst fruits = new Map([; [apples, 500], [bananas, 300], [oranges, 200]]); 获取键的值get() 方法获取 Map 中键的值： 实例1fruits.get(apples); // 返回 500 Remember: The key is an object (apples), not a string (“apples”): 实例1fruits.get(&quot;apples&quot;); // 返回 undefined 其他 Map() 方法 方法 描述 clear() 删除 Map 中的所有元素。 delete() 删除由键指定的元素。 has() 如果键存在，则返回 true。 forEach() 为每个键&#x2F;值对调用回调。 Map() 属性 属性 描述 size 获取 Map 中键的值。 Map.sizeMap.size 返回 Map 中元素的数量： 实例1fruits.size; Map.delete()Map.delete() 删除 Map 元素： 实例1fruits.delete(apples); Map.clear()Map.clear() 从 Map 中移除所有元素： 实例1fruits.clear(); Map.has()如果 Map 中存在键，则 Map.has() 返回 true： 实例1fruits.has(apples); JavaScript 对象 vs MapJavaScript 对象和 Map 之间的差异： 对象 Map Size 对象没有 size 属性 Maps 有 size 属性 键类型 对象键必须是字符串（或符号） Map 键可以是任何数据类型 键顺序 对象键没有很好地排序 Map 键按插入排序 默认 对象有默认键 Map 没有默认键 浏览器支持除了 Internet Explorer 之外，所有主要浏览器都支持 JavaScript Map","tags":["JavaScript"],"categories":["Language"]},{"title":"13_JavaScript_ES5_对象方法","path":"/posts/1f521ded.html","content":"ECMAScript 5 (2009) 向 JavaScript 添加了许多新的对象方法。 管理对象1234567891011121314151617181920// 以现有对象为原型创建对象Object.create()// 添加或更改对象属性Object.defineProperty(object, property, descriptor)// 添加或更改对象属性Object.defineProperties(object, descriptors)// 访问属性Object.getOwnPropertyDescriptor(object, property)// 以数组返回所有属性Object.getOwnPropertyNames(object)// 访问原型Object.getPrototypeOf(object)// 以数组返回可枚举属性Object.keys(object) 保护对象1234567891011121314151617// 防止向对象添加属性Object.preventExtensions(object)// 如果属性可以添加到对象，则返回 trueObject.isExtensible(object)// 防止更改对象属性（不是值）Object.seal(object)// 如果对象被密封，则返回 trueObject.isSealed(object)// 防止对对象进行任何更改Object.freeze(object)// 如果对象被冻结，则返回 trueObject.isFrozen(object) 更改属性值语法1Object.defineProperty(object, property, &#123;value : value&#125;) 实例此例更改属性值： 12345678const person = &#123; firstName: &quot;Bill&quot;, lastName : &quot;Gates&quot;, language : &quot;EN&quot;&#125;;// 修改属性Object.defineProperty(person, &quot;language&quot;, &#123;value : &quot;NO&quot;&#125;); 更改元数据ES5 允许更改以下属性元数据： 123456writable : true // 属性值可更改enumerable : true // 属性可枚举configurable : true // 属性可重新配置writable : false // 属性值不可更改enumerable : false // 属性不可枚举configurable : false // 属性不可重新配置 ES5 允许更改 getter 和 setter： 1234// 定义 getterget: function() &#123; return language &#125;// 定义 setterset: function(value) &#123; language = value &#125; 此例设置 language 为只读： 1Object.defineProperty(person, &quot;language&quot;, &#123;writable:false&#125;); 这个例子使 language 不可枚举： 1Object.defineProperty(person, &quot;language&quot;, &#123;enumerable:false&#125;); 列出所有属性这个例子列出了一个对象的所有属性： 实例12345678const person = &#123; firstName: &quot;Bill&quot;, lastName : &quot;Gates&quot;, language : &quot;EN&quot;&#125;;Object.defineProperty(person, &quot;language&quot;, &#123;enumerable:false&#125;);Object.getOwnPropertyNames(person); // 返回数组的数组 列出可枚举的属性此例仅列出对象的可枚举属性： 实例12345678const person = &#123; firstName: &quot;Bill&quot;, lastName : &quot;Gates&quot;, language : &quot;EN&quot;&#125;;Object.defineProperty(person, &quot;language&quot;, &#123;enumerable:false&#125;);Object.keys(person); // 返回可枚举属性的数组 添加属性此例向对象添加新属性： 实例123456789// 创建对象const person = &#123; firstName: &quot;Bill&quot;, lastName : &quot;Gates&quot;, language : &quot;EN&quot;&#125;;// 添加属性Object.defineProperty(person, &quot;year&quot;, &#123;value:&quot;2008&quot;&#125;); 添加 Getter 和 SetterObject.defineProperty() 方法也可以用来添加 Getter 和 Setter： 实例1234567// 创建对象const person = &#123;firstName:&quot;Bill&quot;, lastName:&quot;Gates&quot;&#125;;// 定义 getterObject.defineProperty(person, &quot;fullName&quot;, &#123; get: function () &#123;return this.firstName + &quot; &quot; + this.lastName;&#125;&#125;); 一个计数器实例1234567891011121314151617181920212223242526// 定义对象const obj = &#123;counter:0&#125;;// 定义 setterObject.defineProperty(obj, &quot;reset&quot;, &#123; get : function () &#123;this.counter = 0;&#125;&#125;);Object.defineProperty(obj, &quot;increment&quot;, &#123; get : function () &#123;this.counter++;&#125;&#125;);Object.defineProperty(obj, &quot;decrement&quot;, &#123; get : function () &#123;this.counter--;&#125;&#125;);Object.defineProperty(obj, &quot;add&quot;, &#123; set : function (value) &#123;this.counter += value;&#125;&#125;);Object.defineProperty(obj, &quot;subtract&quot;, &#123; set : function (i) &#123;this.counter -= i;&#125;&#125;);// 操作计数器：obj.reset;obj.add = 5;obj.subtract = 1;obj.increment;obj.decrement;","tags":["JavaScript"],"categories":["Language"]},{"title":"12_JavaScript_对象原型","path":"/posts/d4416a91.html","content":"所有 JavaScript 对象都从原型继承属性和方法。 在前一章里，我们学到了如何使用对象构造器： 实例12345678function Person(first, last, age, eyecolor) &#123; this.firstName = first; this.lastName = last; this.age = age; this.eyeColor = eyecolor;&#125;var myFather = new Person(&quot;Bill&quot;, &quot;Gates&quot;, 62, &quot;blue&quot;);var myMother = new Person(&quot;Steve&quot;, &quot;Jobs&quot;, 56, &quot;green&quot;); 我们已经认识到，您无法为已有的对象构造器添加新属性： 实例1Person.nationality = &quot;English&quot;; 如需向构造器添加一个新属性，则必须把它添加到构造器函数： 实例1234567function Person(first, last, age, eyecolor) &#123; this.firstName = first; this.lastName = last; this.age = age; this.eyeColor = eyecolor; this.nationality = &quot;English&quot;;&#125; 原型继承所有 JavaScript 对象都从原型继承属性和方法。 日期对象继承自 Date.prototype。数组对象继承自 Array.prototype。Person 对象继承自 Person.prototype。 Object.prototype 位于原型继承链的顶端： 日期对象、数组对象和 Person 对象都继承自 Object.prototype。 向对象添加属性和方法有时，您希望向所有给定类型的已有对象添加新属性（或方法）。 有时，您希望向对象构造器添加新属性（或方法）。 使用 prototype 属性JavaScript prototype 属性允许您为对象构造器添加新属性： 实例1234567function Person(first, last, age, eyecolor) &#123; this.firstName = first; this.lastName = last; this.age = age; this.eyeColor = eyecolor;&#125;Person.prototype.nationality = &quot;English&quot;; JavaScript prototype 属性也允许您为对象构造器添加新方法： 实例123456789function Person(first, last, age, eyecolor) &#123; this.firstName = first; this.lastName = last; this.age = age; this.eyeColor = eyecolor;&#125;Person.prototype.name = function() &#123; return this.firstName + &quot; &quot; + this.lastName;&#125;; 请只修改您自己的原型。绝不要修改标准 JavaScript 对象的原型。","tags":["JavaScript"],"categories":["Language"]},{"title":"11_JavaScript_对象构造器","path":"/posts/b7eef2b2.html","content":"实例123456function Person(first, last, age, eye) &#123; this.firstName = first; this.lastName = last; this.age = age; this.eyeColor = eye;&#125; 亲自试一试 用大写首字母对构造器函数命名是个好习惯。 对象类型（蓝图）（类）前一章的实例是有限制的。它们只创建单一对象。 有时我们需要创建相同“类型”的许多对象的“蓝图”。 创建一种“对象类型”的方法，是使用对象构造器函数。 在上面的例子中，函数 Person() 就是对象构造器函数。 通过 new 关键词调用构造器函数可以创建相同类型的对象： 12var myFather = new Person(&quot;Bill&quot;, &quot;Gates&quot;, 62, &quot;blue&quot;);var myMother = new Person(&quot;Steve&quot;, &quot;Jobs&quot;, 56, &quot;green&quot;); 亲自试一试 this 关键词在 JavaScript 中，被称为 this 的事物是代码的“拥有者”。 this 的值，在对象中使用时，就是对象本身。 在构造器函数中，this 是没有值的。它是新对象的替代物。 当一个新对象被创建时，this 的值会成为这个新对象。 请注意 this 并不是变量。它是关键词。您无法改变 this 的值。 为对象添加属性为已有的对象添加新属性很简单： 实例1myFather.nationality = &quot;English&quot;; 亲自试一试 新属性被添加到 myFather。不是 myMother，也不是任何其他 person 对象。 为对象添加方法为已有的对象添加新方法很简单： 实例123myFather.name = function () &#123; return this.firstName + &quot; &quot; + this.lastName;&#125;; 新方法被添加到 myFather。不是 myMother，也不是任何其他 person 对象。 为构造器添加属性与向已有对象添加新属性不同，您无法为对象构造器添加新属性： 实例1Person.nationality = &quot;English&quot;; 如需向构造器添加一个新属性，您必须添加到构造器函数： 实例1234567function Person(first, last, age, eyecolor) &#123; this.firstName = first; this.lastName = last; this.age = age; this.eyeColor = eyecolor; this.nationality = &quot;English&quot;;&#125; 这样对象属性就可以拥有默认值。 为构造器添加方法您的构造器函数也可以定义方法： 实例1234567function Person(first, last, age, eyecolor) &#123; this.firstName = first; this.lastName = last; this.age = age; this.eyeColor = eyecolor; this.name = function() &#123;return this.firstName + &quot; &quot; + this.lastName;&#125;;&#125; 与向已有对象添加新方法不同，您无法为对象构造器添加新方法。 必须在构造器函数内部向一个对象添加方法： 实例123456789function Person(firstName, lastName, age, eyeColor) &#123; this.firstName = firstName; this.lastName = lastName; this.age = age; this.eyeColor = eyeColor; this.changeName = function (name) &#123; this.lastName = name; &#125;;&#125; changeName() 函数把 name 赋值给 person 的 lastName 属性。 现在您可以试一试： 1myMother.changeName(&quot;Jobs&quot;); 通过用 myMother 替代 this，JavaScript 可以获知目前处理的哪个 person。 内建 JavaScript 构造器JavaScript 提供用于原始对象的构造器： 实例12345678var x1 = new Object(); // 一个新的 Object 对象var x2 = new String(); // 一个新的 String 对象var x3 = new Number(); // 一个新的 Number 对象var x4 = new Boolean(); // 一个新的 Boolean 对象var x5 = new Array(); // 一个新的 Array 对象var x6 = new RegExp(); // 一个新的 RegExp 对象var x7 = new Function(); // 一个新的 Function 对象var x8 = new Date(); // 一个新的 Date 对象 Math() 对象不再此列。Math 是全局对象。new 关键词不可用于 Math。 您知道吗？正如以上所见，JavaScript 提供原始数据类型字符串、数字和布尔的对象版本。但是并无理由创建复杂的对象。原始值快得多！ 请使用对象字面量 &#123;&#125; 代替 new Object()。 请使用字符串字面量 &quot;&quot; 代替 new String()。 请使用数值字面量代替 Number()。 请使用布尔字面量代替 new Boolean()。 请使用数组字面量 [] 代替 new Array()。 请使用模式字面量代替 new RexExp()。 请使用函数表达式 () &#123;&#125; 代替 new Function()。 实例1234567var x1 = &#123;&#125;; // 新对象var x2 = &quot;&quot;; // 新的原始字符串var x3 = 0; // 新的原始数值var x4 = false; // 新的原始逻辑值var x5 = []; // 新的数组对象var x6 = /()/ // 新的正则表达式对象var x7 = function()&#123;&#125;; // 新的函数对象 字符串对象通常，字符串被创建为原始值：var firstName &#x3D; “Bill” 但是也可以使用 new 关键词创建字符串对象：var firstName &#x3D; new String(“Bill”) 数字对象通常，数值被创建为原始值：var x &#x3D; 456 但是也可以使用 new 关键词创建数字对象：var x &#x3D; new Number(456) 布尔对象通常，逻辑值被创建为原始值：var x &#x3D; false 但是也可以使用 new 关键词创建逻辑对象：var x &#x3D; new Boolean(false)","tags":["JavaScript"],"categories":["Language"]},{"title":"10_JavaScript_对象访问器","path":"/posts/632f4a49.html","content":"JavaScript 访问器（Getter 和 Setter）ECMAScript 5 (2009) 引入了 Getter 和 Setter。 Getter 和 Setter 允许您定义对象访问器（被计算的属性）。 JavaScript Getter（get 关键词）本例使用 lang 属性来获取 language 属性的值。 实例123456789101112// 创建对象：var person = &#123; firstName: &quot;Bill&quot;, lastName : &quot;Gates&quot;, language : &quot;en&quot;, get lang() &#123; return this.language; &#125;&#125;;// 使用 getter 来显示来自对象的数据：document.getElementById(&quot;demo&quot;).innerHTML = person.lang; JavaScript Setter（set 关键词）本例使用 lang 属性来设置 language 属性的值。 实例1234567891011121314var person = &#123; firstName: &quot;Bill&quot;, lastName : &quot;Gates&quot;, language : &quot;&quot;, set lang(lang) &#123; this.language = lang; &#125;&#125;;// 使用 setter 来设置对象属性：person.lang = &quot;en&quot;;// 显示来自对象的数据：document.getElementById(&quot;demo&quot;).innerHTML = person.language; JavaScript 函数还是 Getter？下面两个例子的区别在哪里？ 例子 112345678910var person = &#123; firstName: &quot;Bill&quot;, lastName : &quot;Gates&quot;, fullName : function() &#123; return this.firstName + &quot; &quot; + this.lastName; &#125;&#125;;// 使用方法来显示来自对象的数据：document.getElementById(&quot;demo&quot;).innerHTML = person.fullName(); 例子 212345678910var person = &#123; firstName: &quot;Bill&quot;, lastName : &quot;Gates&quot;, get fullName() &#123; return this.firstName + &quot; &quot; + this.lastName; &#125;&#125;;// 使用 getter 来显示来自对象的数据：document.getElementById(&quot;demo&quot;).innerHTML = person.fullName; 例子 1 以函数形式访问 fullName：person.fullName()。 例子 2 以属性形式访问 fullName：person.fullName。 第二个例子提供了更简洁的语法。 数据质量使用 getter 和 setter 时，JavaScript 可以确保更好的数据质量。 在本例中，使用 lang 属性以大写形式返回 language 属性的值： 实例123456789101112// 创建对象：var person = &#123; firstName: &quot;Bill&quot;, lastName : &quot;Gates&quot;, language : &quot;en&quot;, get lang() &#123; return this.language.toUpperCase(); &#125;&#125;;// 使用 getter 来显示来自对象的数据：document.getElementById(&quot;demo&quot;).innerHTML = person.lang; 在本例中，使用 lang 属性将大写值存储在 language 属性中： 实例1234567891011121314var person = &#123; firstName: &quot;Bill&quot;, lastName : &quot;Gates&quot;, language : &quot;&quot;, set lang(lang) &#123; this.language = lang.toUpperCase(); &#125;&#125;;// 使用 setter 来设置对象属性：person.lang = &quot;en&quot;;// 显示来自对象的数据：document.getElementById(&quot;demo&quot;).innerHTML = person.language; 为什么使用 Getter 和 Setter？ 它提供了更简洁的语法 它允许属性和方法的语法相同 它可以确保更好的数据质量 有利于后台工作 一个计数器实例实例1234567891011121314151617181920212223242526var obj = &#123; counter : 0, get reset() &#123; this.counter = 0; &#125;, get increment() &#123; this.counter++; &#125;, get decrement() &#123; this.counter--; &#125;, set add(value) &#123; this.counter += value; &#125;, set subtract(value) &#123; this.counter -= value; &#125;&#125;;// 操作计数器：obj.reset;obj.add = 5;obj.subtract = 1;obj.increment;obj.decrement;Object.defineProperty() Object.defineProperty() 方法也可用于添加 Getter 和 Setter： 实例1234567891011121314151617181920212223242526// 定义对象var obj = &#123;counter : 0&#125;;// 定义 settersObject.defineProperty(obj, &quot;reset&quot;, &#123; get : function () &#123;this.counter = 0;&#125;&#125;);Object.defineProperty(obj, &quot;increment&quot;, &#123; get : function () &#123;this.counter++;&#125;&#125;);Object.defineProperty(obj, &quot;decrement&quot;, &#123; get : function () &#123;this.counter--;&#125;&#125;);Object.defineProperty(obj, &quot;add&quot;, &#123; set : function (value) &#123;this.counter += value;&#125;&#125;);Object.defineProperty(obj, &quot;subtract&quot;, &#123; set : function (value) &#123;this.counter -= value;&#125;&#125;);// 操作计数器：obj.reset;obj.add = 5;obj.subtract = 1;obj.increment;obj.decrement;","tags":["JavaScript"],"categories":["Language"]},{"title":"09_JavaScript_显示对象","path":"/posts/8815d2e0.html","content":"如何显示 JavaScript 对象？显示 JavaScript 对象将输出 *[object Object]*。 实例1234567const person = &#123; name: &quot;Bill&quot;, age: 19, city: &quot;Seattle&quot;&#125;;document.getElementById(&quot;demo&quot;).innerHTML = person; 显示 JavaScript 对象的一些常见解决方案是： 按名称显示对象属性 循环显示对象属性 使用 Object.values() 显示对象 使用 JSON.stringify() 显示对象 显示对象属性对象的属性可显示为字符串： 实例12345678const person = &#123; name: &quot;Bill&quot;, age: 19, city: &quot;Seattle&quot;&#125;;document.getElementById(&quot;demo&quot;).innerHTML =person.name + &quot;,&quot; + person.age + &quot;,&quot; + person.city; 在循环中显示对象可以在循环中收集对象的属性： 实例123456789101112const person = &#123; name: &quot;Bill&quot;, age: 19, city: &quot;Seattle&quot;&#125;;let txt = &quot;&quot;;for (let x in person) &#123;txt += person[x] + &quot; &quot;;&#125;;document.getElementById(&quot;demo&quot;).innerHTML = txt; 您必须在循环中使用 person[x]。 person.x 将不起作用（因为 x 是一个变量）。 使用 Object.values()通过使用 Object.values()，任何 JavaScript 对象都可以被转换为数组： 1234567const person = &#123; name: &quot;Bill&quot;, age: 19, city: &quot;Seattle&quot;&#125;;const myArray = Object.values(person); myArray 现在是 JavaScript 数组，可以显示了： 实例12345678const person = &#123; name: &quot;Bill&quot;, age: 19, city: &quot;Seattle&quot;&#125;;const myArray = Object.values(person);document.getElementById(&quot;demo&quot;).innerHTML = myArray; 自 2016 年以来，所有主要浏览器都支持 Object.values()。 使用 JSON.stringify()任何 JavaScript 对象都可以使用 JavaScript 函数 JSON.stringify() 进行字符串化（转换为字符串）： 1234567const person = &#123; name: &quot;Bill&quot;, age: 19, city: &quot;Seattle&quot;&#125;;let myString = JSON.stringify(person); myString 现在是 JavaScript 字符串，可以显示了： 实例12345678const person = &#123; name: &quot;Bill&quot;, age: 19, city: &quot;Seattle&quot;&#125;;let myString = JSON.stringify(person);document.getElementById(&quot;demo&quot;).innerHTML = myString; 结果将是一个遵循 JSON 标记法的字符串： 1&#123;&quot;name&quot;:&quot;Bill&quot;,&quot;age&quot;:19,&quot;city&quot;:&quot;Seattle&quot;&#125; JSON.stringify() 包含在 JavaScript 中，所有主流浏览器都支持。 日期字符串化JSON.stringify 将日期转换为字符串： 实例1234567const person = &#123; name: &quot;Bill&quot;, today: new Date()&#125;;let myString = JSON.stringify(person);document.getElementById(&quot;demo&quot;).innerHTML = myString; 函数字符串化JSON.stringify 不会对函数进行字符串化： 实例1234567const person = &#123; name: &quot;Bill&quot;, age: function () &#123;return 19;&#125;&#125;;let myString = JSON.stringify(person);document.getElementById(&quot;demo&quot;).innerHTML = myString; 如果在字符串化之前将函数转换为字符串，这可以是“固定的”。 实例12345678const person = &#123; name: &quot;Bill&quot;, age: function () &#123;return 19;&#125;&#125;;person.age = person.age.toString();let myString = JSON.stringify(person);document.getElementById(&quot;demo&quot;).innerHTML = myString; 数组字符串化也可以对 JavaScript 数组进行字符串化： 实例1234const arr = [&quot;Bill&quot;, &quot;Steve&quot;, &quot;Elon&quot;, &quot;David&quot;];let myString = JSON.stringify(arr);document.getElementById(&quot;demo&quot;).innerHTML = myString; 结果将是一个遵循 JSON 标记法的字符串： 1[&quot;Bill&quot;,&quot;Steve&quot;,&quot;Elon&quot;,&quot;David&quot;]","tags":["JavaScript"],"categories":["Language"]},{"title":"08_JavaScript_ES5_对象方法","path":"/posts/28e6502b.html","content":"12345678var person = &#123; firstName: &quot;Bill&quot;, lastName : &quot;Gates&quot;, id : 648, fullName : function() &#123; return this.firstName + &quot; &quot; + this.lastName; &#125;&#125;; JavaScript 方法JavaScript 方法是能够在对象上执行的动作。 JavaScript 方法是包含函数定义的属性。 属性 值 firstName Bill lastName Gates age 62 eyeColor blue fullName function() {return this.firstName + “ “ + this.lastName;} 方法是存储为对象属性的函数。 this 关键词在 JavaScript 中，被称为 this 的事物，指的是拥有该 JavaScript 代码的对象。 this 的值，在函数中使用时，是“拥有”该函数的对象。 请注意 this 并非变量。它是关键词。您无法改变 this 的值。 访问对象方法请使用如下语法创建对象方法： 1methodName : function() &#123; 代码行 &#125; 请通过如下语法来访问对象方法： 1objectName.methodName() 您通常会把 fullName() 描述为 person 对象的方法，把 fullName 描述为属性。 fullName 属性在被通过 () 调用后会以函数形式执行。 此例访问 person 对象的 fullName() 方法： 实例1name = person.fullName(); 如果您访问 fullName 属性时没有使用 ()，则将返回函数定义： 实例1name = person.fullName; 使用内建方法此例使用 String 对象的 toUpperCase() 方法，把文本转换为大写： 12var message = &quot;Hello world!&quot;;var x = message.toUpperCase(); x 的值，在以上代码执行后将是： 1HELLO WORLD! 添加新的方法向对象添加方法是在构造器函数内部完成的： 实例123456789function person(firstName, lastName, age, eyeColor) &#123; this.firstName = firstName; this.lastName = lastName; this.age = age; this.eyeColor = eyeColor; this.changeName = function (name) &#123; this.lastName = name; &#125;;&#125; changeName() 函数 name 的值赋给了 person 的 lastName 属性。 现在您可以尝试： 1myMother.changeName(&quot;Jobs&quot;); 通过用 myMother “替代” this，JavaScript 清楚您指的是哪个 person。","tags":["JavaScript"],"categories":["Language"]},{"title":"07_JavaScript_对象原型","path":"/posts/6d6a16f3.html","content":"所有 JavaScript 对象都从原型继承属性和方法。 在前一章里，我们学到了如何使用对象构造器： 实例12345678function Person(first, last, age, eyecolor) &#123; this.firstName = first; this.lastName = last; this.age = age; this.eyeColor = eyecolor;&#125;var myFather = new Person(&quot;Bill&quot;, &quot;Gates&quot;, 62, &quot;blue&quot;);var myMother = new Person(&quot;Steve&quot;, &quot;Jobs&quot;, 56, &quot;green&quot;); 我们已经认识到，您无法为已有的对象构造器添加新属性： 实例1Person.nationality = &quot;English&quot;; 如需向构造器添加一个新属性，则必须把它添加到构造器函数： 实例1234567function Person(first, last, age, eyecolor) &#123; this.firstName = first; this.lastName = last; this.age = age; this.eyeColor = eyecolor; this.nationality = &quot;English&quot;;&#125; 原型继承所有 JavaScript 对象都从原型继承属性和方法。 日期对象继承自 Date.prototype。数组对象继承自 Array.prototype。Person 对象继承自 Person.prototype。 Object.prototype 位于原型继承链的顶端： 日期对象、数组对象和 Person 对象都继承自 Object.prototype。 向对象添加属性和方法有时，您希望向所有给定类型的已有对象添加新属性（或方法）。 有时，您希望向对象构造器添加新属性（或方法）。 使用 prototype 属性JavaScript prototype 属性允许您为对象构造器添加新属性： 实例1234567function Person(first, last, age, eyecolor) &#123; this.firstName = first; this.lastName = last; this.age = age; this.eyeColor = eyecolor;&#125;Person.prototype.nationality = &quot;English&quot;; JavaScript prototype 属性也允许您为对象构造器添加新方法： 实例123456789function Person(first, last, age, eyecolor) &#123; this.firstName = first; this.lastName = last; this.age = age; this.eyeColor = eyecolor;&#125;Person.prototype.name = function() &#123; return this.firstName + &quot; &quot; + this.lastName;&#125;; 请只修改您自己的原型。绝不要修改标准 JavaScript 对象的原型。","tags":["JavaScript"],"categories":["Language"]},{"title":"06_JavaScript_对象构造器","path":"/posts/d0e0d8c5.html","content":"实例123456function Person(first, last, age, eye) &#123; this.firstName = first; this.lastName = last; this.age = age; this.eyeColor = eye;&#125; 用大写首字母对构造器函数命名是个好习惯。 对象类型（蓝图）（类）前一章的实例是有限制的。它们只创建单一对象。 有时我们需要创建相同“类型”的许多对象的“蓝图”。 创建一种“对象类型”的方法，是使用对象构造器函数。 在上面的例子中，函数 Person() 就是对象构造器函数。 通过 new 关键词调用构造器函数可以创建相同类型的对象： 12var myFather = new Person(&quot;Bill&quot;, &quot;Gates&quot;, 62, &quot;blue&quot;);var myMother = new Person(&quot;Steve&quot;, &quot;Jobs&quot;, 56, &quot;green&quot;); this 关键词在 JavaScript 中，被称为 this 的事物是代码的“拥有者”。 this 的值，在对象中使用时，就是对象本身。 在构造器函数中，this 是没有值的。它是新对象的替代物。 当一个新对象被创建时，this 的值会成为这个新对象。 请注意 this 并不是变量。它是关键词。您无法改变 this 的值。 为对象添加属性为已有的对象添加新属性很简单： 实例1myFather.nationality = &quot;English&quot;; 新属性被添加到 myFather。不是 myMother，也不是任何其他 person 对象。 为对象添加方法为已有的对象添加新方法很简单： 实例123myFather.name = function () &#123; return this.firstName + &quot; &quot; + this.lastName;&#125;; 新方法被添加到 myFather。不是 myMother，也不是任何其他 person 对象。 为构造器添加属性与向已有对象添加新属性不同，您无法为对象构造器添加新属性： 实例1Person.nationality = &quot;English&quot;; 如需向构造器添加一个新属性，您必须添加到构造器函数： 实例1234567function Person(first, last, age, eyecolor) &#123; this.firstName = first; this.lastName = last; this.age = age; this.eyeColor = eyecolor; this.nationality = &quot;English&quot;;&#125; 这样对象属性就可以拥有默认值。 为构造器添加方法您的构造器函数也可以定义方法： 实例1234567function Person(first, last, age, eyecolor) &#123; this.firstName = first; this.lastName = last; this.age = age; this.eyeColor = eyecolor; this.name = function() &#123;return this.firstName + &quot; &quot; + this.lastName;&#125;;&#125; 与向已有对象添加新方法不同，您无法为对象构造器添加新方法。 必须在构造器函数内部向一个对象添加方法： 实例123456789function Person(firstName, lastName, age, eyeColor) &#123; this.firstName = firstName; this.lastName = lastName; this.age = age; this.eyeColor = eyeColor; this.changeName = function (name) &#123; this.lastName = name; &#125;;&#125; changeName() 函数把 name 赋值给 person 的 lastName 属性。 1myMother.changeName(&quot;Jobs&quot;); 通过用 myMother 替代 this，JavaScript 可以获知目前处理的哪个 person。 内建 JavaScript 构造器JavaScript 提供用于原始对象的构造器： 实例12345678var x1 = new Object(); // 一个新的 Object 对象var x2 = new String(); // 一个新的 String 对象var x3 = new Number(); // 一个新的 Number 对象var x4 = new Boolean(); // 一个新的 Boolean 对象var x5 = new Array(); // 一个新的 Array 对象var x6 = new RegExp(); // 一个新的 RegExp 对象var x7 = new Function(); // 一个新的 Function 对象var x8 = new Date(); // 一个新的 Date 对象 Math() 对象不再此列。Math 是全局对象。new 关键词不可用于 Math。 您知道吗？正如以上所见，JavaScript 提供原始数据类型字符串、数字和布尔的对象版本。但是并无理由创建复杂的对象。原始值快得多！ 请使用对象字面量 &#123;&#125; 代替 new Object()。 请使用字符串字面量 &quot;&quot; 代替 new String()。 请使用数值字面量代替 Number()。 请使用布尔字面量代替 new Boolean()。 请使用数组字面量 [] 代替 new Array()。 请使用模式字面量代替 new RexExp()。 请使用函数表达式 () &#123;&#125; 代替 new Function()。 实例1234567var x1 = &#123;&#125;; // 新对象var x2 = &quot;&quot;; // 新的原始字符串var x3 = 0; // 新的原始数值var x4 = false; // 新的原始逻辑值var x5 = []; // 新的数组对象var x6 = /()/ // 新的正则表达式对象var x7 = function()&#123;&#125;; // 新的函数对象 字符串对象通常，字符串被创建为原始值：var firstName &#x3D; “Bill” 但是也可以使用 new 关键词创建字符串对象：var firstName &#x3D; new String(“Bill”) 数字对象通常，数值被创建为原始值：var x &#x3D; 456 但是也可以使用 new 关键词创建数字对象：var x &#x3D; new Number(456) 布尔对象通常，逻辑值被创建为原始值：var x &#x3D; false 但是也可以使用 new 关键词创建逻辑对象：var x &#x3D; new Boolean(false)","tags":["JavaScript"],"categories":["Language"]},{"title":"05_JavaScript_对象访问器","path":"/posts/74a9a04.html","content":"JavaScript 访问器（Getter 和 Setter）ECMAScript 5 (2009) 引入了 Getter 和 Setter。 Getter 和 Setter 允许您定义对象访问器（被计算的属性）。 JavaScript Getter（get 关键词）本例使用 lang 属性来获取 language 属性的值。 实例123456789101112// 创建对象：var person = &#123; firstName: &quot;Bill&quot;, lastName : &quot;Gates&quot;, language : &quot;en&quot;, get lang() &#123; return this.language; &#125;&#125;;// 使用 getter 来显示来自对象的数据：document.getElementById(&quot;demo&quot;).innerHTML = person.lang; JavaScript Setter（set 关键词）本例使用 lang 属性来设置 language 属性的值。 实例1234567891011121314var person = &#123; firstName: &quot;Bill&quot;, lastName : &quot;Gates&quot;, language : &quot;&quot;, set lang(lang) &#123; this.language = lang; &#125;&#125;;// 使用 setter 来设置对象属性：person.lang = &quot;en&quot;;// 显示来自对象的数据：document.getElementById(&quot;demo&quot;).innerHTML = person.language; JavaScript 函数还是 Getter？下面两个例子的区别在哪里？ 例子 112345678910var person = &#123; firstName: &quot;Bill&quot;, lastName : &quot;Gates&quot;, fullName : function() &#123; return this.firstName + &quot; &quot; + this.lastName; &#125;&#125;;// 使用方法来显示来自对象的数据：document.getElementById(&quot;demo&quot;).innerHTML = person.fullName(); 例子 212345678910var person = &#123; firstName: &quot;Bill&quot;, lastName : &quot;Gates&quot;, get fullName() &#123; return this.firstName + &quot; &quot; + this.lastName; &#125;&#125;;// 使用 getter 来显示来自对象的数据：document.getElementById(&quot;demo&quot;).innerHTML = person.fullName; 例子 1 以函数形式访问 fullName：person.fullName()。 例子 2 以属性形式访问 fullName：person.fullName。 第二个例子提供了更简洁的语法。 数据质量使用 getter 和 setter 时，JavaScript 可以确保更好的数据质量。 在本例中，使用 lang 属性以大写形式返回 language 属性的值： 实例123456789101112// 创建对象：var person = &#123; firstName: &quot;Bill&quot;, lastName : &quot;Gates&quot;, language : &quot;en&quot;, get lang() &#123; return this.language.toUpperCase(); &#125;&#125;;// 使用 getter 来显示来自对象的数据：document.getElementById(&quot;demo&quot;).innerHTML = person.lang; 在本例中，使用 lang 属性将大写值存储在 language 属性中： 实例1234567891011121314var person = &#123; firstName: &quot;Bill&quot;, lastName : &quot;Gates&quot;, language : &quot;&quot;, set lang(lang) &#123; this.language = lang.toUpperCase(); &#125;&#125;;// 使用 setter 来设置对象属性：person.lang = &quot;en&quot;;// 显示来自对象的数据：document.getElementById(&quot;demo&quot;).innerHTML = person.language; 为什么使用 Getter 和 Setter？ 它提供了更简洁的语法 它允许属性和方法的语法相同 它可以确保更好的数据质量 有利于后台工作 一个计数器实例实例1234567891011121314151617181920212223242526var obj = &#123; counter : 0, get reset() &#123; this.counter = 0; &#125;, get increment() &#123; this.counter++; &#125;, get decrement() &#123; this.counter--; &#125;, set add(value) &#123; this.counter += value; &#125;, set subtract(value) &#123; this.counter -= value; &#125;&#125;;// 操作计数器：obj.reset;obj.add = 5;obj.subtract = 1;obj.increment;obj.decrement;Object.defineProperty() Object.defineProperty() 方法也可用于添加 Getter 和 Setter： 实例1234567891011121314151617181920212223242526// 定义对象var obj = &#123;counter : 0&#125;;// 定义 settersObject.defineProperty(obj, &quot;reset&quot;, &#123; get : function () &#123;this.counter = 0;&#125;&#125;);Object.defineProperty(obj, &quot;increment&quot;, &#123; get : function () &#123;this.counter++;&#125;&#125;);Object.defineProperty(obj, &quot;decrement&quot;, &#123; get : function () &#123;this.counter--;&#125;&#125;);Object.defineProperty(obj, &quot;add&quot;, &#123; set : function (value) &#123;this.counter += value;&#125;&#125;);Object.defineProperty(obj, &quot;subtract&quot;, &#123; set : function (value) &#123;this.counter -= value;&#125;&#125;);// 操作计数器：obj.reset;obj.add = 5;obj.subtract = 1;obj.increment;obj.decrement; 浏览器支持Internet Explorer 8 或更早的版本不支持 Getter 和 Setter","tags":["JavaScript"],"categories":["Language"]},{"title":"04_JavaScript_显示对象","path":"/posts/fa289ba2.html","content":"如何显示 JavaScript 对象？显示 JavaScript 对象将输出 *[object Object]*。 实例1234567const person = &#123; name: &quot;Bill&quot;, age: 19, city: &quot;Seattle&quot;&#125;;document.getElementById(&quot;demo&quot;).innerHTML = person; 显示 JavaScript 对象的一些常见解决方案是： 按名称显示对象属性 循环显示对象属性 使用 Object.values() 显示对象 使用 JSON.stringify() 显示对象 显示对象属性对象的属性可显示为字符串： 实例12345678const person = &#123; name: &quot;Bill&quot;, age: 19, city: &quot;Seattle&quot;&#125;;document.getElementById(&quot;demo&quot;).innerHTML =person.name + &quot;,&quot; + person.age + &quot;,&quot; + person.city; 在循环中显示对象可以在循环中收集对象的属性： 实例123456789101112const person = &#123; name: &quot;Bill&quot;, age: 19, city: &quot;Seattle&quot;&#125;;let txt = &quot;&quot;;for (let x in person) &#123;txt += person[x] + &quot; &quot;;&#125;;document.getElementById(&quot;demo&quot;).innerHTML = txt; 您必须在循环中使用 person[x]。 person.x 将不起作用（因为 x 是一个变量）。 使用 Object.values()通过使用 Object.values()，任何 JavaScript 对象都可以被转换为数组： 1234567const person = &#123; name: &quot;Bill&quot;, age: 19, city: &quot;Seattle&quot;&#125;;const myArray = Object.values(person); myArray 现在是 JavaScript 数组，可以显示了： 实例12345678const person = &#123; name: &quot;Bill&quot;, age: 19, city: &quot;Seattle&quot;&#125;;const myArray = Object.values(person);document.getElementById(&quot;demo&quot;).innerHTML = myArray; 自 2016 年以来，所有主要浏览器都支持 Object.values()。 Chrome IE Firefox Safari Opera 54 (2016) 14 (2016) 47 (2016) 10 (2016) 41 (2016) 使用 JSON.stringify()任何 JavaScript 对象都可以使用 JavaScript 函数 JSON.stringify() 进行字符串化（转换为字符串）： 1234567const person = &#123; name: &quot;Bill&quot;, age: 19, city: &quot;Seattle&quot;&#125;;let myString = JSON.stringify(person); myString 现在是 JavaScript 字符串，可以显示了： 实例12345678const person = &#123; name: &quot;Bill&quot;, age: 19, city: &quot;Seattle&quot;&#125;;let myString = JSON.stringify(person);document.getElementById(&quot;demo&quot;).innerHTML = myString; 结果将是一个遵循 JSON 标记法的字符串： 1&#123;&quot;name&quot;:&quot;Bill&quot;,&quot;age&quot;:19,&quot;city&quot;:&quot;Seattle&quot;&#125; JSON.stringify() 包含在 JavaScript 中，所有主流浏览器都支持。 日期字符串化JSON.stringify 将日期转换为字符串： 实例1234567const person = &#123; name: &quot;Bill&quot;, today: new Date()&#125;;let myString = JSON.stringify(person);document.getElementById(&quot;demo&quot;).innerHTML = myString; 函数字符串化JSON.stringify 不会对函数进行字符串化： 实例1234567const person = &#123; name: &quot;Bill&quot;, age: function () &#123;return 19;&#125;&#125;;let myString = JSON.stringify(person);document.getElementById(&quot;demo&quot;).innerHTML = myString; 如果在字符串化之前将函数转换为字符串，这可以是“固定的”。 实例12345678const person = &#123; name: &quot;Bill&quot;, age: function () &#123;return 19;&#125;&#125;;person.age = person.age.toString();let myString = JSON.stringify(person);document.getElementById(&quot;demo&quot;).innerHTML = myString; 数组字符串化也可以对 JavaScript 数组进行字符串化： 实例1234const arr = [&quot;Bill&quot;, &quot;Steve&quot;, &quot;Elon&quot;, &quot;David&quot;];let myString = JSON.stringify(arr);document.getElementById(&quot;demo&quot;).innerHTML = myString; 结果将是一个遵循 JSON 标记法的字符串： 1[&quot;Bill&quot;,&quot;Steve&quot;,&quot;Elon&quot;,&quot;David&quot;]","tags":["JavaScript"],"categories":["Language"]},{"title":"03_JavaScript_对象方法","path":"/posts/1de9dbd2.html","content":"实例12345678var person = &#123; firstName: &quot;Bill&quot;, lastName : &quot;Gates&quot;, id : 648, fullName : function() &#123; return this.firstName + &quot; &quot; + this.lastName; &#125;&#125;; JavaScript 方法JavaScript 方法是能够在对象上执行的动作。 JavaScript 方法是包含函数定义的属性。 属性 值 firstName Bill lastName Gates age 62 eyeColor blue fullName function() {return this.firstName + “ “ + this.lastName;} 方法是存储为对象属性的函数。 this 关键词在 JavaScript 中，被称为 this 的事物，指的是拥有该 JavaScript 代码的对象。 this 的值，在函数中使用时，是“拥有”该函数的对象。 请注意 this 并非变量。它是关键词。您无法改变 this 的值。 访问对象方法请使用如下语法创建对象方法： 1methodName : function() &#123; 代码行 &#125; 请通过如下语法来访问对象方法： 1objectName.methodName() 您通常会把 fullName() 描述为 person 对象的方法，把 fullName 描述为属性。 fullName 属性在被通过 () 调用后会以函数形式执行。 此例访问 person 对象的 fullName() 方法： 实例1name = person.fullName(); 如果您访问 fullName 属性时没有使用 ()，则将返回函数定义： 实例1name = person.fullName; 使用内建方法此例使用 String 对象的 toUpperCase() 方法，把文本转换为大写： 12var message = &quot;Hello world!&quot;;var x = message.toUpperCase(); x 的值，在以上代码执行后将是： 1HELLO WORLD! 添加新的方法向对象添加方法是在构造器函数内部完成的： 实例123456789function person(firstName, lastName, age, eyeColor) &#123; this.firstName = firstName; this.lastName = lastName; this.age = age; this.eyeColor = eyeColor; this.changeName = function (name) &#123; this.lastName = name; &#125;;&#125; changeName() 函数 name 的值赋给了 person 的 lastName 属性。 现在您可以尝试： 1myMother.changeName(&quot;Jobs&quot;); 通过用 myMother “替代” this，JavaScript 清楚您指的是哪个 person。","tags":["JavaScript"],"categories":["Language"]},{"title":"02_JavaScript_对象属性","path":"/posts/4c4e6951.html","content":"属性是任何 JavaScript 对象最重要的部分。 JavaScript 属性属性指的是与 JavaScript 对象相关的值。 JavaScript 对象是无序属性的集合。 属性通常可以被修改、添加和删除，但是某些属性是只读的。 访问 JavaScript 属性访问对象属性的语法是： 1objectName.property // person.age 或者： 1objectName[&quot;property&quot;] // person[&quot;age&quot;] 或者： 1objectName[expression] // x = &quot;age&quot;; person[x] 表达式必须计算为属性名。 例子 11person.firstname + &quot; is &quot; + person.age + &quot; years old.&quot;; 例子 21person[&quot;firstname&quot;] + &quot; is &quot; + person[&quot;age&quot;] + &quot; years old.&quot;; JavaScript for…in 循环JavaScript for...in 语句遍历对象的属性。 语法123for (variable in object) &#123; 要执行的代码&#125; for...in 循环中的代码块会为每个属性执行一次。 循环对象的属性： 实例12345var person = &#123;fname:&quot;Bill&quot;, lname:&quot;Gates&quot;, age:62&#125;; for (x in person) &#123; txt += person[x];&#125; 添加新属性您可以通过简单的赋值，向已存在的对象添加新属性。 假设 person 对象已存在 - 那么您可以为其添加新属性： 实例1person.nationality = &quot;English&quot;; 您不能使用预留词作为属性名（或方法名）。请使用 JavaScript 命名规则。 删除属性delete 关键词从对象中删除属性： 实例12var person = &#123;firstName:&quot;Bill&quot;, lastName:&quot;Gates&quot;, age:62, eyeColor:&quot;blue&quot;&#125;;delete person.age; // 或 delete person[&quot;age&quot;]; delete 关键词会同时删除属性的值和属性本身。 删除完成后，属性在被添加回来之前是无法使用的。 delete 操作符被设计用于对象属性。它对变量或函数没有影响。 delete 操作符不应被用于预定义的 JavaScript 对象属性。这样做会使应用程序崩溃。 属性值所有属性都有名称。此外它们还有值。 值是属性的特性之一。 其他特性包括：可列举、可配置、可写。 这些特性定义了属性被访问的方式（是可读的还是可写的？） 在 JavaScript 中，所有属性都是可读的，但是只有值是可修改的（只有当属性为可写时）。 （ECMAScript 5 拥有获取和设置所有属性特性的方法） 原型属性JavaScript 对象继承了它们的原型的属性。 delete 关键词不会删除被继承的属性，但是如果您删除了某个原型属性，则将影响到所有从原型继承的对象","tags":["JavaScript"],"categories":["Language"]},{"title":"01_JavaScript_对象定义","path":"/posts/c5a71c1d.html","content":"在 JavaScript 中，几乎“所有事物”都是对象。 布尔是对象（如果用 new 关键词定义） 数字是对象（如果用 new 关键词定义） 字符串是对象（如果用 new 关键词定义） 日期永远都是对象 算术永远都是对象 正则表达式永远都是对象 数组永远都是对象 函数永远都是对象 对象永远都是对象 所有 JavaScript 值，除了原始值，都是对象。 JavaScript 原始值原始值指的是没有属性或方法的值。 原始数据类型指的是拥有原始值的数据。 JavaScript 定义了 5 种原始数据类型： string number boolean null undefined 原始值是一成不变的（它们是硬编码的，因此不能改变）。 假设 x &#x3D; 3.14，您能够改变 x 的值。但是您无法改变 3.14 的值。 值 类型 注释 “Hello” string “Hello” 始终是 “Hello” 3.14 number 3.14 始终是 3.14 true boolean true 始终是 true false boolean false 始终是 false null null (object) null 始终是 null undefined undefined undefined 始终是 undefined 对象是包含变量的变量JavaScript 变量能够包含单个的值： 实例1var person = &quot;Bill Gates&quot;; 对象也是变量。但是对象能够包含很多值。 值按照名称 : 值对的形式编写（名称和值以冒号分隔）。 实例1var person = &#123;firstName:&quot;Bill&quot;, lastName:&quot;Gates&quot;, age:62, eyeColor:&quot;blue&quot;&#125;; JavaScript 对象是命名值的集合。 对象属性JavaScript 对象中的命名值，被称为属性。 属性 值 firstName Bill lastName Gates age 62 eyeColor blue 以名称值对书写的对象类似于： PHP 中的关联数组 Python 中的字典 C 中的哈希表 Java 中的哈希映射 Ruby 和 Perl 中的散列 对象方法方法是可以在对象上执行的动作。 对象属性可以是原始值、其他对象以及函数。 对象方法是包含函数定义的对象属性。 属性 值 firstName Bill lastName Gates age 62 eyeColor blue fullName function() {return this.firstName + “ “ + this.lastName;} JavaScript 对象是被称为属性和方法的命名值的容器。 您将在下一章中学到更多有关方法的知识。 创建 JavaScript 对象通过 JavaScript，您能够定义和创建自己的对象。 有不同的方法来创建对象： 定义和创建单个对象，使用对象文字。 定义和创建单个对象，通过关键词 new。 定义对象构造器，然后创建构造类型的对象。 在 ECMAScript 5 中，也可以通过函数 Object.create() 来创建对象。 使用对象字面量这是创建对象最简答的方法。 使用对象文字，您可以在一条语句中定义和创建对象。 对象文字指的是花括号 &#123;&#125; 中的名称:值对（比如 age:62）。 下面的例子创建带有四个属性的新的 JavaScript 对象： 实例1var person = &#123;firstName:&quot;Bill&quot;, lastName:&quot;Gates&quot;, age:62, eyeColor:&quot;blue&quot;&#125;; 空格和折行不重要。对象定义可横跨多行： 实例123456var person = &#123; firstName:&quot;Bill&quot;, lastName:&quot;Gates&quot;, age:62, eyeColor:&quot;blue&quot;&#125;; 使用 JavaScript 关键词 new下面的例子也创建了带有四个属性的新的 JavaScript 对象： 实例12345var person = new Object();person.firstName = &quot;Bill&quot;;person.lastName = &quot;Gates&quot;;person.age = 50;person.eyeColor = &quot;blue&quot;; 上面的两个例子结果是一样的。无需使用 new Object()。 出于简易性、可读性和执行速度的考虑，请使用第一种创建方法（对象文字方法）。 JavaScript 对象是易变的对象是易变的：它们通过引用来寻址，而非值。 如果 person 是一个对象，下面的语句不会创建 person 的副本： 1var x = person; // 这不会创建 person 的副本。 对象 x 并非 person 的副本。它就是 person。x 和 person 是同一个对象。 对 x 的任何改变都将改变 person，因为 x 和 person 是相同的对象。 实例1234var person = &#123;firstName:&quot;Bill&quot;, lastName:&quot;Gates&quot;, age:62, eyeColor:&quot;blue&quot;&#125; var x = person;x.age = 10; // 这将同时改变 both x.age 和 person.age 注释：JavaScript 变量不是易变的。只有 JavaScript 对象如此。","tags":["JavaScript"],"categories":["Language"]},{"title":"06_ECMAScript_2018","path":"/posts/c5bb7cc7.html","content":"JavaScript 命名约定始于 ES1、ES2、ES3、ES5 和 ES6。 但是，ECMAScript 2016 和 2017 未被称为 ES7 和 ES8。 自 2016 年以来，新版本按年份命名（ECMAScript 2016&#x2F;2017&#x2F;2018）。 ECMAScript 2018 中的新特性本章介绍 ECMAScript 2018 的新特性： 异步迭代 Promise Finally 对象 Rest 属性 新的 RegExp 特性 JavaScript 异步迭代ECMAScript 2018 添加了异步迭代器和可迭代对象。 通过异步迭代，我们可以在 for/of 循环中使用 await 关键字。 实例1for await () &#123;&#125; Firefox 和 Safari 是第一批支持 JavaScript 异步迭代的浏览器： Chrome IE Firefox Safari Opera Chrome 63 Edge 79 Firefox 57 Safari 11 Opera 50 2017 年 12 月 2020 年 1 月 2017 年 11 月 2017 年 9 月 2018 年 1 月 JavaScript Promise.finallyECMAScript 2018 使用 Promise.finally 完成了 Promise 对象的完整实现： 实例12345let myPromise = new Promise();myPromise.then();myPromise.catch();myPromise.finally(); Chrome 和 Firefox 是第一批支持 Promise.finally 的浏览器： Chrome IE Firefox Safari Opera Chrome 63 Edge 18 Firefox 58 Safari 11.1 Opera 50 2017 年 12 月 2018 年 11 月 2018 年 1 月 2018 年 3 月 2018 年 1 月 JavaScript 对象 Rest 属性ECMAScript 2018 添加了 Rest 属性。 这允许我们破坏一个对象并将剩余物收集到一个新对象上： 实例1234let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;x; // 1y; // 2z; // &#123; a: 3, b: 4 &#125; Chrome、Firefox 和 Opera 是第一批支持对象 Rest 属性的浏览器： Chrome IE Firefox Safari Opera Chrome 60 Edge 79 Firefox 55 Safari 11.1 Opera 47 2017 年 7 月 2020 年 1 月 2017 年 8 月 2018 年 3 月 2017 年 8 月 新的 JavaScript RegExp 特性ECMAScript 2018 添加了 4 个新的 RegExp 特性： Unicode 属性转义 (\\p{…}) 后行断言（Lookbehind Assertions） (?&lt;&#x3D; ) 和 (?&lt;! ) 命名捕获组（Named Capture Groups） s (dotAll) 标志 Chrome 和 Firefox 是第一批支持所有新 RegExp 功能的浏览器： Chrome IE Firefox Safari Opera Chrome 64 Edge 79 Firefox 78 Safari 12 Opera 51 2018 年 1 月 2020 年 1 月 2020 年 6 月 2018 年 9 月 2018 年 2 月","tags":["JavaScript"],"categories":["Language"]},{"title":"05_ECMAScript_2017","path":"/posts/69e3ad2.html","content":"JavaScript 命名约定始于 ES1、ES2、ES3、ES5 和 ES6。 但是，ECMAScript 2016 和 2017 未被称为 ES7 和 ES8。 自 2016 年以来，新版本按年份命名（ECMAScript 2016&#x2F;2017&#x2F;2018）。 ECMAScript 2017 中的新特性本章介绍 ECMAScript 2017 的新特性： JavaScript 字符串填充 JavaScript Object.entries JavaScript Object.values JavaScript 异步函数 JavaScript 共享内存 JavaScript 字符串填充ECMAScript 2017 添加了两个 String 方法：padStart 和 padEnd，以支持在字符串的开头和结尾进行填充。 实例123let str = &quot;5&quot;;str = str.padStart(4,0);// 结果是： 0005 实例123let str = &quot;5&quot;;str = str.padEnd(4,0);// 结果是： 5000 Internet Explorer 不支持字符串填充。 Firefox 和 Safari 是第一批支持 JavaScript 字符串填充的浏览器： Chrome IE Firefox Safari Opera Chrome 57 Edge 15 Firefox 48 Safari 10 Opera 44 2017 年 3 月 2017 年 4 月 2016 年 8 月 2016 年 9 月 2017 年 3 月 JavaScript 对象条目ECMAScript 2017 向对象添加了新的 Object.entries 方法。 Object.entries() 方法返回对象中键&#x2F;值对的数组： 实例1234567const person = &#123; firstName : &quot;Bill&quot;, lastName : &quot;Gates&quot;, age : 50, eyeColor : &quot;blue&quot;&#125;;document.getElementById(&quot;demo&quot;).innerHTML = Object.entries(person); Object.entries() 使循环中使用对象变简单了： 实例1234567const fruits = &#123;Bananas:300, Oranges:200, Apples:500&#125;;let text = &quot;&quot;;for (let [fruit, value] of Object.entries(fruits)) &#123;text += fruit + &quot;: &quot; + value + &quot;&quot;;&#125; Object.entries() 也使得将对象转换为映射变得简单： 实例123const fruits = &#123;Bananas:300, Oranges:200, Apples:500&#125;;const myMap = new Map(Object.entries(fruits)); Chrome 和 Firefox 是第一批支持 Object.entries 的浏览器： Chrome IE Firefox Safari Opera Chrome 47 Edge 14 Firefox 47 Safari 10.1 Opera 41 2016 年 6 月 2016 年 8 月 2016 年 6 月 2017 年 3 月 2016 年 10 月 JavaScript 对象值Object.values 类似 Object.entries，但返回对象值的单维数组： 实例1234567const person = &#123; firstName : &quot;Bill&quot;, lastName : &quot;Gates&quot;, age : 50, eyeColor : &quot;blue&quot;&#125;;document.getElementById(&quot;demo&quot;).innerHTML = Object.values(person); Firefox 和 Chrome 是第一批支持 Object.values 的浏览器： Chrome IE Firefox Safari Opera Chrome 54 Edge 14 Firefox 47 Safari 10.1 Opera 41 2016 年 10 月 2016 年 8 月 2016 年 6 月 2017 年 3 月 2016 年 10 月 JavaScript Async 函数等待超时12345678async function myDisplay() &#123; let myPromise = new Promise(function(myResolve, myReject) &#123; setTimeout(function() &#123; myResolve(&quot;I love You !!&quot;); &#125;, 3000); &#125;); document.getElementById(&quot;demo&quot;).innerHTML = await myPromise;&#125;myDisplay(); Firefox 和 Chrome 是第一批支持异步 JavaScript 函数的浏览器： Chrome IE Firefox Safari Opera Chrome 55 Edge 15 Firefox 52 Safari 11 Opera 42 2016 年 12 月 2017 年 4 月 2017 年 3 月 2017 年 9 月 2016 年 12 月","tags":["JavaScript"],"categories":["Language"]},{"title":"04_ECMAScript_2016","path":"/posts/f63fc107.html","content":"JavaScript 命名约定始于 ES1、ES2、ES3、ES5 和 ES6。 但是，ECMAScript 2016 和 2017 未被称为 ES7 和 ES8。 自 2016 年以来，新版本按年份命名（ECMAScript 2016&#x2F;2017&#x2F;2018）。 ECMAScript 2016 中的新特性本章介绍 ECMAScript 2016 的新特性： JavaScript 求幂 (**) JavaScript 求幂赋值 (**&#x3D;) JavaScript Array.prototype.includes 求幂运算符幂运算符 (**) 将第一个操作数提高到第二个操作数的幂。 实例12let x = 5;let z = x ** 2; // 结果是： 25 x ** y 产生与 Math.pow(x, y) 相同的结果： 实例12let x = 5;let z = Math.pow(x,2); // 结果是： 25 求幂赋值幂赋值运算符 (**=) 将变量的值提高到右操作数的幂。 实例12let x = 5;x **= 2; // 结果是 25 Chrome 52 和 Edge 14 是首个完全支持指数运算符的浏览器： Chrome IE Firefox Safari Opera Chrome 52 Edge 14 Firefox 52 Safari 10.1 Opera 39 2016 年 7 月 2016 年 8 月 2017 年 3 月 2017 年 3 月 2016 年 8 月 JavaScript Array.includes()ECMAScript 2016 将 Array.prototype.includes 引入数组。这允许我们检查元素是否存在于数组中： 实例123const fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.includes(&quot;Mango&quot;); // 为 true 所有现代浏览器都支持 Array.prototype.includes： Chrome IE Firefox Safari Opera Chrome 47 Edge 14 Firefox 43 Safari 9 Opera 34 2015 年 12 月 2016 年 8 月 2015 年 12 月 2015 年 10 月 2015 年 12 月","tags":["JavaScript"],"categories":["Language"]},{"title":"03_JavaScript_ES6","path":"/posts/93ef5037.html","content":"ECMAScript 6 是什么？ECMAScript 6 也称为 ES6 和 ECMAScript 2015。 一些人把它称作 JavaScript 6。 本章介绍 ES6 中的一些新特性。 JavaScript let JavaScript const 幂 (**) 默认参数值 Array.find() Array.findIndex() 对 ES6（ECMAScript 2015）的浏览器支持Safari 10 和 Edge 14 是首先完全支持 ES6 的浏览器： Chrome 58 Edge 14 Firefox 54 Safari 10 Opera 55 Jan 2017 Aug 2016 Mar 2017 Jul 2016 Aug 2018 JavaScript letlet 语句允许您使用块作用域声明变量。 实例1234567var x = 10;// Here x is 10&#123; let x = 2; // Here x is 2&#125;// Here x is 10 JavaScript constconst 语句允许您声明常量（具有常量值的 JavaScript 变量）。 常量类似于 let 变量，但不能更改值。 实例1234567var x = 10;// Here x is 10&#123; const x = 2; // Here x is 2&#125;// Here x is 10 指数运算符取幂运算符（**）将第一个操作数提升到第二个操作数的幂。 实例12var x = 5;var z = x ** 2; // 结果是 25 x ** y 的结果与 Math.pow(x,y) 相同： 实例12var x = 5;var z = Math.pow(x,2); // 结果是 25 默认参数值ES6 允许函数参数具有默认值。 实例12345function myFunction(x, y = 10) &#123; // y is 10 if not passed or undefined return x + y;&#125;myFunction(5); // 将返回 15 Array.find()find() 方法返回通过测试函数的第一个数组元素的值。 此例查找（返回）第一个大于 18 的元素（的值）： 实例123456var numbers = [4, 9, 16, 25, 29];var first = numbers.find(myFunction);function myFunction(value, index, array) &#123; return value &gt; 18;&#125; 请注意此函数接受 3 个参数： 项目值 项目索引 数组本身 Array.findIndex()findIndex() 方法返回通过测试函数的第一个数组元素的索引。 此例确定大于 18 的第一个元素的索引： 实例123456var numbers = [4, 9, 16, 25, 29];var first = numbers.findIndex(myFunction);function myFunction(value, index, array) &#123; return value &gt; 18;&#125; 请注意此函数接受 3 个参数： 项目值 项目索引 数组本身 新的数字属性ES6 将以下属性添加到 Number 对象： EPSILON MIN_SAFE_INTEGER MAX_SAFE_INTEGER 实例1var x = Number.EPSILON; 实例1var x = Number.MIN_SAFE_INTEGER; 实例1var x = Number.MAX_SAFE_INTEGER; 新的数字方法ES6 为 Number 对象添加了 2 个新方法： Number.isInteger() Number.isSafeInteger() Number.isInteger() 方法如果参数是整数，则 Number.isInteger() 方法返回 true。 实例12Number.isInteger(10); // 返回 trueNumber.isInteger(10.5); // 返回 false Number.isSafeInteger() 方法安全整数是可以精确表示为双精度数的整数。 如果参数是安全整数，则 Number.isSafeInteger() 方法返回 true。 实例12Number.isSafeInteger(10); // 返回 trueNumber.isSafeInteger(12345678901234567890); // 返回 false 安全整数指的是从 -(253 - 1) 到 +(253 - 1) 的所有整数。 这是安全的：9007199254740991。这是不安全的：9007199254740992。 新的全局方法ES6 还增加了 2 个新的全局数字方法： isFinite() isNaN() isFinite() 方法如果参数为 Infinity 或 NaN，则全局 isFinite() 方法返回 false。 否则返回 true： 实例12isFinite(10/0); // 返回 falseisFinite(10/1); // 返回 true isNaN() 方法如果参数是 NaN，则全局 isNaN() 方法返回 true。否则返回 false： 实例1isNaN(&quot;Hello&quot;); // 返回 true 箭头函数（Arrow Function）箭头函数允许使用简短的语法来编写函数表达式。 您不需要 function 关键字、return 关键字以及花括号。 实例1234567// ES5var x = function(x, y) &#123; return x * y;&#125;// ES6const x = (x, y) =&gt; x * y; 箭头功能没有自己的 this。它们不适合定义对象方法。 箭头功能未被提升。它们必须在使用前进行定义。 使用 const 比使用 var 更安全，因为函数表达式始终是常量值。 如果函数是单个语句，则只能省略 return 关键字和花括号。因此，保留它们可能是一个好习惯： 实例1const x = (x, y) =&gt; &#123; return x * y &#125;;","tags":["JavaScript"],"categories":["Language"]},{"title":"02_JavaScript_ES5","path":"/posts/a48e901c.html","content":"ECMAScript 5 是什么？ECMAScript 5 也称为 ES5 和 ECMAScript 2009。 本章介绍 ES5 的一些最重要的特性。 ECMAScript 5 特性这些是 2009 年发布的新特性： “use strict” 指令 String.trim() Array.isArray() Array.forEach() Array.map() Array.filter() Array.reduce() Array.reduceRight() Array.every() Array.some() Array.indexOf() Array.lastIndexOf() JSON.parse() JSON.stringify() Date.now() 属性 Getter 和 Setter 新的对象属性和方法 ECMAScript 5 语法更改 对字符串的属性访问 [ ] 数组和对象字面量中的尾随逗号 多行字符串字面量 作为属性名称的保留字 “use strict” 指令“use strict” 定义 JavaScript 代码应该以“严格模式”执行。 例如，使用严格模式，不能使用未声明的变量。 您可以在所有程序中使用严格模式。它可以帮助您编写更清晰的代码，例如阻止您使用未声明的变量。 “use strict” 只是一个字符串表达式。旧浏览器如果不理解它们就不会抛出错误。 String.trim()String.trim() 删除字符串两端的空白字符。 实例12var str = &quot; Hello World! &quot;;alert(str.trim()); Array.isArray()isArray() 方法检查对象是否为数组。 实例12345function myFunction() &#123; var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;]; var x = document.getElementById(&quot;demo&quot;); x.innerHTML = Array.isArray(fruits);&#125; Array.forEach()forEach() 方法为每个数组元素调用一次函数。 实例1234567var txt = &quot;&quot;;var numbers = [45, 4, 9, 16, 25];numbers.forEach(myFunction);function myFunction(value) &#123; txt = txt + value + &quot;&lt;br&gt;&quot;; &#125; Array.map()这个例子给每个数组值乘以 2： 实例123456var numbers1 = [45, 4, 9, 16, 25];var numbers2 = numbers1.map(myFunction);function myFunction(value) &#123; return value * 2;&#125; Array.filter()此例用值大于 18 的元素创建一个新数组： 实例123456var numbers = [45, 4, 9, 16, 25];var over18 = numbers.filter(myFunction);function myFunction(value) &#123; return value &gt; 18;&#125; Array.reduce()这个例子确定数组中所有数的总和： 实例123456var numbers1 = [45, 4, 9, 16, 25];var sum = numbers1.reduce(myFunction);function myFunction(total, value) &#123; return total + value;&#125; Array.reduceRight()这个例子同样是确定数组中所有数的总和： 实例123456var numbers1 = [45, 4, 9, 16, 25];var sum = numbers1.reduceRight(myFunction);function myFunction(total, value) &#123; return total + value;&#125; Array.every()这个例子检查是否所有值都超过 18： 实例123456var numbers = [45, 4, 9, 16, 25];var allOver18 = numbers.every(myFunction);function myFunction(value) &#123; return value &gt; 18;&#125; Array.some()这个例子检查某些值是否超过 18： 实例123456var numbers = [45, 4, 9, 16, 25];var allOver18 = numbers.some(myFunction);function myFunction(value) &#123; return value &gt; 18;&#125; Array.indexOf()检索数组中的某个元素值并返回其位置： 实例12var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var a = fruits.indexOf(&quot;Apple&quot;); Array.lastIndexOf()Array.lastIndexOf() 与 Array.indexOf() 类似，但是从数组结尾处开始检索。 实例12var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var a = fruits.lastIndexOf(&quot;Apple&quot;); JSON.parse()JSON 的一个常见用途是从 Web 服务器接收数据。 想象一下，您从Web服务器收到这条文本字符串： 1&#x27;&#123;&quot;name&quot;:&quot;Bill&quot;, &quot;age&quot;:62, &quot;city&quot;:&quot;Seatle&quot;&#125;&#x27; JavaScript 函数 JSON.parse() 用于将文本转换为 JavaScript 对象： 1var obj = JSON.parse(&#x27;&#123;&quot;name&quot;:&quot;Bill&quot;, &quot;age&quot;:62, &quot;city&quot;:&quot;Seatle&quot;&#125;&#x27;); JSON.stringify()JSON 的一个常见用途是将数据发送到Web服务器。 将数据发送到 Web 服务器时，数据必须是字符串。 想象一下，我们在 JavaScript 中有这个对象： 1var obj = &#123;&quot;name&quot;:&quot;Bill&quot;, &quot;age&quot;:62, &quot;city&quot;:&quot;Seatle&quot;&#125;; 请使用 JavaScript 函数 JSON.stringify() 将其转换为字符串。 1var myJSON = JSON.stringify(obj); 结果将是遵循 JSON 表示法的字符串。 myJSON 现在是一个字符串，准备好发送到服务器： 实例123var obj = &#123;&quot;name&quot;:&quot;Bill&quot;, &quot;age&quot;:62, &quot;city&quot;:&quot;Seatle&quot;&#125;;var myJSON = JSON.stringify(obj);document.getElementById(&quot;demo&quot;).innerHTML = myJSON; Date.now()Date.now() 返回自零日期（1970 年 1 月 1 日 00:00:00:00）以来的毫秒数。 实例1var timInMSs = Date.now(); Date.now() 的返回与在 Date 对象上执行 getTime() 的结果相同。 属性 Getter 和 SetterES5 允许您使用类似于获取或设置属性的语法来定义对象方法。 这个例子为名为 fullName 的属性创建一个 getter： 实例1234567891011// 创建对象：var person = &#123; firstName: &quot;Bill&quot;, lastName : &quot;Gates&quot;, get fullName() &#123; return this.firstName + &quot; &quot; + this.lastName; &#125;&#125;;// 使用 getter 显示来自对象的数据：document.getElementById(&quot;demo&quot;).innerHTML = person.fullName; 这个例子为语言属性创建一个 setter 和一个 getter： 实例1234567891011121314151617var person = &#123; firstName: &quot;Bill&quot;, lastName : &quot;Gates&quot;, language : &quot;NO&quot;, get lang() &#123; return this.language; &#125;, set lang(value) &#123; this.language = value; &#125;&#125;;// 使用 setter 设置对象属性：person.lang = &quot;en&quot;;// 使用 getter 显示来自对象的数据：document.getElementById(&quot;demo&quot;).innerHTML = person.lang; 这个例子使用 setter 来确保语言的大写更新： 实例1234567891011121314var person = &#123; firstName: &quot;Bill&quot;, lastName : &quot;Gates&quot;, language : &quot;NO&quot;, set lang(value) &#123; this.language = value.toUpperCase(); &#125;&#125;;// 使用 setter 设置对象属性：person.lang = &quot;en&quot;;// 显示来自对象的数据：document.getElementById(&quot;demo&quot;).innerHTML = person.language; 新的对象属性和方法Object.defineProperty() 是 ES5 中的新对象方法。 它允许您定义对象属性和&#x2F;或更改属性的值和&#x2F;或元数据。 实例123456789101112131415161718192021// 创建对象：var person = &#123; firstName: &quot;Bill&quot;, lastName : &quot;Gates&quot;, language : &quot;NO&quot;, &#125;;// 更改属性：Object.defineProperty(person, &quot;language&quot;, &#123; value: &quot;EN&quot;, writable : true, enumerable : true, configurable : true&#125;);// 枚举属性var txt = &quot;&quot;;for (var x in person) &#123; txt += person[x] + &quot;&lt;br&gt;&quot;;&#125;document.getElementById(&quot;demo&quot;).innerHTML = txt; 下一个例子是相同的代码，但它隐藏了枚举中的语言属性： 实例123456789101112131415161718192021// 创建对象：var person = &#123; firstName: &quot;Bill&quot;, lastName : &quot;Gates&quot;, language : &quot;NO&quot;, &#125;;// 更改属性：Object.defineProperty(person, &quot;language&quot;, &#123; value: &quot;EN&quot;, writable : true, enumerable : false, configurable : true&#125;);// 枚举属性var txt = &quot;&quot;;for (var x in person) &#123; txt += person[x] + &quot;&lt;br&gt;&quot;;&#125;document.getElementById(&quot;demo&quot;).innerHTML = txt; 此例创建一个 setter 和 getter 来确保语言的大写更新： 实例123456789101112131415161718// 创建对象：var person = &#123; firstName: &quot;Bill&quot;, lastName : &quot;Gates&quot;, language : &quot;NO&quot;&#125;;// 更改属性：Object.defineProperty(person, &quot;language&quot;, &#123; get : function() &#123; return language &#125;, set : function(value) &#123; language = value.toUpperCase()&#125;&#125;);// 更改语言person.language = &quot;en&quot;;// 显示语言document.getElementById(&quot;demo&quot;).innerHTML = person.language; ES5 新的对象方法ECMAScript 5 为 JavaScript 添加了许多新的对象方法： 1234567891011121314151617181920212223242526272829303132333435// 添加或更改对象属性Object.defineProperty(object, property, descriptor)// 添加或更改多个对象属性Object.defineProperties(object, descriptors)// 访问属性Object.getOwnPropertyDescriptor(object, property)// 将所有属性作为数组返回Object.getOwnPropertyNames(object)// 将可枚举属性作为数组返回Object.keys(object)// 访问原型Object.getPrototypeOf(object)// 防止向对象添加属性Object.preventExtensions(object)// 如果可以将属性添加到对象，则返回 trueObject.isExtensible(object)// 防止更改对象属性（而不是值）Object.seal(object)// 如果对象被密封，则返回 trueObject.isSealed(object)// 防止对对象进行任何更改Object.freeze(object)// 如果对象被冻结，则返回 trueObject.isFrozen(object) 对字符串的属性访问charAt() 方法返回字符串中指定索引（位置）的字符： 实例12var str = &quot;HELLO WORLD&quot;;str.charAt(0); // 返回 H ECMAScript 5 允许对字符串进行属性访问： 实例12var str = &quot;HELLO WORLD&quot;;str[0]; // 返回 H 对字符串的属性访问可能有点不可预测。 请在 中学习更多内容。 尾随逗号(Trailing Commas)ECMAScript 5 允许在对象和数组定义中使用尾随逗号： Object 实例12345person = &#123; firstName: &quot;Bill&quot;, lastName: &quot; Gates&quot;, age: 62,&#125; Array 实例12345678points = [ 1, 5, 10, 25, 40, 100,]; 警告！！！Internet Explorer 8 将崩溃。 JSON 不允许使用尾随逗号。 JSON 对象：1234567// 允许：var person = &#x27;&#123;&quot;firstName&quot;:&quot;Bill&quot;, &quot;lastName&quot;:&quot;Gates&quot;, &quot;age&quot;:62&#125;&#x27;JSON.parse(person)// 不允许：var person = &#x27;&#123;&quot;firstName&quot;:&quot;Bill&quot;, &quot;lastName&quot;:&quot;Gates&quot;, &quot;age&quot;:62,&#125;&#x27;JSON.parse(person) JSON 数组：12345// 允许：points = [40, 100, 1, 5, 25, 10]// 不允许：points = [40, 100, 1, 5, 25, 10,] 多行字符串如果使用反斜杠转义，ECMAScript 5 允许多行的字符串文字（字面量）： 实例12&quot;Hello \\Kitty!&quot;; \\ 方法可能没有得到普遍的支持。 较旧的浏览器可能会以不同的方式处理反斜杠周围的空格。 一些旧的浏览器不允许 \\ 字符后面的空格。 分解字符串文字的一种更安全的方法是使用字符串添加： 实例12&quot;Hello &quot; + &quot;Kitty!&quot;; 保留字作为属性名称ECMAScript 5 允许保留字作为属性名称： 对象实例1var obj = &#123;name: &quot;Bill&quot;, new: &quot;yes&quot;&#125; ES5（ECMAScript 5）浏览器支持Chrome 23、IE 10 和 Safari 6 是第一批完全支持 ECMAScript 5 的浏览器： Chrome 23 IE10 &#x2F; Edge Firefox 21 Safari 6 Opera 15 2012 年 9 月 2012 年 9 月 2013 年 4 月 2012 年 7 月 2013 年 7 月","tags":["JavaScript"],"categories":["Language"]},{"title":"01_JavaScript_版本","path":"/posts/e518e6ab.html","content":"JavaScript 版本JavaScript 由 Brendan Eich 于 1995 年发明，并于 1997 年成为 ECMA 标准。 ECMAScript 是该语言的官方名称。 从 2015 年起，ECMAScript 按年命名（ECMAScript 2015）。 ECMAScript 版本 版本 官方名称 描述 1 ECMAScript 1 (1997) 第一版。 2 ECMAScript 2 (1998) 只改变编辑方式。 3 ECMAScript 3 (1999) 添加了正则表达式。添加了 try&#x2F;catch。 4 ECMAScript 4 从未发布过。 5 ECMAScript 5 (2009) 添加了“严格模式”。添加了 JSON 支持。添加了 String.trim()。添加了 Array.isArray()。添加了数组迭代方法。 5.1 ECMAScript 5.1 (2011) 编辑改变。 6 ECMAScript 2015 添加了 let 和 const添加了默认参数值添加了 Array.find()添加了 Array.findIndex() 7 ECMAScript 2016 添加了指数运算符（**）。添加了 Array.prototype.includes。 8 ECMAScript 2017 添加了字符串填充。添加了新的 Object 属性。添加了异步功能。添加了共享内存。 9 ECMAScript 2018 添加了 rest &#x2F; spread 属性。添加了异步迭代。添加了 Promise.finally()。增加 RegExp。 ECMAScript 通常缩写为 ES。 浏览器支持所有浏览器都完全支持 ECMAScript 3。 所有现代浏览器都完全支持 ECMAScript 5。 对 ES5 的浏览器支持（2009） 浏览器 版本 起始日期 Chrome 23 2012 年 9 月 Firefox 21 2013 年 4 月 IE 9* 2011 年 3 月 IE &#x2F; Edge 10 2012 年 9 月 Safari 6 2012 年 7 月 Opera 15 2013 年 7 月 * Internet Explorer 9 不支持 ECMAScript 5 “use strict”。 对 ES6 的浏览器支持（ECMAScript 2015） 浏览器 版本 日期 Chrome 58 2017 年 4 月 Firefox 54 2017 年 6 月 Edge 14 2016 年 8 月 Safari 10 2016 年 9 月 Opera 55 2017 年 8 月 Internet Explorer 不支持 ECMAScript 2015。 对 ES7 的浏览器支持（ECMAScript 2016） 浏览器 版本 日期 Chrome 68 2018 年 5 月 Opera 47 2018 年 7 月 JavaScript &#x2F; ECMAScriptJavaScript 是为 Netscape 开发的。 Netscape 2 是第一个运行 JavaScript 的浏览器。 在 Netscape 之后，Mozilla 基金会继续为 Firefox 浏览器开发 JavaScript。 最新的 JavaScript 版本是 1.8.5。 （与 ECMAScript 5 相同）。 ECMAScript 由 ECMA International 在组织采用 JavaScript 之后开发的。 第一版 ECMAScript 于 1997 年发布。 此列表比较了不同产品的版本号： 年份 JavaScript ECMA 浏览器 1996 1.0 Netscape 2 1997 ECMAScript 1 IE 4 1998 1.3 Netscape 4 1999 ECMAScript 2 IE 5 2000 ECMAScript 3 IE 5.5 2000 1.5 Netscape 6 2000 1.5 Firefox 1 2011 ECMAScript 5 IE 9（除了 “use strict”） 2011 1.8.5 Firefox 4（除了 parseInt 中的前导零） 2012 IE 10 2012 Chrome 23 2012 Safari 6 2013 Firefox 21 2013 Opera 15 2015 ECMAScript 2015 在所有浏览器中部分支持 IE 4 是第一个支持 ECMAScript 1（1997）的浏览器。 IE 5 是第一个支持 ECMAScript 2（1999）的浏览器。 IE 5.5 是第一个支持 ECMAScript 3（2000）的浏览器。 IE 9 * 是第一个支持 ECMAScript 5（2011）的浏览器。 Internet Explorer 9 不支持 ECMAScript 5“use strict”。 Chrome 23、IE 10 和Safari 6 是第一批完全支持 ECMAScript 5 的浏览器： Chrome 23 IE10 &#x2F; Edge Firefox 21 Safari 6 Opera 15 2012 年 9 月 2012 年 9 月 2013 年 4 月 2012 年 7 月 2013 年 7 月","tags":["JavaScript"],"categories":["Language"]},{"title":"58_JavaScript_保留词","path":"/posts/57771c7f.html","content":"JavaScript 保留词在 JavaScript 中，您不能把这些保留词作为变量、标记或函数名来使用： abstract arguments await* boolean break byte case catch char class* const continue debugger default delete do double else enum* eval export* extends* false final finally float for function goto if implements import* in instanceof int interface let* long native new null package private protected public return short static super* switch synchronized this throw throws transient true try typeof var void volatile while with yield 用星号标记的关键词是 ECMAScript 5 和 6 中的新词。 被删除的保留词以下保留词已被从 ECMAScript 5&#x2F;6 标准中删除： abstract boolean byte char double final float goto int long native short synchronized throws transient volatile 请不要将这些保留词用作变量。并非所有浏览器都完全支持 ECMAScript 5&#x2F;6。 JavaScript 对象、属性和方法您还应该避免使用 JavaScript 内建对象的名称、属性和方法： Array Date eval function hasOwnProperty Infinity isFinite isNaN isPrototypeOf length Math NaN name Number Object prototype String toString undefined valueOf Java 保留词JavaScript 常与 Java 一起使用。您应该避免把某些 Java 对象和属性用作 JavaScript 标识符： getClass java JavaArray javaClass JavaObject JavaPackage 其他保留词JavaScript 能够在很多应用程序中被用作编程语言。 您还应该避免使用 HTML 和 Window 对象和属性的名称： alert all anchor anchors area assign blur button checkbox clearInterval clearTimeout clientInformation close closed confirm constructor crypto decodeURI decodeURIComponent defaultStatus document element elements embed embeds encodeURI encodeURIComponent escape event fileUpload focus form forms frame innerHeight innerWidth layer layers link location mimeTypes navigate navigator frames frameRate hidden history image images offscreenBuffering open opener option outerHeight outerWidth packages pageXOffset pageYOffset parent parseFloat parseInt password pkcs11 plugin prompt propertyIsEnum radio reset screenX screenY scroll secure select self setInterval setTimeout status submit taint text textarea top unescape untaint window HTML 事件处理程序此外您应该避免使用所有 HTML 事件处理程序的名称。 例如： onblur onclick onerror onfocus onkeydown onkeypress onkeyup onmouseover onload onmouseup onmousedown onsubmit","tags":["JavaScript"],"categories":["Language"]},{"title":"57_JavaScript_性能","path":"/posts/c027307d.html","content":"如何加速您的 JavaScript 代码。 减少循环中的活动编程经常会用到循环。 循环每迭代一次，循环中的每条语句，包括 for 语句，都会被执行。 能够放在循环之外的语句或赋值会使循环运行得更快。 差的代码： 12var i;for (i = 0; i &lt; arr.length; i++) &#123; 更好的代码： 123var i;var l = arr.length;for (i = 0; i &lt; l; i++) &#123; 循环每次迭代时，坏代码就会访问数组的 length 属性。 好代码在循环之外访问 length 属性，使循环更快。 减少 DOM 访问与其他 JavaScript 相比，访问 HTML DOM 非常缓慢。 假如您期望访问某个 DOM 元素若干次，那么只访问一次，并把它作为本地变量来使用： 实例123var obj;obj = document.getElementById(&quot;demo&quot;);obj.innerHTML = &quot;Hello&quot;; 缩减 DOM 规模请尽量保持 HTML DOM 中较少的元素数量。 这么做总是会提高页面加载，并加快渲染（页面显示），尤其是在较小的设备上。 每一次试图搜索 DOM（比如 getElementsByTagName）都将受益于一个较小的 DOM。 避免不必要的变量请不要创建不打算存储值的新变量。 通常您可以替换代码： 12var fullName = firstName + &quot; &quot; + lastName;document.getElementById(&quot;demo&quot;).innerHTML = fullName; 用这段代码： 1document.getElementById(&quot;demo&quot;).innerHTML = firstName + &quot; &quot; + lastName 延迟 JavaScript 加载请把脚本放在页面底部，使浏览器首先加载页面。 脚本在下载时，浏览器不会启动任何其他的下载。此外所有解析和渲染活动都可能会被阻塞。 HTTP 规范定义浏览器不应该并行下载超过两种要素。 一个选项是在 script 标签中使用 defer=&quot;true&quot;。defer 属性规定了脚本应该在页面完成解析后执行，但它只适用于外部脚本。 如果可能，您可以在页面完成加载后，通过代码向页面添加脚本： 实例123456789&lt;script&gt;window.onload = downScripts;function downScripts() &#123; var element = document.createElement(&quot;script&quot;); element.src = &quot;myScript.js&quot;; document.body.appendChild(element);&#125;&lt;/script&gt; 避免使用 with请避免使用 with 关键词。它对速度有负面影响。它也将混淆 JavaScript 作用域。 严格模式中不允许 with 关键词。","tags":["JavaScript"],"categories":["Language"]},{"title":"56_JavaScript_常见错误","path":"/posts/92716d46.html","content":"本章指出一些常见的 JavaScript 错误。 意外使用赋值运算符如果程序员在 if 语句中意外使用赋值运算符（=）而不是比较运算符（===），JavaScript 程序可能会产生一些无法预料的结果。 这条 if 语句返回 false（正如预期），因为 x 不等于 10： 12var x = 0;if (x == 10) 这条 if 语句返回 true（也许不像预期），因为 10 为 true： 12var x = 0;if (x = 10) 这条 if 语句返回 false（也许不像预期），因为 0 为 false： 12var x = 0;if (x = 0) 赋值总是返回赋值的值。 期望松散的比较在常规比较中，数据类型不重要。这条 if 语句返回 true： 123var x = 10;var y = &quot;10&quot;;if (x == y) 在严格比较中，数据类型确实重要。这条 if 语句返回 false： 123var x = 10;var y = &quot;10&quot;;if (x === y) 有一个常见的错误是忘记在 switch 语句中使用严格比较： 这条 switch 语句会显示提示框： 1234var x = 10;switch(x) &#123; case 10: alert(&quot;Hello&quot;);&#125; 这条 switch 语句不会显示提示框： 1234var x = 10;switch(x) &#123; case &quot;10&quot;: alert(&quot;Hello&quot;);&#125; 令人困惑的加法和级联加法用于加数值。 级联（Concatenation）用于加字符串。 在 JavaScript 中，这两种运算均使用相同的 + 运算符。 正因如此，将数字作为数值相加，与将数字作为字符串相加，将产生不同的结果： 12var x = 10 + 5; // x 中的结果是 15var x = 10 + &quot;5&quot;; // x 中的结果是　&quot;105&quot; 如果是两个变量相加，很难预测结果： 1234567var x = 10;var y = 5;var z = x + y; // z 中的结果是 15var x = 10;var y = &quot;5&quot;;var z = x + y; // z 中的结果是 &quot;105&quot; 令人误解的浮点JavaScript 中的数字均保存为 64 位的浮点数（Floats）。 所有编程语言，包括 JavaScript，都存在处理浮点值的困难： 123var x = 0.1;var y = 0.2;var z = x + y // z 中的结果并不是 0.3 为了解决上面的问题，请使用乘除运算： 实例1var z = (x * 10 + y * 10) / 10; // z 中的结果将是 0.3 对 JavaScript 字符串换行JavaScript 允许您把一条语句换行为两行： 例子 112var x =&quot;Hello World!&quot;; 但是，在字符串中间来换行是不对的： 例子 212var x = &quot;HelloWorld!&quot;; 如果必须在字符串中换行，则必须使用反斜杠： 例子 312var x = &quot;Hello \\World!&quot;; 错位的分号因为一个错误的分号，此代码块无论 x 的值如何都会执行： 1234if (x == 19);&#123; // code block&#125; 对 return 语句进行换行在一行的结尾自动关闭语句是默认的 JavaScript 行为。 正因如此，下面两个例子返回相同的结果： 例子 11234function myFunction(a) &#123; var power = 10 return a * power&#125; 例子 21234function myFunction(a) &#123; var power = 10; return a * power;&#125; JavaScript 也允许您将一条语句换行为两行。 正因如此，例子 3 也将返回相同的结果： 例子 312345function myFunction(a) &#123; var power = 10; return a * power;&#125; 但是，如果把 return 语句换行为两行会发生什么呢： 例子 4123456function myFunction(a) &#123; var power = 10; return a * power;&#125; 此函数将返回 undefined！ 为什么呢？因为 JavaScript 认为你的意思是： 例子 5123456function myFunction(a) &#123; var power = 10; return; a * power;&#125; 解释如果某条语句是不完整的： 1var JavaScript 将通过读取下一行来完成这条语句： 1power = 10; 但是由于这条语句是完整的： 1return JavaScript 会自动关闭该语句： 1return; 发生这种情况是因为，在 JavaScript 中，用分号来关闭（结束）语句是可选的。 JavaScript 会在行末关闭 return 语句，因为它本身就是一条完整的语句。 所以，绝不要对 return 语句进行换行。 通过命名索引来访问数组很多编程语言支持带有命名索引的数组。 带有命名索引的数组被称为关联数组（或散列）。 JavaScript 不支持带有命名索引的数组。 在 JavaScript 中，数组使用数字索引： 实例123456var person = [];person[0] = &quot;Bill&quot;;person[1] = &quot;Gates&quot;;person[2] = 46;var x = person.length; // person.length 将返回 3var y = person[0]; // person[0] 将返回 &quot;Bill&quot; 在 JavaScript 中，对象使用命名索引。 如果您使用命名索引，那么在访问数组时，JavaScript 会将数组重新定义为标准对象。 在自动重定义之后，数组方法或属性将产生未定义或非正确的结果： 实例123456var person = [];person[&quot;firstName&quot;] = &quot;Bill&quot;;person[&quot;lastName&quot;] = &quot;Gates&quot;;person[&quot;age&quot;] = 46;var x = person.length; // person.length 将返回 0var y = person[0]; // person[0] 将返回 undefined 用逗号来结束定义对象和数组定义中的尾随逗号在 ECMAScript 5 中是合法的。 对象实例：1person = &#123;firstName:&quot;Bill&quot;, lastName:&quot;Gates&quot;, age:62,&#125; 数组实例：1points = [35, 450, 2, 7, 30, 16,]; 警告！！Internet Explorer 8 会崩溃。 JSON 不允许尾随逗号。 JSON:1person = &#123;firstName:&quot;Bill&quot;, lastName:&quot;Gates&quot;, age:62&#125; JSON:1points = [35, 450, 2, 7, 30, 16]; Undefined 不是 NullJavaScript 对象、变量、属性和方法可以是未定义的。 此外，空的 JavaScript 对象的值可以为 null。 这可能会使测试对象是否为空变得有点困难。 您可以通过测试类型是否为 undefined，来测试对象是否存在： 实例1if (typeof myObj === &quot;undefined&quot;) 但是您无法测试对象是否为 null，因为如果对象未定义，将抛出错误： 不正确的：1if (myObj === null) 要解决此问题，必须测试对象是否为 null，而不是未定义。 但这仍然会引发错误： 不正确的：1if (myObj !== null &amp;&amp; typeof myObj !== &quot;undefined&quot;) 因此，在测试非 null 之前，必须先测试未定义： 正确的：1if (typeof myObj !== &quot;undefined&quot; &amp;&amp; myObj !== null) 期望块级范围JavaScript 不会为每个代码块创建新的作用域。 很多编程语言都是如此，但是 JavaScript 并非如此。 认为这段代码会返回 undefined，是新的 JavaScript 开发者的常见错误： 实例1234for (var i = 0; i &lt; 10; i++) &#123; // 代码块&#125;return i;","tags":["JavaScript"],"categories":["Language"]},{"title":"55_JavaScript_最佳实践","path":"/posts/d72d6436.html","content":"请避免全局变量、new、===、eval() 避免全局变量请尽量少地使用全局变量。 它包括所有的数据类型、对象和函数。 全局变量和函数可被其他脚本覆盖。 请使用局部变量替代，并学习如何使用闭包。 始终声明局部变量所有在函数中使用的变量应该被声明为局部变量。 局部变量必须通过 var 关键词来声明，否则它们将变成全局变量。 严格模式不允许未声明的变量。 在顶部声明一项好的编码习惯是把所有声明放在每段脚本或函数的顶部。 这么做的好处是： 获得更整洁的代码 提供了查找局部变量的好位置 更容易避免不需要的全局变量 减少不需要的重新声明的可能性 1234567891011// 在顶部声明var firstName, lastName, price, discount, fullPrice;// 稍后使用firstName = &quot;Bill&quot;;lastName = &quot;Gates&quot;;price = 19.90;discount = 0.10;fullPrice = price * 100 / discount; 也可以用于循环变量： 12345// 在顶部声明var i;// 稍后使用for (i = 0; i &lt; 5; i++) &#123; 默认地，JavaScript 会将所有声明移至顶部（JavaScript hoisting）。 初始化变量在您声明变量时对其进行初始化是个好习惯。 这么做的好处是： 更整洁的代码 在单独的位置来初始化变量 避免未定义值 12345678// 在开头进行声明和初始化var firstName = &quot;&quot;, lastName = &quot;&quot;, price = 0, discount = 0, fullPrice = 0, myArray = [], myObject = &#123;&#125;; 变量初始化使我们能够了解预期用途和预期的数据类型。 请不要声明数值、字符串或布尔对象请始终将数值、字符串或布尔值视作原始值。而非对象。 如果把这些类型声明为对象，会拖慢执行速度，并产生讨厌的副作用： 实例123var x = &quot;Bill&quot;; var y = new String(&quot;Bill&quot;);(x === y) // 结果为 false，因为 x 是字符串，而 y 是对象。 或者甚至更糟： 实例123var x = new String(&quot;Bill&quot;); var y = new String(&quot;Bill&quot;);(x == y) // 结果是 false，因为你无法比较对象。 请勿使用 new Object() 请使用 {} 来代替 new Object() 请使用 “” 来代替 new String() 请使用 0 来代替 new Number() 请使用 false 来代替 new Boolean() 请使用 [] 来代替 new Array() 请使用 &#x2F;()&#x2F; 来代替 new RegExp() 请使用 function (){}来代替 new Function() 实例1234567var x1 = &#123;&#125;; // 新对象var x2 = &quot;&quot;; // 新的原始字符串值var x3 = 0; // 新的原始数值var x4 = false; // 新的原始布尔值var x5 = []; // 新的数组对象var x6 = /()/; // 新的正则表达式var x7 = function()&#123;&#125;; // 新的函数对象 意识到自动类型转换请意识到数值会被意外转换为字符串或 NaN（Not a Number）。 JavaScript 属于松散类型。变量可包含不同的数据类型，并且变量能够改变其数据类型： 实例12var x = &quot;Hello&quot;; // typeof x 为字符串x = 5; // 把 typeof x 更改为数值 如果进行数学运算，JavaScript 能够将数值转换为字符串： 实例1234567var x = 5 + 7; // x.valueOf() 是 12, typeof x 是数值var x = 5 + &quot;7&quot;; // x.valueOf() 是 57, typeof x 是字符串var x = &quot;5&quot; + 7; // x.valueOf() 是 57, typeof x 是字符串var x = 5 - 7; // x.valueOf() 是 -2, typeof x 是数值var x = 5 - &quot;7&quot;; // x.valueOf() 是 -2, typeof x 是数值var x = &quot;5&quot; - 7; // x.valueOf() 是 -2, typeof x 是数值var x = 5 - &quot;x&quot;; // x.valueOf() 是 NaN, typeof x 是数值 用字符串减去字符串，不会产生错误而是返回 NaN（Not a Number）： 实例1&quot;Hello&quot; - &quot;Dolly&quot; // 返回 NaN 使用 &#x3D;&#x3D;&#x3D; 比较== 比较运算符总是在比较之前进行类型转换（以匹配类型）。 === 运算符会强制对值和类型进行比较： 实例12345670 == &quot;&quot;; // true1 == &quot;1&quot;; // true1 == true; // true0 === &quot;&quot;; // false1 === &quot;1&quot;; // false1 === true; // false 使用 Parameter Defaults如果调用函数时缺少一个参数，那么这个缺失参数的值会被设置为 undefined。 undefined 值会破坏您的代码。为参数设置默认值是一个好习惯。 实例12345function myFunction(x, y) &#123; if (y === undefined) &#123; y = 0; &#125;&#125; 用 default 来结束 switch请使用 default 来结束您的 switch 语句。即使您认为没有这个必要。 实例12345678910111213141516171819202122232425switch (new Date().getDay()) &#123; case 0: day = &quot;Sunday&quot;; break; case 1: day = &quot;Monday&quot;; break; case 2: day = &quot;Tuesday&quot;; break; case 3: day = &quot;Wednesday&quot;; break; case 4: day = &quot;Thursday&quot;; break; case 5: day = &quot;Friday&quot;; break; case 6: day = &quot;Saturday&quot;; break; default: day = &quot;Unknown&quot;;&#125; 避免使用 eval()eval() 函数用于将文本作为代码来允许。在几乎所有情况下，都没有必要使用它。 因为允许任意代码运行，它同时也意味着安全问题。","tags":["JavaScript"],"categories":["Language"]},{"title":"54_JavaScript_样式指南","path":"/posts/867e7548.html","content":"请始终为您所有的 JavaScript 项目使用相同的代码约定。 JavaScript 代码约定代码约定(Coding conventions)指的是编程的样式指导方针。这些原则大体上包括： 变量和函数的命名和声明规则 使用空格、缩进和注释的规则 编程习惯和准则 代码约定确保质量： 改善代码可读性 提升代码可维护性 代码约定可以是团队遵守的成文规则，也可以是您个人的编码习惯。 本页介绍 W3School 使用的通用 JavaScript 代码约定。 您应该继续阅读下一章“最佳实践”，学习如何避免编码陷阱。 变量名在 W3School，我们对标识符名称（变量和函数）使用了驼峰式大小写。 所有名称以字母开头。 在本页的底部，我们会更广泛地讨论命名规则。 1234567firstName = &quot;Bill&quot;;lastName = &quot;Gates&quot;;price = 19.90;tax = 0.20;fullPrice = price + (price * tax); 运算符周围的空格请始终在运算符（ &#x3D; + - * &#x2F; ）周围以及逗号之后添加空格： 实例12var x = y + z;var values = [&quot;Volvo&quot;, &quot;Saab&quot;, &quot;Fiat&quot;]; 代码缩进请始终使用对代码块缩进使用 4 个空格： 函数123function toCelsius(fahrenheit) &#123; return (5 / 9) * (fahrenheit - 32);&#125; 请不要对缩进使用制表符。不同的编辑器对 tab 的解释也不尽相同。 语句规则简单语句的通用规则： 请始终以分号结束单条语句： 实例12345678var values = [&quot;Volvo&quot;, &quot;Saab&quot;, &quot;Fiat&quot;];var person = &#123; firstName: &quot;Bill&quot;, lastName: &quot;Gates&quot;, age: 50, eyeColor: &quot;blue&quot;&#125;; 针对复杂语句（compound）的通用规则： 请在第一行的结尾处写开括号 请在开括号前使用一个空格 请在新行上写闭括号，不带前导空格 请不要以分号来结束复杂语句 函数：123function toCelsius(fahrenheit) &#123; return (5 / 9) * (fahrenheit - 32);&#125; 循环：123for (i = 0; i &lt; 5; i++) &#123; x += i;&#125; 条件：12345if (time &lt; 20) &#123; greeting = &quot;Good day&quot;;&#125; else &#123; greeting = &quot;Good evening&quot;;&#125; 对象规则针对对象定义的通用规则： 把开括号与对象名放在同一行 在每个属性与其值之间使用冒号加一个空格 不要在最后一个属性值对后面写逗号 请在新行上写闭括号，不带前导空格 请始终以分号结束对象定义 实例123456var person = &#123; firstName: &quot;Bill&quot;, lastName: &quot;Gates&quot;, age: 19, eyeColor: &quot;blue&quot;&#125;; 可以对短对象在一行中进行压缩，只在属性之间使用空格，就像这样： 1var person = &#123;firstName:&quot;Bill&quot;, lastName:&quot;Gates&quot;, age:50, eyeColor:&quot;blue&quot;&#125;; 行长度小于 80为了提高可读性，请避免每行的长度超过 80 个字符。 如果 JavaScript 语句超过一行的长度，换行的最佳位置是运算符或逗号之后。 实例12document.getElementById(&quot;demo&quot;).innerHTML = &quot;Hello Kitty.&quot;; 命名约定请始终对您所有的代码使用相同的命名约定。例如： 变量和函数名以驼峰大小写来写 全局变量使用大写（我们不这样做，但是相当普遍） 常量（比如 PI）使用大写 我们是否应在变量名中使用连字符、驼峰大小写或下划线吗？ 这是程序员们经常讨论的问题。答案取决于这个问题是谁回答的： HTML 和 CSS 中的连字符：HTML5 属性能够以 data- 开头（data-quantity, data-price）。 CSS 在 property-names 中使用连字符（font-size）。 Hyphens 可被错误地视为减法运算符。JavaScript 命名不允许使用连字符。 下划线：许多程序员喜欢使用下划线（date_of_birth），特别是在 SQL 数据库中。 下划线经常被用在 PHP 参考资料中。 帕斯卡命名法（PascalCase）：C 语言程序员经常使用帕斯卡命名法。 驼峰大小写（camelCase）：JavaScript 本身、jQuery 以及其他 JavaScript 库使用驼峰大小写。 JavaScript 命名请不要以 $ 符号开头。此举会引起 JavaScript 库名称冲突。 在 HTML 中加载 JavaScript使用简单的语法来加载外部脚本（type 属性不是必需的）： 1&lt;script src=&quot;myscript.js&quot;&gt;&lt;/script&gt; 访问 HTML 元素使用“不整洁的” HTML 样式的后果，也许是导致 JavaScript 错误。 这两条 JavaScript 语句会产生不同的结果： 123var obj = getElementById(&quot;Demo&quot;)var obj = getElementById(&quot;demo&quot;) 如果可能，请在 HTML 中使用相同的命名约定（就像 JavaScript 那样）。 文件扩展名HTML 文件应该使用 .html 扩展名（而非 .htm）。 CSS 文件应该使用 .css 扩展名。 JavaScript 文件应该使用 .js 扩展名。 使用小写文件名大多数 web 服务器（Apache、Unix）对文件名的大小写敏感： london.jpg 无法视作 London.jpg 进行访问。 其他 web 服务器（微软的 IIS）对大小写不敏感： london.jpg 能够以 London.jpg 或 london.jpg 来访问。 如果您混合使用大小写，则必须严格保持连续和一致。 如果您将站点从大小写不敏感的服务器转移至对大小写敏感的服务器，即使这种小错误也可能破坏您的网站。 为了避免这些问题，请始终使用小写文件名（如果可能）。 性能计算机不会使用代码约定。大部分规则对程序的执行影响很小。 缩进和额外的空格对小段脚本并不重要。 对于开发中的脚本，应该优先考虑可读性。应该缩小更大型的生产脚本。","tags":["JavaScript"],"categories":["Language"]},{"title":"53_JavaScript_调试","path":"/posts/91b01f54.html","content":"错误总会发生，每当您写一些新的计算机代码时。 JavaScript 调试在没有调试器的情况下写 JavaScript 是有难度的。 您的代码中也许包含了语法错误，或者逻辑错误，这些都难以诊断。 通常，如果 JavaScript 代码包含错误，也不会发生任何事情。不会有错误消息，并且不会有任何可供查找错误的指示信息。 通常，每当你尝试编写新的 JavaScript 代码，就可能发生错误。 JavaScript 调试器查找编程代码中的错误被称为代码调试。 调试并不简单。但幸运地是，所有现代浏览器都有内置的调试器。 内置的调试器可打开或关闭，强制将错误报告给用户。 通过调试器，您也可以设置断点（代码执行被中断的位置），并在代码执行时检查变量。 通常通过 F12 键启动浏览器中的调试器，然后在调试器菜单中选择“控制台”。 console.log() 方法如果您的浏览器支持调试，那么您可以使用 console.log() 在调试窗口中显示 JavaScript 的值： 实例123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;My First Web Page&lt;/h1&gt;&lt;script&gt;a = 5;b = 6;c = a + b;console.log(c);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 提示：请访问我们的 JavaScript Console 参考手册，获取更多有关 console.log() 方法的信息。 设置断点在调试窗口中，您可在 JavaScript 代码中设置断点。 在每个断点中，JavaScript 将停止执行，以使您能够检查 JavaScript 的值。 在检查值之后，您可以恢复代码执行。 debugger 关键词debugger 关键词会停止 JavaScript 的执行，并调用（如果有）调试函数。 这与在调试器中设置断点的功能是一样的。 如果调试器不可用，debugger 语句没有效果。 如果调试器已打开，此代码会在执行第三行之前停止运行。 实例123var x = 15 * 5;debugger;document.getElementbyId(&quot;demo&quot;).innerHTML = x; 主流浏览器的调试工具通常，您在浏览器中通过 F12 键启用调试，并在调试器菜单中选择“控制台”。 否则请按照以下步骤： Chrome 打开浏览器 从菜单中选择工具 从工具中选择开发者工具 最后，选择控制台 Firefox Firebug 打开浏览器 前往网页：http://www.getfirebug.com 根据如下指令：如何安装 Firebug Internet Explorer 打开浏览器 从菜单选择工具 从工具选择开发者工具 最后，选择控制台 Opera 打开浏览器 请前往网页：http://dev.opera.com 根据如下指令：如何安装 Firebug Lite Safari Develop Menu 点击 Safari 菜单，偏好设置，高级 选中“在菜单栏中启用开发菜单” 当菜单中出现新选项“开发”时，选择“显示错误控制台” 您知道吗？调试是测试、找到并减少计算机程序中 bug（错误）的过程。 历史上首个已知的计算机 bug 是一只卡在电子器件中的真实的虫子（一种昆虫）。","tags":["JavaScript"],"categories":["Language"]},{"title":"52_JavaScript_JSON","path":"/posts/3e8ab108.html","content":"JSON 是存储和传输数据的格式。 JSON 经常在数据从服务器发送到网页时使用。 什么是 JSON？ JSON 指的是 JavaScript Object Notation JSON 是轻量级的数据交换格式 JSON 独立于语言 ***** JSON 是“自描述的”且易于理解 * JSON 的语法是来自 JavaScript 对象符号的语法，但 JSON 格式是纯文本。读取和生成 JSON 数据的代码可以在任何编程语言编写的。 JSON 实例JSON 语法定义了一个雇员对象：包含三条员工记录的数组（对象）： JSON 实例1234567&#123;&quot;employees&quot;:[ &#123;&quot;firstName&quot;:&quot;Bill&quot;, &quot;lastName&quot;:&quot;Gates&quot;&#125;, &#123;&quot;firstName&quot;:&quot;Steve&quot;, &quot;lastName&quot;:&quot;Jobs&quot;&#125;, &#123;&quot;firstName&quot;:&quot;Alan&quot;, &quot;lastName&quot;:&quot;Turing&quot;&#125;]&#125; JSON 格式评估为 JavaScript 对象JSON 格式在语法上与创建 JavaScript 对象的代码相同。 由于这种相似性，JavaScript 程序可以很容易地将 JSON 数据转换成本地的 JavaScript 对象。 JSON 语法规则 数据是名称&#x2F;值对 数据由逗号分隔 花括号保存对象 方括号保存数组 JSON 数据 - 名称和值JSON 数据的书写方式是名称&#x2F;值对，类似 JavaScript 对象属性。 名称&#x2F;值对由（双引号中的）字段名构成，其后是冒号，再其后是值： 1&quot;firstName&quot;:&quot;Bill&quot; JSON 名称需要双引号。JavaScript 名称不需要。 JSON 对象JSON 对象是在花括号内书写的。 类似 JavaScript，对象能够包含多个名称&#x2F;值对： 1&#123;&quot;firstName&quot;:&quot;Bill&quot;, &quot;lastName&quot;:&quot;Gates&quot;&#125; JSON 数组JSON 数组在方括号中书写。 类似 JavaScript，数组能够包含对象： 12345&quot;employees&quot;:[ &#123;&quot;firstName&quot;:&quot;Bill&quot;, &quot;lastName&quot;:&quot;Gates&quot;&#125;, &#123;&quot;firstName&quot;:&quot;Steve&quot;, &quot;lastName&quot;:&quot;Jobs&quot;&#125;, &#123;&quot;firstName&quot;:&quot;Alan&quot;, &quot;lastName&quot;:&quot;Turing&quot;&#125;] 在上面的例子中，对象 “employees” 是一个数组。它包含了三个对象。 每个对象代表一个人的一条记录（带有名和姓）。 把 JSON 文本转换为 JavaScript 对象JSON 的通常用法是从 web 服务器读取数据，然后在网页中显示数据。 为了简单起见，可以使用字符串作为输入演示。 首先，创建包含 JSON 语法的 JavaScript 字符串： 1234var text = &#x27;&#123; &quot;employees&quot; : [&#x27; +&#x27;&#123; &quot;firstName&quot;:&quot;Bill&quot; , &quot;lastName&quot;:&quot;Gates&quot; &#125;,&#x27; +&#x27;&#123; &quot;firstName&quot;:&quot;Steve&quot; , &quot;lastName&quot;:&quot;Jobs&quot; &#125;,&#x27; +&#x27;&#123; &quot;firstName&quot;:&quot;Alan&quot; , &quot;lastName&quot;:&quot;Turing&quot; &#125; ]&#125;&#x27;; 然后，使用 JavaScript 的内建函数 JSON.parse() 来把这个字符串转换为 JavaScript 对象： 1var obj = JSON.parse(text); 最后，请在您的页面中使用这个新的 JavaScript 对象： 实例123456&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;document.getElementById(&quot;demo&quot;).innerHTML =obj.employees[1].firstName + &quot; &quot; + obj.employees[1].lastName;&lt;/script&gt;","tags":["JavaScript"],"categories":["Language"]},{"title":"51_JavaScript_类","path":"/posts/c55c7e25.html","content":"ECMAScript 2015，也称 ES6，引入了 JavaScript 类。 JavaScript 类是 JavaScript 对象的模板。 JavaScript 类的语法请使用关键字 class 创建类。 请始终添加名为 constructor() 的方法： 语法123class ClassName &#123; constructor() &#123; ... &#125;&#125; 实例123456class Car &#123; constructor(name, year) &#123; this.name = name; this.year = year; &#125;&#125; 上面的例子创建了一个名为 “Car” 的类。 该类有两个初始属性：”name” 和 “year”。 JavaScript 类不是对象。 它只是 JavaScript 对象的模板。 使用类如果您有一个类，那么您可以使用该类来创建对象： 实例12let myCar1 = new Car(&quot;Ford&quot;, 2014);let myCar2 = new Car(&quot;Audi&quot;, 2019); 上面的例子使用 Car 类创建了两个 Car 对象。 在创建新对象时会自动调用 constructor 方法。 Constructor 方法构造方法是一种特殊的方法： 它必须拥有确切名称的“构造函数” 创建新对象时自动执行 用于初始化对象属性 如果未定义构造函数方法，JavaScript 会添加空的构造函数方法。 Class 方法类方法的创建 语法与对象方法相同。 请使用关键字 class 创建类。 请始终添加 constructor() 方法。 然后添加任意数量的方法。 语法123456class ClassName &#123; constructor() &#123; ... &#125; method_1() &#123; ... &#125; method_2() &#123; ... &#125; method_3() &#123; ... &#125;&#125; 创建名为 “age” 的类方法，它返回车龄： 实例12345678910111213class Car &#123; constructor(name, year) &#123; this.name = name; this.year = year; &#125; age() &#123; let date = new Date(); return date.getFullYear() - this.year; &#125;&#125;let myCar = new Car(&quot;Ford&quot;, 2014);document.getElementById(&quot;demo&quot;).innerHTML = &quot;My car is &quot; + myCar.age() + &quot; years old.&quot;; 您可以向类方法发送参数： 实例123456789101112131415class Car &#123; constructor(name, year) &#123; this.name = name; this.year = year; &#125; age(x) &#123; return x - this.year; &#125;&#125;let date = new Date();let year = date.getFullYear();let myCar = new Car(&quot;Ford&quot;, 2014);document.getElementById(&quot;demo&quot;).innerHTML = &quot;My car is &quot; + myCar.age(year) + &quot; years old.&quot;; 浏览器支持下表注明了首个完全支持 JavaScript 类的浏览器版本： Chrome IE Firefox Safari Opera Chrome 49 Edge 12 Firefox 45 Safari 9 Opera 36 2016 年 3 月 2015 年 7 月 2016 年 3 月 2015 年 10 月 2016 年 3 月","tags":["JavaScript"],"categories":["Language"]},{"title":"50_JavaScript_箭头函数","path":"/posts/ca235adc.html","content":"ES6 中引入了箭头函数。 箭头函数允许我们编写更短的函数 语法： 之前： 123hello = function() &#123; return &quot;Hello World!&quot;;&#125; 用了箭头函数之后： 123hello = () =&gt; &#123; return &quot;Hello World!&quot;;&#125; 确实变短了！如果函数只有一个语句，并且该语句返回一个值，则可以去掉括号和 return 关键字： 箭头函数默认返回值： 1hello = () =&gt; &quot;Hello World!&quot;; 注释：这仅在函数只有一条语句时才有效。 如果您有参数，则将它们传递到括号内： 带参数的箭头函数： 1hello = (val) =&gt; &quot;Hello &quot; + val; 事实上，如果只有一个参数，您也可以略过括号： 不带括号的箭头函数： 1hello = val =&gt; &quot;Hello &quot; + val; this 怎么办？与常规函数相比，箭头函数对 this 的处理也有所不同。 简而言之，使用箭头函数没有对 this 的绑定。 在常规函数中，关键字 this 表示调用该函数的对象，可以是窗口、文档、按钮或其他任何东西。 对于箭头函数，this 关键字始终表示定义箭头函数的对象。 让我们看两个例子来理解其中的差异。 这两个例子都调用了两次方法，第一次是在页面加载时，第二次是在用户单击按钮时。 第一个例子使用常规函数，第二个例子使用箭头函数。 结果显示第一个例子返回两个不同的对象（window 和 button），第二个例子返回两次 window 对象，因为 window 对象是函数的“所有者”。 实例对于常规函数，this 表示调用该函数的对象： 12345678910// 常规函数：hello = function() &#123; document.getElementById(&quot;demo&quot;).innerHTML += this;&#125;// window 对象调用该函数：window.addEventListener(&quot;load&quot;, hello);// button 对象调用该函数：document.getElementById(&quot;btn&quot;).addEventListener(&quot;click&quot;, hello); 实例用了箭头函数，则 this 表示函数的拥有者： 12345678910// 箭头函数：hello = () =&gt; &#123; document.getElementById(&quot;demo&quot;).innerHTML += this;&#125;// window 对象调用该函数：window.addEventListener(&quot;load&quot;, hello);// button 对象调用该函数：document.getElementById(&quot;btn&quot;).addEventListener(&quot;click&quot;, hello); 使用函数时请记住这些差异。有时，常规函数的行为正是您想要的，如果不是，请使用箭头函数。 浏览器支持下表注明了首个完全支持 JavaScript 箭头函数的浏览器版本： Chrome IE Firefox Safari Opera Chrome 45 Edge 12 Firefox 22 Safari 10 Opera 32 2015 年 9 月 2015 年 7 月 2013 年 5 月 2016 年 9 月 2015 年 9 月","tags":["JavaScript"],"categories":["Language"]},{"title":"49_JavaScript_this_关键词","path":"/posts/e6af3a43.html","content":"实例12345678var person = &#123; firstName: &quot;Bill&quot;, lastName : &quot;Gates&quot;, id : 678, fullName : function() &#123; return this.firstName + &quot; &quot; + this.lastName; &#125;&#125;; this 是什么？JavaScript this 关键词指的是它所属的对象。 它拥有不同的值，具体取决于它的使用位置： 在方法中，this 指的是所有者对象。 单独的情况下，this 指的是全局对象。 在函数中，this 指的是全局对象。 在函数中，严格模式下，this 是 undefined。 在事件中，this 指的是接收事件的元素。 像 call() 和 apply() 这样的方法可以将 this 引用到任何对象。 方法中的 this在对象方法中，this 指的是此方法的“拥有者”。 在本页最上面的例子中，this 指的是 person 对象。 person 对象是 fullName 方法的拥有者。 123fullName : function() &#123; return this.firstName + &quot; &quot; + this.lastName;&#125; 单独的 this在单独使用时，拥有者是全局对象，因此 this 指的是全局对象。 在浏览器窗口中，全局对象是 [object Window]： 实例1var x = this; 在严格模式中，如果单独使用，那么 this 指的是全局对象 [object Window]： 实例12&quot;use strict&quot;;var x = this; 函数中的 this（默认）在 JavaScript 函数中，函数的拥有者默认绑定 this。 因此，在函数中，this 指的是全局对象 [object Window]。 实例123function myFunction() &#123; return this;&#125; 函数中的 this（严格模式）JavaScript 严格模式不允许默认绑定。 因此，在函数中使用时，在严格模式下，this 是未定义的（undefined）。 实例1234&quot;use strict&quot;;function myFunction() &#123; return this;&#125; 事件处理程序中的 this在 HTML 事件处理程序中，this 指的是接收此事件的 HTML 元素： 实例123&lt;button onclick=&quot;this.style.display=&#x27;none&#x27;&quot;&gt; 点击来删除我！&lt;/button&gt; 对象方法绑定在此例中，this 是 person 对象（person 对象是该函数的“拥有者”）： 实例12345678var person = &#123; firstName : &quot;Bill&quot;, lastName : &quot;Gates&quot;, id : 678, myFunction : function() &#123; return this; &#125;&#125;; 实例12345678var person = &#123; firstName: &quot;Bill&quot;, lastName : &quot;Gates&quot;, id : 678, fullName : function() &#123; return this.firstName + &quot; &quot; + this.lastName; &#125;&#125;; 换句话说，this.firstName 意味着 this（person）对象的 firstName 属性。 显式函数绑定call() 和 apply() 方法是预定义的 JavaScript 方法。 它们都可以用于将另一个对象作为参数调用对象方法。 您可以在本教程后面阅读有关 call() 和 apply() 的更多内容。 在下面的例子中，当使用 person2 作为参数调用 person1.fullName 时，this 将引用 person2，即使它是 person1 的方法： 实例12345678910var person1 = &#123; fullName: function() &#123; return this.firstName + &quot; &quot; + this.lastName; &#125;&#125;var person2 = &#123; firstName:&quot;Bill&quot;, lastName: &quot;Gates&quot;,&#125;person1.fullName.call(person2); // 会返回 &quot;Bill Gates&quot;","tags":["JavaScript"],"categories":["Language"]},{"title":"38_JavaScript_For_Of","path":"/posts/13d648a6.html","content":"For Of 循环JavaScript for of 语句循环遍历可迭代对象的值。 它允许您循环遍历可迭代的数据结构，例如数组、字符串、映射、节点列表等： 语法123for (variable of iterable) &#123; // code block to be executed&#125; variable - 对于每次迭代，下一个属性的值都会分配给变量。变量可以用 const、let 或 var 声明。 iterable - 具有可迭代属性的对象。 浏览器支持For&#x2F;of 在 2015 年被添加到 JavaScript (ES6) Safari 7 是第一个支持 for of 的浏览器： Chrome IE Firefox Safari Opera Chrome 38 Edge 12 Firefox 51 Safari 7 Opera 25 2014 年 10 月 2015 年 7 月 2016 年 10 月 2013 年 10 月 2014 年 10 月 Internet Explorer 不支持 For&#x2F;of。 遍历数组实例123456const cars = [&quot;BMW&quot;, &quot;Volvo&quot;, &quot;Mini&quot;];let text = &quot;&quot;;for (let x of cars) &#123; text += x;&#125; 遍历字符串实例123456let language = &quot;JavaScript&quot;;let text = &quot;&quot;;for (let x of language) &#123;text += x;&#125;","tags":["JavaScript"],"categories":["Language"]},{"title":"37_JavaScript_For_In","path":"/posts/8c8f1dc.html","content":"For In 循环JavaScript for in 语句循环遍历对象的属性： 语法123for (key in object) &#123; // code block to be executed&#125; 实例123456const person = &#123;fname:&quot;Bill&quot;, lname:&quot;Gates&quot;, age:25&#125;;let text = &quot;&quot;;for (let x in person) &#123; text += person[x];&#125; 例子解释 for in 循环遍历 person 对象 每次迭代返回一个键 (x) 键用于访问键的值 键的值为 person[x] For In 遍历数组JavaScript for in 语句也可以遍历数组的属性： 语法123for (variable in array) &#123; code&#125; 实例123456const numbers = [45, 4, 9, 16, 25];let txt = &quot;&quot;;for (let x in numbers) &#123; txt += numbers[x];&#125; 如果索引顺序很重要，请不要在数组上使用 for in。 索引顺序依赖于实现，可能不会按照您期望的顺序访问数组值。 当顺序很重要时，最好使用 for 循环、for of 循环或 *Array.forEach()*。 Array.forEach()forEach() 方法为每个数组元素调用一次函数（回调函数）。 实例12345678const numbers = [45, 4, 9, 16, 25];let txt = &quot;&quot;;numbers.forEach(myFunction);function myFunction(value, index, array) &#123; txt += value;&#125; 请注意，该函数采用 3 个参数： 项目值 项目索引 数组本身 上面的例子仅使用 value 参数。可以改写为： 实例12345678const numbers = [45, 4, 9, 16, 25];let txt = &quot;&quot;;numbers.forEach(myFunction);function myFunction(value) &#123; txt += value; &#125;","tags":["JavaScript"],"categories":["Language"]},{"title":"48_JavaScript_严格模式","path":"/posts/82bba1fb.html","content":"&quot;use strict&quot;; 定义 JavaScript 代码应该以“严格模式”执行。 “use strict” 指令&quot;use strict&quot; 是 JavaScript 1.8.5 中的新指令（ECMAScript version 5）。 它不算一条语句，而是一段文字表达式，更早版本的 JavaScript 会忽略它。 &quot;use strict&quot;; 的作用是指示 JavaScript 代码应该以“严格模式”执行。 在严格模式中，您无法，例如，使用未声明的变量。 以下版本的浏览器支持严格模式： 版本 10 以后的 IE 版本 4 以后的 Firefox 版本 13 以后的 Chrome 版本 5.1 以后的 Safari 版本 12 以后的 Opera 声明严格模式通过在脚本或函数的开头添加 &quot;use strict&quot;; 来声明严格模式。 在脚本开头进行声明，拥有全局作用域（脚本中的所有代码均以严格模式来执行）： 实例12&quot;use strict&quot;;x = 3.14; // 这会引发错误，因为 x 尚未声明 实例123456&quot;use strict&quot;;myFunction();function myFunction() &#123; y = 3.14; // 这会引发错误，因为 y 尚未声明&#125; 在函数中声明严格模式，拥有局部作用域（只有函数中的代码以严格模式执行）： 1234567x = 3.14; // 这不会引发错误myFunction();function myFunction() &#123;\t&quot;use strict&quot;; y = 3.14; // 这会引发错误&#125; “use strict”; 语法声明严格模式的语法被设计为兼容更早版本的 JavaScript。 编译 JavaScript 程序中的数值文字（比如 4+5）或字符串文字（”Bill Gates”）不会有负面效果。它只会编译为不存在的变量然后消失。 所有 &quot;use strict&quot;; 只会对“理解”其含义的新编译器产生影响。 为什么使用严格模式？严格模式使我们更容易编写“安全的” JavaScript。 严格模式把之前可接受的“坏语法”转变为真实的错误。 举例来说，在普通的 JavaScript 中，错打变量名会创建新的全局变量。在严格模式中，此举将抛出错误，这样就不可能意外创建全局变量。 在普通 JavaScript 中，如果向不可写属性赋值，开发者不会得到任何错误反馈。 在严格模式中，向不可写的、只能读取的、不存在的属性赋值，或者向不存在的变量或对象赋值，将抛出错误。 严格模式中不允许的事项在不声明变量的情况下使用变量，是不允许的： 12&quot;use strict&quot;;x = 3.14; // 这将引发错误 对象也是变量 在不声明对象的情况下使用对象也是不允许的： 12&quot;use strict&quot;;x = &#123;p1:10, p2:20&#125;; // 这将引发错误 删除变量（或对象）是不允许的： 123&quot;use strict&quot;;var x = 3.14;delete x; // 这将引发错误 删除函数是不允许的： 123&quot;use strict&quot;;function x(p1, p2) &#123;&#125;; delete x; // 这将引发错误 重复参数名是不允许的： 12&quot;use strict&quot;;function x(p1, p1) &#123;&#125;; // 这将引发错误 八进制数值文本是不允许的： 12&quot;use strict&quot;;var x = 010; // 这将引发错误 转义字符是不允许的： 12&quot;use strict&quot;;var x = \\010; // 这将引发错误 写入只读属性是不允许的： 12345&quot;use strict&quot;;var obj = &#123;&#125;;Object.defineProperty(obj, &quot;x&quot;, &#123;value:0, writable:false&#125;);obj.x = 3.14; // 这将引发错误 写入只能获取的属性是不允许的： 1234&quot;use strict&quot;;var obj = &#123;get x() &#123;return 0&#125; &#125;;obj.x = 3.14; // 这将引发错误 删除不可删除的属性是不允许的： 12&quot;use strict&quot;;delete Object.prototype; // 这将引发错误 字符串 “eval” 不可用作变量： 12&quot;use strict&quot;;var eval = 3.14; // 这将引发错误 字符串 “arguments” 不可用作变量： 12&quot;use strict&quot;;var arguments = 3.14; // 这将引发错误 with 语句是不允许的： 12&quot;use strict&quot;;with (Math)&#123;x = cos(2)&#125;; // 这将引发错误 处于安全考虑，不允许 eval() 在其被调用的作用域中创建变量： 123&quot;use strict&quot;;eval (&quot;var x = 2&quot;);alert (x); // 这将引发错误 在类似 f() 的函数调用中，this 的值是全局对象。在严格模式中，现在它成为了 undefined。 对未来的保障严格模式中不允许使用为未来预留的关键词。它们是： implements interface let package private protected public static yield 12&quot;use strict&quot;;var public = 1500; // 这将引发错误 警告&quot;use strict&quot; 指令只能在脚本或函数的开头被识别。","tags":["JavaScript"],"categories":["Language"]},{"title":"47_JavaScript_Hoisting","path":"/posts/943bcaaa.html","content":"提升（Hoisting）是 JavaScript 将声明移至顶部的默认行为。 JavaScript 声明会被提升在 JavaScript 中，可以在使用变量之后对其进行声明。 换句话说，可以在声明变量之前使用它。 例子 1 与例子 2 的结果相同： 例子 1123456x = 5; // 把 5 赋值给 x elem = document.getElementById(&quot;demo&quot;); // 查找元素elem.innerHTML = x; // 在元素中显示 xvar x; // 声明 x 例子 212345var x; // 声明 xx = 5; // 把 5 赋值给 xelem = document.getElementById(&quot;demo&quot;); // 查找元素elem.innerHTML = x; // 在元素中显示 x 为了理解这一点，您必须理解术语 “hoisting”。 Hoisting 是 JavaScript 将所有声明提升到当前作用域顶部的默认行为（提升到当前脚本或当前函数的顶部）。 let 和 const 关键字用 let 或 const 声明的变量和常量不会被提升！ JavaScript 初始化不会被提升JavaScript 只提升声明，而非初始化。 例子 1 与例子 2 的结果不相同： 例子 112345var x = 5; // 初始化 xvar y = 7; // 初始化 yelem = document.getElementById(&quot;demo&quot;); // 查找元素elem.innerHTML = x + &quot; &quot; + y; // 显示 x 和 y 例子 2123456var x = 5; // 初始化 x elem = document.getElementById(&quot;demo&quot;); // 查找元素elem.innerHTML = x + &quot; &quot; + y; // 显示 x 和 y var y = 7; // 初始化 y 最后一个例子中的 y 仍然是未定义能说得通吗？ 这是因为只有声明（var y）而不是初始化（&#x3D;7）被提升到顶部。 由于 hoisting，y 在其被使用前已经被声明，但是由于未对初始化进行提升，y 的值仍是未定义。 例子 2 也一样： 实例1234567var x = 5; // 初始化 xvar y; // 声明 y elem = document.getElementById(&quot;demo&quot;); // 查找元素elem.innerHTML = x + &quot; &quot; + y; // 显示 x 和 y y = 7; // 把 7 赋值给 y 在顶部声明您的变量！Hoisting（对很多开发者来说）是 JavaScript 的一种未知的或被忽视的行为。 如果开发者不理解 hoisting，程序也许会包含 bug（错误）。 为了避免 bug，请始终在每个作用域的开头声明所有变量。 由于这就是 JavaScript 解释代码的方式，请保持这个好习惯。 严格模式中的 JavaScript 不允许在未被声明的情况下使用变量。","tags":["JavaScript"],"categories":["Language"]},{"title":"46_JavaScript_作用域","path":"/posts/b234e47e.html","content":"作用域指的是您有权访问的变量集合。 JavaScript 函数作用域在 JavaScript 中有两种作用域类型： 局部作用域 全局作用域 JavaScript 拥有函数作用域：每个函数创建一个新的作用域。 作用域决定了这些变量的可访问性（可见性）。 函数内部定义的变量从函数外部是不可访问的（不可见的）。 局部 JavaScript 变量在 JavaScript 函数中声明的变量，会成为函数的局部变量。 局部变量的作用域是局部的：只能在函数内部访问它们。 实例12345678// 此处的代码不能使用 carName 变量function myFunction() &#123; var carName = &quot;porsche&quot;; // 此处的代码能使用 carName 变量&#125; 由于只能在函数内部识别局部变量，因此能够在不同函数中使用同名变量。 在函数开始时会创建局部变量，在函数完成时会删除它们。 全局 JavaScript 变量函数之外声明的变量，会成为全局变量。 全局变量的作用域是全局的：网页的所有脚本和函数都能够访问它。 实例12345678910var carName = &quot; porsche&quot;;// 此处的代码能够使用 carName 变量function myFunction() &#123; // 此处的代码也能够使用 carName 变量&#125; JavaScript 变量在 JavaScript 中，对象和函数也是变量。 作用域决定了从代码不同部分对变量、对象和函数的可访问性。 自动全局如果您为尚未声明的变量赋值，此变量会自动成为全局变量。 这段代码将声明一个全局变量 carName，即使在函数内进行了赋值。 实例12345678myFunction();// 此处的代码能够使用 carName 变量function myFunction() &#123; carName = &quot;porsche&quot;;&#125; 严格模式所有现代浏览器都支持以“严格模式”运行 JavaScript。 您将在本教程稍后的章节学习更多如何使用严格模式的知识。 在“严格模式”中不会自动创建全局变量。 HTML 中的全局变量通过 JavaScript，全局作用域形成了完整的 JavaScript 环境。 在 HTML 中，全局作用域是 window。所有全局变量均属于 window 对象。 实例123var carName = &quot;porsche&quot;;// 此处的代码能够使用 window.carName 警告除非有意为之，否则请勿创建全局变量。 您的全局变量（或函数）能够覆盖 window 变量（或函数）。 任何函数，包括 window 对象，能够覆盖您的全局变量和函数。 JavaScript 变量的有效期JavaScript 变量的有效期始于其被创建时。 局部变量会在函数完成时被删除。 全局变量会在您关闭页面是被删除。 函数参数函数参数也是函数内的局部变量。","tags":["JavaScript"],"categories":["Language"]},{"title":"45_JavaScript_错误_-_Throw_和_Try_to_Catch","path":"/posts/77c623c4.html","content":"try 语句使您能够测试代码块中的错误。 catch 语句允许您处理错误。 throw 语句允许您创建自定义错误。 finally 使您能够执行代码，在 try 和 catch 之后，无论结果如何。 错误总会发生！当执行 JavaScript 代码时，会发生各种错误。 错误可能是程序员的编码错误，由错误输入引起的错误，或者由于其他不可预见的问题。 实例在本例中，我们通过 adddlert 编写警告代码来故意制造了一个错误： 12345678910&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;try &#123; adddlert(&quot;欢迎访问！&quot;);&#125;catch(err) &#123; document.getElementById(&quot;demo&quot;).innerHTML = err.message;&#125;&lt;/script&gt; JavaScript 将 adddlert 捕获为一个错误，然后执行代码来处理该错误。 JavaScript try 和 catchtry 语句允许您定义一个代码块，以便在执行时检测错误。 catch 语句允许你定义一个要执行的代码块，如果 try 代码块中发生错误。 JavaScript 语句 try 和 catch 成对出现： 123456try &#123; 供测试的代码块&#125; catch(err) &#123; 处理错误的代码块&#125; JavaScript 抛出错误当发生错误时，JavaScript 通常会停止并产生错误消息。 技术术语是这样描述的：JavaScript 将抛出异常（抛出错误）。 JavaScript 实际上会创建带有两个属性的 Error 对象：name 和 message。 throw 语句throw 语句允许您创建自定义错误。 从技术上讲您能够抛出异常（抛出错误）。 异常可以是 JavaScript 字符串、数字、布尔或对象： 12throw &quot;Too big&quot;; // 抛出文本throw 500; //抛出数字 如果把 throw 与 try 和 catch 一同使用，就可以控制程序流并生成自定义错误消息。 输入验证案例本例会检查输入。如果值是错误的，将抛出异常（err）。 该异常（err）被 catch 语句捕获并显示一条自定义的错误消息： 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;p&gt;请输入 5 - 10 之间的数字：&lt;/p&gt;&lt;input id=&quot;demo&quot; type=&quot;text&quot;&gt;&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;测试输入&lt;/button&gt;&lt;p id=&quot;message&quot;&gt;&lt;/p&gt;&lt;script&gt;function myFunction() &#123; var message, x; message = document.getElementById(&quot;message&quot;); message.innerHTML = &quot;&quot;; x = document.getElementById(&quot;demo&quot;).value; try &#123; if(x == &quot;&quot;) throw &quot;空的&quot;; if(isNaN(x)) throw &quot;不是数字&quot;; x = Number(x); if(x &lt; 5) throw &quot;太小&quot;; if(x &gt; 10) throw &quot;太大&quot;; &#125; catch(err) &#123; message.innerHTML = &quot;输入是 &quot; + err; &#125;&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; HTML 验证以上代码仅仅是一个例子。 现代浏览器通常会结合 JavaScript 与内置的 HTML 验证，通过使用在 HTML 属性中定义的预定义的验证规则： 1&lt;input id=&quot;demo&quot; type=&quot;number&quot; min=&quot;5&quot; max=&quot;10&quot; step=&quot;1&quot;&gt; 您将在本教程稍后的章节学到更多有关表单验证的知识。 finally 语句finally 语句允许您在 try 和 catch 之后执行代码，无论结果： 123456789try &#123; // 供测试的代码块&#125; catch(err) &#123; // 处理错误的代码块&#125; finally &#123; // 无论结果如何都执行的代码块&#125; 实例12345678910111213141516171819function myFunction() &#123; var message, x; message = document.getElementById(&quot;message&quot;); message.innerHTML = &quot;&quot;; x = document.getElementById(&quot;demo&quot;).value; try &#123; if(x == &quot;&quot;) throw &quot;是空的&quot;; if(isNaN(x)) throw &quot;不是数字&quot;; x = Number(x); if(x &gt; 10) throw &quot;太大&quot;; if(x &lt; 5) throw &quot;太小&quot;; &#125; catch(err) &#123; message.innerHTML = &quot;错误：&quot; + err + &quot;.&quot;; &#125; finally &#123; document.getElementById(&quot;demo&quot;).value = &quot;&quot;; &#125;&#125; Error 对象JavaScript 拥有当错误发生时提供错误信息的内置 error 对象。 error 对象提供两个有用的属性：name 和 message。 Error 对象属性 属性 描述 name 设置或返回错误名 message 设置或返回错误消息（一条字符串） Error Name Valueserror 的 name 属性可返回六个不同的值： 错误名 描述 EvalError 已在 eval() 函数中发生的错误 RangeError 已发生超出数字范围的错误 ReferenceError 已发生非法引用 SyntaxError 已发生语法错误 TypeError 已发生类型错误 URIError 在 encodeURI() 中已发生的错误 下面为您详解这六个不同的值。 Eval 错误EvalError 指示 eval() 函数中的错误。 更新版本的 JavaScript 不会抛出任何 EvalError。请使用 SyntaxError 代替。 范围错误RangeError 会在您使用了合法值的范围之外的数字时抛出。 例如：您不能将数字的有效位数设置为 500。 实例1234567var num = 1;try &#123; num.toPrecision(500); // 数无法拥有 500 个有效数 &#125;catch(err) &#123; document.getElementById(&quot;demo&quot;).innerHTML = err.name;&#125; 引用错误假如您使用（引用）了尚未声明的变量，则 ReferenceError 会被抛出： 实例1234567var x;try &#123; x = y + 1; // y 无法被引用（使用） &#125;catch(err) &#123; document.getElementById(&quot;demo&quot;).innerHTML = err.name;&#125; 语法错误假如您计算带语法错误的代码，会 SyntaxError 被抛出： 实例123456try &#123; eval(&quot;alert(&#x27;Hello)&quot;); // 缺少 &#x27; 会产生错误&#125;catch(err) &#123; document.getElementById(&quot;demo&quot;).innerHTML = err.name;&#125; 类型错误假如您使用的值不在期望值的范围之内，则 TypeError 被抛出： 实例1234567var num = 1;try &#123; num.toUpperCase(); // 您无法将数字转换为大写 &#125;catch(err) &#123; document.getElementById(&quot;demo&quot;).innerHTML = err.name;&#125; URI 错误假如您在 URI 函数中使用非法字符，则 URIError 被抛出： 实例123456try &#123; decodeURI(&quot;%%%&quot;); // 您无法对这些百分号进行 URI 编码 &#125;catch(err) &#123; document.getElementById(&quot;demo&quot;).innerHTML = err.name;&#125; 非标准的 Error 对象属性Mozilla 和 Microsoft 定义了非标准的 error 对象属性： fileName (Mozilla) lineNumber (Mozilla) columnNumber (Mozilla) stack (Mozilla) description (Microsoft) number (Microsoft) 请勿在公共网站使用这些属性。它们并不会在所有浏览器中工作。","tags":["JavaScript"],"categories":["Language"]},{"title":"44_JavaScript_正则表达式","path":"/posts/f842c174.html","content":"正则表达式是构成搜索模式的字符序列。 该搜索模式可用于文本搜索和文本替换操作。 什么是正则表达式？正则表达式是构成搜索模式（search pattern）的字符序列。 当您搜索文本中的数据时，您可使用搜索模式来描述您搜索的内容。 正则表达式可以是单字符，或者更复杂的模式。 正则表达式可用于执行所有类型的文本搜索和文本替换操作。 语法1/pattern/modifiers; 实例1var patt = /w3school/i; 例子解释：/w3school/i 是一个正则表达式。 w3school 是模式（pattern）（在搜索中使用）。 i 是修饰符（把搜索修改为大小写不敏感）。 使用字符串方法在 JavaScript 中，正则表达式常用于两个字符串方法：search() 和 replace()。 search() 方法使用表达式来搜索匹配，然后返回匹配的位置。 replace() 方法返回模式被替换处修改后的字符串。 使用字符串方法 search() 来处理字符串search() 方法也接受字符串作为搜索参数。字符串参数将被转换为正则表达式： 实例使用字符串来执行对 “W3school” 的搜索： 12var str = &quot;Visit W3School!&quot;;var n = str.search(&quot;W3School&quot;); 在字符串方法 search() 中使用正则表达式实例使用正则表达式执行搜索字符串中 “w3school” 的大小写不敏感的搜索： 12var str = &quot;Visit W3School&quot;;var n = str.search(/w3school/i); n 中的结果将是： 16 使用字符串方法 replace() 处理字符串replace() 也接受字符串作为搜索参数： 12var str = &quot;Visit Microsoft!&quot;;var res = str.replace(&quot;Microsoft&quot;, &quot;W3School&quot;); 在字符串方法 replace() 中使用正则表达式实例使用大小写不明的正则表达式以 W3school 来替换字符串中的 Microsoft： 12var str = &quot;Visit Microsoft!&quot;;var res = str.replace(/microsoft/i, &quot;W3School&quot;); res 的结果将是： 1Visit W3School! 您注意到了吗？正则表达式参数（而不是字符串参数）可以在上面的方法中使用。 正则表达式可以使您的搜索更强大（例如，不区分大小写）。 正则表达式修饰符修饰符可用于大小写不敏感的更全局的搜素： 修饰符 描述 i 执行对大小写不敏感的匹配。 g 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。 m 执行多行匹配。 正则表达式模式括号用于查找一定范围的字符串： 表达式 描述 [abc] 查找方括号之间的任何字符。 [0-9] 查找任何从 0 至 9 的数字。 (x|y) 查找由 | 分隔的任何选项。 元字符（Metacharacter）是拥有特殊含义的字符： 元字符 描述 \\d 查找数字。 \\s 查找空白字符。 \\b 匹配单词边界。 \\uxxxx 查找以十六进制数 xxxx 规定的 Unicode 字符。 Quantifiers 定义量词： 量词 描述 n+ 匹配任何包含至少一个 n 的字符串。 n* 匹配任何包含零个或多个 n 的字符串。 n? 匹配任何包含零个或一个 n 的字符串。 使用 RegExp 对象在 JavaScript 中，RegExp 对象是带有预定义属性和方法的正则表达式对象。 使用 test()test() 是一个正则表达式方法。 它通过模式来搜索字符串，然后根据结果返回 true 或 false。 下面的例子搜索字符串中的字符 “e”： 实例12var patt = /e/;patt.test(&quot;The best things in life are free!&quot;); 由于字符串中有一个 “e”，以上代码的输出将是： 1true 您不必首先把正则表达式放入变量中。上面的两行可缩短为一行： 1/e/.test(&quot;The best things in life are free!&quot;); 使用 exec()exec() 方法是一个正则表达式方法。 它通过指定的模式（pattern）搜索字符串，并返回已找到的文本。 如果未找到匹配，则返回 null。 下面的例子搜索字符串中的字符 “e”： 实例1/e/.exec(&quot;The best things in life are free!&quot;); 由于字符串中有一个 “e”，以上代码的输出将是： 1e","tags":["JavaScript"],"categories":["Language"]},{"title":"43_JavaScript_位运算符-未理解","path":"/posts/ed11d0e2.html","content":"JavaScript 位运算符 运算符 名称 描述 &amp; AND 如果两位都是 1 则设置每位为 1 | OR 如果两位之一为 1 则设置每位为 1 ^ XOR 如果两位只有一位为 1 则设置每位为 1 ~ NOT 反转所有位 &lt;&lt; 零填充左位移 通过从右推入零向左位移，并使最左边的位脱落。 &gt;&gt; 有符号右位移 通过从左推入最左位的拷贝来向右位移，并使最右边的位脱落。 &gt;&gt;&gt; 零填充右位移 通过从左推入零来向右位移，并使最右边的位脱落。 实例 操作 结果 等同于 结果 5 &amp; 1 1 0101 &amp; 0001 0001 5 | 1 5 0101 | 0001 0101 5 ^ 1 4 0101 ^ 0001 0100 ~ 5 10 ~0101 1010 5 &lt;&lt; 1 10 0101 &lt;&lt; 1 1010 5 &gt;&gt; 1 2 0101 &gt;&gt; 1 0010 5 &gt;&gt;&gt; 1 2 0101 &gt;&gt;&gt; 1 0010 JavaScript 使用 32 位按位运算数JavaScript 将数字存储为 64 位浮点数，但所有按位运算都以 32 位二进制数执行。 在执行位运算之前，JavaScript 将数字转换为 32 位有符号整数。 执行按位操作后，结果将转换回 64 位 JavaScript 数。 上面的例子使用 4 位无符号二进制数。所以 ~ 5 返回 10。 由于 JavaScript 使用 32 位有符号整数，JavaScript 将返回 -6。 00000000000000000000000000000101 (5) 11111111111111111111111111111010 (~5 &#x3D; -6) 有符号整数使用最左边的位作为减号。 位运算 AND当对一对数位执行位运算 AND 时，如果数位均为 1 则返回 1。 单位示例： 运算 结果 0 &amp; 0 0 0 &amp; 1 0 1 &amp; 0 0 1 &amp; 1 1 四位示例： 运算 结果 1111 &amp; 0000 0000 1111 &amp; 0001 0001 1111 &amp; 0010 0010 1111 &amp; 0100 0100 位运算 OR当对一对数位执行位运算 OR 时，如果其中一位是 1 则返回 1： 单位示例 运算 结果 0 | 0 0 0 | 1 1 1 | 0 1 1 | 1 1 四位运算： 操作 结果 1111 | 0000 1111 1111 | 0001 1111 1111 | 0010 1111 1111 | 0100 1111 位运算 XOR当对一对数位进行位运算 XOR 时，如果数位是不同的则返回 1： 单位示例： 运算 结果 0 ^ 0 0 0 ^ 1 1 1 ^ 0 1 1 ^ 1 0 四位示例： 运算 结果 1111 ^ 0000 1111 1111 ^ 0001 1110 1111 ^ 0010 1101 1111 ^ 0100 1011 JavaScript 位运算 AND (&amp;)如果位数都是 1，则位运算 AND 返回 1： 十进制 二进制 5 00000000000000000000000000000101 1 00000000000000000000000000000001 5 &amp; 1 00000000000000000000000000000001 (1) 实例1var x = 5 &amp; 1; JavaScript 位运算 OR (|)如果数位之一是 1，则位运算 OR 返回 1： 十进制 二进制 5 00000000000000000000000000000101 1 00000000000000000000000000000001 5 | 1 00000000000000000000000000000101 (5) 实例1var x = 5 | 1; JavaScript 位运算 XOR (^)如果数位是不同的，则 XOR 返回 1： 十进制 二进制 5 00000000000000000000000000000101 1 00000000000000000000000000000001 5 ^ 1 00000000000000000000000000000100 (4) 实例1var x = 5 ^ 1; JavaScript 位运算 NOT (~) 十进制 二进制 5 00000000000000000000000000000101 ~5 11111111111111111111111111111010 (-6) 实例1var x = ~5; JavaScript（零填充）位运算左移（&lt;&lt;）这是零填充的左移。一个或多个零数位从右被推入，最左侧的数位被移除： 十进制 二进制 5 00000000000000000000000000000101 5 &lt;&lt; 1 00000000000000000000000000001010 (10) 实例1var x = 5 &lt;&lt; 1; JavaScript（有符号）位运算右移（&gt;&gt;）这是保留符号的右移。最左侧的数位被从左侧推入，最右侧的数位被移出： 十进制 二进制 -5 11111111111111111111111111111011 -5 &gt;&gt; 1 11111111111111111111111111111101 (-3) 实例1var x = -5 &gt;&gt; 1; JavaScript（零填充）右移（&gt;&gt;&gt;）这是零填充的右移。一个或多个零数位从左侧被推入，最右侧的数位被移出： 十进制 二进制 5 00000000000000000000000000000101 5 &gt;&gt;&gt; 1 00000000000000000000000000000010 (2) 实例1var x = 5 &gt;&gt;&gt; 1; 32-bit 有符号整数（二进制数）仅设置一位的 32 位整数很好理解： 二进制表示 十进制值 00000000000000000000000000000001 1 00000000000000000000000000000010 2 00000000000000000000000000000100 4 00000000000000000000000000001000 8 00000000000000000000000000010000 16 00000000000000000000000000100000 32 00000000000000000000000001000000 64 多设置一些数位揭示了二进制的模式： 二进制表示 十进制值 00000000000000000000000000000101 5 (4 + 1) 00000000000000000000000000101000 40 (32 + 8) 00000000000000000000000000101101 45 (32 + 8 + 4 + 1) 负数是正数的二进制补码加 1： 二进制表示 十进制值 00000000000000000000000000000101 5 11111111111111111111111111111011 -5 00000000000000000000000000101000 40 11111111111111111111111111011000 -40 11111111111111111111111111011001 -41 把十进制转换为二进制实例123function dec2bin(dec)&#123; return (dec &gt;&gt;&gt; 0).toString(2);&#125; 把二进制转换为十进制实例123function bin2dec(bin)&#123; return parseInt(bin, 2).toString(10);&#125;","tags":["JavaScript"],"categories":["Language"]},{"title":"24_JavaScript_数组迭代","path":"/posts/790664a7.html","content":"数组迭代方法对每个数组项进行操作。 Array.forEach()forEach() 方法为每个数组元素调用一次函数（回调函数）。 实例1234567var txt = &quot;&quot;;var numbers = [45, 4, 9, 16, 25];numbers.forEach(myFunction);function myFunction(value, index, array) &#123; txt = txt + value + &quot;&lt;br&gt;&quot;; &#125; 注释：该函数接受 3 个参数： 项目值 项目索引 数组本身 上面的例子只用了 value 参数。这个例子可以重新写为： 实例1234567var txt = &quot;&quot;;var numbers = [45, 4, 9, 16, 25];numbers.forEach(myFunction);function myFunction(value) &#123; txt = txt + value + &quot;&lt;br&gt;&quot;; &#125; 所有浏览器都支持 Array.forEach()，除了 Internet Explorer 8 或更早的版本： Array.map()map() 方法通过对每个数组元素执行函数来创建新数组。 map() 方法不会对没有值的数组元素执行函数。 map() 方法不会更改原始数组。 这个例子将每个数组值乘以2： 实例123456var numbers1 = [45, 4, 9, 16, 25];var numbers2 = numbers1.map(myFunction);function myFunction(value, index, array) &#123; return value * 2;&#125; 请注意，该函数有 3 个参数： 项目值 项目索引 数组本身 当回调函数仅使用 value 参数时，可以省略索引和数组参数： 实例123456var numbers1 = [45, 4, 9, 16, 25];var numbers2 = numbers1.map(myFunction);function myFunction(value) &#123; return value * 2;&#125; 所有浏览器都支持 Array.map()，除了 Internet Explorer 8 或更早的版本： Array.filter()filter() 方法创建一个包含通过测试的数组元素的新数组。 这个例子用值大于 18 的元素创建一个新数组： 实例123456var numbers = [45, 4, 9, 16, 25];var over18 = numbers.filter(myFunction);function myFunction(value, index, array) &#123; return value &gt; 18;&#125; 请注意此函数接受 3 个参数： 项目值 项目索引 数组本身 在上面的例子中，回调函数不使用 index 和 array 参数，因此可以省略它们： 实例123456var numbers = [45, 4, 9, 16, 25];var over18 = numbers.filter(myFunction);function myFunction(value) &#123; return value &gt; 18;&#125; 所有浏览器都支持 Array.filter()，除了 Internet Explorer 8 或更早的版本： Array.reduce()reduce() 方法在每个数组元素上运行函数，以生成（减少它）单个值。 reduce() 方法在数组中从左到右工作。另请参阅 reduceRight()。 reduce() 方法不会减少原始数组。 这个例子确定数组中所有数字的总和： 实例123456var numbers1 = [45, 4, 9, 16, 25];var sum = numbers1.reduce(myFunction);function myFunction(total, value, index, array) &#123; return total + value;&#125; 请注意此函数接受 4 个参数： 总数（初始值&#x2F;先前返回的值） 项目值 项目索引 数组本身 上例并未使用 index 和 array 参数。可以将它改写为： 实例123456var numbers1 = [45, 4, 9, 16, 25];var sum = numbers1.reduce(myFunction);function myFunction(total, value) &#123; return total + value;&#125; reduce() 方法能够接受一个初始值： 实例123456var numbers1 = [45, 4, 9, 16, 25];var sum = numbers1.reduce(myFunction, 100);function myFunction(total, value) &#123; return total + value;&#125; 所有浏览器都支持 Array.reduce()，除了 Internet Explorer 8 或更早的版本： Array.reduceRight()reduceRight() 方法在每个数组元素上运行函数，以生成（减少它）单个值。 reduceRight() 方法在数组中从右到左工作。另请参阅 reduce()。 reduceRight() 方法不会减少原始数组。 这个例子确定数组中所有数字的总和： 实例123456var numbers1 = [45, 4, 9, 16, 25];var sum = numbers1.reduceRight(myFunction);function myFunction(total, value, index, array) &#123; return total + value;&#125; 请注意此函数接受 4 个参数： 总数（初始值&#x2F;先前返回的值） 项目值 项目索引 数组本身 上例并未使用 index 和 array 参数。可以将它改写为： 实例123456var numbers1 = [45, 4, 9, 16, 25];var sum = numbers1.reduceRight(myFunction);function myFunction(total, value) &#123; return total + value;&#125; 所有浏览器都支持 Array.reduceRight() Array.every()every() 方法检查所有数组值是否通过测试。 这个例子检查所有数组值是否大于 18： 实例123456var numbers = [45, 4, 9, 16, 25];var allOver18 = numbers.every(myFunction);function myFunction(value, index, array) &#123; return value &gt; 18;&#125; 请注意此函数接受 3 个参数： 项目值 项目索引 数组本身 如果回调函数仅使用第一个参数（值）时，可以省略其他参数： 实例123456var numbers = [45, 4, 9, 16, 25];var allOver18 = numbers.every(myFunction);function myFunction(value) &#123; return value &gt; 18;&#125; 所有浏览器都支持 Array.every() Array.some()some() 方法检查某些数组值是否通过了测试。 这个例子检查某些数组值是否大于 18： 实例123456var numbers = [45, 4, 9, 16, 25];var someOver18 = numbers.some(myFunction);function myFunction(value, index, array) &#123; return value &gt; 18;&#125; 请注意此函数接受 3 个参数： 项目值 项目索引 数组本身 所有浏览器都支持 Array.some() Array.indexOf()indexOf() 方法在数组中搜索元素值并返回其位置。 注释：第一个项目的位置是 0，第二个项目的位置是 1，以此类推。 实例检索数组中的项目 “Apple”： 12var fruits = [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var a = fruits.indexOf(&quot;Apple&quot;); 所有浏览器都支持 Array.indexOf() 语法1array.indexOf(item, start) item 必需。要检索的项目。 start 可选。从哪里开始搜索。负值将从结尾开始的给定位置开始，并搜索到结尾。 如果未找到项目，Array.indexOf() 返回 -1。 如果项目多次出现，则返回第一次出现的位置。 Array.lastIndexOf()Array.lastIndexOf() 与 Array.indexOf() 类似，但是从数组结尾开始搜索。 实例检索数组中的项目 “Apple”： 12var fruits = [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var a = fruits.lastIndexOf(&quot;Apple&quot;); 语法1array.lastIndexOf(item, start) item 必需。要检索的项目。 start 可选。从哪里开始搜索。负值将从结尾开始的给定位置开始，并搜索到开头。 Array.find()find() 方法返回通过测试函数的第一个数组元素的值。 这个例子查找（返回）大于 18 的第一个元素的值： 实例123456var numbers = [4, 9, 16, 25, 29];var first = numbers.find(myFunction);function myFunction(value, index, array) &#123; return value &gt; 18;&#125; 请注意此函数接受 3 个参数： 项目值 项目索引 数组本身 老旧的浏览器不支持 Array.find()。 Array.findIndex()findIndex() 方法返回通过测试函数的第一个数组元素的索引。 这个例子查找大于 18 的第一个元素的索引： 实例123456var numbers = [4, 9, 16, 25, 29];var first = numbers.findIndex(myFunction);function myFunction(value, index, array) &#123; return value &gt; 18;&#125; 请注意此函数接受 3 个参数： 项目值 项目索引 数组本身","tags":["JavaScript"],"categories":["Language"]},{"title":"42_JavaScript_类型转换","path":"/posts/2ec8eba8.html","content":"Number() 转换数值，String() 转换字符串，Boolean() 转换布尔值。 JavaScript 数据类型JavaScript 中有五种可包含值的数据类型： 字符串（string） 数字（number） 布尔（boolean） 对象（object） 函数（function） 有三种对象类型： 对象（Object） 日期（Date） 数组（Array） 同时有两种不能包含值的数据类型： null undefined typeof 运算符您可以使用 typeof 运算符来确定 JavaScript 变量的数据类型。 实例12345678910typeof &quot;Bill&quot; // 返回 &quot;string&quot;typeof 3.14 // 返回 &quot;number&quot;typeof NaN // 返回 &quot;number&quot;typeof false // 返回 &quot;boolean&quot;typeof [1,2,3,4] // 返回 &quot;object&quot;typeof &#123;name:&#x27;Bill&#x27;, age:62&#125; // 返回 &quot;object&quot;typeof new Date() // 返回 &quot;object&quot;typeof function () &#123;&#125; // 返回 &quot;function&quot;typeof myCar // 返回 &quot;undefined&quot; *typeof null // 返回 &quot;object&quot; 请注意： NaN 的数据类型是数值 数组的数据类型是对象 日期的数据类型是对象 null 的数据类型是对象 未定义变量的数据类型是 undefined 尚未赋值的变量的数据类型也是 undefined 您无法使用 typeof 去判断 JavaScript 对象是否是数组（或日期）。 typeof 的数据类型typeof 运算符不是变量。它属于运算符。运算符（比如 + - * /）没有数据类型。 但是，typeof 始终会返回字符串（包含运算数的类型）。 constructor 属性constructor 属性返回所有 JavaScript 变量的构造器函数。 实例1234567&quot;Bill&quot;.constructor // 返回 &quot;function String() &#123; [native code] &#125;&quot;(3.14).constructor // 返回 &quot;function Number() &#123; [native code] &#125;&quot;false.constructor // 返回 &quot;function Boolean() &#123; [native code] &#125;&quot;[1,2,3,4].constructor // 返回 &quot;function Array() &#123; [native code] &#125;&quot;&#123;name:&#x27;Bill&#x27;, age:62&#125;.constructor // 返回&quot; function Object() &#123; [native code] &#125;&quot;new Date().constructor // 返回 &quot;function Date() &#123; [native code] &#125;&quot;function () &#123;&#125;.constructor // 返回 &quot;function Function()&#123; [native code] &#125;&quot; 您可以通过检查 constructor 属性来确定某个对象是否为数组（包含单词 “Array”）： 实例123function isArray(myArray) &#123; return myArray.constructor.toString().indexOf(&quot;Array&quot;) &gt; -1;&#125; 或者更简单，您可以检查对象是否是数组函数： 实例123function isArray(myArray) &#123; return myArray.constructor === Array;&#125; 您可以通过检查 constructor 属性来确定某个对象是否为日期（包含单词 “Date”）： 实例123function isDate(myDate) &#123; return myDate.constructor.toString().indexOf(&quot;Date&quot;) &gt; -1;&#125; 或者更简单，您可以检查对象是否是日期函数： 实例123function isDate(myDate) &#123; return myDate.constructor === Date;&#125; JavaScript 类型转换JavaScript 变量能够被转换为新变量以及另一种数据类型： 通过使用 JavaScript 函数 通过 JavaScript 本身自动转换 把数值转换为字符串全局方法 String() 能够把数字转换为字符串。 它可用于任意类型的数字、文字、变量或表达式： 实例123String(x) // 从数值变量 x 返回字符串String(123) // 从数值文本 123 返回字符串String(100 + 23) // 从表达式中的数值返回字符串 数字方法 toString() 同理。 实例123x.toString()(123).toString()(100 + 23).toString() 方法 描述 toExponential() 返回字符串，对数字进行舍入，并使用指数计数法来写。 toFixed() 返回字符串，对数字进行舍入，并使用指定位数的小数来写。 toPrecision() 返回字符串，把数字写为指定的长度。 把布尔转换为字符串全局方法 String() 能够将布尔转换为字符串。 12String(false) // 返回 &quot;false&quot;String(true) // 返回 &quot;true&quot; 布尔方法 toString() 同理。 12false.toString() // 返回 &quot;false&quot;true.toString() // 返回 &quot;true&quot; 把日期转换为字符串全局方法 String() 可将日期转换为字符串。 1String(Date()) &quot;demo1&quot;&gt;// 返回 &quot;Fri Apr 29 2022 16:38:03 GMT+0800 (中国标准时间)&quot; 日期方法 toString() 同理。 实例1Date().toString() &quot;demo2&quot;&gt;// 返回 &quot;Fri Apr 29 2022 16:38:03 GMT+0800 (中国标准时间)&quot; 方法 描述 getDate() 获得以数值计（1-31）的日 getDay() 或者以数值计（0-6）的周 getFullYear() 获得四位的年（yyyy） getHours() 获得时（0-23） getMilliseconds() 获得毫秒（0-999） getMinutes() 获得分钟（0-59） getMonth() 获得月（0-11） getSeconds() 获得秒（0-59） getTime() 获得时间（1970 年 1 月 1 日以来的毫秒） 把字符串转换为数值全局方法 Number() 可把字符串转换为数字。 包含数字的字符串（比如 “3.14”）转换为数字（比如 3.14）。 空的字符串转换为 0。 其他字符串将转换为 NaN（Not a number，不是数字）。 1234Number(&quot;3.14&quot;) // 返回 3.14Number(&quot; &quot;) // 返回 0Number(&quot;&quot;) // 返回 0Number(&quot;99 88&quot;) // 返回 NaN 方法 描述 parseFloat() 解析字符串并返回浮点数。 parseInt() 解析字符串并返回整数。 一元 + 运算符一元的 + 运算符可用于把变量转换为数字： 实例12var y = &quot;5&quot;; // y 是字符串var x = + y; // x 是数字 如果无法转换变量，则仍会成为数字，但是值为 NaN（Not a number）： 实例12var y = &quot;Bill&quot;; // y 是字符串var x = + y; // x 是数字 (NaN) 把布尔转换数值全局方法 Number() 也可把布尔转换为数字。 12Number(false) // 返回 0Number(true) // 返回 1 把日期转换为数字全局方法 Number() 可用于把日期转换为数字。 12d = new Date();Number(d) &quot;demo3&quot;&gt;// 返回 1651221483823 日期方法 getTime() 同理。 12d = new Date();d.getTime() &quot;demo4&quot;&gt;// 返回 1651221483823 自动类型转换如果 JavaScript 尝试操作一种“错误”的数据类型，它会试图将该值转换为“正确”的类型。 结果并不总是你所期望的： 123455 + null // 返回 5 因为 null 被转换为 0&quot;5&quot; + null // 返回 &quot;5null&quot; 因为 null 被转换为 &quot;null&quot;&quot;5&quot; + 2 // 返回 52 因为 2 被转换为 &quot;2&quot;&quot;5&quot; - 2 // 返回 3 因为 &quot;5&quot; 被转换为 5&quot;5&quot; * &quot;2&quot; // 返回 10 因为 &quot;5&quot; 和 &quot;2&quot; 被转换为 5 和 2 自动字符串转换JavaScript 自动调用变量的 toString() 函数，当您试图“输出”对象或变量时： 12345document.getElementById(&quot;demo&quot;).innerHTML = myVar;// 如果 myVar = &#123;name:&quot;Fjohn&quot;&#125; // toString 转换为 &quot;[object Object]&quot;// 如果 myVar = [1,2,3,4] // toString 转换为 &quot;1,2,3,4&quot;// 如果 myVar = new Date() // toString 转换为 &quot;Fri Apr 29 2022 16:38:03 GMT+0800 (中国标准时间)&quot; 数字和布尔也会被转换，但并不明显： 123// 如果 myVar = 123 // toString 转换为 &quot;123&quot;// 如果 myVar = true // toString 转换为 &quot;true&quot;// 如果 myVar = false // toString 转换为 &quot;false&quot; JavaScript 类型转换表下表中列出了将不同 JavaScript 值转换为数字、字符串和布尔的结果： 原始值 转换为数字 转换为字符串 转换为逻辑 false 0 “false” false true 1 “true” true 0 0 “0” false 1 1 “1” true “0” 0 “0” true “000” 0 “000” true “1” 1 “1” true NaN NaN “NaN” false Infinity Infinity “Infinity” true -Infinity -Infinity “-Infinity” true “” 0 “” false “20” 20 “20” true “twenty” NaN “twenty” true [ ] 0 “” true [20] 20 “20” true [10,20] NaN “10,20” true [“twenty”] NaN “twenty” true [“ten”,”twenty”] NaN “ten,twenty” true function(){} NaN “function(){}” true { } NaN “[object Object]” true null 0 “null” false undefined NaN “undefined” false 引号中的值指示字符串值。","tags":["JavaScript"],"categories":["Language"]},{"title":"41_JavaScript_typeof","path":"/posts/9cb23b03.html","content":"JavaScript typeof在 JavaScript 中有 5 种不同的可以包含值的数据类型： string number boolean object function 有 6 种类型的对象： Object Date Array String Number Boolean 以及 2 种不能包含值的数据类型： null undefined typeof 运算符您可以使用 typeof 运算符来确定 JavaScript 变量的数据类型。 实例12345678910typeof &quot;Bill&quot; // 返回 &quot;string&quot;typeof 3.14 // 返回 &quot;number&quot;typeof NaN // 返回 &quot;number&quot;typeof false // 返回 &quot;boolean&quot;typeof [1,2,3,4] // 返回 &quot;object&quot;typeof &#123;name:&#x27;Bill&#x27;, age:19&#125; // 返回 &quot;object&quot;typeof new Date() // 返回 &quot;object&quot;typeof function () &#123;&#125; // 返回 &quot;function&quot;typeof myCar // 返回 &quot;undefined&quot; *typeof null // 返回 &quot;object&quot; 请注意： NaN 的数据类型是数字 数组的数据类型是对象 日期的数据类型是对象 null 的数据类型是 object 未定义变量的数据类型为 undefined * 未赋值的变量的数据类型也是 undefined * 您无法使用 typeof 来确定 JavaScript 对象是否是数组（或日期）。 原始日期原始数据值指的是没有附加属性和方法的单个简单数据值。 typeof 运算符可以返回以下原始类型之一： string number boolean undefined 实例12345typeof &quot;Bill&quot; // 返回 &quot;string&quot;typeof 3.14 // 返回 &quot;number&quot;typeof true // 返回 &quot;boolean&quot;typeof false // 返回 &quot;boolean&quot;typeof x // 返回 &quot;undefined&quot; (if x has no value) 复杂数据typeof 运算符可以返回两种复杂类型之一： function object typeof 运算符会为对象、数组和 null 返回 “object”。 typeof 运算符不会为函数返回 “object”。 实例1234typeof &#123;name:&#x27;Bill&#x27;, age:19&#125; // 返回 &quot;object&quot;typeof [1,2,3,4] // 返回 &quot;object&quot;（非 &quot;array&quot;，请注意下面的例子）typeof null // 返回 &quot;object&quot;typeof function myFunc()&#123;&#125; // 返回 &quot;function&quot; typeof 运算符会为数组返回 &quot;object&quot;，因为在 JavaScript 中数组是对象。 typeof 的数据类型typeof 运算符并不是变量。它只是一个运算符。运算符 (+ - * &#x2F;) 没有任何数据类型。 但是，typeof 运算符总是返回字符串（包含操作数的类型）。 constructor 属性constructor 属性返回所有 JavaScript 变量的构造函数。 实例1234567&quot;Bill&quot;.constructor // 返回 function String() &#123;[native code]&#125;(3.14).constructor // 返回 function Number() &#123;[native code]&#125;false.constructor // 返回 function Boolean() &#123;[native code]&#125;[1,2,3,4].constructor // 返回 function Array() &#123;[native code]&#125;&#123;name:&#x27;Bill&#x27;,age:19&#125;.constructor // 返回 function Object() &#123;[native code]&#125;new Date().constructor // 返回 function Date() &#123;[native code]&#125;function () &#123;&#125;.constructor // 返回 function Function()&#123;[native code]&#125; 您可以检查 constructor 属性以确定对象是否为数组（包含 &quot;Array&quot; 一词）： 实例123function isArray(myArray) &#123; return myArray.constructor.toString().indexOf(&quot;Array&quot;) &gt; -1;&#125; 或者更简单，您可以检查对象是否为数组函数： 实例123function isArray(myArray) &#123; return myArray.constructor === Array;&#125; 您可以检查 constructor 属性以确定对象是否为日期（包含 &quot;Date&quot; 一词）： 实例123function isDate(myDate) &#123; return myDate.constructor.toString().indexOf(&quot;Date&quot;) &gt; -1;&#125; 或者更简单，您可以检查对象是否为日期函数： 实例123function isDate(myDate) &#123; return myDate.constructor === Date;&#125; Undefined在 JavaScript 中，没有值的变量的值是 undefined。类型也是 undefined。 实例1let car; // 值是 undefined，类型也是 undefined。 通过将其值设置为 undefined，可以清空任何变量。类型也将是 undefined。 实例1car = undefined; // 值是 undefined，类型也是 undefined。 空值空值与 undefined 无关。 空字符串既有合法值又有类型。 实例1let car = &quot;&quot;; // 值是 &quot;&quot;，类型是 &quot;string&quot; Null在 JavaScript 中 null 即是“无”。它应该是不存在的东西。 不幸的是，在 JavaScript 中，null 的数据类型是一个对象。 你可以认为它是 JavaScript 中的一个 bug，typeof null 是一个对象。类型应为 null。 您可以通过将对象设置为 null 来清空对象： 实例12let person = &#123;firstName:&quot;Bill&quot;, lastName:&quot;Gates&quot;, age:19, eyeColor:&quot;blue&quot;&#125;;person = null; // 现在值为 null，但类型仍然是对象 您还可以通过将对象设置为 undefined 来清空对象： 实例12let person = &#123;firstName:&quot;Bill&quot;, lastName:&quot;Gates&quot;, age:19, eyeColor:&quot;blue&quot;&#125;;person = undefined; // 现在值和类型都是未定义 undefined 与 null 的区别undefined 和 null 值相等但类型不同： 12345typeof undefined // undefinedtypeof null // objectnull === undefined // falsenull == undefined // true","tags":["JavaScript"],"categories":["Language"]},{"title":"40_JavaScript_Break_和_Continue","path":"/posts/673cb41d.html","content":"break 语句“跳出”循环。 continue 语句“跳过”循环中的一个迭代。 Break 语句在本教程稍早的章节中，您已见到了 break 语句。它被用于“跳出” switch 语句。 break 语句也可用于跳出循环。 break 语句会中断循环，并继续执行循环之后的代码（如果有）： 实例1234for (i = 0; i &lt; 10; i++) &#123; if (i === 3) &#123; break; &#125; text += &quot;数字是 &quot; + i + &quot;&lt;br&gt;&quot;;&#125; Continue 语句continue 语句中断（循环中）的一个迭代，如果发生指定的条件。然后继续循环中的下一个迭代。 本例跳过值 3 ： 实例1234for (i = 0; i &lt; 10; i++) &#123; if (i === 3) &#123; continue; &#125; text += &quot;数字是 &quot; + i + &quot;&lt;br&gt;&quot;;&#125; JavaScript 标签如需标记 JavaScript 语句，请将标签名和冒号置于语句之前： 12label:statements break 和 continue 语句是仅有的可“跳出”代码块的 JavaScript 语句。 语法：123break labelname;continue labelname; continue 语句（不论有无标签引用）只能用于跳过一个迭代。 break 语句，如果没有标签引用，只能用于跳出一个循环或一个 switch。 如果有标签引用，则 break 语句可用于跳出任意代码块： 实例12345678910var cars = [&quot;BMW&quot;, &quot;Volvo&quot;, &quot;Saab&quot;, &quot;Ford&quot;];list: &#123; text += cars[0] + &quot;&lt;br&gt;&quot;; text += cars[1] + &quot;&lt;br&gt;&quot;; text += cars[2] + &quot;&lt;br&gt;&quot;; break list; text += cars[3] + &quot;&lt;br&gt;&quot;; text += cars[4] + &quot;&lt;br&gt;&quot;; text += cars[5] + &quot;&lt;br&gt;&quot;; &#125; 代码块指的是 &#123; 与 &#125; 直接的代码片段。","tags":["JavaScript"],"categories":["Language"]},{"title":"39_JavaScript_While_循环","path":"/posts/9858f01.html","content":"只要条件为 true，循环能够一直执行代码块。 While 循环while 循环会一直循环代码块，只要指定的条件为 true。 语法123while (条件) &#123; 要执行的代码块&#125; 实例在下面的例子中，循环中的代码将运行，一遍又一遍，只要变量（i）小于 10： 1234while (i &lt; 10) &#123; text += &quot;数字是 &quot; + i; i++;&#125; 如果您忘了对条件中使用的变量进行递增，那么循环永不会结束。这会导致浏览器崩溃。 Do&#x2F;While 循环do&#x2F;while 循环是 while 循环的变体。在检查条件是否为真之前，这种循环会执行一次代码块，然后只要条件为真就会重复循环。 语法12345do &#123; 要执行的代码块&#125;while (条件); 实例下面的例子使用了 do&#x2F;while 循环。该循环会执行至少一次，即使条件为 false，因为代码块会在条件测试之前执行： 12345do &#123; text += &quot;The number is &quot; + i; i++; &#125;while (i &lt; 10); 不要忘记对条件中所用变量进行递增，否则循环永不会结束！ 比较 For 与 While如果您已经阅读了之前关于循环的章节，您会发现 while 循环与 for 循环相当类似，其中的语句 1 和 语句 2 都可以省略。 本例中的循环使用 for 循环来提取 cars 数组中的汽车品牌： 实例12345678var cars = [&quot;BMW&quot;, &quot;Volvo&quot;, &quot;Saab&quot;, &quot;Ford&quot;];var i = 0;var text = &quot;&quot;;for (;cars[i];) &#123; text += cars[i] + &quot;&lt;br&gt;&quot;; i++;&#125; 本例中的循环使用 while 循环来提取 cars 数组中的汽车品牌： 实例12345678var cars = [&quot;BMW&quot;, &quot;Volvo&quot;, &quot;Saab&quot;, &quot;Ford&quot;];var i = 0;var text = &quot;&quot;; while (cars[i]) &#123; text += cars[i] + &quot;&lt;br&gt;&quot;; i++;&#125;","tags":["JavaScript"],"categories":["Language"]},{"title":"36_JavaScript_For_循环","path":"/posts/e572654e.html","content":"循环可多次执行代码块。 JavaScript 循环假如您需要运行代码多次，且每次使用不同的值，那么循环（loop）相当方便使用。 通常我们会遇到使用数组的例子： 不需要这样写： 123456text += cars[0] + &quot;&lt;br&gt;&quot;; text += cars[1] + &quot;&lt;br&gt;&quot;; text += cars[2] + &quot;&lt;br&gt;&quot;; text += cars[3] + &quot;&lt;br&gt;&quot;; text += cars[4] + &quot;&lt;br&gt;&quot;; text += cars[5] + &quot;&lt;br&gt;&quot;; 您能够这样写： 123for (i = 0; i &lt; cars.length; i++) &#123; text += cars[i] + &quot;&lt;br&gt;&quot;; &#125; 不同类型的循环JavaScript 支持不同类型的循环： for - 多次遍历代码块 for/in - 遍历对象属性 while - 当指定条件为 true 时循环一段代码块 do/while - 当指定条件为 true 时循环一段代码块 For 循环for 循环是在您希望创建循环时经常使用的工具。 for 循环的语法如下： 123for (语句 1; 语句 2; 语句 3) &#123; 要执行的代码块&#125; 语句 1 在循环（代码块）开始之前执行。 语句 2 定义运行循环（代码块）的条件。 语句 3 会在循环（代码块）每次被执行后执行。 实例123for (i = 0; i &lt; 5; i++) &#123; text += &quot;数字是 &quot; + i + &quot;&lt;br&gt;&quot;;&#125; 从上面的代码中，您可以了解到： 语句 1 在循环开始之前设置了一个变量（var i &#x3D; 0）。 语句 2 定义运行循环的条件（i 必须小于 5）。 语句 3 会在代码块每次执行之后对值进行递增（i++）。 语句 1通常，您会使用语句 1 来初始化循环中所使用的的变量（i &#x3D; 0）。 但情况并不总是这样，JavaScript 不会在意。语句 1 是可选的。 您可以在语句 1 中初始化多个值（由逗号分隔）： 实例123for (i = 0, len = cars.length, text = &quot;&quot;; i &lt; len; i++) &#123; text += cars[i] + &quot;&lt;br&gt;&quot;;&#125; 而且您还可以省略语句 1（比如在循环开始前设置好值）： 实例123456var i = 2;var len = cars.length;var text = &quot;&quot;;for (; i &lt; len; i++) &#123; text += cars[i] + &quot;&lt;br&gt;&quot;;&#125; 语句 2通常语句 2 用于计算初始变量的条件。 但情况并不总是这样，JavaScript 不会在意。语句 2 也是可选的。 如果语句 2 返回 true，那么循环会重新开始，如果返回 false，则循环将结束。 如果省略语句 2，那么必须在循环中提供一个 break。否则循环永远不会结束。请在下一章阅读更多关于 break 的内容。 语句 3通常语句 3 会递增初始变量的值。 但情况并不总是这样，JavaScript 不会在意。语句 3 也是可选的。 语句 3 可做任何事情，比如负递增（i–），正递增（i &#x3D; i + 15），或者任何其他事情。 语句 3 也可被省略（比如当您在循环内递增值时）： 实例123456var i = 0;var len = cars.length;for (; i &lt; len; ) &#123; text += cars[i] + &quot;&lt;br&gt;&quot;; i++;&#125; For&#x2F;In 循环JavaScript for/in 语句遍历对象的属性： 实例1234567var person = &#123;fname:&quot;Bill&quot;, lname:&quot;Gates&quot;, age:62&#125;; var text = &quot;&quot;;var x;for (x in person) &#123; text += person[x];&#125;","tags":["JavaScript"],"categories":["Language"]},{"title":"35_JavaScript_Switch_语句","path":"/posts/b9ce8036.html","content":"switch 语句用于基于不同条件执行不同动作。 JavaScript Switch 语句请使用 switch 语句来选择多个需被执行的代码块之一。 语法12345678910switch(表达式) &#123; case n: 代码块 break; case n: 代码块 break; default: 默认代码块&#125; 代码解释： 计算一次 switch 表达式 把表达式的值与每个 case 的值进行对比 如果存在匹配，则执行关联代码 实例getDay() 方法返回 0 至 6 之间的周名数字（weekday number）。 (Sunday&#x3D;0, Monday&#x3D;1, Tuesday&#x3D;2 ..) 本例使用周名数字来计算周的名称： 12345678910111213141516171819202122switch (new Date().getDay()) &#123; case 0: day = &quot;星期天&quot;; break; case 1: day = &quot;星期一&quot;; break; case 2: day = &quot;星期二&quot;; break; case 3: day = &quot;星期三&quot;; break; case 4: day = &quot;星期四&quot;; break; case 5: day = &quot;星期五&quot;; break; case 6: day = &quot;星期六&quot;;&#125; 结果将是： 1今天是星期五 break 关键词如果 JavaScript 遇到 break 关键词，它会跳出 switch 代码块。 此举将停止代码块中更多代码的执行以及 case 测试。 如果找到匹配，并完成任务，则随机中断执行（break）。无需更多测试。 break 能够节省大量执行时间，因为它会“忽略” switch 代码块中的其他代码的执行。 不必中断 switch 代码块中的最后一个 case。代码块在此处会自然结束。 default 关键词default 关键词规定不存在 case 匹配时所运行的代码： 实例getDay() 方法返回 0 至 6 的数字周名。 如果今日既不是周六（6）也不是周日（0），则输出一段默认消息： 12345678910switch (new Date().getDay()) &#123; case 6: text = &quot;今天是周六&quot;; break; case 0: text = &quot;今天是周日&quot;; break; default: text = &quot;期待周末~&quot;;&#125; text 的结果是： 1期待周末~ 默认的 case 不必是 switch 代码块中最后一个 case： 实例12345678910switch (new Date().getDay()) &#123; default: text = &quot;期待周末！&quot;; break; case 6: text = &quot;今天是周六&quot;; break; case 0: text = &quot;今天是周日&quot;;&#125; 如果 default 不是 switch 代码块中最后一个 case，请记得用 break 结束默认 case。 常见的代码块有时您会需要不同的 case 来使用相同的代码。 在本例中，case 4 和 5 分享相同的代码块，而 0 和 6 分享另一段代码块： 实例123456789101112switch (new Date().getDay()) &#123; case 4: case 5: text = &quot;周末快到了：）&quot;; break; case 0: case 6: text = &quot;今天是周末~&quot;; break; default: text = &quot;期待周末！&quot;;&#125; Switching 的细节如果多种 case 匹配一个 case 值，则选择第一个 case。 如果未找到匹配的 case，程序将继续使用默认 label。 如果未找到默认 label，程序将继续 switch 后的语句。 严格的比较Switch case 使用严格比较（===）。 值必须与要匹配的类型相同。 只有操作数属于同一类型时，严格比较才能为 true。 在这个例子中，x 将不匹配： 实例1234567891011var x = &quot;0&quot;;switch (x) &#123; case 0: text = &quot;Off&quot;; break; case 1: text = &quot;On&quot;; break; default: text = &quot;No value found&quot;;&#125;","tags":["JavaScript"],"categories":["Language"]},{"title":"34_JavaScript_条件","path":"/posts/d31ebbf9.html","content":"条件语句用于基于不同条件执行不同的动作。 条件语句在您写代码时，经常会需要基于不同判断执行不同的动作。 您可以在代码中使用条件语句来实现这一点。 在 JavaScript 中，我们可使用如下条件语句： 使用 if 来规定要执行的代码块，如果指定条件为 true 使用 else 来规定要执行的代码块，如果相同的条件为 false 使用 else if 来规定要测试的新条件，如果第一个条件为 false 使用 switch 来规定多个被执行的备选代码块 if 语句请使用 if 语句来规定假如条件为 true 时被执行的 JavaScript 代码块。 语法123if (条件) &#123; 如果条件为 true 时执行的代码&#125; 注释：if 使用小写字母。大写字母（IF 或 If）会产生 JavaScript 错误。 实例如果时间早于 18:00，则发出 “Good day” 的问候： 123if (hour &lt; 18) &#123; greeting = &quot;Good day&quot;;&#125; 如果时间早于 18 点，则 greeting 的结果将是： 1Good day else 语句请使用 else 语句来规定假如条件为 false 时的代码块。 12345if (条件) &#123; 条件为 true 时执行的代码块&#125; else &#123; 条件为 false 时执行的代码块&#125; 实例如果 hour 小于 18，创建 “Good day” 问候，否则 “Good evening”： 12345if (hour &lt; 18) &#123; greeting = &quot;Good day&quot;; &#125; else &#123; greeting = &quot;Good evening&quot;; &#125; greeting 的结果： 1Good day else if 语句请使用 else if 来规定当首个条件为 false 时的新条件。 语法1234567if (条件 1) &#123; 条件 1 为 true 时执行的代码块&#125; else if (条件 2) &#123; 条件 1 为 false 而条件 2 为 true 时执行的代码块 &#125; else &#123; 条件 1 和条件 2 同时为 false 时执行的代码块&#125; 实例如果时间早于 10:00，则创建 “Good morning” 问候，如果不是，但时间早于 18:00，则创建 “Good day” 问候，否则创建 “Good evening”： 1234567if (time &lt; 10) &#123; greeting = &quot;Good morning&quot;; &#125; else if (time &lt; 18) &#123; greeting = &quot;Good day&quot;; &#125; else &#123; greeting = &quot;Good evening&quot;; &#125; greeting 的结果： 1Good day","tags":["JavaScript"],"categories":["Language"]},{"title":"33_JavaScript_比较","path":"/posts/a7ea1ac5.html","content":"比较和逻辑运算符用于测试 true 或 false。 比较运算符比较运算符在逻辑语句中使用，以判定变量或值是否相等。 我们给定 x &#x3D; 5，下表中解释了比较运算符： 运算符 描述 比较 返回 &#x3D;&#x3D; 等于 x &#x3D;&#x3D; 8 false x &#x3D;&#x3D; 5 true x &#x3D;&#x3D; “5” true &#x3D;&#x3D;&#x3D; 值相等并且类型相等 x &#x3D;&#x3D;&#x3D; 5 true x &#x3D;&#x3D;&#x3D; “5” false !&#x3D; 不相等 x !&#x3D; 8 true !&#x3D;&#x3D; 值不相等或类型不相等 x !&#x3D;&#x3D; 5 false x !&#x3D;&#x3D; “5” true x !&#x3D;&#x3D; 8 true &gt; 大于 x &gt; 8 false &lt; 小于 x &lt; 8 true &gt;&#x3D; 大于或等于 x &gt;&#x3D; 8 false &lt;&#x3D; 小于或等于 x &lt;&#x3D; 8 true 如何使用比较运算符可用在条件语句中对值进行比较，并根据结果采取动作： 1if (age &lt; 18) text = &quot;太年轻&quot;; 本教程接下来的章节中，您将在学到更多有关条件语句的知识。 逻辑运算符逻辑运算符用于判定变量或值之间的逻辑。 我们给定 x &#x3D; 6 且 y &#x3D; 3，下表解释了逻辑运算符： 运算符 描述 例子 &amp;&amp; 与 (x &lt; 10 &amp;&amp; y &gt; 1) 为 true || 或 (x &#x3D;&#x3D; 5 || y &#x3D;&#x3D; 5) 为 false ! 非 !(x &#x3D;&#x3D; y) 为 true 条件（三元）运算符JavaScript 也包含了可基于某些条件向变量赋值的条件运算符。 语法1variablename = (condition) ? value1:value2 实例1var voteable = (age &lt; 18) ? &quot;太年轻&quot;:&quot;足够成熟&quot;; 如果变量 age 的值小于 18，变量 voteable 的值将是 “太年轻”，否则变量 voteable 的值将是 “足够成熟”。 比较不同的类型比较不同类型的数据也许会出现不可预料的结果。 如果将字符串与数字进行比较，那么在做比较时 JavaScript 会把字符串转换为数值。空字符串将被转换为 0。非数值字符串将被转换为始终为 false 的 NaN。 案例 值 2 &lt; 12 true 2 &lt; “12” true 2 &lt; “Bill” false 2 &gt; “Bill” false 2 &#x3D;&#x3D; “Bill” false “2” &lt; “12” false “2” &gt; “12” true “2” &#x3D;&#x3D; “12” false 当比较两个字符串时，”2” 大于 “12”，因为（按照字母排序）1 小于 2。 为了确保正确的结果，在比较值前应该把变量转换为合适的类型： 123456age = Number(age);if (isNaN(age)) &#123; voteable = &quot;输入错误&quot;;&#125; else &#123; voteable = (age &lt; 18) ? &quot;太年轻&quot; : &quot;足够成熟&quot;;&#125;","tags":["JavaScript"],"categories":["Language"]},{"title":"32_JavaScript_逻辑","path":"/posts/c9275ebd.html","content":"JavaScript 布尔（逻辑）代表两个值之一：true 或 false。 布尔值通常，在编程中，您会需要只能有两个值之一的数据类型，比如 YES &#x2F; NO ON &#x2F; OFF TRUE &#x2F; FALSE 鉴于此，JavaScript 提供一种布尔数据类型。它只接受值 true 或 false。 Boolean() 函数您可以使用 Boolean() 函数来确定表达式（或变量）是否为真： 实例1Boolean(10 &gt; 9) // 返回 true 或者甚至更简单： 实例12(10 &gt; 9) // 也返回 true10 &gt; 9 // 也返回 true 比较和条件JS 比较这一章列出了完整的比较运算符。 JS 条件这一章列出了完整的条件语句。 下面是一些例子： 运算符 描述 实例 &#x3D;&#x3D; 等于 if (day &#x3D;&#x3D; “Monday”) &gt; 大于 if (salary &gt; 9000) &lt; 小于 if (age &lt; 18) 表达式的布尔值是 JavaScript 比较和条件的基础。 所有具有“真实”值的即为 True实例123456789101112131003.14-15&quot;Hello&quot;&quot;false&quot;7 + 1 + 3.145 &lt; 6 所有不具有“真实”值的即为 False0（零）的布尔值为 false： 12var x = 0;Boolean(x); // 返回 false -0 （负零）的布尔值为 false： 12var x = -0;Boolean(x); // 返回 false “”（空值）的布尔值为 false： 12var x = &quot;&quot;;Boolean(x); // 返回 false undefined 的布尔值是 false： 12var x;Boolean(x); // 返回 false null 的布尔值是 false： 12var x = null;Boolean(x); // 返回 false false 的布尔值（正如您猜到的）是 false： 12var x = false;Boolean(x); // 返回 false NaN 的布尔值是 false： 12var x = 10 / &quot;H&quot;;Boolean(x); // 返回 false 布尔可以是对象通常 JavaScript 布尔是由字面量创建的原始值： 1var x = false 但是布尔也可以通过关键词 new 作为对象来定义： 1var y = new Boolean(false) 实例12345var x = false;var y = new Boolean(false);// typeof x 返回 boolean// typeof y 返回 object 不要创建布尔对象。它会拖慢执行速度。 new 关键词会使代码复杂化，并产生某些意想不到的结果： 当使用 == 运算符时，相等的布尔是相等的： 实例1234var x = false; var y = new Boolean(false);// (x == y) 为 true，因为 x 和 y 拥有相等的值 当使用 === 运算符时，相等的布尔是不相等的，因为 === 运算符需要在类型和值两方面同时相等。 实例1234var x = false; var y = new Boolean(false);// (x === y) 为 false，因为 x 和 y 的类型不同 或者甚至更糟。对象无法进行比较： 实例1234var x = new Boolean(false); var y = new Boolean(false);// (x == y) 为 false，因为对象无法比较 比较两个 JavaScript 对象将始终返回 false。","tags":["JavaScript"],"categories":["Language"]},{"title":"31_JavaScript_随机","path":"/posts/3ef8aaab.html","content":"Math.random()Math.random() 返回 0（包括） 至 1（不包括） 之间的随机数： 实例1Math.random(); // 返回随机数 Math.random() 总是返回小于 1 的数。 JavaScript 随机整数Math.random() 与 Math.floor() 一起使用用于返回随机整数。 实例1Math.floor(Math.random() * 10); // 返回 0 至 9 之间的数 实例1Math.floor(Math.random() * 11); // 返回 0 至 10 之间的数 实例1Math.floor(Math.random() * 100);\t// 返回 0 至 99 之间的数 实例1Math.floor(Math.random() * 101);\t// 返回 0 至 100 之间的数 实例1Math.floor(Math.random() * 10) + 1;\t// 返回 1 至 10 之间的数 实例1Math.floor(Math.random() * 100) + 1;\t// 返回 1 至 100 之间的数 一个适当的随机函数正如你从上面的例子看到的，创建一个随机函数用于生成所有随机整数是一个好主意。 这个 JavaScript 函数始终返回介于 min（包括）和 max（不包括）之间的随机数： 实例123function getRndInteger(min, max) &#123; return Math.floor(Math.random() * (max - min) ) + min;&#125; 这个 JavaScript 函数始终返回介于 min 和 max（都包括）之间的随机数： 实例123function getRndInteger(min, max) &#123; return Math.floor(Math.random() * (max - min + 1) ) + min;&#125;","tags":["JavaScript"],"categories":["Language"]},{"title":"30_JavaScript_数学","path":"/posts/e24e02a4.html","content":"JavaScript Math 对象允许您对数字执行数学任务。 实例1Math.PI; // 返回 3.141592653589793 Math.round()Math.round(x) 的返回值是 x 四舍五入为最接近的整数： 实例12Math.round(6.8); // 返回 7Math.round(2.3); // 返回 2 Math.pow()Math.pow(x, y) 的返回值是 x 的 y 次幂： 实例1Math.pow(8, 2); // 返回 64 Math.sqrt()Math.sqrt(x) 返回 x 的平方根： 实例1Math.sqrt(64); // 返回 8 Math.abs()Math.abs(x) 返回 x 的绝对（正）值： 实例1Math.abs(-4.7); // 返回 4.7 Math.ceil()Math.ceil(x) 的返回值是 x 上舍入最接近的整数： 实例1Math.ceil(6.4); // 返回 7 Math.floor()Math.floor(x) 的返回值是 x 下舍入最接近的整数： 实例1Math.floor(2.7); // 返回 2 Math.sin()Math.sin(x) 返回角 x（以弧度计）的正弦（介于 -1 与 1 之间的值）。 如果您希望使用角度替代弧度，则需要将角度转换为弧度： 1Angle in radians = Angle in degrees x PI / 180. 实例1Math.sin(90 * Math.PI / 180); // 返回 1（90 度的正弦） Math.cos()Math.cos(x) 返回角 x（以弧度计）的余弦（介于 -1 与 1 之间的值）。 如果您希望使用角度替代弧度，则需要将角度转换为弧度： 1Angle in radians = Angle in degrees x PI / 180. 实例1Math.cos(0 * Math.PI / 180); // 返回 1（0 度的余弦） Math.min() 和 Math.max()Math.min() 和 Math.max() 可用于查找参数列表中的最低或最高值： 实例1Math.min(0, 450, 35, 10, -8, -300, -78); // 返回 -300 实例1Math.max(0, 450, 35, 10, -8, -300, -78); // 返回 450 Math.random()Math.random() 返回介于 0（包括） 与 1（不包括） 之间的随机数： 实例1Math.random(); // 返回随机数 您将在本教程的下一章学到更多有关 Math.random() 的知识。 Math 属性（常量）JavaScript 提供了可由 Math 对象访问的 8 个数学常量： 实例12345678Math.E // 返回欧拉指数（Euler&#x27;s number）Math.PI // 返回圆周率（PI）Math.SQRT2 // 返回 2 的平方根Math.SQRT1_2 // 返回 1/2 的平方根Math.LN2 // 返回 2 的自然对数Math.LN10 // 返回 10 的自然对数Math.LOG2E // 返回以 2 为底的 e 的对数（约等于 1.414）Math.LOG10E // 返回以 10 为底的 e 的对数（约等于 0.434） Math 构造器与其他全局对象不同，Math对象没有构造函数。方法和属性是静态的。 可以在不首先创建Math对象的情况下使用所有方法和属性（常量）。 Math 对象方法 方法 描述 abs(x) 返回 x 的绝对值 acos(x) 返回 x 的反余弦值，以弧度计 asin(x) 返回 x 的反正弦值，以弧度计 atan(x) 以介于 -PI&#x2F;2 与 PI&#x2F;2 弧度之间的数值来返回 x 的反正切值。 atan2(y,x) 返回从 x 轴到点 (x,y) 的角度 ceil(x) 对 x 进行上舍入 cos(x) 返回 x 的余弦 exp(x) 返回 Ex 的值 floor(x) 对 x 进行下舍入 log(x) 返回 x 的自然对数（底为e） max(x,y,z,…,n) 返回最高值 min(x,y,z,…,n) 返回最低值 pow(x,y) 返回 x 的 y 次幂 random() 返回 0 ~ 1 之间的随机数 round(x) 把 x 四舍五入为最接近的整数 sin(x) 返回 x（x 以角度计）的正弦 sqrt(x) 返回 x 的平方根 tan(x) 返回角的正切","tags":["JavaScript"],"categories":["Language"]},{"title":"29_JavaScript_日期设置方法","path":"/posts/ceac5b5f.html","content":"使用“设置日期”方法可以设置日期对象的日期值（年、月、日、小时、分钟、秒、毫秒）。 日期设置方法设置方法用于设置日期的某个部分。下面是最常用的方法（按照字母顺序排序）： 方法 描述 setDate() 以数值（1-31）设置日 setFullYear() 设置年（可选月和日） setHours() 设置小时（0-23） setMilliseconds() 设置毫秒（0-999） setMinutes() 设置分（0-59） setMonth() 设置月（0-11） setSeconds() 设置秒（0-59） setTime() 设置时间（从 1970 年 1 月 1 日至今的毫秒数） setFullYear() 方法setFullYear() 方法设置日期对象的年份。这个例子设置为 2020 年： 实例12345&lt;script&gt;var d = new Date();d.setFullYear(2020);document.getElementById(&quot;demo&quot;).innerHTML = d;&lt;/script&gt; setFullYear() 方法可以选择设置月和日： 实例12345&lt;script&gt;var d = new Date();d.setFullYear(2020, 11, 3);document.getElementById(&quot;demo&quot;).innerHTML = d;&lt;/script&gt; setMonth() 方法setMonth() 方法设置日期对象的月份（0-11）： 实例12345&lt;script&gt;var d = new Date();d.setMonth(11);document.getElementById(&quot;demo&quot;).innerHTML = d;&lt;/script&gt; setDate() 方法setDate() 方法设置日期对象的日（1-31）： 实例12345&lt;script&gt;var d = new Date();d.setDate(15);document.getElementById(&quot;demo&quot;).innerHTML = d;&lt;/script&gt; setDate() 方法也可用于将天数添加到日期： 实例12345&lt;script&gt;var d = new Date();d.setDate(d.getDate() + 50);document.getElementById(&quot;demo&quot;).innerHTML = d;&lt;/script&gt; 如果添加天数，切换月份或年份，则更改将由 Date 对象自动处理。 setHours() 方法setHours() 方法设置日期对象的小时（0-23）： 实例12345&lt;script&gt;var d = new Date();d.setHours(22);document.getElementById(&quot;demo&quot;).innerHTML = d;&lt;/script&gt; setMinutes() 方法setMinutes() 方法设置日期对象的分钟（0-59）： 实例12345&lt;script&gt;var d = new Date();d.setMinutes(30);document.getElementById(&quot;demo&quot;).innerHTML = d;&lt;/script&gt; setSeconds() 方法setSeconds() 方法设置日期对象的秒数（0-59）： 实例12345&lt;script&gt;var d = new Date();d.setSeconds(30);document.getElementById(&quot;demo&quot;).innerHTML = d;&lt;/script&gt; 比较日期日期可以很容易地进行比较。 下面的例子把今日与 2049 年 1 月 16 日进行比较： 实例1234567891011var today, someday, text;today = new Date();someday = new Date();someday.setFullYear(2049, 0, 16);if (someday &gt; today) &#123; text = &quot;今天在 2049 年 1 月 16 日之前&quot;;&#125; else &#123; text = &quot;今天在 2049 年 1 月 16 日之后&quot;;&#125;document.getElementById(&quot;demo&quot;).innerHTML = text; JavaScript 从 0 到 11 计数月份。1 月是 0。12 月是 11。","tags":["JavaScript"],"categories":["Language"]},{"title":"28_JavaScript_日期获取方法","path":"/posts/c8508020.html","content":"日期方法允许您获取并设置日期值（年、月、日、时、分、秒、毫秒） 日期获取方法获取方法用于获取日期的某个部分（来自日期对象的信息）。下面是最常用的方法（以字母顺序排序）： 方法 描述 getDate() 以数值返回天（1-31） getDay() 以数值获取周名（0-6） getFullYear() 获取四位的年（yyyy） getHours() 获取小时（0-23） getMilliseconds() 获取毫秒（0-999） getMinutes() 获取分（0-59） getMonth() 获取月（0-11） getSeconds() 获取秒（0-59） getTime() 获取时间（从 1970 年 1 月 1 日至今） getTime() 方法getTime() 方法返回自 1970 年 1 月 1 日以来的毫秒数： 实例12var d = new Date();document.getElementById(&quot;demo&quot;).innerHTML = d.getTime(); getFullYear() 方法getFullYear() 方法以四位数字形式返回日期年份： 实例12var d = new Date();document.getElementById(&quot;demo&quot;).innerHTML = d.getFullYear(); getMonth() 方法getMonth() 以数字（0-11）返回日期的月份： 实例12var d = new Date();document.getElementById(&quot;demo&quot;).innerHTML = d.getMonth(); 在 JavaScript 中，第一个月（1 月）是月号 0，因此 12 月返回月号 11。 您可以使用名称数组，并使用 getMonth() 将月份作为名称返回： 实例1234567var d = new Date();var months = [ &quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot; ];document.getElementById(&quot;demo&quot;).innerHTML = months[d.getMonth()]; getDate() 方法getDate() 方法以数字（1-31）返回日期的日： 实例12var d = new Date();document.getElementById(&quot;demo&quot;).innerHTML = d.getDate(); getHours() 方法getHours() 方法以数字（0-23）返回日期的小时数： 实例12var d = new Date();document.getElementById(&quot;demo&quot;).innerHTML = d.getHours(); getMinutes() 方法getMinutes() 方法以数字（0-59）返回日期的分钟数： 实例12var d = new Date();document.getElementById(&quot;demo&quot;).innerHTML = d.getMinutes(); getSeconds() 方法getSeconds() 方法以数字（0-59）返回日期的秒数： 实例12var d = new Date();document.getElementById(&quot;demo&quot;).innerHTML = d.getSeconds(); getMilliseconds() 方法getMilliseconds() 方法以数字（0-999）返回日期的毫秒数： 实例12var d = new Date();document.getElementById(&quot;demo&quot;).innerHTML = d.getMilliseconds(); getDay() 方法getDay() 方法以数字（0-6）返回日期的星期名（weekday）： 实例12var d = new Date();document.getElementById(&quot;demo&quot;).innerHTML = d.getDay(); 在 JavaScript 中，一周的第一天（0）表示“星期日”，即使世界上的一些国家认为周的第一天是“星期一”。 您可以使用名称数组，并使用 getDay() 将星期名作为名称返回： 实例123var d = new Date();var days = [&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;];document.getElementById(&quot;demo&quot;).innerHTML = days[d.getDay()]; UTC 日期方法UTC 日期方法用于处理 UTC 日期（通用时区日期，Univeral Time Zone dates）： 方法 描述 getUTCDate() 等于 getDate()，但返回 UTC 日期 getUTCDay() 等于 getDay()，但返回 UTC 日 getUTCFullYear() 等于 getFullYear()，但返回 UTC 年 getUTCHours() 等于 getHours()，但返回 UTC 小时 getUTCMilliseconds() 等于 getMilliseconds()，但返回 UTC 毫秒 getUTCMinutes() 等于 getMinutes()，但返回 UTC 分 getUTCMonth() 等于 getMonth()，但返回 UTC 月 getUTCSeconds() 等于 getSeconds()，但返回 UTC 秒","tags":["JavaScript"],"categories":["Language"]},{"title":"27_JavaScript_日期格式","path":"/posts/1855576b.html","content":"有四种 JavaScript 日期输入格式： 类型 实例 ISO 日期 “2018-02-19” （国际标准） 短日期 “02&#x2F;19&#x2F;2018” 或者 “2018&#x2F;02&#x2F;19” 长日期 “Feb 19 2018” 或者 “19 Feb 2019” 完整日期 “Monday February 25 2015” ISO 格式遵守 JavaScript 中的严格标准。 其他格式不太明确，可能是浏览器特定的。 JavaScript 日期输出无论输入格式如何，JavaScript 默认将输出全文本字符串格式： 1Mon Feb 19 2018 06:00:00 GMT+0800 (中国标准时间) JavaScript ISO 日期ISO 8601 是表现日期和时间的国际标准。 ISO 8601 语法 (YYYY-MM-DD) 也是首选的 JavaScript 日期格式： 实例（完整日期）1var d = new Date(&quot;2018-02-19&quot;); 计算的日期相对于您的时区。 根据您的时区，上面的结果将在 2 月 18 日至 2 月 19 日之间变化。 ISO 日期（年和月）写日期也可以不规定具体某日 (YYYY-MM)： 1var d = new Date(&quot;2015-03&quot;); 时区会对结果在 2 月 28 日至 3 月 1 日之间产生变化。 ISO 日期（只有年）写日期也可以不规定具体的月和日 (YYYY)： 1var d = new Date(&quot;2018&quot;); 时区会对结果在 2017 年 12 月 31 日至 2018 年 1 月 1 日之间产生变化。 ISO 日期（完整的日期加时、分和秒）写日期也可以添加时、分和秒 (YYYY-MM-DDTHH:MM:SS)： 1var d = new Date(&quot;2018-02-19T12:00:00&quot;); 日期和时间通过大写字母 T 来分隔。 UTC 时间通过大写字母 Z 来定义。 如果您希望修改相对于 UTC 的时间，请删除 Z 并用 +HH:MM 或 -HH:MM 代替： 实例1var d = new Date(&quot;2018-02-19T12:00:00-08:30&quot;); UTC（Universal Time Coordinated）等同于 GMT（格林威治时间）。 注释：UTC，协调世界时，又称世界统一时间，世界标准时间，国际协调时间。 在日期-时间字符串中省略 T 或 Z，在不同浏览器中会产生不同结果。 时区在设置日期时，如果不规定时区，则 JavaScript 会使用浏览器的时区。 当获取日期时，如果不规定时区，则结果会被转换为浏览器时区。 换句话说，假如日期&#x2F;时间以 GMT（格林威治标准时间）创建，该日期&#x2F;时间将被转换为 CST（中国标准时间），如果用户从中国进行浏览。 JavaScript 短日期短日期通常使用 “MM&#x2F;DD&#x2F;YYYY” 这样的语法： 实例1var d = new Date(&quot;02/19/2018&quot;); 警告在某些浏览器中，不带前导零的月或其会产生错误： 1var d = new Date(&quot;2018-2-19&quot;); “YYYY &#x2F; MM &#x2F; DD”的行为未定义。 有些浏览器会尝试猜测格式。有些会返回 NaN。 1var d = new Date(&quot;2018/02/19&quot;); “DD-MM-YYYY”的行为也是未定义的。 有些浏览器会尝试猜测格式。有些会返回 NaN。 1var d = new Date(&quot;19-02-2018&quot;); JavaScript 长日期长日期通常以 “MMM DD YYYY” 这样的语法来写： 实例1var d = new Date(&quot;Feb 19 2018&quot;); 月和天能够以任意顺序出现： 实例1var d = new Date(&quot;19 Feb 2018&quot;); 并且，月能够以全称 (January) 或缩写 (Jan) 来写： 实例1var d = new Date(&quot;February 19 2018&quot;); 实例1var d = new Date(&quot;Feb 19 2018&quot;); 逗号会被忽略，且对大小写不敏感： 实例1var d = new Date(&quot;FEBRUARY, 25, 2015&quot;); JavaScript 完整日期JavaScript 接受“完整 JavaScript 格式”的日期字符串： 实例1var d = new Date(&quot;Mon Feb 19 2018 06:55:23 GMT+0100 (W. Europe Standard Time)&quot;); JavaScript 会忽略日期名称和时间括号中的错误： 实例1var d = new Date(&quot;Fri Mar 26 2018 09:56:24 GMT+0100 (Tokyo Time)&quot;);","tags":["JavaScript"],"categories":["Language"]},{"title":"26_JavaScript_日期","path":"/posts/9cecf7df.html","content":"实例1var d = new Date(); JavaScript 日期输出默认情况下，JavaScript 将使用浏览器的时区并将日期显示为全文本字符串： 1Tue Apr 02 2019 09:01:19 GMT+0800 (中国标准时间) 稍后，您将在本教程学到更多关于如何显示日期的知识。 创建 Date 对象Date 对象由新的 Date() 构造函数创建。 有 4 种方法创建新的日期对象： new Date() new Date(year, month, day, hours, minutes, seconds, milliseconds) new Date(milliseconds) new Date(date string) new Date()new Date() 用当前日期和时间创建新的日期对象： 实例1var d = new Date(); 日期对象是静态的。计算机时间正在滴答作响，但日期对象不会。 new Date(year, month, …)new Date(*year*, *month*, ...) 用指定日期和时间创建新的日期对象。 7个数字分别指定年、月、日、小时、分钟、秒和毫秒（按此顺序）： 实例1var d = new Date(2018, 11, 24, 10, 33, 30, 0); 注释：JavaScript 从 0 到 11 计算月份。 一月是 0。十二月是11。 6个数字指定年、月、日、小时、分钟、秒： 实例1var d = new Date(2018, 11, 24, 10, 33, 30); 5个数字指定年、月、日、小时和分钟： 实例1var d = new Date(2018, 11, 24, 10, 33); 4个数字指定年、月、日和小时： 实例1var d = new Date(2018, 11, 24, 10); 3 个数字指定年、月和日： 实例1var d = new Date(2018, 11, 24); 2个数字指定年份和月份： 实例1var d = new Date(2018, 11); 您不能省略月份。如果只提供一个参数，则将其视为毫秒。 实例1var d = new Date(2018); 上个世纪一位和两位数年份将被解释为 19xx 年： 实例1var d = new Date(99, 11, 24); 实例1var d = new Date(9, 11, 24); new Date(dateString)new Date(dateString) 从日期字符串创建一个新的日期对象： 实例1var d = new Date(&quot;October 13, 2014 11:13:00&quot;); 日期字符串将在下一章中介绍。 JavaScript 将日期存储为毫秒JavaScript 将日期存储为自 1970 年 1 月 1 日 00:00:00 UTC（协调世界时）以来的毫秒数。 零时间是 1970 年 1 月 1 日 00:00:00 UTC。 现在的时间是：1970 年 1 月 1 日之后的 1554166879383 毫秒。 new Date(milliseconds)new Date(milliseconds) 创建一个零时加毫秒的新日期对象： 实例1var d = new Date(0); 1970年 1 月 1 日加上100 000 000 000毫秒，大约是 1973 年 3 月 3 日： 实例1var d = new Date(100000000000); 1970 年 1 月 1 日减去 100 000 000 000 毫秒大约是 1966 年 10 月 31 日： 实例1var d = new Date(-100000000000); 实例1var d = new Date(86400000); 一天（24 小时）是 86 400 000 毫秒。 日期方法创建 Date 对象时，可以使用许多方法对其进行操作。 日期方法允许您使用本地时间或 UTC（通用或 GMT）时间来获取和设置日期对象的年、月、日、小时、分钟、秒和毫秒。 日期方法和时区将在下一章中介绍。 显示日期JavaScript（默认情况下）将以全文本字符串格式输出日期： 1Wed Mar 25 2015 08:00:00 GMT+0800 (中国标准时间) 在 HTML 中显示日期对象时，会使用 toString() 方法自动转换为字符串。 实例12d = new Date();document.getElementById(&quot;demo&quot;).innerHTML = d; 等同于： 12d = new Date();document.getElementById(&quot;demo&quot;).innerHTML = d.toString(); toUTCString() 方法将日期转换为 UTC 字符串（一种日期显示标准）。 实例12var d = new Date();document.getElementById(&quot;demo&quot;).innerHTML = d.toUTCString(); toDateString() 方法将日期转换为更易读的格式： 实例12var d = new Date();document.getElementById(&quot;demo&quot;).innerHTML = d.toDateString();","tags":["JavaScript"],"categories":["Language"]},{"title":"25_JavaScript_数组_Const","path":"/posts/7df4c8d2.html","content":"ECMAScript 2015 (ES6)2015 年，JavaScript 引入了一个重要的新关键字：const。 使用 const 声明数组已成为一种常见做法： 实例1const cars = [&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;]; 无法重新赋值用 const 声明的数组不能重新赋值： 实例12const cars = [&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;];cars = [&quot;Toyota&quot;, &quot;Volvo&quot;, &quot;Audi&quot;]; // ERROR 数组不是常量关键字 const 有一定误导性。 它不定义常量数组。它定义的是对数组的常量引用。 因此，我们仍然可以更改常量数组的元素。 元素可以重新赋值您可以更改常量数组的元素： 实例12345678// 您可以创建常量数组：const cars = [&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;];// 您可以更改元素：cars[0] = &quot;Toyota&quot;;// 您可以添加元素：cars.push(&quot;Audi&quot;); 浏览器支持Internet Explorer 10 或更早的版本不支持 const 关键字。 下表注明了完全支持 const 关键字的首个浏览器版本： Chrome IE Firefox Safari Opera Chrome 49 IE 11 &#x2F; Edge Firefox 36 Safari 10 Opera 36 2016 年 3 月 2013 年 10 月 2015 年 2 月 2016 年 9 月 2016 年 3 月 声明时赋值JavaScript const 变量在声明时必须赋值： 意思是：用 const 声明的数组必须在声明时进行初始化。 使用 const 而不初始化数组是一个语法错误： 实例不起作用： 12const cars;cars = [&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;]; 用 var 声明的数组可以随时初始化。 您甚至可以在声明之前使用该数组： 实例没问题： 12cars = [&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;];var cars; const 块作用域用 const 声明的数组具有块作用域。 在块中声明的数组与在块外声明的数组不同： 实例1234567const cars = [&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;];// 此处 cars[0] 为 &quot;Saab&quot;&#123; const cars = [&quot;Toyota&quot;, &quot;Volvo&quot;, &quot;BMW&quot;]; // 此处 cars[0] 为 &quot;Toyota&quot;&#125;// 此处 cars[0] 为 &quot;Saab&quot; 用 var 声明的数组没有块作用域： 实例1234567var cars = [&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;];// 此处 cars[0] 为 &quot;Saab&quot;&#123; var cars = [&quot;Toyota&quot;, &quot;Volvo&quot;, &quot;BMW&quot;]; // 此处 cars[0] 为 &quot;Toyota&quot;&#125;// 此处 cars[0] 为 &quot;Toyota&quot; 您可以在以下章节中学习更多关于块作用域的内容：JavaScript 作用域。 重新声明数组在程序中的任何位置都允许用 var 重新声明数组： 实例123var cars = [&quot;Volvo&quot;, &quot;BMW&quot;]; // 允许var cars = [&quot;Toyota&quot;, &quot;BMW&quot;]; // 允许cars = [&quot;Volvo&quot;, &quot;Saab&quot;]; // 允许 不允许在同一作用域或同一块中将数组重新声明或重新赋值给 const： 实例123456var cars = [&quot;Volvo&quot;, &quot;BMW&quot;]; // 允许const cars = [&quot;Volvo&quot;, &quot;BMW&quot;]; // 不允许&#123; var cars = [&quot;Volvo&quot;, &quot;BMW&quot;]; // 允许 const cars = [&quot;Volvo&quot;, &quot;BMW&quot;]; // 不允许&#125; 不允许在同一作用域或同一块中重新声明或重新赋值现有的 const 数组： 实例1234567891011const cars = [&quot;Volvo&quot;, &quot;BMW&quot;]; // 允许const cars = [&quot;Volvo&quot;, &quot;BMW&quot;]; // 不允许var cars = [&quot;Volvo&quot;, &quot;BMW&quot;]; // 不允许cars = [&quot;Volvo&quot;, &quot;BMW&quot;]; // 不允许&#123; const cars = [&quot;Volvo&quot;, &quot;BMW&quot;]; // 允许 const cars = [&quot;Volvo&quot;, &quot;BMW&quot;]; // 不允许 var cars = [&quot;Volvo&quot;, &quot;BMW&quot;]; // 不允许 cars = [&quot;Volvo&quot;, &quot;BMW&quot;]; // 不允许&#125; 允许在另一个作用域或另一个块中使用 const 重新声明数组： 实例1234567const cars = [&quot;Volvo&quot;, &quot;BMW&quot;]; // 允许&#123; const cars = [&quot;Volvo&quot;, &quot;BMW&quot;]; // 允许&#125;&#123; const cars = [&quot;Volvo&quot;, &quot;BMW&quot;]; // 允许&#125;","tags":["JavaScript"],"categories":["Language"]},{"title":"23_JavaScript_数组方法","path":"/posts/9a11bf3d.html","content":"JavaScript 数组的力量隐藏在数组方法中。 把数组转换为字符串JavaScript 方法 toString() 把数组转换为数组值（逗号分隔）的字符串。 实例12var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];document.getElementById(&quot;demo&quot;).innerHTML = fruits.toString(); 结果 1Banana,Orange,Apple,Mango join() 方法也可将所有数组元素结合为一个字符串。 它的行为类似 toString()，但是您还可以规定分隔符： 实例12var fruits = [&quot;Banana&quot;, &quot;Orange&quot;,&quot;Apple&quot;, &quot;Mango&quot;];document.getElementById(&quot;demo&quot;).innerHTML = fruits.join(&quot; * &quot;); 结果 1Banana * Orange * Apple * Mango Popping 和 Pushing在处理数组时，删除元素和添加新元素是很简单的。 Popping 和 Pushing 指的是： 从数组弹出项目，或向数组推入项目。 Poppingpop() 方法从数组中删除最后一个元素： 实例12var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.pop(); // 从 fruits 删除最后一个元素（&quot;Mango&quot;） pop() 方法返回“被弹出”的值： 实例12var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var x = fruits.pop(); // x 的值是 &quot;Mango&quot; Pushingpush() 方法（在数组结尾处）向数组添加一个新的元素： 实例12var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.push(&quot;Kiwi&quot;); // 向 fruits 添加一个新元素 push() 方法返回新数组的长度： 实例12var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var x = fruits.push(&quot;Kiwi&quot;); // x 的值是 5 位移元素位移与弹出等同，但处理首个元素而不是最后一个。 shift() 方法会删除首个数组元素，并把所有其他元素“位移”到更低的索引。 实例12var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.shift(); // 从 fruits 删除第一个元素 &quot;Banana&quot; shift() 方法返回被“位移出”的字符串： 实例12var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.shift(); // 返回 &quot;Banana&quot; unshift() 方法（在开头）向数组添加新元素，并“反向位移”旧元素： 实例12var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.unshift(&quot;Lemon&quot;); // 向 fruits 添加新元素 &quot;Lemon&quot; unshift() 方法返回新数组的长度。 实例12var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.unshift(&quot;Lemon&quot;); // 返回 5 更改元素通过使用它们的索引号来访问数组元素： 数组索引（下标）以 0 开始。[0] 是第一个数组元素，[1] 是第二个，[2] 是第三个 … 实例12var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits[0] = &quot;Kiwi&quot;; // 把 fruits 的第一个元素改为 &quot;Kiwi&quot; length 属性提供了向数组追加新元素的简易方法： 实例12var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits[fruits.length] = &quot;Kiwi&quot;; // 向 fruits 追加 &quot;Kiwi&quot; 删除元素既然 JavaScript 数组属于对象，其中的元素就可以使用 JavaScript delete 运算符来删除： 实例12var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];delete fruits[0]; // 把 fruits 中的首个元素改为 undefined 使用 delete 会在数组留下未定义的空洞。请使用 pop() 或 shift() 取而代之。 拼接数组splice() 方法可用于向数组添加新项： 实例12var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.splice(2, 0, &quot;Lemon&quot;, &quot;Kiwi&quot;); 第一个参数（2）定义了应添加新元素的位置（拼接）。 第二个参数（0）定义应删除多少元素。 其余参数（“Lemon”，“Kiwi”）定义要添加的新元素。 splice() 方法返回一个包含已删除项的数组： 实例12var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.splice(2, 2, &quot;Lemon&quot;, &quot;Kiwi&quot;); 使用 splice() 来删除元素通过聪明的参数设定，您能够使用 splice() 在数组中不留“空洞”的情况下移除元素： 实例12var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.splice(0, 1); // 删除 fruits 中的第一个元素 第一个参数（0）定义新元素应该被添加（接入）的位置。 第二个参数（1）定义应该删除多个元素。 其余参数被省略。没有新元素将被添加。 合并（连接）数组concat() 方法通过合并（连接）现有数组来创建一个新数组： 实例（合并两个数组）123var myGirls = [&quot;Cecilie&quot;, &quot;Lone&quot;];var myBoys = [&quot;Emil&quot;, &quot;Tobias&quot;, &quot;Linus&quot;];var myChildren = myGirls.concat(myBoys); // 连接 myGirls 和 myBoys concat() 方法不会更改现有数组。它总是返回一个新数组。 concat() 方法可以使用任意数量的数组参数： 实例（合并三个数组）1234var arr1 = [&quot;Cecilie&quot;, &quot;Lone&quot;];var arr2 = [&quot;Emil&quot;, &quot;Tobias&quot;, &quot;Linus&quot;];var arr3 = [&quot;Robin&quot;, &quot;Morgan&quot;];var myChildren = arr1.concat(arr2, arr3); // 将arr1、arr2 与 arr3 连接在一起 concat() 方法也可以将值作为参数： 实例（将数组与值合并）12var arr1 = [&quot;Cecilie&quot;, &quot;Lone&quot;];var myChildren = arr1.concat([&quot;Emil&quot;, &quot;Tobias&quot;, &quot;Linus&quot;]); 裁剪数组slice() 方法用数组的某个片段切出新数组。 本例从数组元素 1 （”Orange”）开始切出一段数组： 实例12var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var citrus = fruits.slice(1); slice() 方法创建新数组。它不会从源数组中删除任何元素。 本例从数组元素 3 （”Apple”）开始切出一段数组： 实例12var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var citrus = fruits.slice(3); slice() 可接受两个参数，比如 (1, 3)。 该方法会从开始参数选取元素，直到结束参数（不包括）为止。 实例12var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var citrus = fruits.slice(1, 3); 如果结束参数被省略，比如第一个例子，则 slice() 会切出数组的剩余部分。 实例12var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var citrus = fruits.slice(2); 自动 toString()如果需要原始值，则 JavaScript 会自动把数组转换为字符串。下面两个例子将产生相同的结果： 实例12var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];document.getElementById(&quot;demo&quot;).innerHTML = fruits.toString(); 实例12var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];document.getElementById(&quot;demo&quot;).innerHTML = fruits; 所有 JavaScript 对象都拥有 toString() 方法。 数组排序我们将在下一章学习到数组排序的知识~。 查找数组中的最大和最小值没有在 JavaScript 数组中查找最高和最低值的内建函数。 您将在本教程的下一章学习如何解决这个问题。 完整的数组参考手册如需完整的参考手册，请访问我们完整的 JavaScript 数组参考手册。 该参考手册包含所有数组属性和方法的描述和实例。","tags":["JavaScript"],"categories":["Language"]},{"title":"22_JavaScript_数组","path":"/posts/39e11f4e.html","content":"JavaScript 数组用于在单一变量中存储多个值。 实例1var cars = [&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;]; 什么是数组？数组是一种特殊的变量，它能够一次存放一个以上的值。 如果您有一个项目清单（例如，汽车品牌列表），在单个变量中存储汽车品牌应该是这样的： 123var car1 = &quot;Saab&quot;;var car2 = &quot;Volvo&quot;;var car3 = &quot;BMW&quot;; 不过，假如您希望遍历所有汽车并找到一个特定的值？假如不是三个汽车品牌而是三百个呢？ 解决方法就是数组！ 数组可以用一个单一的名称存放很多值，并且还可以通过引用索引号来访问这些值。 创建数组使用数组文本是创建 JavaScript 数组最简单的方法。 语法：1var array-name = [item1, item2, ...]; 实例1var cars = [&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;]; 空格和折行并不重要。声明可横跨多行： 实例12345var cars = [ &quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;]; 请不要最后一个元素之后写逗号（比如 “BMW”,）。 可能存在跨浏览器兼容性问题。 使用 JavaScript 关键词 new下面的例子也会创建数组，并为其赋值： 实例1var cars = new Array(&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;); 以上两个例子效果完全一样。无需使用 new Array()。 出于简洁、可读性和执行速度的考虑，请使用第一种方法（数组文本方法）。 访问数组元素我们通过引用索引号（下标号）来引用某个数组元素。 这条语句访问 cars 中的首个元素的值： 1var name = cars[0]; 这条语句修改 cars 中的首个元素： 1cars[0] = &quot;Opel&quot;; 实例12var cars = [&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;];document.getElementById(&quot;demo&quot;).innerHTML = cars[0]; [0] 是数组中的第一个元素。[1] 是第二个。数组索引从 0 开始。 改变数组元素这条语句修改了 cars 中第一个元素的值： 1cars[0] = &quot;Opel&quot;; 实例123var cars = [&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;];cars[0] = &quot;Opel&quot;;document.getElementById(&quot;demo&quot;).innerHTML = cars[0]; 访问完整数组通过 JavaScript，可通过引用数组名来访问完整数组： 实例12var cars = [&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;];document.getElementById(&quot;demo&quot;).innerHTML = cars; 数组是对象数组是一种特殊类型的对象。在 JavaScript 中对数组使用 typeof 运算符会返回 “object”。 但是，JavaScript 数组最好以数组来描述。 数组使用数字来访问其“元素”。在本例中，person[0] 返回 Bill： 数组：1var person = [&quot;Bill&quot;, &quot;Gates&quot;, 62]; 对象使用名称来访问其“成员”。在本例中，person.firstName 返回 Bill： 对象：1var person = &#123;firstName:&quot;John&quot;, lastName:&quot;Doe&quot;, age:46&#125;; 数组元素可以是对象JavaScript 变量可以是对象。数组是特殊类型的对象。 正因如此，您可以在相同数组中存放不同类型的变量。 您可以在数组保存对象。您可以在数组中保存函数。你甚至可以在数组中保存数组： 123myArray[0] = Date.now;myArray[1] = myFunction;myArray[2] = myCars; 数组属性和方法JavaScript 数组的真实力量隐藏在数组的属性和方法中： 实例12var x = cars.length; // length 属性返回元素的数量var y = cars.sort(); // sort() 方法对数组进行排序 我们将在下一章学习数组方法。 length 属性length 属性返回数组的长度（数组元素的数目）。 实例12var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.length; // fruits 的长度是 4 length 属性始终大于最高数组索引（下标）。 访问第一个数组元素实例12fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var first = fruits[0]; 访问最后一个数组元素实例12fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var last = fruits[fruits.length - 1]; 遍历数组元素遍历数组的最安全方法是使用 “for“ 循环： 实例12345678var fruits, text, fLen, i;fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fLen = fruits.length;text = &quot;&lt;ul&gt;&quot;;for (i = 0; i &lt; fLen; i++) &#123; text += &quot;&lt;li&gt;&quot; + fruits[i] + &quot;&lt;/li&gt;&quot;;&#125; 您也可以使用 Array.foreach() 函数： 实例12345678910var fruits, text;fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];text = &quot;&lt;ul&gt;&quot;;fruits.forEach(myFunction);text += &quot;&lt;/ul&gt;&quot;;function myFunction(value) &#123; text += &quot;&lt;li&gt;&quot; + value + &quot;&lt;/li&gt;&quot;;&#125; 添加数组元素向数组添加新元素的最佳方法是使用 push() 方法： 实例12var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.push(&quot;Lemon&quot;); // 向 fruits 添加一个新元素 (Lemon) 也可以使用 length 属性向数组添加新元素： 实例12var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits[fruits.length] = &quot;Lemon&quot;; // 向 fruits 添加一个新元素 (Lemon) 警告！添加最高索引的元素可在数组中创建未定义的“洞”： 实例12var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits[6] = &quot;Lemon&quot;; // 向 fruits 添加一个新元素 (Lemon) 关联数组很多编程元素支持命名索引的数组。 具有命名索引的数组被称为关联数组（或散列）。 JavaScript 不支持命名索引的数组。 在 JavaScript 中，数组只能使用数字索引。 实例123456var person = [];person[0] = &quot;Bill&quot;;person[1] = &quot;Gates&quot;;person[2] = 62;var x = person.length; // person.length 返回 3var y = person[0]; // person[0] 返回 &quot;Bill&quot; 警告！假如您使用命名索引，JavaScript 会把数组重定义为标准对象。 之后，所有数组的方法和属性将产生非正确结果。 实例：123456var person = [];person[&quot;firstName&quot;] = &quot;Bill&quot;;person[&quot;lastName&quot;] = &quot;Gates&quot;;person[&quot;age&quot;] = 62;var x = person.length; // person.length 将返回 0var y = person[0]; // person[0] 将返回 undefined 数组和对象的区别在 JavaScript 中，数组使用数字索引。 在 JavaScript 中，对象使用命名索引。 数组是特殊类型的对象，具有数字索引。 何时使用数组，何时使用对象？ JavaScript 不支持关联数组 如果希望元素名为字符串（文本）则应该使用对象。 如果希望元素名为数字则应该使用数组。 避免 new Array()没有必要使用 JavaScript 的内建数组构造器 new Array()。 请使用 [] 取而代之！ 下面两条不同的语句创建了名为 points 的新的空数组： 12var points = new Array(); // 差var points = []; // 优 下面两条不同的语句创建包含六个数字的新数组： 12var points = new Array(40, 100, 1, 5, 25, 10); // 差var points = [40, 100, 1, 5, 25, 10]; // 优 new 关键词只会使代码复杂化。它还会产生某些不可预期的结果： 1var points = new Array(40, 100); // 创建包含两个元素的数组（40 和 100） 假如删除其中一个元素会怎么样？ 1var points = new Array(40); // 创建包含 40 个未定义元素的数组！！！ 如何识别数组常见的问题是：我如何知晓某个变量是否是数组？ 问题在于 JavaScript 运算符 typeof 返回 “object“： 123var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];typeof fruits; // 返回 object typeof 运算符返回 “object”，因为 JavaScript 数组属于对象。 解决方案 1：为了解决这个问题，ECMAScript 5 定义了新方法 Array.isArray()： 1Array.isArray(fruits); // 返回 true 此方案的问题在于 ECMAScript 5 不支持老的浏览器。 解决方案 2：创建您自己的 isArray() 函数以解决此问题： 123function isArray(x) &#123; return x.constructor.toString().indexOf(&quot;Array&quot;) &gt; -1;&#125; 假如参数为数组，则上面的函数始终返回 true。 或者更准确的解释是：假如对象原型包含单词 “Array” 则返回 true。 解决方案 3：假如对象由给定的构造器创建，则 instanceof 运算符返回 true： 123var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;]; fruits instanceof Array // 返回 true","tags":["JavaScript"],"categories":["Language"]},{"title":"21_JavaScript_数字方法","path":"/posts/c8630f19.html","content":"Number 方法帮助您处理数值。 Number 方法和属性原始值（比如 3.14 或 2016），无法拥有属性和方法（因为它们不是对象）。 但是通过 JavaScript，方法和属性也可用于原始值，因为 JavaScript 在执行方法和属性时将原始值视作对象。 toString() 方法toString() 以字符串返回数值。 所有数字方法可用于任意类型的数字（字面量、变量或表达式）： 实例1234var x = 123;x.toString(); // 从变量 x 返回 123(123).toString(); // 从文本 123 返回 123(100 + 23).toString(); // 从表达式 100 + 23 返回 123 toExponential() 方法toExponential() 返回字符串值，它包含已被四舍五入并使用指数计数法的数字。 参数定义小数点后的字符数： 实例1234var x = 9.656;x.toExponential(2); // 返回 9.66e+0x.toExponential(4); // 返回 9.6560e+0x.toExponential(6); // 返回 9.656000e+0 该参数是可选的。如果您没有设置它，JavaScript 不会对数字进行舍入。 toFixed() 方法toFixed() 返回字符串值，它包含了指定位数小数的数字： 实例12345var x = 9.656;x.toFixed(0); // 返回 10x.toFixed(2); // 返回 9.66x.toFixed(4); // 返回 9.6560x.toFixed(6); // 返回 9.656000 toFixed(2) 非常适合处理金钱。 toPrecision() 方法toPrecision() 返回字符串值，它包含了指定长度的数字： 实例12345var x = 9.656;x.toPrecision(); // 返回 9.656x.toPrecision(2); // 返回 9.7x.toPrecision(4); // 返回 9.656x.toPrecision(6); // 返回 9.65600 valueOf() 方法valueOf() 以数值返回数值： 实例1234var x = 123;x.valueOf(); // 从变量 x 返回 123(123).valueOf(); // 从文本 123 返回 123(100 + 23).valueOf(); // 从表达式 100 + 23 返回 123 在 JavaScript 中，数字可以是原始值（typeof &#x3D; number）或对象（typeof &#x3D; object）。 在 JavaScript 内部使用 valueOf() 方法可将 Number 对象转换为原始值。 没有理由在代码中使用它。 所有 JavaScript 数据类型都有 valueOf() 和 toString() 方法。 把变量转换为数值这三种 JavaScript 方法可用于将变量转换为数字： Number() 方法 parseInt() 方法 parseFloat() 方法 这些方法并非数字方法，而是全局 JavaScript 方法。 全局方法JavaScript 全局方法可用于所有 JavaScript 数据类型。 这些是在处理数字时最相关的方法： 方法 描述 Number() 返回数字，由其参数转换而来。 parseFloat() 解析其参数并返回浮点数。 parseInt() 解析其参数并返回整数。 Number() 方法Number() 可用于把 JavaScript 变量转换为数值： 实例12345678910x = true;Number(x); // 返回 1x = false; Number(x); // 返回 0x = new Date();Number(x); // 返回 1404568027739x = &quot;10&quot;Number(x); // 返回 10x = &quot;10 20&quot;Number(x); // 返回 NaN 如果无法转换数字，则返回 NaN。 用于日期的 Number() 方法Number() 还可以把日期转换为数字： 实例1Number(new Date(&quot;2019-04-15&quot;)); // 返回 1506729600000 上面的 Number() 方法返回 1970 年 1 月 1 日至今的毫秒数。 parseInt() 方法parseInt() 解析一段字符串并返回数值。允许空格。只返回首个数字： 实例12345parseInt(&quot;10&quot;); // 返回 10parseInt(&quot;10.33&quot;); // 返回 10parseInt(&quot;10 20 30&quot;); // 返回 10parseInt(&quot;10 years&quot;); // 返回 10parseInt(&quot;years 10&quot;); // 返回 NaN 如果无法转换为数值，则返回 NaN (Not a Number)。 parseFloat() 方法parseFloat() 解析一段字符串并返回数值。允许空格。只返回首个数字： 实例12345parseFloat(&quot;10&quot;); // 返回 10parseFloat(&quot;10.33&quot;); // 返回 10.33parseFloat(&quot;10 20 30&quot;); // 返回 10parseFloat(&quot;10 years&quot;); // 返回 10parseFloat(&quot;years 10&quot;); // 返回 NaN 如果无法转换为数值，则返回 NaN (Not a Number)。 数值属性 属性 描述 MAX_VALUE 返回 JavaScript 中可能的最大数。 MIN_VALUE 返回 JavaScript 中可能的最小数。 NEGATIVE_INFINITY 表示负的无穷大（溢出返回）。 NaN 表示非数字值（”Not-a-Number”）。 POSITIVE_INFINITY 表示无穷大（溢出返回）。 JavaScript MIN_VALUE 和 MAX_VALUEMAX_VALUE 返回 JavaScript 中可能的最大数字。 实例1var x = Number.MAX_VALUE; MIN_VALUE 返回 JavaScript 中可能的最小数字。 实例1var x = Number.MIN_VALUE; JavaScript POSITIVE_INFINITY实例1var x = Number.POSITIVE_INFINITY; 溢出时返回 POSITIVE_INFINITY： 实例1var x = 1 / 0; JavaScript NEGATIVE_INFINITY实例1var x = Number.NEGATIVE_INFINITY; 溢出时返回 NEGATIVE_INFINITY： 实例1var x = -1 / 0; JavaScript NaN - 非数字实例1var x = Number.NaN; NaN 属于 JavaScript 保留字，指示数字并非合法的数字。 尝试使用非数字字符串进行算术运算将导致 NaN（非数字）： 实例1var x = 100 / &quot;Apple&quot;; // x 将是 NaN (Not a Number) 数字属性不可用于变量数字属性属于名为 number 的 JavaScript 数字对象包装器。 这些属性只能作为 Number.MAX_VALUE 访问。 使用 myNumber.MAX_VALUE，其中 myNumber 是变量、表达式或值，将返回 undefined： 实例12var x = 6;var y = x.MAX_VALUE; // y 成为 undefined 完整的 JavaScript Number 参考手册如需完整的参考手册，请访问我们完整的 JavaScript Number 参考手册。 参考手册包含所有 Number 对象属性和方法的描述和实例。","tags":["JavaScript"],"categories":["Language"]},{"title":"20_JavaScript_数字","path":"/posts/d6f739d8.html","content":"JavaScript 只有一种数值类型。 书写数值时带不带小数点均可。 JavaScript 数值书写 JavaScript 数值既可以带小数点，也可以不带： 实例12var x = 3.14; // 带小数点的数值var y = 3; // 不带小数点的数值 超大或超小的数可通过科学计数法来写： 实例12var x = 123e5; // 12300000var y = 123e-5; // 0.00123 JavaScript 数值始终是 64 位的浮点数与许多其他编程语言不同，JavaScript 不会定义不同类型的数，比如整数、短的、长的、浮点的等等。 JavaScript 数值始终以双精度浮点数来存储，根据国际 IEEE 754 标准。 此格式用 64 位存储数值，其中 0 到 51 存储数字（片段），52 到 62 存储指数，63 位存储符号： 值(aka Fraction&#x2F;Mantissa) 指数 符号 52 bits(0 - 51) 11 bits (52 - 62) 1 bit (63) 精度整数（不使用指数或科学计数法）会被精确到 15 位。 实例12var x = 999999999999999; // x 将是 999999999999999var y = 9999999999999999; // y 将是 10000000000000000 小数的最大数是 17 位，但是浮点的算数并不总是 100% 精准： 实例1var x = 0.2 + 0.1; // x 将是 0.30000000000000004 使用乘除法有助于解决上面的问题： 实例1var x = (0.2 * 10 + 0.1 * 10) / 10; // x 将是 0.3 数字和字符串相加警告！！JavaScript 的加法和级联（concatenation）都使用 + 运算符。 数字用加法。字符串用级联。 如果您对两个数相加，结果将是一个数： 实例123var x = 10;var y = 20;var z = x + y; // z 将是 30（一个数） 如果对两个字符串相加，结果将是一个字符串的级联： 实例123var x = &quot;10&quot;;var y = &quot;20&quot;;var z = x + y; // z 将是 1020（字符串） 如果您对一个数和一个字符串相加，结果也是字符串级联： 实例123var x = 10;var y = &quot;20&quot;;var z = x + y; // z 将是 1020（一个字符串） 如果您对一个字符串和一个数字相加，结果也是字符串级联： 实例123var x = &quot;10&quot;;var y = 20;var z = x + y; // z 将是 1020（字符串） 常见的错误是认为结果应该是 30： 实例123var x = 10;var y = 20;var z = &quot;The result is: &quot; + x + y; 常见的错误是认为结果应该是 102030： 实例1234var x = 10;var y = 20;var z = &quot;30&quot;;var result = x + y + z; JavaScript 从左向右进行编译。 因为 x 和 y 都是数，10 + 20 将被相加。 因为 z 是字符串，30 + “30” 被级联。 数字字符串JavaScript 字符串可以拥有数字内容： 123var x = 100; // x 是数字var y = &quot;100&quot;; // y 是字符串 在所有数字运算中，JavaScript 会尝试将字符串转换为数字： 该例如此运行： 123var x = &quot;100&quot;;var y = &quot;10&quot;;var z = x / y; // z 将是 10 该例也将如此运行： 123var x = &quot;100&quot;;var y = &quot;10&quot;;var z = x * y; // z 将是 1000 该例如此运行： 123var x = &quot;100&quot;;var y = &quot;10&quot;;var z = x - y; // z 将是 90 但是该例不会如上例般运行： 123var x = &quot;100&quot;;var y = &quot;10&quot;;var z = x + y; // z 不会是 110（而是 10010） 在最后一个例子中，JavaScript 用 + 运算符对字符串进行了级联。 NaN - 非数值NaN 属于 JavaScript 保留词，指示某个数不是合法数。 尝试用一个非数字字符串进行除法会得到 NaN（Not a Number）： 实例1var x = 100 / &quot;Apple&quot;; // x 将是 NaN（Not a Number） 不过，假如字符串包含数值，则结果将是数： 实例1var x = 100 / &quot;10&quot;; // x 将是 10 您可使用全局 JavaScript 函数 isNaN() 来确定某个值是否是数： 实例12var x = 100 / &quot;Apple&quot;;isNaN(x); // 返回 true，因为 x 不是数 要小心 NaN。假如您在数学运算中使用了 NaN，则结果也将是 NaN： 实例123var x = NaN;var y = 5;var z = x + y; // z 将是 NaN 结果也许是串连接： 实例123var x = NaN;var y = &quot;5&quot;;var z = x + y; // z 将是 NaN5 NaN 是数，typeof NaN 返回 number： 实例1typeof NaN; // 返回 &quot;number&quot; InfinityInfinity （或 -Infinity）是 JavaScript 在计算数时超出最大可能数范围时返回的值。 实例12345var myNumber = 2;while (myNumber != Infinity) &#123; // 执行直到 Infinity myNumber = myNumber * myNumber;&#125; 除以 0（零）也会生成 Infinity： 实例12var x = 2 / 0; // x 将是 Infinityvar y = -2 / 0; // y 将是 -Infinity Infinity 是数：typeOf Infinity 返回 number。 实例1typeof Infinity; // 返回 &quot;number&quot; 十六进制JavaScript 会把前缀为 0x 的数值常量解释为十六进制。 实例1var x = 0xFF; // x 将是 255。 绝不要用前导零写数字（比如 07）。 一些 JavaScript 版本会把带有前导零的数解释为八进制。 默认地，Javascript 把数显示为十进制小数。 但是您能够使用 toString() 方法把数输出为十六进制、八进制或二进制。 实例1234var myNumber = 128;myNumber.toString(16); // 返回 80myNumber.toString(8); // 返回 200myNumber.toString(2); // 返回 10000000 数值可以是对象通常 JavaScript 数值是通过字面量创建的原始值：var x &#x3D; 123 但是也可以通过关键词 new 定义为对象：var y &#x3D; new Number(123) 实例12345var x = 123;var y = new Number(123);// typeof x 返回 number// typeof y 返回 object 请不要创建数值对象。这样会拖慢执行速度。 new 关键词使代码复杂化，并产生某些无法预料的结果： 当使用 == 相等运算符时，相等的数看上去相等： 实例1234var x = 500; var y = new Number(500);// (x == y) 为 true，因为 x 和 y 有相等的值 当使用 === 相等运算符后，相等的数变为不相等，因为 === 运算符需要类型和值同时相等。 实例1234var x = 500; var y = new Number(500);// (x === y) 为 false，因为 x 和 y 的类型不同 甚至更糟。对象无法进行对比： 实例1234var x = new Number(500); var y = new Number(500);// (x == y) 为 false，因为对象无法比较 JavaScript 对象无法进行比较","tags":["JavaScript"],"categories":["Language"]},{"title":"19_JavaScript_字符串模板","path":"/posts/606308a6.html","content":"同义词： Template Literals Template Strings String Templates Back-Tics 语法 Back-Tics 语法模板字面量使用反引号 (&#96;&#96;) 而不是引号 (“”) 来定义字符串： 实例1let text = `Hello World!`; 字符串内的引号通过使用模板字面量，您可以在字符串中同时使用单引号和双引号： 实例1let text = `He&#x27;s often called &quot;Johnny&quot;`; 多行字符串模板字面量允许多行字符串： 实例12345let text =`The quickbrown foxjumps overthe lazy dog`; 插值模板字面量提供了一种将变量和表达式插入字符串的简单方法。 该方法称为字符串插值（string interpolation）。 语法1$&#123;...&#125; 变量替换模板字面量允许字符串中的变量： 实例1234let firstName = &quot;John&quot;;let lastName = &quot;Doe&quot;;let text = `Welcome $&#123;firstName&#125;, $&#123;lastName&#125;!`; 用真实值自动替换变量称为字符串插值。 表达式替换模板字面量允许字符串中的表达式： 实例1234let price = 10;let VAT = 0.25;let total = `Total: $&#123;(price * (1 + VAT)).toFixed(2)&#125;`; 用真实值自动替换表达式称为字符串插值。 HTML 模板实例123456789let header = &quot;Templates Literals&quot;;let tags = [&quot;template literals&quot;, &quot;javascript&quot;, &quot;es6&quot;];let html = `&lt;h2&gt;$&#123;header&#125;&lt;/h2&gt;&lt;ul&gt;`;for (const x of tags) &#123; html += `&lt;li&gt;$&#123;x&#125;&lt;/li&gt;`;&#125;html += `&lt;/ul&gt;`; 浏览器支持Internet Explorer 不支持模板字面量。 第一个完全支持模板字面量的浏览器版本是： Chrome IE Firefox Safari Opera Chrome 41 Edge 13 Firefox 34 Safari 10 Opera 29 2015 年 3 月 2015 年 11 月 2014 年 12 月 2016 年 9 月 2015 年 4 月 完整的字符串参考如需完整参考，请访问我们的完整 JavaScript 字符串参考手册。 该手册包含所有字符串属性和方法的描述和实例。","tags":["JavaScript"],"categories":["Language"]},{"title":"18_JavaScript_字符串搜索","path":"/posts/d444bf85.html","content":"用于搜索字符串的 JavaScript 方法： String.indexOf() String.lastIndexOf() String.startsWith() String.endsWith() String.indexOf()indexOf() 方法返回指定文本在字符串中第一次出现（的位置）的索引： 实例12let str = &quot;Please locate where &#x27;locate&#x27; occurs!&quot;;str.indexOf(&quot;locate&quot;) // 返回 7 JavaScript 从零开始计算位置。 0 是字符串中的第一个位置，1 是第二个，2 是第三个 …… String.lastIndexOf()lastIndexOf() 方法返回指定文本在字符串中最后一次出现的索引： 实例12let str = &quot;Please locate where &#x27;locate&#x27; occurs!&quot;;str.lastIndexOf(&quot;locate&quot;) // 返回 21 如果未找到文本，indexOf() 和 lastIndexOf() 都返回 -1： 实例12let str = &quot;Please locate where &#x27;locate&#x27; occurs!&quot;;str.lastIndexOf(&quot;John&quot;) // 返回 -1 这两种方法都接受第二个参数作为搜索的开始位置： 实例12let str = &quot;Please locate where &#x27;locate&#x27; occurs!&quot;;str.indexOf(&quot;locate&quot;, 15) // 返回 21 lastIndexOf() 方法向后搜索（从末尾到开头），意思是：如果第二个参数是 15，则从位置 15 开始搜索，一直搜索到字符串的开头。 实例12let str = &quot;Please locate where &#x27;locate&#x27; occurs!&quot;;str.lastIndexOf(&quot;locate&quot;, 15) // 返回 7 String.search()search() 方法在字符串中搜索指定值并返回匹配的位置： 实例12let str = &quot;Please locate where &#x27;locate&#x27; occurs!&quot;;str.search(&quot;locate&quot;) // 返回 7 您注意到了吗？indexOf() 和 search() 这两个方法，相等吗？ 它们接受相同的参数，并返回相同的值？ 这两种方法并不相等。差别如下： search() 方法不能接受第二个起始位置参数。 indexOf() 方法不能采用强大的搜索值（正则表达式）。 您将在后面的章节中学到有关正则表达式的更多内容。 String.match()match() 方法根据正则表达式在字符串中搜索匹配项，并将匹配项作为 Array 对象返回。 实例 1在字符串中搜索 “ain”： 12let text = &quot;The rain in SPAIN stays mainly in the plain&quot;;text.match(/ain/g) // 返回数组 [ain,ain,ain] 请在 JS RegExp 一章中学习有关正则表达式的更多内容。 如果正则表达式不包含 g 修饰符（执行全局搜索），match() 方法将只返回字符串中的第一个匹配项。 语法1string.match(regexp) regexp 必需。需要搜索的值，为正则表达式。 返回： 数组，包含匹配项，每个匹配项对应一个项目，若未找到匹配项，则为 null。 实例 2对 “ain” 执行不区分大小写的全局搜索： 12let text = &quot;The rain in SPAIN stays mainly in the plain&quot;;text.match(/ain/gi) // 返回数组 [ain,AIN,ain,ain] String.includes()如果字符串包含指定值，includes() 方法返回 true。 实例12let text = &quot;Hello world, welcome to the universe.&quot;;text.includes(&quot;world&quot;) // 返回 true 浏览器支持Internet Explorer 不支持 String.includes()。 Chrome IE Firefox Safari Opera Chrome 41 Edge 12 Firefox 40 Safari 9 Opera 28 2015 年 3 月 2015 年 7 月 2015 年 8 月 2015 年 10 月 2015 年 3 月 语法1string.includes(searchvalue, start) searchvalue 必需。需要搜索的字符串。 start 可选。默认为 0. 开始搜索的位置。 返回： 如果字符串包含该值则返回 true，否则返回 false。 JS 版本： ES6 (2015) 检查字符串是否包含 “world”，从位置 12 开始搜索： 12let text = &quot;Hello world, welcome to the universe.&quot;;text.includes(&quot;world&quot;, 12) // 返回 false String.startsWith()如果字符串以指定值开头，则 startsWith() 方法返回 true，否则返回 false： 实例123let text = &quot;Hello world, welcome to the universe.&quot;;text.startsWith(&quot;Hello&quot;) // 返回 true 语法1string.startsWith(searchvalue, start) 参数值 参数 描述 searchvalue 必需。需要搜索的值。 start 可选。默认为 0。开始搜索的位置。 实例123456789let text = &quot;Hello world, welcome to the universe.&quot;;text.startsWith(&quot;world&quot;) // 返回 falselet text = &quot;Hello world, welcome to the universe.&quot;;text.startsWith(&quot;world&quot;, 5) // 返回 falselet text = &quot;Hello world, welcome to the universe.&quot;;text.startsWith(&quot;world&quot;, 6) // 返回 true 注释：startsWith() 方法区分大小写。 Internet Explorer 不支持 startsWith() 方法。 第一个完全支持的浏览器版本是： Chrome IE Firefox Safari Opera Chrome 41 Edge 12 Firefox 17 Safari 9 Opera 28 2015 年 3 月 2015 年 7 月 2015 年 8 月 2015 年 10 月 2015 年 3 月 String.endsWith()如果字符串以指定值结尾，则 endsWith() 方法返回 true，否则返回 false： 实例检查字符串是否以 “Doe” 结尾： 12var text = &quot;John Doe&quot;;text.endsWith(&quot;Doe&quot;) // 返回 true 语法1string.endsWith(searchvalue, length) 参数值 参数 描述 searchvalue 必需。需要搜索的值。 length 可选。要搜索的长度。 检索以 “world” 结尾的字符串的前 11 个字符： 12let text = &quot;Hello world, welcome to the universe.&quot;;text.endsWith(&quot;world&quot;, 11) // 返回 true 注释：endsWith() 方法区分大小写。 Internet Explorer 不支持 endsWith() 方法。 第一个完全支持该方法的浏览器版本是： Chrome IE Firefox Safari Opera Chrome 51 Edge 15 Firefox 54 Safari 10 Opera 38 2016 年 5 月 2017 年 4 月 2017 年 6 月 2016 年 9 月 2016 年 6 月 完整字符串参考手册如需完整参考，请访问我们的完整 JavaScript 字符串参考手册。 该手册包含所有字符串属性和方法的描述和实例。","tags":["JavaScript"],"categories":["Language"]},{"title":"17_JavaScript_字符串方法","path":"/posts/3370576d.html","content":"字符串方法帮助您处理字符串。 字符串方法和属性原始值，比如“Bill Gates”，无法拥有属性和方法（因为它们不是对象）。 但是通过 JavaScript，方法和属性也可用于原始值，因为在执行方法和属性时 JavaScript 将原始值视为对象。 字符串长度length 属性返回字符串的长度： 实例12var txt = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;var sln = txt.length; 查找字符串中的字符串indexOf() 方法返回字符串中指定文本首次出现的索引（位置）： 实例12var str = &quot;The full name of China is the People&#x27;s Republic of China.&quot;;var pos = str.indexOf(&quot;China&quot;); JavaScript 从零计算位置。 0 是字符串中的第一个位置，1 是第二个，2 是第三个 … lastIndexOf() 方法返回指定文本在字符串中最后一次出现的索引： 实例12var str = &quot;The full name of China is the People&#x27;s Republic of China.&quot;;var pos = str.lastIndexOf(&quot;China&quot;); 如果未找到文本， indexOf() 和 lastIndexOf() 均返回 -1。 实例12var str = &quot;The full name of China is the People&#x27;s Republic of China.&quot;;var pos = str.indexOf(&quot;USA&quot;); 两种方法都接受作为检索起始位置的第二个参数。 实例12var str = &quot;The full name of China is the People&#x27;s Republic of China.&quot;;var pos = str.indexOf(&quot;China&quot;, 18); lastIndexOf() 方法向后进行检索（从尾到头），这意味着：假如第二个参数是 50，则从位置 50 开始检索，直到字符串的起点。 实例12var str = &quot;The full name of China is the People&#x27;s Republic of China.&quot;;var pos = str.lastIndexOf(&quot;China&quot;, 50); 检索字符串中的字符串search() 方法搜索特定值的字符串，并返回匹配的位置： 实例12var str = &quot;The full name of China is the People&#x27;s Republic of China.&quot;;var pos = str.search(&quot;locate&quot;); 您注意到了吗？两种方法，indexOf() 与 search()，是相等的。 这两种方法是不相等的。区别在于： search() 方法无法设置第二个开始位置参数。 indexOf() 方法无法设置更强大的搜索值（正则表达式）。 您将在正则表达式的章节学习到这些更强大的检索值。 提取部分字符串有三种提取部分字符串的方法： slice(start, end) substring(start, end) substr(start, length) slice() 方法slice() 提取字符串的某个部分并在新字符串中返回被提取的部分。 该方法设置两个参数：起始索引（开始位置），终止索引（结束位置）。 这个例子裁剪字符串中位置 7 到位置 13 的片段： 实例12var str = &quot;Apple, Banana, Mango&quot;;var res = str.slice(7,13); res 的结果是： 1Banana 如果某个参数为负，则从字符串的结尾开始计数。 这个例子裁剪字符串中位置 -12 到位置 -6 的片段： 实例12var str = &quot;Apple, Banana, Mango&quot;;var res = str.slice(-13,-7); res 的结果是： 1Banana 如果省略第二个参数，则该方法将裁剪字符串的剩余部分： 实例1var res = str.slice(7); 或者从结尾计数： 实例1var res = str.slice(-13); 提示：负值位置不适用 Internet Explorer 8 及其更早版本。 substring() 方法substring() 类似于 slice()。 不同之处在于 substring() 无法接受负的索引。 实例12var str = &quot;Apple, Banana, Mango&quot;;var res = str.substring(7,13); res 的结果是： 1Banana 如果省略第二个参数，则该 substring() 将裁剪字符串的剩余部分。 substr() 方法substr() 类似于 slice()。 不同之处在于第二个参数规定被提取部分的长度。 实例12var str = &quot;Apple, Banana, Mango&quot;;var res = str.substr(7,6); res 的结果是： 1Banana 如果省略第二个参数，则该 substr() 将裁剪字符串的剩余部分。 实例12var str = &quot;Apple, Banana, Mango&quot;;var res = str.substr(7); res 的结果是： 1Banana, Mango 如果首个参数为负，则从字符串的结尾计算位置。 实例12var str = &quot;Apple, Banana, Mango&quot;;var res = str.substr(-5); res 的结果是： 1Mango 第二个参数不能为负，因为它定义的是长度。 替换字符串内容replace() 方法用另一个值替换在字符串中指定的值： 实例12str = &quot;Please visit Microsoft!&quot;;var n = str.replace(&quot;Microsoft&quot;, &quot;W3School&quot;); replace() 方法不会改变调用它的字符串。它返回的是新字符串。 默认地，replace() 只替换首个匹配： 实例12str = &quot;Please visit Microsoft and Microsoft!&quot;;var n = str.replace(&quot;Microsoft&quot;, &quot;W3School&quot;); 默认地，replace() 对大小写敏感。因此不对匹配 MICROSOFT： 实例12str = &quot;Please visit Microsoft!&quot;;var n = str.replace(&quot;MICROSOFT&quot;, &quot;W3School&quot;); 如需执行大小写不敏感的替换，请使用正则表达式 /i（大小写不敏感）： 实例12str = &quot;Please visit Microsoft!&quot;;var n = str.replace(/MICROSOFT/i, &quot;W3School&quot;); 请注意正则表达式不带引号。 如需替换所有匹配，请使用正则表达式的 g 标志（用于全局搜索）： 实例12str = &quot;Please visit Microsoft and Microsoft!&quot;;var n = str.replace(/Microsoft/g, &quot;W3School&quot;); 您将在 JavaScript 正则表达式这一章学到更多有关正则表达式的内容。 转换为大写和小写通过 toUpperCase() 把字符串转换为大写： 实例12var text1 = &quot;Hello World!&quot;; // 字符串var text2 = text1.toUpperCase(); // text2 是被转换为大写的 text1 通过 toLowerCase() 把字符串转换为小写： 实例12var text1 = &quot;Hello World!&quot;; // 字符串var text2 = text1.toLowerCase(); // text2 是被转换为小写的 text1 concat() 方法concat() 连接两个或多个字符串： 实例123var text1 = &quot;Hello&quot;;var text2 = &quot;World&quot;;text3 = text1.concat(&quot; &quot;,text2); concat() 方法可用于代替加运算符。下面两行是等效的： 实例12var text = &quot;Hello&quot; + &quot; &quot; + &quot;World!&quot;;var text = &quot;Hello&quot;.concat(&quot; &quot;,&quot;World!&quot;); 所有字符串方法都会返回新字符串。它们不会修改原始字符串。 正式地说：字符串是不可变的：字符串不能更改，只能替换。 String.trim()trim() 方法删除字符串两端的空白符： 实例12var str = &quot; Hello World! &quot;;alert(str.trim()); 警告：Internet Explorer 8 或更低版本不支持 trim() 方法。 如需支持 IE 8，您可搭配正则表达式使用 replace() 方法代替： 实例12var str = &quot; Hello World! &quot;;alert(str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, &#x27;&#x27;)); 您还可以使用上面的 replace 方案把 trim 函数添加到 JavaScript String.prototype： 实例123456if (!String.prototype.trim) &#123; String.prototype.trim = function () &#123; return this.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, &#x27;&#x27;);&#125;;var str = &quot; Hello World! &quot;;alert(str.trim()); 提取字符串字符这是两个提取字符串字符的安全方法： charAt(position) charCodeAt(position) charAt() 方法charAt() 方法返回字符串中指定下标（位置）的字符串： 实例12var str = &quot;HELLO WORLD&quot;;str.charAt(0); // 返回 H charCodeAt() 方法charCodeAt() 方法返回字符串中指定索引的字符 unicode 编码： 实例123var str = &quot;HELLO WORLD&quot;;str.charCodeAt(0); // 返回 72 属性访问（Property Access）ECMAScript 5 (2009) 允许对字符串的属性访问 [ ]： 实例12var str = &quot;HELLO WORLD&quot;;str[0]; // 返回 H 使用属性访问有点不太靠谱： 不适用 Internet Explorer 7 或更早的版本 它让字符串看起来像是数组（其实并不是） 如果找不到字符，[ ] 返回 undefined，而 charAt() 返回空字符串。 它是只读的。str[0] = &quot;A&quot; 不会产生错误（但也不会工作！） 实例123var str = &quot;HELLO WORLD&quot;;str[0] = &quot;A&quot;; // 不产生错误，但不会工作str[0]; // 返回 H 提示：如果您希望按照数组的方式处理字符串，可以先把它转换为数组。 把字符串转换为数组可以通过 split() 将字符串转换为数组： 实例1234var txt = &quot;a,b,c,d,e&quot;; // 字符串txt.split(&quot;,&quot;); // 用逗号分隔txt.split(&quot; &quot;); // 用空格分隔txt.split(&quot;|&quot;); // 用竖线分隔 如果省略分隔符，被返回的数组将包含 index [0] 中的整个字符串。 如果分隔符是 “”，被返回的数组将是间隔单个字符的数组： 实例12var txt = &quot;Hello&quot;; // 字符串txt.split(&quot;&quot;); // 分隔为字符 完整的 String 参考手册如需完整的参考手册，请访问我们完整的 JavaScript 字符串参考手册。 该手册包含了有关所有字符串属性和方法的描述和实例。","tags":["JavaScript"],"categories":["Language"]},{"title":"16_JavaScript_字符串","path":"/posts/af8adef8.html","content":"JavaScript 字符串用于存储和操作文本。 JavaScript 字符串JavaScript 字符串是引号中的零个或多个字符。 实例1var x = &quot;Bill Gates&quot; 您能够使用单引号或双引号： 实例12var carname = &quot;Porsche 911&quot;;var carname = &#x27;Porsche 911&#x27;; 您可以在字符串中使用引号，只要不匹配围绕字符串的引号即可： 实例123var answer = &quot;It&#x27;s good to see you again!&quot;;var answer = &quot;He is called &#x27;Bill&#x27;&quot;;var answer = &#x27;He is called &quot;Bill&quot;&#x27;; 字符串长度内建属性 length 可返回字符串的长度： 实例12var txt = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;var sln = txt.length; 特殊字符由于字符串必须由引号包围，JavaScript 会误解这段字符串： 1var y = &quot;中国是瓷器的故乡，因此 china 与&quot;China（中国）&quot;同名。&quot; 该字符串将被切为 “中国是瓷器的故乡，因此 china 与”。 避免此问题的解决方法是，使用 \\ 转义字符。 反斜杠转义字符把特殊字符转换为字符串字符： 代码 结果 描述 &#39; ‘ 单引号 &quot; “ 双引号 \\ \\ 反斜杠 实例序列 \\&quot; 在字符串中插入双引号： 实例1var x = &quot;中国是瓷器的故乡，因此 china 与\\&quot;China（中国）\\&quot;同名。&quot; 序列 \\&#39; 在字符串中插入单引号： 实例1var x = &#x27;It\\&#x27;s good to see you again&#x27;; 序列 \\\\ 在字符串中插入反斜杠： 实例1var x = &quot;字符 \\\\ 被称为反斜杠。&quot;; 转义字符（\\）也可用于在字符串中插入其他特殊字符。 其他六个 JavaScript 中有效的转义序列： 代码 结果 \\b 退格键 \\f 换页 新行 \\r 回车 \\t 水平制表符 \\v 垂直制表符 这六个转义字符最初设计用于控制打字机、电传打字机和传真机。它们在 HTML 中没有任何意义。 长代码行换行为了最佳可读性， 程序员们通常会避免每行代码超过 80 个字符串。 如果某条 JavaScript 语句不适合一整行，那么最佳换行位置是某个运算符之后： 实例12document.getElementById(&quot;demo&quot;).innerHTML =&quot;Hello Kitty.&quot;; 您也可以在字符串中换行，通过一个反斜杠即可： 实例12document.getElementById(&quot;demo&quot;).innerHTML = &quot;Hello \\Kitty!&quot;; \\ 方法并不是 ECMAScript (JavaScript) 标准。 某些浏览器也不允许 \\ 字符之后的空格。 对长字符串换行的最安全做法（但是有点慢）是使用字符串加法： 实例12document.getElementById(&quot;demo&quot;).innerHTML = &quot;Hello&quot; + &quot;Kitty!&quot;; 您不能通过反斜杠对代码行进行换行： 实例12document.getElementById(&quot;demo&quot;).innerHTML = \\ &quot;Hello Kitty!&quot;; 字符串可以是对象通常，JavaScript 字符串是原始值，通过字面方式创建： 1var firstName = &quot;Bill&quot; 但是字符串也可通过关键词 new 定义为对象： 1var firstName = new String(&quot;Bill&quot;) 实例12345var x = &quot;Bill&quot;;var y = new String(&quot;Bill&quot;);// typeof x 将返回 string// typeof y 将返回 object 请不要把字符串创建为对象。它会拖慢执行速度。 new 关键字使代码复杂化。也可能产生一些意想不到的结果： 当使用 == 相等运算符时，相等字符串是相等的： 实例1234var x = &quot;Bill&quot;; var y = new String(&quot;Bill&quot;);// (x == y) 为 true，因为 x 和 y 的值相等 当使用 === 运算符时，相等字符串是不相等的，因为 === 运算符需要类型和值同时相等。 实例1234var x = &quot;Bill&quot;; var y = new String(&quot;Bill&quot;);// (x === y) 为 false，因为 x 和 y 的类型不同（字符串与对象） 甚至更糟。对象无法比较： 实例1234var x = new String(&quot;Bill&quot;); var y = new String(&quot;Bill&quot;);// (x == y) 为 false，因为 x 和 y 是不同的对象 实例1234var x = new String(&quot;Bill&quot;); var y = new String(&quot;Bill&quot;);// (x === y) 为 false，因为 x 和 y 是不同的对象 请注意 (x&#x3D;&#x3D;y) 与 (x&#x3D;&#x3D;&#x3D;y) 的区别。 JavaScript 对象无法进行对比，比较两个 JavaScript 将始终返回 false。","tags":["JavaScript"],"categories":["Language"]},{"title":"15_JavaScript_事件","path":"/posts/3f945068.html","content":"HTML 事件是发生在 HTML 元素上的“事情”。 当在 HTML 页面中使用 JavaScript 时，JavaScript 能够“应对”这些事件。 HTML 事件HTML 事件可以是浏览器或用户做的某些事情。 下面是 HTML 事件的一些例子： HTML 网页完成加载 HTML 输入字段被修改 HTML 按钮被点击 通常，当事件发生时，用户会希望做某件事。 JavaScript 允许您在事件被侦测到时执行代码。 通过 JavaScript 代码，HTML 允许您向 HTML 元素添加事件处理程序。 使用单引号： 1&lt;element event=&#x27;一些 JavaScript&#x27;&gt; 使用双引号： 1&lt;element event=&quot;一些 JavaScript&quot;&gt; 在下面的例子中，onclick 属性（以及代码）被添加到 &lt;button&gt; 元素： 实例1&lt;button onclick=&#x27;document.getElementById(&quot;demo&quot;).innerHTML=Date()&#x27;&gt;现在的时间是？&lt;/button&gt; 在上面的例子中，JavaScript 代码改变了 id&#x3D;”demo” 的元素的内容。 在接下来的例子中，代码（使用 this.innerHTML）改变了其自身元素的内容： 实例1&lt;button onclick=&quot;this.innerHTML=Date()&quot;&gt;现在的时间是？&lt;/button&gt; JavaScript 代码通常有很多行。事件属性调用函数更为常见： 实例1&lt;button onclick=&quot;displayDate()&quot;&gt;现在的时间是？&lt;/button&gt; 常见的 HTML 事件下面是一些常见的 HTML 事件： 事件 描述 onchange HTML 元素已被改变 onclick 用户点击了 HTML 元素 onmouseover 用户把鼠标移动到 HTML 元素上 onmouseout 用户把鼠标移开 HTML 元素 onkeydown 用户按下键盘按键 onload 浏览器已经完成页面加载 更完整的列表：W3School JavaScript 参考手册 HTML DOM 事件。 JavaScript 能够做什么？事件处理程序可用于处理、验证用户输入、用户动作和浏览器动作： 每当页面加载时应该做的事情 当页面被关闭时应该做的事情 当用户点击按钮时应该被执行的动作 当用户输入数据时应该被验证的内容 等等 让 JavaScript 处理事件的不同方法有很多： HTML 事件属性可执行 JavaScript 代码 HTML 事件属性能够调用 JavaScript 函数 您能够向 HTML 元素分配自己的事件处理函数 您能够阻止事件被发送或被处理 等等 您将在 HTML DOM 章节中学到更多有关事件和事件处理程序的知识。","tags":["JavaScript"],"categories":["Language"]},{"title":"14_JavaScript_对象","path":"/posts/a12ebf64.html","content":"真实生活中的对象、属性和方法在真实生活中，汽车是一个对象。 汽车有诸如车重和颜色等属性，也有诸如启动和停止的方法： 对象 属性 方法 car.name &#x3D; porsche car.model &#x3D; 911 car.length &#x3D; 4499mm car.color &#x3D; white car.start() car.drive() car.brake() car.stop() 所有汽车都拥有同样的属性，但属性值因车而异。 所有汽车都拥有相同的方法，但是方法会在不同时间被执行。 JavaScript 对象您之前已经学到，JavaScript 变量是数据值的容器。 这段代码把一个单一值（porsche）赋给名为 car 的变量： 1var car = &quot;porsche&quot;; 对象也是变量。但是对象包含很多值。 这段代码把多个值（porsche, 911, white）赋给名为 car 的变量： 1var car = &#123;type:&quot;porsche&quot;, model:&quot;911&quot;, color:&quot;white&quot;&#125;; 值以名称:值对的方式来书写（名称和值由冒号分隔）。 JavaScript 对象是被命名值的容器。 对象属性（JavaScript 对象中的）名称:值对被称为属性。 1var person = &#123;firstName:&quot;Bill&quot;, lastName:&quot;Gates&quot;, age:62, eyeColor:&quot;blue&quot;&#125;; 属性 属性值 firstName Bill lastName Gates age 62 eyeColor blue 对象方法对象也可以有方法。 方法是在对象上执行的动作。 方法以函数定义被存储在属性中。 属性 属性值 firstName Bill lastName Gates age 62 eyeColor blue fullName function() {return this.firstName + “ “ + this.lastName;} 方法是作为属性来存储的函数。 实例12345678var person = &#123; firstName: &quot;Bill&quot;, lastName : &quot;Gates&quot;, id : 678, fullName : function() &#123; return this.firstName + &quot; &quot; + this.lastName; &#125;&#125;; this 关键词在函数定义中，this 引用该函数的“拥有者”。 在上面的例子中，this 指的是“拥有” fullName 函数的 person 对象。 换言之，this.firstName 的意思是 this 对象的 firstName 属性。 请在 JS this 关键词这一章学习更多有关 this 关键词的知识。 对象定义我们定义（创建）了一个 JavaScript 对象： 实例1var person = &#123;firstName:&quot;Bill&quot;, lastName:&quot;Gates&quot;, age:62, eyeColor:&quot;blue&quot;&#125;; 空格和折行都是允许的。对象定义可横跨多行： 实例123456var person = &#123; firstName:&quot;Bill&quot;, lastName:&quot;Gates&quot;, age:50, eyeColor:&quot;blue&quot;&#125;; 访问对象属性您能够以两种方式访问属性： 1objectName.propertyName 或者 1objectName[&quot;propertyName&quot;] 例子 11person.lastName; 例子 21person[&quot;lastName&quot;]; 访问对象方法您能够通过如下语法访问对象方法： 1objectName.methodName() 实例1name = person.fullName(); 如果您不使用 () 访问 fullName 方法，则将返回函数定义： 实例1name = person.fullName; 方法实际上是以属性值的形式存储的函数定义。 请不要把字符串、数值和布尔值声明为对象！如果通过关键词 “new” 来声明 JavaScript 变量，则该变量会被创建为对象： 123var x = new String(); // 把 x 声明为 String 对象var y = new Number(); // 把 y 声明为 Number 对象var z = new Boolean(); //\t把 z 声明为 Boolean 对象 请避免字符串、数值或逻辑对象。他们会增加代码的复杂性并降低执行速度。 您将在本教程的稍后章节学到更多有关对象的知识。","tags":["JavaScript"],"categories":["Language"]},{"title":"13_JavaScript_函数","path":"/posts/4052be3.html","content":"JavaScript 函数是被设计为执行特定任务的代码块。 JavaScript 函数会在某代码调用它时被执行。 实例123function myFunction(p1, p2) &#123; return p1 * p2; // 该函数返回 p1 和 p2 的乘积&#125; JavaScript 函数语法JavaScript 函数通过 function 关键词进行定义，其后是函数名和括号 ()。 函数名可包含字母、数字、下划线和美元符号（规则与变量名相同）。 圆括号可包括由逗号分隔的参数： 1(参数 1, 参数 2, ...) 由函数执行的代码被放置在花括号中：*{}* 123function name(参数 1, 参数 2, 参数 3) &#123; 要执行的代码&#125; 函数参数（Function parameters）是在函数定义中所列的名称。 函数参数（Function arguments）是当调用函数时由函数接收的真实的值。 在函数中，参数是局部变量。 在其他编程语言中，函数近似程序（Procedure）或子程序（Subroutine）。 函数调用函数中的代码将在其他代码调用该函数时执行： 当事件发生时（当用户点击按钮时） 当 JavaScript 代码调用时 自动的（自调用） 您将在本教程中学到更多有关函数调用的知识。 函数返回当 JavaScript 到达 return 语句，函数将停止执行。 如果函数被某条语句调用，JavaScript 将在调用语句之后“返回”执行代码。 函数通常会计算出返回值。这个返回值会返回给调用者： 实例计算两个数的乘积，并返回结果： 12345var x = myFunction(7, 8); // 调用函数，返回值被赋值给 xfunction myFunction(a, b) &#123; return a * b; // 函数返回 a 和 b 的乘积&#125; x 的结果将是： 156 为何使用函数？您能够对代码进行复用：只要定义一次代码，就可以多次使用它。 您能够多次向同一函数传递不同的参数，以产生不同的结果。 实例把华氏度转换为摄氏度： 12345function toCelsius(fahrenheit) &#123; return (5/9) * (fahrenheit-32);&#125;document.getElementById(&quot;demo&quot;).innerHTML = toCelsius(77); () 运算符调用函数使用上面的例子，toCelsius 引用的是函数对象，而 toCelsius() 引用的是函数结果。 实例访问没有 () 的函数将返回函数定义： 12345function toCelsius(fahrenheit) &#123; return (5/9) * (fahrenheit-32);&#125;document.getElementById(&quot;demo&quot;).innerHTML = toCelsius; 函数的使用方法与变量一致，在所有类型的公式、赋值和计算中。 实例使用变量来存储函数的值： 12var x = toCelsius(77);var text = &quot;The temperature is &quot; + x + &quot; Celsius&quot;; 您能够把函数当做变量值直接使用： 1var text = &quot;The temperature is &quot; + toCelsius(77) + &quot; Celsius&quot;; 您将在本教程中学到更多有关函数的知识。 局部变量在 JavaScript 函数中声明的变量，会成为函数的局部变量。 局部变量只能在函数内访问。 实例12345678// 此处的代码不能使用 carNamefunction myFunction() &#123; var carName = &quot;Volvo&quot;; // code here CAN use carName&#125;// 此处的代码可以使用 carName 由于局部变量只能被其函数识别，因此可以在不同函数中使用相同名称的变量。 局部变量在函数开始时创建，在函数完成时被删除。","tags":["JavaScript"],"categories":["Language"]},{"title":"Hello World","path":"/posts/4a17b156.html","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":["Hexo"],"categories":["Hexo"]},{"title":"12_JavaScript_数据类型","path":"/posts/380edb4f.html","content":"字符串值，数值，布尔值，数组，对象。 JavaScript 数据类型JavaScript 变量能够保存多种数据类型：数值、字符串值、数组、对象等等： 1234var length = 7; // 数字var lastName = &quot;Gates&quot;; // 字符串var cars = [&quot;Porsche&quot;, &quot;Volvo&quot;, &quot;BMW&quot;]; // 数组var x = &#123;firstName:&quot;Bill&quot;, lastName:&quot;Gates&quot;&#125;; // 对象 数据类型的概念在编程过程中，数据类型是重要的概念。 为了能够操作变量，了解数据类型是很重要的。 如果没有数据类型，计算机就无法安全地解决这道题： 1var x = 911 + &quot;Porsche&quot;; 给 “Volvo” 加上 911 有意义吗？这么做会发生错误还是会产生一个结果？ JavaScript 会这样处理上面的例子： 1var x = &quot;911&quot; + &quot;Porsche&quot;; 当数值和字符串相加时，JavaScript 将把数值视作字符串。 实例1var x = 911 + &quot;Porsche&quot;; 实例1var x = &quot;Porsche&quot; + 911; JavaScript 从左向右计算表达式。不同的次序会产生不同的结果： JavaScript：1var x = 911 + 7 + &quot;Porsche&quot;; 结果： 1918Porsche JavaScript：1var x = &quot;Porsche&quot; + 911 + 7; 结果： 1Porsche9117 在第一个例子中，JavaScript 把 911 和 7 视作数值，直到遇见 “Porsche”。 在第二个例子中，由于第一个操作数是字符串，因此所有操作数都被视为字符串。 JavaScript 拥有动态类型JavaScript 拥有动态类型。这意味着相同变量可用作不同类型： 实例123var x; // 现在 x 是 undefinedvar x = 7; // 现在 x 是数值var x = &quot;Bill&quot;; // 现在 x 是字符串值 JavaScript 字符串值字符串（或文本字符串）是一串字符（比如 “Bill Gates”）。 字符串被引号包围。您可使用单引号或双引号： 实例12var carName = &quot;Porsche 911&quot;; // 使用双引号var carName = &#x27;Porsche 911&#x27;; // 使用单引号 您可以在字符串内使用引号，只要这些引号与包围字符串的引号不匹配： 实例123var answer = &quot;It&#x27;s alright&quot;; // 双引号内的单引号var answer = &quot;He is called &#x27;Bill&#x27;&quot;; // 双引号内的单引号var answer = &#x27;He is called &quot;Bill&quot;&#x27;; // 单引号内的双引号 您将在本教程中学到更多有关字符串的知识。 JavaScript 数值JavaScript 只有一种数值类型。 写数值时用不用小数点均可： 实例12var x1 = 34.00; // 带小数点var x2 = 34; // 不带小数点 超大或超小的数值可以用科学计数法来写： 实例12var y = 123e5; // 12300000var z = 123e-5; // 0.00123 您将在本教程中学到更多有关数值的知识。 JavaScript 布尔值布尔值只有两个值：true 或 false。 实例12var x = true;var y = false; 布尔值经常用在条件测试中。 您将在本教程中学到更多有关条件测试的知识。 JavaScript 数组JavaScript 数组用方括号书写。 数组的项目由逗号分隔。 下面的代码声明（创建）了名为 cars 的数组，包含三个项目（汽车品牌）： 实例1var cars = [&quot;Porsche&quot;, &quot;Volvo&quot;, &quot;BMW&quot;]; 数组索引基于零，这意味着第一个项目是 [0]，第二个项目是 [1]，以此类推。 您将在本教程中学到更多有关数组的知识。 JavaScript 对象JavaScript 对象用花括号来书写。 对象属性是 name:value 对，由逗号分隔。 实例1var person = &#123;firstName:&quot;Bill&quot;, lastName:&quot;Gates&quot;, age:62, eyeColor:&quot;blue&quot;&#125;; 上例中的对象（person）有四个属性：firstName、lastName、age 以及 eyeColor。 您将在本教程中学到更多有关对象的知识。 typeof 运算符您可使用 JavaScript 的 typeof 来确定 JavaScript 变量的类型： typeof 运算符返回变量或表达式的类型： 实例123typeof &quot;&quot; // 返回 &quot;string&quot;typeof &quot;Bill&quot; // 返回 &quot;string&quot;typeof &quot;Bill Gates&quot; // 返回 &quot;string&quot; 实例12345typeof 0 // 返回 &quot;number&quot;typeof 314 // 返回 &quot;number&quot;typeof 3.14 // 返回 &quot;number&quot;typeof (7) // 返回 &quot;number&quot;typeof (7 + 8) // 返回 &quot;number&quot; typeof 运算符对数组返回 “object”，因为在 JavaScript 中数组属于对象。 Undefined在 JavaScript 中，没有值的变量，其值是 undefined。typeof 也返回 undefined。 实例1var person; // 值是 undefined，类型是 undefined。 任何变量均可通过设置值为 undefined 进行清空。其类型也将是 undefined。 实例1person = undefined; // 值是 undefined，类型是 undefined。 空值空值与 undefined 不是一回事。 空的字符串变量既有值也有类型。 实例1var car = &quot;&quot;; // 值是 &quot;&quot;，类型是 &quot;string&quot; Null在 JavaScript 中，null 是 “nothing”。它被看做不存在的事物。 不幸的是，在 JavaScript 中，null 的数据类型是对象。 您可以把 null 在 JavaScript 中是对象理解为一个 bug。它本应是 null。 您可以通过设置值为 null 清空对象： 实例1var person = null; // 值是 null，但是类型仍然是对象 您也可以通过设置值为 undefined 清空对象： 实例1var person = undefined; // 值是 undefined，类型是 undefined。 Undefined 与 Null 的区别Undefined 与 null 的值相等，但类型不相等： 1234typeof undefined // undefinedtypeof null // objectnull === undefined // falsenull == undefined // true 原始数据原始数据值是一种没有额外属性和方法的单一简单数据值。 typeof 运算符可返回以下原始类型之一： string number boolean undefined 实例12345typeof &quot;Bill&quot; // 返回 &quot;string&quot;typeof 3.14 // 返回 &quot;number&quot;typeof true // 返回 &quot;boolean&quot;typeof false // 返回 &quot;boolean&quot;typeof x // 返回 &quot;undefined&quot; (假如 x 没有值) 复杂数据typeof 运算符可返回以下两种类型之一： function object typeof 运算符把对象、数组或 null 返回 object。 typeof 运算符不会把函数返回 object。 实例1234typeof &#123;name:&#x27;Bill&#x27;, age:62&#125; // 返回 &quot;object&quot;typeof [1,2,3,4] // 返回 &quot;object&quot; (并非 &quot;array&quot;，参见下面的注释)typeof null // 返回 &quot;object&quot;typeof function myFunc()&#123;&#125; // 返回 &quot;function&quot; typeof 运算符把数组返回为 “object“，因为在 JavaScript 中数组即对象。","tags":["JavaScript"],"categories":["Language"]},{"title":"11_JavaScript_赋值运算符","path":"/posts/3cdeab12.html","content":"JavaScript 赋值运算符赋值运算符向 JavaScript 变量赋值。 运算符 例子 等同于 &#x3D; x &#x3D; y x &#x3D; y +&#x3D; x +&#x3D; y x &#x3D; x + y -&#x3D; x -&#x3D; y x &#x3D; x - y *&#x3D; x *&#x3D; y x &#x3D; x * y &#x2F;&#x3D; x &#x2F;&#x3D; y x &#x3D; x &#x2F; y %&#x3D; x %&#x3D; y x &#x3D; x % y &lt;&lt;&#x3D; x &lt;&lt;&#x3D; y x &#x3D; x &lt;&lt; y &gt;&gt;&#x3D; x &gt;&gt;&#x3D; y x &#x3D; x &gt;&gt; y &gt;&gt;&gt;&#x3D; x &gt;&gt;&gt;&#x3D; y x &#x3D; x &gt;&gt;&gt; y &amp;&#x3D; x &amp;&#x3D; y x &#x3D; x &amp; y ^&#x3D; x ^&#x3D; y x &#x3D; x ^ y |&#x3D; x |&#x3D; y x &#x3D; x | y **&#x3D; x **&#x3D; y x &#x3D; x ** y 提示：**= 运算符属于 ECMAScript 2016 proposal (ES7) 的实验部分。它的跨浏览器表现并不稳定。请勿使用。 赋值实例= 赋值运算符向变量赋值。 赋值1var x = 7; += 赋值运算符向变量添加值。 赋值12var x = 7;x += 8; -= 赋值运算符从变量中减去一个值。 赋值12var x = 7;x -= 8; *= 赋值运算符相乘变量。 赋值12var x = 7;x *= 8; /= 赋值运算符对变量相除。 赋值12var x = 7;x /= 8; %= 赋值运算符把余数赋值给变量。 赋值12var x = 7;x %= 8;","tags":["JavaScript"],"categories":["Language"]},{"title":"10_JavaScript_算数","path":"/posts/e9c50e6e.html","content":"处理数值的典型情景是算数。 JavaScript 算数运算符算术运算符对数值（文字或变量）执行算术运算。 运算符 描述 + 加法 - 减法 * 乘法 ** 幂（ES2016） &#x2F; 除法 % 系数 ++ 递增 – 递减 算数运算符典型的算术运算会操作两个数值。 这两个数可以是字面量： 实例1var x = 7 + 8; 或变量： 实例1var x = a + b; 或表达式： 实例1var x = (7 + 8) * a; 运算符和操作数在算术运算中，数被称为操作数。 （两个操作数之间执行的）运算由运算符定义。 操作数 运算符 操作数 7 + 8 加法加法运算符（+）加数： 123var x = 7;var y = 8;var z = x + y; 减法减法运算符（-）减数。 123var x = 7;var y = 8;var z = x - y; 乘法乘法运算符（*）乘数。 123var x = 7;var y = 8;var z = x * y; 除法除法运算符（/）除数。 123var x = 7;var y = 2;var z = x / y; 系数系数运算符（%）返回除法的余数。 123var x = 7;var y = 2;var z = x % y; 注释：在算术中，两个整数的除法产生商和余数。 注释：在数学中，模运算的结果是算术除法的余数。 递增递增运算符（++）对数值进行递增。 123var x = 7;x++;var z = x; 递减递减运算符（--）对数值进行递减。 123var x = 7;x--;var z = x; 幂取幂运算符（**）将第一个操作数提升到第二个操作数的幂。 实例12var x = 5;var z = x ** 2; // 结果是 25 x ** y 产生的结果与 Math.pow(x,y) 相同: 实例12var x = 5;var z = Math.pow(x,2); // 结果是 25 运算符优先级运算符优先级（Operator precedence）描述了在算术表达式中所执行操作的顺序。 实例1var x = 200 + 50 * 2; 上例的结果是 250 * 2 还是 200 + 100 呢？ 是加法还是乘法优先呢？ 在传统的学校数学中，乘法是优先的。 乘法（*）和除法（%）比加法（+）和减法（-）拥有更高的优先级。 同时，（就像在学校的数学中那样）能够通过使用括号来改变优先级： 实例1var x = (200 + 50) * 2; 当使用括号时，括号中的运算符会首先被计算。 当多个运算拥有相同的优先级时（比如加法和减法），对它们的计算是从左向右的： 实例1var x = 200 + 50 - 2; JavaScript 运算符优先级值 值 运算符 描述 实例 20 ( ) 表达式分组 (3 + 4) 19 . 成员 person.name 19 [] 成员 person[“name”] 19 () 函数调用 myFunction() 19 new 创建 new Date() 17 ++ 后缀递增 i++ 17 – 后缀递减 i– 16 ++ 前缀递增 ++i 16 – 前缀递减 –i 16 ! 逻辑否 !(x&#x3D;&#x3D;y) 16 typeof 类型 typeof x 15 ** 求幂 (ES7) 10 ** 2 14 * 乘 10 * 5 14 &#x2F; 除 10 &#x2F; 5 14 % 模数除法 10 % 5 13 + 加 10 + 5 13 - 减 10 - 5 12 &lt;&lt; 左位移 x &lt;&lt; 2 12 &gt;&gt; 右位移 x &gt;&gt; 2 12 &gt;&gt;&gt; 右位移（无符号） x &gt;&gt;&gt; 2 11 &lt; 小于 x &lt; y 11 &lt;&#x3D; 小于或等于 x &lt;&#x3D; y 11 &gt; 大于 x &gt; y 11 &gt;&#x3D; 大于或等于 x &gt;&#x3D; y 11 in 对象中的属性 “PI” in Math 11 instanceof 对象的实例 instanceof Array 10 &#x3D;&#x3D; 相等 x &#x3D;&#x3D; y 10 &#x3D;&#x3D;&#x3D; 严格相等 x &#x3D;&#x3D;&#x3D; y 10 !&#x3D; 不相等 x !&#x3D; y 10 !&#x3D;&#x3D; 严格不相等 x !&#x3D;&#x3D; y 9 &amp; 按位与 x &amp; y 8 ^ 按位 XOR x ^ y 7 | 按位或 x | y 6 &amp;&amp; 逻辑与 x &amp;&amp; y 5 || 逻辑否 x || y 4 ? : 条件 ? “Yes” : “No” 3 &#x3D; 赋值 x &#x3D; y 3 +&#x3D; 赋值 x +&#x3D; y 3 -&#x3D; 赋值 x -&#x3D; y 3 *&#x3D; 赋值 x *&#x3D; y 3 %&#x3D; 赋值 x %&#x3D; y 3 &lt;&lt;&#x3D; 赋值 x &lt;&lt;&#x3D; y 3 &gt;&gt;&#x3D; 赋值 x &gt;&gt;&#x3D; y 3 &gt;&gt;&gt;&#x3D; 赋值 x &gt;&gt;&gt;&#x3D; y 3 &amp;&#x3D; 赋值 x &amp;&#x3D; y 3 ^&#x3D; 赋值 x ^&#x3D; y 3 |&#x3D; 赋值 x |&#x3D; y 2 yield 暂停函数 yield x 1 , 逗号 7 , 8 注意：淡红色指示实验性或建议性的技术（ECMASScript 2016 或 ES7） 提示：括号中的表达式会在值在表达式的其余部分中被使用之前进行完全计算。","tags":["JavaScript"],"categories":["Language"]},{"title":"09_JavaScript_运算符","path":"/posts/e670b236.html","content":"JavaScript 运算符实例向变量赋值，并把它们相加： 123var x = 7; // 向 x 赋值 5var y = 8; // 向 y 赋值 2var z = x + y; // 向 z (x + y) 赋值 7 赋值运算符（=）把值赋给变量。 赋值1var x = 15; 加法运算符（+）对数字相加： 加法123var x = 7;var y = 8;var z = x + y; 乘法运算符（*）对数字相乘： 乘法123var x = 7;var y = 8;var z = x * y; JavaScript 算数运算符算数运算符用于对数字执行算数运算： 运算符 描述 + 加法 - 减法 * 乘法 &#x2F; 除法 % 取模（余数） ++ 递加 – 递减 注释：JS 算数这一章对算数运算符进行了完整描述。 JavaScript 赋值运算符赋值运算符向 JavaScript 变量赋值。 运算符 例子 等同于 &#x3D; x &#x3D; y x &#x3D; y +&#x3D; x +&#x3D; y x &#x3D; x + y -&#x3D; x -&#x3D; y x &#x3D; x - y *&#x3D; x *&#x3D; y x &#x3D; x * y &#x2F;&#x3D; x &#x2F;&#x3D; y x &#x3D; x &#x2F; y %&#x3D; x %&#x3D; y x &#x3D; x % y 加法赋值运算符（+=）向变量添加一个值。 赋值12var x = 7;x += 8; 注释：JS 赋值这一章中完整描述了赋值运算符。 JavaScript 字符串运算符+ 运算符也可用于对字符串进行相加（concatenate，级联）。 实例123txt1 = &quot;Bill&quot;;txt2 = &quot;Gates&quot;;txt3 = txt1 + &quot; &quot; + txt2; txt3 的结果将是： 1Bill Gates += 赋值运算符也可用于相加（级联）字符串： 实例12txt1 = &quot;Hello &quot;;txt1 += &quot;Kitty!&quot;; txt1 的结果将是： 1Hello Kitty! 提示：在用于字符串时，+ 运算符被称为级联运算符。 字符串和数字的相加相加两个数字，将返回和，但对一个数字和一个字符串相加将返回一个字符串： 实例123x = 7 + 8;y = &quot;7&quot; + 8;z = &quot;Hello&quot; + 7; x、y 和 z 的结果将是： 1231578Hello7 提示：如果您对数字和字符串相加，结果将是字符串！ JavaScript 比较运算符 运算符 描述 &#x3D;&#x3D; 等于 &#x3D;&#x3D;&#x3D; 等值等型 !&#x3D; 不相等 !&#x3D;&#x3D; 不等值或不等型 &gt; 大于 &lt; 小于 &gt;&#x3D; 大于或等于 &lt;&#x3D; 小于或等于 ? 三元运算符 注释：JS 比较这一章中完整描述了比较运算符。 JavaScript 逻辑运算符 运算符 描述 &amp;&amp; 逻辑与 || 逻辑或 ! 逻辑非 注释：JS 比较这一章中完整描述了逻辑运算符。 JavaScript 类型运算符 运算符 描述 typeof 返回变量的类型。 instanceof 返回 true，如果对象是对象类型的实例。 注释：JS 类型转换这一章完整描述了类型运算符。 JavaScript 位运算符位运算符处理 32 位数。 该运算中的任何数值运算数都会被转换为 32 位的数。结果会被转换回 JavaScript 数。 运算符 描述 例子 等同于 结果 十进制 &amp; 与 5 &amp; 1 0101 &amp; 0001 0001 1 | 或 5 | 1 0101 | 0001 0101 5 ~ 非 ~ 5 ~0101 1010 10 ^ 异或 5 ^ 1 0101 ^ 0001 0100 4 &lt;&lt; 零填充左位移 5 &lt;&lt; 1 0101 &lt;&lt; 1 1010 10 &gt;&gt; 有符号右位移 5 &gt;&gt; 1 0101 &gt;&gt; 1 0010 2 &gt;&gt;&gt; 零填充右位移 5 &gt;&gt;&gt; 1 0101 &gt;&gt;&gt; 1 0010 2 上例使用 4 位无符号的例子。但是 JavaScript 使用 32 位有符号数。 因此，在 JavaScript 中，~ 5 不会返回 10，而是返回 -6。 ~00000000000000000000000000000101 将返回 11111111111111111111111111111010。 注释：我们将在 JS 位运算这一章为您详解位运算符。 课外书如需更多有关 JavaScript 运算符的知识，请阅读 JavaScript 高级教程中的相关内容： ECMAScript 一元运算符 一元运算符只有一个参数，即要操作的对象或值。本节讲解 ECMAScript 中最简单的运算符 - 一元运算符。 ECMAScript 位运算符 位运算符是在数字底层进行操作的。本节深入讲解了有关整数的知识，并介绍了 ECMAScript 的各种位运算符。 ECMAScript Boolean 运算符 Boolean 运算符非常重要。本节深入讲解三种 Boolean 运算符：NOT、AND 和 OR。 ECMAScript 乘性运算符 本节讲解 ECMAScript 的乘性运算符：乘法、除法、取模运算符，以及它们的特殊行为。 ECMAScript 加性运算符 本节讲解 ECMAScript 的加性运算符：加法、减法运算符，以及它们的特殊行为。 ECMAScript 关系运算符 关系运算符执行的是比较运算。本节讲解关系运算符的常规比较方式，以及如何比较字符串与数字。 ECMAScript 等性运算符 等性运算符用于判断变量是否相等。ECMAScript 提供两套等性运算符：等号和非等号，以及全等号和非全等号。 ECMAScript 条件运算符 本节讲解 ECMAScript 中的条件运算符。 ECMAScript 赋值运算符 本节讲解 ECMAScript 中的赋值运算符。 ECMAScript 逗号运算符符 本节讲解 ECMAScript 中的逗号运算符。","tags":["JavaScript"],"categories":["Language"]},{"title":"08_JavaScript_Const","path":"/posts/430a511f.html","content":"ECMAScript 2015ES2015 引入了两个重要的 JavaScript 新关键词：let 和 const。 通过 const 定义的变量与 let 变量类似，但不能重新赋值： 实例123const PI = 3.141592653589793;PI = 3.14; // 会出错PI = PI + 10; // 也会出错 块作用域在块作用域内使用 const 声明的变量与 let 变量相似。 在本例中，x 在块中声明，不同于在块之外声明的 x： 实例1234567var x = 10;// 此处，x 为 10&#123; const x = 6; // 此处，x 为 6&#125;// 此处，x 为 10 您可以在上一章 JavaScript Let 中学到更多有关块作用域的知识。 在声明时赋值JavaScript const 变量必须在声明时赋值： 不正确12const PI;PI = 3.14159265359; 正确1const PI = 3.14159265359; 不是真正的常数关键字 const 有一定的误导性。 它没有定义常量值。它定义了对值的常量引用。 因此，我们不能更改常量原始值，但我们可以更改常量对象的属性。 原始值如果我们将一个原始值赋给常量，我们就不能改变原始值： 实例123const PI = 3.141592653589793;PI = 3.14; // 会出错PI = PI + 10; // 也会出错 常量对象可以更改您可以更改常量对象的属性： 实例12345678// 您可以创建 const 对象：const car = &#123;type:&quot;porsche&quot;, model:&quot;911&quot;, color:&quot;Black&quot;&#125;;// 您可以更改属性：car.color = &quot;White&quot;;// 您可以添加属性：car.owner = &quot;Bill&quot;; 但是您无法重新为常量对象赋值： 实例12const car = &#123;type:&quot;porsche&quot;, model:&quot;911&quot;, color:&quot;Black&quot;&#125;;car = &#123;type:&quot;Volvo&quot;, model:&quot;XC60&quot;, color:&quot;White&quot;&#125;; // ERROR 常量数组可以更改您可以更改常量数组的元素： 实例12345678// 您可以创建常量数组：const cars = [&quot;Audi&quot;, &quot;BMW&quot;, &quot;porsche&quot;];// 您可以更改元素：cars[0] = &quot;Honda&quot;;// 您可以添加元素：cars.push(&quot;Volvo&quot;); 但是您无法重新为常量数组赋值： 实例12const cars = [&quot;Audi&quot;, &quot;BMW&quot;, &quot;porsche&quot;];cars = [&quot;Honda&quot;, &quot;Toyota&quot;, &quot;Volvo&quot;]; // ERROR 浏览器支持Internet Explorer 10 或更早版本不支持 const 关键词。 下表定义了第一个完全支持 const 关键词的浏览器版本： Chrome 49 IE &#x2F; Edge 11 Firefox 36 Safari 10 Opera 36 2016 年 3 月 2013 年 10 月 2015 年 2 月 2016 年 9 月 2016 年 3 月 重新声明在程序中的任何位置都允许重新声明 JavaScript var 变量： 实例123var x = 2; // 允许var x = 3; // 允许x = 4; // 允许 在同一作用域或块中，不允许将已有的 var 或 let 变量重新声明或重新赋值给 const： 实例123456var x = 2; // 允许const x = 2; // 不允许&#123; let x = 2; // 允许 const x = 2; // 不允许&#125; 在同一作用域或块中，为已有的 const 变量重新声明声明或赋值是不允许的： 实例12345678910111213const x = 2; // 允许const x = 3; // 不允许x = 3; // 不允许var x = 3; // 不允许let x = 3; // 不允许&#123; const x = 2; // 允许 const x = 3; // 不允许 x = 3; // 不允许 var x = 3; // 不允许 let x = 3; // 不允许&#125; 在另外的作用域或块中重新声明 const 是允许的： 实例123456789const x = 2; // 允许&#123; const x = 3; // 允许&#125;&#123; const x = 4; // 允许&#125; 提升通过 var 定义的变量会被提升到顶端。如果您不了解什么是提升（Hoisting），请学习提升这一章。 您可以在声明 var 变量之前就使用它： 实例12carName = &quot;Volvo&quot;; // 您可以在此处使用 carNamevar carName; 通过 const 定义的变量不会被提升到顶端。 const 变量不能在声明之前使用： 实例12carName = &quot;Volvo&quot;; // 您不可以在此处使用 carNameconst carName = &quot;Volvo&quot;;","tags":["JavaScript"],"categories":["Language"]},{"title":"07_JavaScript_Let","path":"/posts/59c196f6.html","content":"ECMAScript 2015ES2015 引入了两个重要的 JavaScript 新关键词：let 和 const。 这两个关键字在 JavaScript 中提供了块作用域（Block Scope）变量（和常量）。 在 ES2015 之前，JavaScript 只有两种类型的作用域：全局作用域和函数作用域。 全局作用域全局（在函数之外）声明的变量拥有全局作用域。 实例1234567var carName = &quot;porsche&quot;;// 此处的代码可以使用 carNamefunction myFunction() &#123; // 此处的代码也可以使用 carName&#125; 全局变量可以在 JavaScript 程序中的任何位置访问。 函数作用域局部（函数内）声明的变量拥有函数作用域。 实例12345678// 此处的代码不可以使用 carNamefunction myFunction() &#123; var carName = &quot;porsche&quot;; // code here CAN use carName&#125;// 此处的代码不可以使用 carName 局部变量只能在它们被声明的函数内访问。 JavaScript 块作用域通过 var 关键词声明的变量没有块作用域。 在块 {} 内声明的变量可以从块之外进行访问。 实例1234&#123; var x = 10; &#125;// 此处可以使用 x 在 ES2015 之前，JavaScript 是没有块作用域的。 可以使用 let 关键词声明拥有块作用域的变量。 在块 {} 内声明的变量无法从块外访问： 实例1234&#123; let x = 10;&#125;// 此处不可以使用 x 重新声明变量使用 var 关键字重新声明变量会带来问题。 在块中重新声明变量也将重新声明块外的变量： 实例1234567var x = 10;// 此处 x 为 10&#123; var x = 6; // 此处 x 为 6&#125;// 此处 x 为 6 使用 let 关键字重新声明变量可以解决这个问题。 在块中重新声明变量不会重新声明块外的变量： 实例1234567var x = 10;// 此处 x 为 10&#123; let x = 6; // 此处 x 为 6&#125;// 此处 x 为 10 浏览器支持Internet Explorer 11 或更早的版本不完全支持 let 关键词。 下表定义了第一个完全支持 let 关键词的浏览器版本： Chrome 49 IE &#x2F; Edge 12 Firefox 44 Safari 11 Opera 36 2016 年 3 月 2015 年 7 月 2015 年 1 月 2017 年 9 月 2016 年 3 月 循环作用域在循环中使用 var： 实例12345var i = 7;for (var i = 0; i &lt; 10; i++) &#123; // 一些语句&#125;// 此处，i 为 10 在循环中使用 let： 实例12345let i = 7;for (let i = 0; i &lt; 10; i++) &#123; // 一些语句&#125;// 此处 i 为 7 在第一个例子中，在循环中使用的变量使用 var 重新声明了循环之外的变量。 在第二个例子中，在循环中使用的变量使用 let 并没有重新声明循环外的变量。 如果在循环中用 let 声明了变量 i，那么只有在循环内，变量 i 才是可见的。 函数作用域在函数内声明变量时，使用 var 和 let 很相似。 它们都有函数作用域： 123456function myFunction() &#123; var carName = &quot;porsche&quot;; // 函数作用域&#125;function myFunction() &#123; let carName = &quot;porsche&quot;; // 函数作用域&#125; 全局作用域如果在块外声明声明，那么 var 和 let 也很相似。 它们都拥有全局作用域： 12var x = 10; // 全局作用域let y = 6; // 全局作用域 HTML 中的全局变量使用 JavaScript 的情况下，全局作用域是 JavaScript 环境。 在 HTML 中，全局作用域是 window 对象。 通过 var 关键词定义的全局变量属于 window 对象： 实例12var carName = &quot;porsche&quot;;// 此处的代码可使用 window.carName 通过 let 关键词定义的全局变量不属于 window 对象： 实例12let carName = &quot;porsche&quot;;// 此处的代码不可使用 window.carName 重新声明允许在程序的任何位置使用 var 重新声明 JavaScript 变量： 实例1234567var x = 10;// 现在，x 为 10 var x = 6;// 现在，x 为 6 在相同的作用域，或在相同的块中，通过 let 重新声明一个 var 变量是不允许的： 实例1234567var x = 10; // 允许let x = 6; // 不允许&#123; var x = 10; // 允许 let x = 6; // 不允许&#125; 在相同的作用域，或在相同的块中，通过 let 重新声明一个 let 变量是不允许的： 实例1234567let x = 10; // 允许let x = 6; // 不允许&#123; let x = 10; // 允许 let x = 6; // 不允许&#125; 在相同的作用域，或在相同的块中，通过 var 重新声明一个 let 变量是不允许的： 实例1234567let x = 10; // 允许var x = 6; // 不允许&#123; let x = 10; // 允许 var x = 6; // 不允许&#125; 在不同的作用域或块中，通过 let 重新声明变量是允许的： 实例123456789let x = 6; // 允许&#123; let x = 7; // 允许&#125;&#123; let x = 8; // 允许&#125; 提升通过 var 声明的变量会提升到顶端。如果您不了解什么是提升（Hoisting），请学习我们的提升这一章。 您可以在声明变量之前就使用它： 实例12// 在此处，您可以使用 carNamevar carName; 通过 let 定义的变量不会被提升到顶端。 在声明 let 变量之前就使用它会导致 ReferenceError。 变量从块的开头一直处于“暂时死区”，直到声明为止： 实例12// 在此处，您不可以使用 carNamelet carName;","tags":["JavaScript"],"categories":["Language"]},{"title":"06_JavaScript_变量","path":"/posts/3dba9301.html","content":"JavaScript 变量JavaScript 变量是存储数据值的容器。 在本例中，x、y 和 z 是变量： 实例123var x = 7;var y = 8;var z = x + y; 从上例中，您可获得： x 存储值 7 y 存储值 8 z 存储值 15 类似代数在本例中，price1、price2 以及 total 是变量： 实例1234var price1 = 7;var price2 = 8;var price3 = 12;var total = price1 + price2 + price3; 在编程中，类似代数，我们使用变量（比如 price1）来存放值。 在编程中，类似代数，我们在表达式中使用变量（total &#x3D; price1 + price2）。 从上例中，您可以算出 total 的值是 15。 提示：JavaScript 变量是存储数据值的容器。 JavaScript 标识符所有 JavaScript 变量必须以唯一的名称的标识。 这些唯一的名称称为标识符。 标识符可以是短名称（比如 x 和 y），或者更具描述性的名称（age、sum、totalVolume）。 构造变量名称（唯一标识符）的通用规则是： 名称可包含字母、数字、下划线和美元符号 名称必须以字母开头 名称也可以 $ 和 _ 开头（但是在本教程中我们不会这么做） 名称对大小写敏感（y 和 Y 是不同的变量） 保留字（比如 JavaScript 的关键词）无法用作变量名称 提示：JavaScript 标识符对大小写敏感。 赋值运算符在 JavaScript 中，等号（=）是赋值运算符，而不是“等于”运算符。 这一点与代数不同。下面的代码在代数中是不合理的： 1x = x + 5 然而在 JavaScript 中，它非常合理：把 x + 5 的值赋给 x。 （计算 x + 5 的值并把结果放入 x 中。x 的值递增 5。） 注释：JavaScript 中的“等于”运算符是 ==。 JavaScript 数据类型JavaScript 变量可存放数值，比如 100，以及文本值，比如 “Bill Gates”。 在编程中，文本值被称为字符串。 JavaScript 可处理多种数据类型，但是现在，我们只关注数值和字符串值。 字符串被包围在双引号或单引号中。数值不用引号。 如果把数值放在引号中，会被视作文本字符串。 实例123var pi = 3.14;var person = &quot;Bill Gates&quot;;var answer = &#x27;How are you!&#x27;; 声明（创建） JavaScript 变量在 JavaScript 中创建变量被称为“声明”变量。 您可以通过 var 关键词来声明 JavaScript 变量： 1var carName; 声明之后，变量是没有值的。（技术上，它的值是 undefined。） 如需赋值给变量，请使用等号： 1carName = &quot;porsche&quot;; 您可以在声明变量时向它赋值： 1var carName = &quot;porsche&quot;; 在上面的例子中，我们创建了名为 carName 的变量，并向其赋值 “porsche”。 然后，我们在 id&#x3D;”demo” 的 HTML 段落中“输出”该值： 实例123456&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;var carName = &quot;porsche&quot;;document.getElementById(&quot;demo&quot;).innerHTML = carName; &lt;/script&gt; 提示：在脚本的开头声明所有变量是个好习惯！ 一条语句，多个变量您可以在一条语句中声明许多变量。 以 var 作为语句的开头，并以逗号分隔变量： 1var person = &quot;Bill Gates&quot;, carName = &quot;porsche&quot;, price = 15000; 声明可横跨多行： 123var person = &quot;Bill Gates&quot;,carName = &quot;porsche&quot;,price = 15000; Value &#x3D; undefined在计算机程序中，被声明的变量经常是不带值的。值可以是需被计算的内容，或是之后被提供的数据，比如数据输入。 不带有值的变量，它的值将是 undefined。 变量 carName 在这条语句执行后的值是 undefined： 实例1var carName; 重复声明 JavaScript 变量如果再次声明某个 JavaScript 变量，将不会丢它的值。 在这两条语句执行后，变量 carName 的值仍然是 “porsche”： 实例12var carName = &quot;porsche&quot;;var carName; JavaScript 算术与代数类似，您能够通过 JavaScript 变量进行算术运算，使用 = 和 + 之类的运算符： 实例1var x = 3 + 5 + 8; 字符串也可以使用加号，但是字符串将被级联： 实例1var x = &quot;Bill&quot; + &quot; &quot; + &quot;Gates&quot;; 还可以试试这个： 实例1var x = &quot;8&quot; + 3 + 5; 提示：如果把要给数值放入引号中，其余数值会被视作字符串并被级联。 现在试试这个： 实例1var x = 3 + 5 + &quot;8&quot;;","tags":["JavaScript"],"categories":["Language"]},{"title":"05_JavaScript_注释","path":"/posts/fce83eaf.html","content":"JavaScript 注释用于解释 JavaScript 代码，增强其可读性。 JavaScript 注释也可以用于在测试替代代码时阻止执行。 单行注释单行注释以 // 开头。 任何位于 // 与行末之间的文本都会被 JavaScript 忽略（不会执行）。 本例在每条代码行之前使用单行注释： 实例1234// 改变标题： document.getElementById(&quot;myH&quot;).innerHTML = &quot;我的第一张页面&quot;;// 改变段落： document.getElementById(&quot;myP&quot;).innerHTML = &quot;我的第一个段落。&quot;; 本例在每行结尾处使用了单行注释来解释代码： 实例12var x = 5; // 声明 x，为其赋值 5var y = x + 2; // 声明 y，为其赋值 x + 2 多行注释多行注释以 /* 开头，以 */ 结尾。 任何位于 /* 和 */ 之间的文本都会被 JavaScript 忽略。 本例使用多行注释（注释块）来解释代码： 实例12345678/* 下面的代码会改变 网页中 id = &quot;myH&quot; 的标题 以及 id = &quot;myP&quot; 的段落：*/document.getElementById(&quot;myH&quot;).innerHTML = &quot;我的第一张页面&quot;;document.getElementById(&quot;myP&quot;).innerHTML = &quot;我的第一个段落。&quot;; 注释：使用单行注释最为常见。 提示：注释块常用于官方声明。 使用注释来阻止执行使用注释来防止代码执行很适合代码测试。 在代码行之前添加 // 会把可执行的代码行更改为注释。 本例使用 // 来阻止代码行的执行： 实例12//document.getElementById(&quot;myH&quot;).innerHTML = &quot;我的第一张页面&quot;;document.getElementById(&quot;myP&quot;).innerHTML = &quot;我的第一个段落。&quot;; 本例使用注释块来阻止多行代码的执行： 实例1234/*document.getElementById(&quot;myH&quot;).innerHTML = &quot;我的第一张页面&quot;;document.getElementById(&quot;myP&quot;).innerHTML = &quot;我的第一个段落。&quot;;*/","tags":["JavaScript"],"categories":["Language"]},{"title":"03_JavaScript_语句","path":"/posts/a3e29048.html","content":"在 HTML 中，JavaScript 语句是由 web 浏览器“执行”的“指令”。 实例1234var x, y, z;\t// 语句 1x = 22; // 语句 2y = 11; // 语句 3z = x + y;\t// 语句 4 JavaScript 程序计算机程序是由计算机“执行”的一系列“指令”。 在编程语言中，这些编程指令被称为语句。 JavaScript 程序就是一系列的编程语句。 注释：在 HTML 中，JavaScript 程序由 web 浏览器执行。 JavaScript 语句JavaScript 语句由以下构成： 值、运算符、表达式、关键词和注释。 这条语句告诉浏览器在 id&#x3D;”demo” 的 HTML 元素中输出 “Hello Kitty.”： 实例1document.getElementById(&quot;demo&quot;).innerHTML = &quot;Hello Kitty.&quot;; 大多数 JavaScript 程序都包含许多 JavaScript 语句。 这些语句会按照它们被编写的顺序逐一执行。 注释：JavaScript 程序（以及 JavaScript 语句）常被称为 JavaScript 代码。 分号 ;分号分隔 JavaScript 语句。 请在每条可执行的语句之后添加分号： 123a = 5;b = 6;c = a + b; 如果有分号分隔，允许在同一行写多条语句： 1a = 5; b = 6; c = a + b; 您可能在网上看到不带分号的例子。 提示：以分号结束语句不是必需的，但我们仍然强烈建议您这么做。 JavaScript 空白字符JavaScript 会忽略多个空格。您可以向脚本添加空格，以增强可读性。 下面这两行是相等的： 12var person = &quot;Bill&quot;;var person=&quot;Bill&quot;; 在运算符旁边（ &#x3D; + - * &#x2F; ）添加空格是个好习惯： 1var x = y + z; JavaScript 行长度和折行为了达到最佳的可读性，程序员们常常喜欢把代码行控制在 80 个字符以内。 如果 JavaScript 语句太长，对其进行折行的最佳位置是某个运算符： 实例12document.getElementById(&quot;demo&quot;).innerHTML = &quot;Hello Kitty.&quot;; JavaScript 代码块JavaScript 语句可以用花括号（&#123;…&#125;）组合在代码块中。 代码块的作用是定义一同执行的语句。 您会在 JavaScript 中看到成块组合在一起的语句： 实例1234function myFunction() &#123; document.getElementById(&quot;demo&quot;).innerHTML = &quot;Hello Kitty.&quot;; document.getElementById(&quot;myDIV&quot;).innerHTML = &quot;How are you?&quot;;&#125; 注释：在本教程中我们为代码块用了 4 个空格的缩进。 提示：您将稍后在本教程中学到更多有关函数的内容。 JavaScript 关键词JavaScript 语句常常通过某个关键词来标识需要执行的 JavaScript 动作。 下面的表格列出了一部分将在教程中学到的关键词： 关键词 描述 break 终止 switch 或循环。 continue 跳出循环并在顶端开始。 debugger 停止执行 JavaScript，并调用调试函数（如果可用）。 do … while 执行语句块，并在条件为真时重复代码块。 for 标记需被执行的语句块，只要条件为真。 function 声明函数。 if … else 标记需被执行的语句块，根据某个条件。 return 退出函数。 switch 标记需被执行的语句块，根据不同的情况。 try … catch 对语句块实现错误处理。 var 声明变量。 注释：JavaScript 关键词指的是保留的单词。保留词无法用作变量名。","tags":["JavaScript"],"categories":["Language"]},{"title":"02_JavaScript_语法输出","path":"/posts/c8ca0c16.html","content":"JavaScript 不提供任何内建的打印或显示函数。 JavaScript 显示方案JavaScript 能够以不同方式“显示”数据： 使用 window.alert() 写入警告框 使用 document.write() 写入 HTML 输出 使用 innerHTML 写入 HTML 元素 使用 console.log() 写入浏览器控制台 使用 innerHTML如需访问 HTML 元素，JavaScript 可使用 document.getElementById(id) 方法。 id 属性定义 HTML 元素。innerHTML 属性定义 HTML 内容： 实例12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;我的第一张网页&lt;/h1&gt;&lt;p&gt;我的第一个段落&lt;/p&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt; document.getElementById(&quot;demo&quot;).innerHTML = 5 + 6;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 提示：更改 HTML 元素的 innerHTML 属性是在 HTML 中显示数据的常用方法。 使用 document.write()出于测试目的，使用 document.write() 比较方便： 实例1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;我的第一张网页&lt;/h1&gt;&lt;p&gt;我的第一个段落&lt;/p&gt;&lt;script&gt;document.write(5 + 6);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意：在 HTML 文档完全加载后使用 document.write() 将删除所有已有的 HTML ： 实例123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;我的第一张网页&lt;/h1&gt;&lt;p&gt;我的第一个段落&lt;/p&gt;&lt;button onclick=&quot;document.write(5 + 6)&quot;&gt;试一试&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 提示：document.write() 方法仅用于测试。 使用 window.alert()您能够使用警告框来显示数据： 实例1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;我的第一张网页&lt;/h1&gt;&lt;p&gt;我的第一个段落&lt;/p&gt;&lt;script&gt;window.alert(5 + 6);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用 console.log()在浏览器中，您可使用 console.log() 方法来显示数据。 请通过 F12 来激活浏览器控制台，并在菜单中选择“控制台”。 实例1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;我的第一张网页&lt;/h1&gt;&lt;p&gt;我的第一个段落&lt;/p&gt;&lt;script&gt;console.log(5 + 6);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":["JavaScript"],"categories":["Language"]},{"title":"01_JavaScript_使用","path":"/posts/94a76e7d.html","content":"标签在 HTML 中，JavaScript 代码必须位于 &lt;script&gt; 与 &lt;/script&gt; 标签之间。 实例123&lt;script&gt;document.getElementById(&quot;demo&quot;).innerHTML = &quot;我的第一段 JavaScript&quot;;&lt;/script&gt; 注释：旧的 JavaScript 例子也许会使用 type 属性：。 注释：type 属性不是必需的。JavaScript 是 HTML 中的默认脚本语言。 JavaScript 函数和事件JavaScript 函数是一种 JavaScript 代码块，它可以在调用时被执行。 例如，当发生事件时调用函数，比如当用户点击按钮时。 提示：您将在稍后的章节学到更多有关函数和事件的知识。 或 中的 JavaScript您能够在 HTML 文档中放置任意数量的脚本。 脚本可被放置与 HTML 页面的 &lt;body&gt; 或 &lt;head&gt; 部分中，或兼而有之。 中的 JavaScript在本例中，JavaScript 函数被放置于 HTML 页面的 &lt;head&gt; 部分。 该函数会在按钮被点击时调用： 实例123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script&gt;function myFunction() &#123; document.getElementById(&quot;demo&quot;).innerHTML = &quot;段落被更改。&quot;;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;一张网页&lt;/h1&gt;&lt;p id=&quot;demo&quot;&gt;一个段落&lt;/p&gt;&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;试一试&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 中的 JavaScript在本例中，JavaScript 函数被放置于 HTML 页面的 &lt;body&gt; 部分。 该函数会在按钮被点击时调用： 实例12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;h1&gt;A Web Page&lt;/h1&gt;&lt;p id=&quot;demo&quot;&gt;一个段落&lt;/p&gt;&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;试一试&lt;/button&gt;&lt;script&gt;function myFunction() &#123; document.getElementById(&quot;demo&quot;).innerHTML = &quot;段落被更改。&quot;;&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 提示：把脚本置于 &lt;body&gt; 元素的底部，可改善显示速度，因为脚本编译会拖慢显示。 外部脚本脚本可放置与外部文件中： 外部文件：myScript.js123function myFunction() &#123; document.getElementById(&quot;demo&quot;).innerHTML = &quot;段落被更改。&quot;;&#125; 外部脚本很实用，如果相同的脚本被用于许多不同的网页。 JavaScript 文件的文件扩展名是 .js。 如需使用外部脚本，请在 &lt;script&gt; 标签的 src (source) 属性中设置脚本的名称： 实例1&lt;script src=&quot;myScript.js&quot;&gt;&lt;/script&gt; 您可以在 &lt;head&gt; 或 &lt;body&gt; 中放置外部脚本引用。 该脚本的表现与它被置于 &lt;script&gt; 标签中是一样的。 注释：外部脚本不能包含 &lt;script&gt; 标签。 外部 JavaScript 的优势在外部文件中放置脚本有如下优势： 分离了 HTML 和代码 使 HTML 和 JavaScript 更易于阅读和维护 已缓存的 JavaScript 文件可加速页面加载 如需向一张页面添加多个脚本文件 - 请使用多个 script 标签： 实例12&lt;script src=&quot;myScript1.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;myScript2.js&quot;&gt;&lt;/script&gt; 外部引用可通过完整的 URL 或相对于当前网页的路径引用外部脚本： 本例使用完整的 URL 来链接至脚本： 实例1&lt;script src=&quot;https://www.w3school.com.cn/js/myScript1.js&quot;&gt;&lt;/script&gt; 本例使用了位于当前网站上指定文件夹中的脚本： 实例1&lt;script src=&quot;/js/myScript1.js&quot;&gt;&lt;/script&gt; 本例链接了与当前页面相同文件夹的脚本： 实例1&lt;script src=&quot;myScript1.js&quot;&gt;&lt;/script&gt;","tags":["JavaScript"],"categories":["Language"]},{"title":"12_NumPy_数组搜索","path":"/posts/12e50e0f.html","content":"搜索数组您可以在数组中搜索（检索）某个值，然后返回获得匹配的索引。 要搜索数组，请使用 where() 方法。 实例查找值为 4 的索引： 1234567import numpy as nparr = np.array([1, 2, 3, 4, 5, 4, 4])x = np.where(arr == 4)print(x) 上例会返回一个元组：(array([3, 5, 6],) 意思就是值 4 出现在索引 3、5 和 6。 实例查找值为偶数的索引： 1234567import numpy as nparr = np.array([1, 2, 3, 4, 5, 6, 7, 8])x = np.where(arr%2 == 0)print(x) 实例查找值为奇数的索引： 1234567import numpy as nparr = np.array([1, 2, 3, 4, 5, 6, 7, 8])x = np.where(arr%2 == 1)print(x) 搜索排序有一个名为 searchsorted() 的方法，该方法在数组中执行二进制搜索，并返回将在其中插入指定值以维持搜索顺序的索引。 假定 searchsorted() 方法用于排序数组。 实例查找应在其中插入值 7 的索引： 1234567import numpy as nparr = np.array([6, 7, 8, 9])x = np.searchsorted(arr, 7)print(x) 例子解释：应该在索引 1 上插入数字 7，以保持排序顺序。 该方法从左侧开始搜索，并返回第一个索引，其中数字 7 不再大于下一个值。 从右侧搜索默认情况下，返回最左边的索引，但是我们可以给定 side&#x3D;’right’，以返回最右边的索引。 实例从右边开始查找应该插入值 7 的索引： 1234567import numpy as nparr = np.array([6, 7, 8, 9])x = np.searchsorted(arr, 7, side=&#x27;right&#x27;)print(x) 例子解释：应该在索引 2 上插入数字 7，以保持排序顺序。 该方法从右边开始搜索，并返回第一个索引，其中数字 7 不再小于下一个值。 多个值要搜索多个值，请使用拥有指定值的数组。 实例查找应在其中插入值 2、4 和 6 的索引： 1234567import numpy as nparr = np.array([1, 3, 5, 7])x = np.searchsorted(arr, [2, 4, 6])print(x) 返回值是一个数组：[1 2 3] 包含三个索引，其中将在原始数组中插入 2、4、6 以维持顺序。","tags":["Python","NumPy"],"categories":["Language"]},{"title":"11_NumPy_数组拆分","path":"/posts/d9ac1bed.html","content":"拆分 NumPy 数组拆分是连接的反向操作。 连接（Joining）是将多个数组合并为一个，拆分（Spliting）将一个数组拆分为多个。 我们使用 array_split() 分割数组，将要分割的数组和分割数传递给它。 实例将数组分为 3 部分： 1234567import numpy as nparr = np.array([1, 2, 3, 4, 5, 6])newarr = np.array_split(arr, 3)print(newarr) 注释：返回值是一个包含三个数组的数组。 如果数组中的元素少于要求的数量，它将从末尾进行相应调整。 实例将数组分为 4 部分： 1234567import numpy as nparr = np.array([1, 2, 3, 4, 5, 6])newarr = np.array_split(arr, 4)print(newarr) 提示：我们也有 split() 方法可用，但是当源数组中的元素较少用于拆分时，它将不会调整元素，如上例那样，array_split() 正常工作，但 split() 会失败。 拆分为数组array_split() 方法的返回值是一个包含每个分割的数组。 如果将一个数组拆分为 3 个数组，则可以像使用任何数组元素一样从结果中访问它们： 实例访问拆分的数组： 123456789import numpy as nparr = np.array([1, 2, 3, 4, 5, 6])newarr = np.array_split(arr, 3)print(newarr[0])print(newarr[1])print(newarr[2]) 分割二维数组拆分二维数组时，请使用相同的语法。 使用 array_split() 方法，传入要分割的数组和想要分割的数目。 实例把这个 2-D 拆分为三个 2-D 数组。 1234567import numpy as nparr = np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]])newarr = np.array_split(arr, 3)print(newarr) 上例返回三个 2-D 数组。 让我们看另一个例子，这次 2-D 数组中的每个元素包含 3 个元素。 实例把这个 2-D 拆分为三个 2-D 数组。 1234567import numpy as nparr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18]])newarr = np.array_split(arr, 3)print(newarr) 上例返回三个 2-D 数组。 此外，您可以指定要进行拆分的轴。 下面的例子还返回三个 2-D 数组，但它们沿行 (axis&#x3D;1) 分割。 实例沿行把这个 2-D 拆分为三个 2-D 数组。 1234567import numpy as nparr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18]])newarr = np.array_split(arr, 3, axis=1)print(newarr) 实例使用 hsplit() 方法将 2-D 数组沿着行分成三个 2-D 数组。 1234567import numpy as nparr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18]])newarr = np.hsplit(arr, 3)print(newarr) 提示：vsplit() 和 dsplit() 可以使用与 vstack() 和 dstack() 类似的替代方法。","tags":["Python","NumPy"],"categories":["Language"]},{"title":"10_NumPy_数组连接","path":"/posts/b1b64840.html","content":"连接 NumPy 数组连接意味着将两个或多个数组的内容放在单个数组中。 在 SQL 中，我们基于键来连接表，而在 NumPy 中，我们按轴连接数组。 我们传递了一系列要与轴一起连接到 concatenate() 函数的数组。如果未显式传递轴，则将其视为 0。 实例连接两个数组： 123456789import numpy as nparr1 = np.array([1, 2, 3])arr2 = np.array([4, 5, 6])arr = np.concatenate((arr1, arr2))print(arr) 实例沿着行 (axis&#x3D;1) 连接两个 2-D 数组： 123456789import numpy as nparr1 = np.array([[1, 2], [3, 4]])arr2 = np.array([[5, 6], [7, 8]])arr = np.concatenate((arr1, arr2), axis=1)print(arr) 使用堆栈函数连接数组堆栈与级联相同，唯一的不同是堆栈是沿着新轴完成的。 我们可以沿着第二个轴连接两个一维数组，这将导致它们彼此重叠，即，堆叠（stacking）。 我们传递了一系列要与轴一起连接到 concatenate() 方法的数组。如果未显式传递轴，则将其视为 0。 实例123456789import numpy as nparr1 = np.array([1, 2, 3])arr2 = np.array([4, 5, 6])arr = np.stack((arr1, arr2), axis=1)print(arr) 沿行堆叠NumPy 提供了一个辅助函数：hstack() 沿行堆叠。 实例123456789import numpy as nparr1 = np.array([1, 2, 3])arr2 = np.array([4, 5, 6])arr = np.hstack((arr1, arr2))print(arr) 沿列堆叠NumPy 提供了一个辅助函数：vstack() 沿列堆叠。 实例123456789import numpy as nparr1 = np.array([1, 2, 3])arr2 = np.array([4, 5, 6])arr = np.vstack((arr1, arr2))print(arr) 沿高度堆叠（深度）NumPy 提供了一个辅助函数：dstack() 沿高度堆叠，该高度与深度相同。 实例123456789import numpy as nparr1 = np.array([1, 2, 3])arr2 = np.array([4, 5, 6])arr = np.dstack((arr1, arr2))print(arr)","tags":["Python","NumPy"],"categories":["Language"]},{"title":"09_NumPy_数组迭代","path":"/posts/7c98c288.html","content":"数组迭代迭代意味着逐一遍历元素。 当我们在 numpy 中处理多维数组时，可以使用 python 的基本 for 循环来完成此操作。 如果我们对 1-D 数组进行迭代，它将逐一遍历每个元素。 实例迭代以下一维数组的元素： 123456import numpy as nparr = np.array([1, 2, 3])for x in arr: print(x) 迭代 2-D 数组在 2-D 数组中，它将遍历所有行。 实例迭代以下二维数组的元素： 123456import numpy as nparr = np.array([[1, 2, 3], [4, 5, 6]])for x in arr: print(x) 如果我们迭代一个 n-D 数组，它将逐一遍历第 n-1 维。 如需返回实际值、标量，我们必须迭代每个维中的数组。 实例迭代 2-D 数组的每个标量元素： 1234567import numpy as nparr = np.array([[1, 2, 3], [4, 5, 6]])for x in arr: for y in x: print(y) 迭代 3-D 数组在 3-D 数组中，它将遍历所有 2-D 数组。 实例迭代以下 3-D 数组的元素： 123456import numpy as nparr = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])for x in arr: print(x) 要返回实际值、标量，我们必须迭代每个维中的数组。 实例迭代到标量： 12345678import numpy as nparr = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])for x in arr: for y in x: for z in y: print(z) 使用 nditer() 迭代数组函数 nditer() 是一个辅助函数，从非常基本的迭代到非常高级的迭代都可以使用。它解决了我们在迭代中面临的一些基本问题，让我们通过例子进行介绍。 迭代每个标量元素在基本的 for 循环中，迭代遍历数组的每个标量，我们需要使用 n 个 for 循环，对于具有高维数的数组可能很难编写。 实例遍历以下 3-D 数组： 123456import numpy as nparr = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])for x in np.nditer(arr): print(x) 迭代不同数据类型的数组我们可以使用 op_dtypes 参数，并传递期望的数据类型，以在迭代时更改元素的数据类型。 NumPy 不会就地更改元素的数据类型（元素位于数组中），因此它需要一些其他空间来执行此操作，该额外空间称为 buffer，为了在 nditer() 中启用它，我们传参 flags&#x3D;[‘buffered’]。 实例以字符串形式遍历数组： 123456import numpy as nparr = np.array([1, 2, 3])for x in np.nditer(arr, flags=[&#x27;buffered&#x27;], op_dtypes=[&#x27;S&#x27;]): print(x) 以不同的步长迭代我们可以使用过滤，然后进行迭代。 实例每遍历 2D 数组的一个标量元素，跳过 1 个元素： 123456import numpy as nparr = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])for x in np.nditer(arr[:, ::2]): print(x) 使用 ndenumerate() 进行枚举迭代枚举是指逐一提及事物的序号。 有时，我们在迭代时需要元素的相应索引，对于这些用例，可以使用 ndenumerate() 方法。 实例枚举以下 1D 数组元素： 123456import numpy as nparr = np.array([1, 2, 3])for idx, x in np.ndenumerate(arr): print(idx, x) 实例枚举以下 2D 数组元素： 123456import numpy as nparr = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])for idx, x in np.ndenumerate(arr): print(idx, x)","tags":["Python","NumPy"],"categories":["Language"]},{"title":"08_NumPy_数组重塑","path":"/posts/9af8b77e.html","content":"数组重塑重塑意味着更改数组的形状。 数组的形状是每个维中元素的数量。 通过重塑，我们可以添加或删除维度或更改每个维度中的元素数量。 从 1-D 重塑为 2-D实例将以下具有 12 个元素的 1-D 数组转换为 2-D 数组。 最外面的维度将有 4 个数组，每个数组包含 3 个元素： 1234567import numpy as nparr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])newarr = arr.reshape(4, 3)print(newarr) 从 1-D 重塑为 3-D实例将以下具有 12 个元素的 1-D 数组转换为 3-D 数组。 最外面的维度将具有 2 个数组，其中包含 3 个数组，每个数组包含 2 个元素： 1234567import numpy as nparr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])newarr = arr.reshape(2, 3, 2)print(newarr) 我们可以重塑成任何形状吗？是的，只要重塑所需的元素在两种形状中均相等。 我们可以将 8 元素 1D 数组重塑为 2 行 2D 数组中的 4 个元素，但是我们不能将其重塑为 3 元素 3 行 2D 数组，因为这将需要 3x3 &#x3D; 9 个元素。 实例尝试将具有 8 个元素的 1D 数组转换为每个维度中具有 3 个元素的 2D 数组（将产生错误）： 1234567import numpy as nparr = np.array([1, 2, 3, 4, 5, 6, 7, 8])newarr = arr.reshape(3, 3)print(newarr) 返回副本还是视图？实例检查返回的数组是副本还是视图： 12345import numpy as nparr = np.array([1, 2, 3, 4, 5, 6, 7, 8])print(arr.reshape(2, 4).base) 上面的例子返回原始数组，因此它是一个视图。 未知的维您可以使用一个“未知”维度。 这意味着您不必在 reshape 方法中为维度之一指定确切的数字。 传递 -1 作为值，NumPy 将为您计算该数字。 实例将 8 个元素的 1D 数组转换为 2x2 元素的 3D 数组： 1234567import numpy as nparr = np.array([1, 2, 3, 4, 5, 6, 7, 8])newarr = arr.reshape(2, 2, -1)print(newarr) 注释：我们不能将 -1 传递给一个以上的维度。 展平数组展平数组（Flattening the arrays）是指将多维数组转换为 1D 数组。 我们可以使用 reshape(-1) 来做到这一点。 实例把数组转换为 1D 数组： 1234567import numpy as nparr = np.array([[1, 2, 3], [4, 5, 6]])newarr = arr.reshape(-1)print(newarr) 注释：有很多功能可以更改 numpy flatten、ravel 中数组形状，还可以重新排列元素 rot90、flip、fliplr、flipud 等。这些功能属于 numpy 的中级至高级部分。","tags":["Python","NumPy"],"categories":["Language"]},{"title":"07_NumPy_数组形状","path":"/posts/529b8407.html","content":"数组的形状数组的形状是每个维中元素的数量。 获取数组的形状NumPy 数组有一个名为 shape 的属性，该属性返回一个元组，每个索引具有相应元素的数量。 实例打印 2-D 数组的形状： 12345import numpy as nparr = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])print(arr.shape) 上面的例子返回 (2, 4)，这意味着该数组有 2 个维，每个维有 4 个元素。 实例利用 ndmin 使用值 1,2,3,4 的向量创建有 5 个维度的数组，并验证最后一个维度的值为 4： 123456import numpy as nparr = np.array([1, 2, 3, 4], ndmin=5)print(arr)print(&#x27;shape of array :&#x27;, arr.shape) 元组的形状代表什么？每个索引处的整数表明相应维度拥有的元素数量。 上例中的索引 4，我们的值为 4，因此可以说第 5 个 ( 4 + 1 th) 维度有 4 个元素。","tags":["Python","NumPy"],"categories":["Language"]},{"title":"05_NumPy_数据类型","path":"/posts/772ac1d5.html","content":"Python 中的数据类型默认情况下，Python 拥有以下数据类型： strings - 用于表示文本数据，文本用引号引起来。例如 “ABCD”。 integer - 用于表示整数。例如 -1, -2, -3。 float - 用于表示实数。例如 1.2, 42.42。 boolean - 用于表示 True 或 False。 complex - 用于表示复平面中的数字。例如 1.0 + 2.0j，1.5 + 2.5j。 NumPy 中的数据类型NumPy 有一些额外的数据类型，并通过一个字符引用数据类型，例如 i 代表整数，u 代表无符号整数等。 以下是 NumPy 中所有数据类型的列表以及用于表示它们的字符。 i - 整数 b - 布尔 u - 无符号整数 f - 浮点 c - 复合浮点数 m - timedelta M - datetime O - 对象 S - 字符串 U - unicode 字符串 V - 固定的其他类型的内存块 ( void ) 检查数组的数据类型NumPy 数组对象有一个名为 dtype 的属性，该属性返回数组的数据类型： 实例获取数组对象的数据类型： 12345import numpy as nparr = np.array([1, 2, 3, 4])print(arr.dtype) 实例获取包含字符串的数组的数据类型： 12345import numpy as nparr = np.array([&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;cherry&#x27;])print(arr.dtype) 用已定义的数据类型创建数组我们使用 array() 函数来创建数组，该函数可以使用可选参数：dtype，它允许我们定义数组元素的预期数据类型： 实例用数据类型字符串创建数组： 123456import numpy as nparr = np.array([1, 2, 3, 4], dtype=&#x27;S&#x27;)print(arr)print(arr.dtype) 对于 i、u、f、S 和 U，我们也可以定义大小。 实例创建数据类型为 4 字节整数的数组： 123456import numpy as nparr = np.array([1, 2, 3, 4], dtype=&#x27;i4&#x27;)print(arr)print(arr.dtype) 假如值无法转换会怎样？如果给出了不能强制转换元素的类型，则 NumPy 将引发 ValueError。 ValueError：在 Python 中，如果传递给函数的参数的类型是非预期或错误的，则会引发 ValueError。 实例无法将非整数字符串（比如 ‘a’）转换为整数（将引发错误）： 123import numpy as nparr = np.array([&#x27;a&#x27;, &#x27;2&#x27;, &#x27;3&#x27;], dtype=&#x27;i&#x27;) 转换已有数组的数据类型更改现有数组的数据类型的最佳方法，是使用 astype() 方法复制该数组。 astype() 函数创建数组的副本，并允许您将数据类型指定为参数。 数据类型可以使用字符串指定，例如 ‘f’ 表示浮点数，’i’ 表示整数等。或者您也可以直接使用数据类型，例如 float 表示浮点数，int 表示整数。 实例通过使用 ‘i’ 作为参数值，将数据类型从浮点数更改为整数： 12345678import numpy as nparr = np.array([1.1, 2.1, 3.1])newarr = arr.astype(&#x27;i&#x27;)print(newarr)print(newarr.dtype) 实例通过使用 int 作为参数值，将数据类型从浮点数更改为整数： 12345678import numpy as nparr = np.array([1.1, 2.1, 3.1])newarr = arr.astype(int)print(newarr)print(newarr.dtype) 实例将数据类型从整数更改为布尔值： 12345678import numpy as nparr = np.array([1, 0, 3])newarr = arr.astype(bool)print(newarr)print(newarr.dtype)","tags":["Python","NumPy"],"categories":["Language"]},{"title":"06_NumPy_数组副本_vs_视图","path":"/posts/9e67ac6a.html","content":"副本和视图之间的区别副本和数组视图之间的主要区别在于副本是一个新数组，而这个视图只是原始数组的视图。 副本拥有数据，对副本所做的任何更改都不会影响原始数组，对原始数组所做的任何更改也不会影响副本。 视图不拥有数据，对视图所做的任何更改都会影响原始数组，而对原始数组所做的任何更改都会影响视图。 副本：实例进行复制，更改原始数组并显示两个数组： 12345678import numpy as nparr = np.array([1, 2, 3, 4, 5])x = arr.copy()arr[0] = 61print(arr) print(x) 该副本不应受到对原始数组所做更改的影响。 视图：实例创建视图，更改原始数组，然后显示两个数组： 12345678import numpy as nparr = np.array([1, 2, 3, 4, 5])x = arr.view()arr[0] = 61print(arr) print(x) 视图应该受到对原始数组所做更改的影响。 在视图中进行更改： 实例创建视图，更改视图，并显示两个数组： 12345678import numpy as nparr = np.array([1, 2, 3, 4, 5])x = arr.view()x[0] = 31print(arr) print(x) 原始数组应该受到对视图所做更改的影响。 检查数组是否拥有数据如上所述，副本拥有数据，而视图不拥有数据，但是我们如何检查呢？ 每个 NumPy 数组都有一个属性 base，如果该数组拥有数据，则这个 base 属性返回 None。 否则，base 属性将引用原始对象。 实例打印 base 属性的值以检查数组是否拥有自己的数据： 123456789import numpy as nparr = np.array([1, 2, 3, 4, 5])x = arr.copy()y = arr.view()print(x.base)print(y.base) 副本返回 None。 视图返回原始数组。","tags":["Python","NumPy"],"categories":["Language"]},{"title":"04_NumPy_数组裁切","path":"/posts/4c9745f6.html","content":"裁切数组python 中裁切的意思是将元素从一个给定的索引带到另一个给定的索引。 我们像这样传递切片而不是索引：[start：end]。 我们还可以定义步长，如下所示：[start：end：step]。 如果我们不传递 start，则将其视为 0。 如果我们不传递 end，则视为该维度内数组的长度。 如果我们不传递 step，则视为 1。 实例从下面的数组中裁切索引 1 到索引 5 的元素： 12345import numpy as nparr = np.array([1, 2, 3, 4, 5, 6, 7])print(arr[1:5]) 注释：结果包括了开始索引，但不包括结束索引。 实例裁切数组中索引 4 到结尾的元素： 12345import numpy as nparr = np.array([1, 2, 3, 4, 5, 6, 7])print(arr[4:]) 实例裁切从开头到索引 4（不包括）的元素： 12345import numpy as nparr = np.array([1, 2, 3, 4, 5, 6, 7])print(arr[:4]) 负裁切使用减号运算符从末尾开始引用索引： 实例从末尾开始的索引 3 到末尾开始的索引 1，对数组进行裁切： 12345import numpy as nparr = np.array([1, 2, 3, 4, 5, 6, 7])print(arr[-3:-1]) STEP请使用 step 值确定裁切的步长： 实例从索引 1 到索引 5，返回相隔的元素： 12345import numpy as nparr = np.array([1, 2, 3, 4, 5, 6, 7])print(arr[1:5:2]) 实例返回数组中相隔的元素： 12345import numpy as nparr = np.array([1, 2, 3, 4, 5, 6, 7])print(arr[::2]) 裁切 2-D 数组实例从第二个元素开始，对从索引 1 到索引 4（不包括）的元素进行切片： 12345import numpy as nparr = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])print(arr[1, 1:4]) 注释：请记得第二个元素的索引为 1。 实例从两个元素中返回索引 2： 12345import numpy as nparr = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])print(arr[0:2, 2]) 实例从两个元素裁切索引 1 到索引 4（不包括），这将返回一个 2-D 数组： 12345import numpy as nparr = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])print(arr[0:2, 1:4])","tags":["Python","NumPy"],"categories":["Language"]},{"title":"03_NumPy_数组索引","path":"/posts/7451984d.html","content":"访问数组元素数组索引等同于访问数组元素。 您可以通过引用其索引号来访问数组元素。 NumPy 数组中的索引以 0 开头，这意味着第一个元素的索引为 0，第二个元素的索引为 1，以此类推。 实例从以下数组中获取第一个元素： 12345import numpy as nparr = np.array([1, 2, 3, 4])print(arr[0]) 实例从以下数组中获取第二个元素： 12345import numpy as nparr = np.array([1, 2, 3, 4])print(arr[1]) 实例从以下数组中获取第三和第四个元素并将其相加： 12345import numpy as nparr = np.array([1, 2, 3, 4])print(arr[2] + arr[3]) 访问 2-D 数组要访问二维数组中的元素，我们可以使用逗号分隔的整数表示元素的维数和索引。 实例访问第一维中的第二个元素： 12345import numpy as nparr = np.array([[1,2,3,4,5], [6,7,8,9,10]])print(&#x27;2nd element on 1st dim: &#x27;, arr[0, 1]) 实例访问第二维中的第五个元素： 12345import numpy as nparr = np.array([[1,2,3,4,5], [6,7,8,9,10]])print(&#x27;5th element on 2nd dim: &#x27;, arr[1, 4]) 访问 3-D 数组要访问 3-D 数组中的元素，我们可以使用逗号分隔的整数来表示元素的维数和索引。 实例访问第一个数组的第二个数组的第三个元素： 12345import numpy as nparr = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])print(arr[0, 1, 2]) 例子解释arr[0, 1, 2] 打印值 6。 工作原理：第一个数字代表第一个维度，其中包含两个数组： [[1, 2, 3], [4, 5, 6]] 然后： [[7, 8, 9], [10, 11, 12]] 由于我们选择了 0，所以剩下第一个数组： [[1, 2, 3], [4, 5, 6]] 第二个数字代表第二维，它也包含两个数组： [1, 2, 3] 然后： [4, 5, 6] 因为我们选择了 1，所以剩下第二个数组： [4, 5, 6] 第三个数字代表第三维，其中包含三个值： 456 由于我们选择了 2，因此最终得到第三个值： 6 负索引使用负索引从尾开始访问数组。 实例打印第二个维中的的最后一个元素： 12345import numpy as nparr = np.array([[1,2,3,4,5], [6,7,8,9,10]])print(&#x27;Last element from 2nd dim: &#x27;, arr[1, -1])","tags":["Python","NumPy"],"categories":["Language"]},{"title":"02_NumPy_数组创建","path":"/posts/519c4b32.html","content":"创建 NumPy ndarray 对象NumPy 用于处理数组。 NumPy 中的数组对象称为 ndarray。 我们可以使用 array() 函数创建一个 NumPy ndarray 对象。 实例1234567import numpy as np arr = np.array([1, 2, 3, 4, 5])print(arr)print(type(arr)) type(): 这个内置的 Python 函数告诉我们传递给它的对象的类型。像上面的代码一样，它表明 arr 是 numpy.ndarray 类型。 要创建 ndarray，我们可以将列表、元组或任何类似数组的对象传递给 array() 方法，然后它将被转换为 ndarray： 实例使用元组创建 NumPy 数组： 12345import numpy as np arr = np.array((1, 2, 3, 4, 5))print(arr) 数组中的维数组中的维是数组深度（嵌套数组）的一个级别。 嵌套数组：指的是将数组作为元素的数组。 0-D 数组0-D 数组，或标量（Scalars），是数组中的元素。数组中的每个值都是一个 0-D 数组。 实例用值 61 创建 0-D 数组： 12345import numpy as nparr = np.array(61)print(arr) 1-D 数组其元素为 0-D 数组的数组，称为一维或 1-D 数组。 这是最常见和基础的数组。 实例创建包含值 1、2、3、4、5、6 的 1-D 数组： 12345import numpy as nparr = np.array([1, 2, 3, 4, 5, 6])print(arr) 2-D 数组其元素为 1-D 数组的数组，称为 2-D 数组。 它们通常用于表示矩阵或二阶张量。 NumPy 有一个专门用于矩阵运算的完整子模块 numpy.mat。 实例创建包含值 1、2、3 和 4、5、6 两个数组的 2-D 数组： 12345import numpy as nparr = np.array([[1, 2, 3], [4, 5, 6]])print(arr) 3-D 数组其元素为 2-D 数组的数组，称为 3-D 数组。 实例用两个 2-D 数组创建一个 3-D 数组，这两个数组均包含值 1、2、3 和 4、5、6 的两个数组： 12345import numpy as nparr = np.array([[[1, 2, 3], [4, 5, 6]], [[1, 2, 3], [4, 5, 6]]])print(arr) 检查维数？NumPy 数组提供了 ndim 属性，该属性返回一个整数，该整数会告诉我们数组有多少维。 实例检查数组有多少维： 1234567891011import numpy as npa = np.array(42)b = np.array([1, 2, 3, 4, 5])c = np.array([[1, 2, 3], [4, 5, 6]])d = np.array([[[1, 2, 3], [4, 5, 6]], [[1, 2, 3], [4, 5, 6]]])print(a.ndim) print(b.ndim) print(c.ndim) print(d.ndim) 更高维的数组数组可以拥有任意数量的维。 在创建数组时，可以使用 ndmin 参数定义维数。 实例创建一个有 5 个维度的数组，并验证它拥有 5 个维度： 123456import numpy as nparr = np.array([1, 2, 3, 4], ndmin=5)print(arr)print(&#x27;number of dimensions :&#x27;, arr.ndim) 在此数组中，最里面的维度（第 5 个 dim）有 4 个元素，第 4 个 dim 有 1 个元素作为向量，第 3 个 dim 具有 1 个元素是与向量的矩阵，第 2 个 dim 有 1 个元素是 3D 数组，而第 1 个 dim 有 1 个元素，该元素是 4D 数组。","tags":["Python","NumPy"],"categories":["Language"]},{"title":"01_NumPy入门","path":"/posts/fecd3090.html","content":"安装 NumPy如果您已经在系统上安装了 Python 和 PIP，那么安装 NumPy 非常容易。 请使用这条命令安装它： 1pip install numpy 如果此命令失败，请使用已经安装了 NumPy 的 python 发行版，例如 Anaconda、Spyder 等。 导入 NumPy安装 NumPy 后，通过添加 import 关键字将其导入您的应用程序： 1import numpy 现在，Numpy 已导入并可以使用。 实例12345import numpy arr = numpy.array([1, 2, 3, 4, 5]) print(arr) NumPy as npNumPy 通常以 np 别名导入。 别名：在 Python 中，别名是用于引用同一事物的替代名称。 请在导入时使用 as 关键字创建别名： 1import numpy as np 现在，可以将 NumPy 包称为 np 而不是 numpy。 实例12345import numpy as np arr = np.array([1, 2, 3, 4, 5]) print(arr) 检查 NumPy 版本版本字符串存储在 version 属性中。 实例123import numpy as npprint(np.__version__)","tags":["Python","NumPy"],"categories":["Language"]},{"title":"Python继承","path":"/posts/a880616a.html","content":"Python 继承继承允许我们定义继承另一个类的所有方法和属性的类。 父类是继承的类，也称为基类。 子类是从另一个类继承的类，也称为派生类。 创建父类任何类都可以是父类，因此语法与创建任何其他类相同： 实例创建一个名为 Person 的类，其中包含 firstname 和 lastname 属性以及 printname 方法： 123456789101112class Person: def __init__(self, fname, lname): self.firstname = fname self.lastname = lname def printname(self): print(self.firstname, self.lastname)# 使用 Person 来创建对象，然后执行 printname 方法：x = Person(&quot;Bill&quot;, &quot;Gates&quot;)x.printname() 创建子类要创建从其他类继承功能的类，请在创建子类时将父类作为参数发送： 实例创建一个名为 Student 的类，它将从 Person 类继承属性和方法： 12class Student(Person): pass 注释：如果您不想向该类添加任何其他属性或方法，请使用 pass 关键字。 现在，Student 类拥有与 Person 类相同的属性和方法。 实例使用 Student 类创建一个对象，然后执行 printname 方法： 12x = Student(&quot;Elon&quot;, &quot;Musk&quot;)x.printname() 添加 init() 函数到目前为止，我们已经创建了一个子类，它继承了父类的属性和方法。 我们想要把 init() 函数添加到子类（而不是 pass 关键字）。 注释：每次使用类创建新对象时，都会自动调用 init() 函数。 实例为 Student 类添加 init() 函数： 123class Student(Person): def __init__(self, fname, lname): # 添加属性等 当您添加 init() 函数时，子类将不再继承父的 init() 函数。 注释：子的 init() 函数会覆盖对父的 init() 函数的继承。 如需保持父的 init() 函数的继承，请添加对父的 init() 函数的调用： 实例123class Student(Person): def __init__(self, fname, lname): Person.__init__(self, fname, lname) 现在，我们已经成功添加了 init() 函数，并保留了父类的继承，我们准备好在 init() 函数中添加功能了。 使用 super() 函数Python 还有一个 super() 函数，它会使子类从其父继承所有方法和属性： 实例123class Student(Person): def __init__(self, fname, lname): super().__init__(fname, lname) 通过使用 super() 函数，您不必使用父元素的名称，它将自动从其父元素继承方法和属性。 添加属性实例把名为 graduationyear 的属性添加到 Student 类： 1234class Student(Person): def __init__(self, fname, lname): super().__init__(fname, lname) self.graduationyear = 2019 在这例子中，2019 年应该是一个变量，并在创建 student 对象时传递到 Student 类。为此，请在 init() 函数中添加另一个参数： 实例添加 year 参数，并在创建对象时传递正确的年份： 123456class Student(Person): def __init__(self, fname, lname, year): super().__init__(fname, lname) self.graduationyear = yearx = Student(&quot;Elon&quot;, &quot;Musk&quot;, 2019) 添加方法实例把名为 welcome 的方法添加到 Student 类： 1234567class Student(Person): def __init__(self, fname, lname, year): super().__init__(fname, lname) self.graduationyear = year def welcome(self): print(&quot;Welcome&quot;, self.firstname, self.lastname, &quot;to the class of&quot;, self.graduationyear) 提示：如果您在子类中添加一个与父类中的函数同名的方法，则将覆盖父方法的继承。","tags":["Python"],"categories":["Language"]},{"title":"Python中的Lambda函数","path":"/posts/d414e35c.html","content":"lambda 函数是一种小的匿名函数。 lambda 函数可接受任意数量的参数，但只能有一个表达式。 语法1lambda arguments : expression 执行表达式并返回结果： 实例一个 lambda 函数，它把作为参数传入的数字加 10，然后打印结果： 12x = lambda a : a + 10print(x(5)) lambda 函数可接受任意数量的参数： 实例一个 lambda 函数，它把参数 a 与参数 b 相乘并打印结果： 12x = lambda a, b : a * bprint(x(5, 6)) 实例一个 lambda 函数，它把参数 a、b 和 c 相加并打印结果： 12x = lambda a, b, c : a + b + cprint(x(5, 6, 2)) 为何使用 Lambda 函数？当您把 lambda 用作另一个函数内的匿名函数时，会更好地展现 lambda 的强大能力。 假设您有一个带一个参数的函数定义，并且该参数将乘以未知数字： 12def myfunc(n): return lambda a : a * n 使用该函数定义来创建一个总是使所发送数字加倍的函数： 实例123456def myfunc(n): return lambda a : a * nmydoubler = myfunc(2)print(mydoubler(11)) 或者，使用相同的函数定义来创建一个总是使您发送的数字增加三倍的函数： 实例123456def myfunc(n): return lambda a : a * nmytripler = myfunc(3)print(mytripler(11)) 或者，在同一程序中使用相同的函数定义来生成两个函数： 实例12345678def myfunc(n): return lambda a : a * nmydoubler = myfunc(2)mytripler = myfunc(3)print(mydoubler(11)) print(mytripler(11)) 如果在短时间内需要匿名函数，请使用 lambda 函数。","tags":["Python"],"categories":["Language"]},{"title":"Pycharm快捷键","path":"/posts/7045fedc.html","content":"1、代码编辑快捷键 序号 快捷键 作用 1 CTRL+ALT+SPACE 快速导入任意类 2 CTRL+SHIFT+ENTER 代码补全 3 SHIFT+F1 查看外部文档 4 CTRL+Q 快速查找文档 5 CTRL+P 参数信息（在方法中调用的参数） 6 CTRL+MOUSEOVERCODE 基本信息 7 CTRL+F1 显示错误或警告的描述 8 CTRL+INSERT 生成代码 9 CTRL+O 重载方法 10 CTRL+ALT+T 包裹代码 11 CTRL+&#x2F; 单行注释 12 CTRL+SHIFT+&#x2F; 块注释 13 CTRL+W 逐步选择代码（块） 14 CTRL+SHIFT+W 逐步取消选择代码（块） 15 CTRL+SHIFT+[ 从当前位置选择到代码块的开始 16 CTRL+SHIFT+] 从当前位置选择到代码块的结束 17 ALT+ENTER 代码快速修正 18 CTRL+ALT+L 代码格式标准化 19 CTRL+ALT+O 最佳化导入 20 CTRL+ALT+I 自动缩进 21 TAB 代码向后缩进 23 SHIFT+TAB 代码向前取消缩进 24 CTRL+SHIFT+V 历史复制粘贴表 25 CTRL+D 复制当前代码行&#x2F;块 26 CTRL+Y 删除当前代码行&#x2F;块 27 CTRL+SHIFT+J 代码连接为一行 28 SHIFT+ENTER 开启新一行 28 CTRL+SHIFT+U 字母大写 29 CTRL+DELETE 向后逐渐删除 30 CTRL+BACKSPACE 向前逐渐删除 31 CTRL+NUMPAD+&#x2F;- 代码块展开&#x2F;折叠 32 CTRL+SHIFT+NUMPAD+ 所有代码块展开叠 33 CTRL+SHIFT+NUMPAD- 所有代码块折叠 34 CTRL+F4 关闭活动编辑窗口 2、搜索&#x2F;替换快捷键 序号 快捷键 作用 1 CTRL+F 查找 2 F3 查找下一个 3 SHIFT+F3 查找上一个 4 CTRL+R 替换 5 CTRL+SHIFT+F 指定路径下查找 6 CTRL+SHIFT+R 指定路径下替换 3、代码运行快捷键 序号 快捷键 作用 1 ALT+SHIFT+F10 选择程序文件并运行代码 2 ALT+SHIFT+F9 选择程序文件并调试代码 3 SHIFT+F10 运行代码 4 SHIFT+F9 调试代码 5 CTRL+SHIFT+F10 运行当前编辑区的程序文件 4、代码调试快捷键 序号 快捷键 作用 1 F8 单步 2 F7 单步（无函数时同F8） 3 SHIFT+F8 单步跳出 4 ALT+F9 运行到光标所在位置处 5 ALT+F8 测试语句 6 F9 重新运行程序 7 CTRL+F8 切换断点 8 CTRL+F8 查看断点 5、应用搜索快捷键 序号 快捷键 作用 1 ALT+F7 查找应用 2 CTRL+F7 在文件中查找应用 3 CTRL+SHIFT+F7 在文件中高亮应用 4 CTRL+ALT+F7 显示应用 6、代码重构快捷键 序号 快捷键 作用 1 F5 复制文件 2 F6 移动文件 3 SHIFT+F6 重命名 4 ALT+DELETE 安全删除 5 CTRL+F6 改变函数形式参数 6 CTRL+ALT+M 将代码提取为函数 7 CTRL+ALT+V 将代码提取为变量 8 CTRL+ALT+C 将代码提取为常数 9 CTRL+ALT+F 将代码提取为字段 10 CTRL+ALT+P 将代码提取为参数 7、动态模块快捷键 序号 快捷键 作用 1 CTRL+ALT+J 使用动态模板包裹 2 CTRL+J 插入动态模板 8、导航快捷键 序号 快捷键 作用 1 CTRL+N 进入类 2 CTRL+SHIFT+N 进入文件 3 CTRL+ALT+SHIFT+N 进入符号 4 CTRL+←← 进入上一个编辑位置 5 CTRL+→→ 进入下一个编辑位置 6 CTRL+→→ 进入下一个编辑位置 7 SHIFT+ESC 隐藏活动&#x2F;最后活动的窗口 8 CTRL+SHIFT+F4 关闭活动的运行&#x2F;消息&#x2F;查找等窗口 9 CTRL+G 显示光标所在行与列 10 CTRL+E 弹出最近打开的文件 11 CTRL+ALT+←&#x2F;→←&#x2F;→ 向前&#x2F;向后导航 12 CTRL+SHIFT+BACKSPACE 导航到最后编辑的位置 13 CTRL+B 跳转到声明部分 14 CTRL+CLICK(鼠标左键) 跳转到声明部分 15 CTRL+ALT+B 跳转到代码实施部分 16 CTRL+SHIFT+I 打开快速定义查找 16 CTRL+SHIFT+B 跳转到类型说明 17 CTRL+U 跳转超类&#x2F;方法 18 CTRL+↑↑ 跳转到上一个方法 19 CTRL+↓↓ 跳转到下一个方法 20 CTRL+[ 跳转到代码块的开头 21 CTRL+] 跳转到代码块的结尾 22 CTRL+F12 弹出文件结构 23 CTRL+H 弹出类层次结构 24 CTRL+SHIFT+H 弹出方法层次结构 25 CTRL+ALT+H 弹出调用层次结构 26 F2&#x2F;SHIFT+F2 下一个&#x2F;上一个错误 27 F4 查看源代码 28 ALT+HOME 显示导航栏 29 F2&#x2F;SHIFT+F2 下一个&#x2F;上一个错误 30 F11 增加书签 31 CTRL+F11 增加数字&#x2F;字母书签 32 CTRL+SHIFT+[1-9] 增加数字书签 33 SHIFT+F11 显示书签 9、通用快捷键 序号 快捷键 作用 1 ALT+[0-9] 打开相应的工具窗口 2 CTRL+ALT+Y 同步 3 CTRL+SHIFT+F12 最大化编辑器 4 ALT+SHIFT+F 添加到收藏夹 5 ALT+SHIFT+I 使用当前配置文件检查当前文件 6 CTRL+ALT+S 快速出现设置对话框 7 CTRL+SHIFT+A 查找并调试编辑器的功能 8 ALT+TAB 在选项卡和工具窗口之间切换","tags":["Python","Pycharm","IDEA"],"categories":["Language"]},{"title":"关于","path":"/about/index.html","content":"没啥好说的 自用笔记罢了Our Goal, Is The Sea And The Stars! I’m not afraid to walk at night, I’m afraid to stand in the crowd. About me别人都说我烂泥扶不上墙 可我为什么要上墙 躺地上不舒服吗? ………"},{"title":"留言板","path":"/comments/index.html","content":"🙆‍♀️社会主义核心价值观富强 民主 文明 和谐 自由 平等 公正 法治 爱国 敬业 诚信 友善 📢留言须知对博客有任何疑问欢迎留言 留言建议留下你的昵称与邮箱，方便及时收到博主回复 可以通过聊天机器人发送消息，收到会及时回复 你在本站发表的内容你无权删除，并且记录评论者的ip 请不要恶意评论，请不要评论违反中国法律的内容。"},{"title":"友链","path":"/friends/index.html","content":"自我提升菜鸟教程W3School 开发社区CSDN稀土掘金 休闲娱乐哔哩哔哩YoutubeWeiboTwitter"}]